// Generate a mesh with holes, where the outer boundary is given by a
// collection of geometrical points.
//
// lower left corner  : (x_geo[p1], y_geo[p1])
// lower right corner : (x_geo[p2], y_geo[p2])
// upper right corner : (x_geo[p3], y_geo[p3])
// upper left corner  : (x_geo[p4], y_geo[p4])
//
// npoints is the total number of geometrical points on the outer boundary


// Do not let Gmsh determine the element size (instead the element size
// will be specified using refinement fields) by setting
// Mesh.CharacteristicLengthExtendFromBoundary to 0 (its default value is 1)

//Mesh.CharacteristicLengthExtendFromBoundary = 0;


// Accuracy of evaluation of the LC field (characteristic length of elements)
// for 1D mesh generation (Default value: 1e-09)
// see: http://www.geuz.org/pipermail/gmsh/2013/008319.html

//Mesh.LcIntegrationPrecision = LcIntegrationPrecision;


// Create domain vertices

For i In {1:npoints}
  Point(i) = {x_geo[i],    y_geo[i],    0.0, dx_box};
EndFor

Physical Point(1) = p1;
Physical Point(2) = p2;
Physical Point(3) = p3;
Physical Point(4) = p4;

// Create domain sides

For i In {1:npoints-1}
  Line(i) = {i,i+1};
EndFor
Line(npoints) = {npoints,1};

Physical Line(1) = {1:p2-1};
Physical Line(2) = {p2:p3-1};
Physical Line(3) = {p3:p4-1};
Physical Line(4) = {p4:npoints};

// Create outer boundary

lin_loop[0] = newll;
Line Loop(lin_loop[0]) = { 1:npoints };

// make sure the line pieces on curve 2 are periodic
// with the line pieces on curve 4

For i In {0:p3-p2-1}
  elem_c2 = i+p2;
  elem_c4 = npoints-i;
  Periodic Line {elem_c4} = {-elem_c2};
EndFor

If ( biperiodic == 1 )
  For i In {0:p4-p3-1}
    elem_c3 = i+p3;
    elem_c1 = p2-1-i;
    Periodic Line {elem_c3} = {-elem_c1};
  EndFor
EndIf



// Create surface mesh (with holes)

Plane Surface(1) = {lin_loop[]};

Physical Surface(1) = {1};

// add refinement points

pcount=0;

If (0 > 0 )

  For i In {1:nrefinement_field}

      // generate a list with the refinement points
      For t In {1:nrefine[i]}

        p_refine = newp; Point(p_refine) = {xp_refine[t+pcount],
          yp_refine[t+pcount], 0.0};

        // apparently, Gmsh start counting with 0, so t-1 is the first index!
        refinement_points[t-1] = p_refine;

      EndFor

      // generate an attractor field that returns the distance to the closest
      // refinement point
      Field[2*i-1] = Attractor;
      Field[2*i-1].NodesList = {refinement_points[]};

      // use the values generated by the attractor field to determine the
      // element size
      Field[2*i] = Threshold;
      Field[2*i].IField = 2*i-1;
      Field[2*i].LcMin = dx_fine[i];
      Field[2*i].LcMax = dx_coarse[i];
      Field[2*i].DistMin = distmin[i];
      Field[2*i].DistMax = distmax[i];

      pcount=pcount+nrefine[i];

    EndFor

    // use the minimum of all element-size-fields
    Field[2*nrefinement_field+1] = Min;
    For i In {1:nrefinement_field}
      field_list[i-1] = i*2;
    EndFor
    Field[2*nrefinement_field+1].FieldsList = {field_list[]};
    Background Field = 2*nrefinement_field+1;

EndIf


// vim: set filetype=gmsh :  //
