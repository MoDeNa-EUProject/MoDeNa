!>This file contains subroutines neccessary for running the code using analytical
!!derivations obtained from automatic differentiation.
 
 
 
 
 
 
 
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
!  Differentiation of formfunctionlocal in forward (tangent) mode:
!   variations   of useful results: f rhop
!   with respect to varying inputs: rhop
!   RW status of diff variables: f:out rhop:in-out
SUBROUTINE FORMFUNCTIONLOCAL_D(rhop, rhopd_nogp, fd, user, ierr)


!PETSc modules
 Use PetscManagement


!DFT modules
  USE MOD_DFT_FMT
  USE MOD_DFT_CHAIN
  USE MOD_DFT_FMT_d
  USE MOD_DFT_CHAIN_d
  USE MOD_DFT_DISP_WDA_D


  USE BASIC_VARIABLES, ONLY : ncomp 
  USE EOS_VARIABLES, Only:dhs, rho
  USE VLE_VAR, Only: rhob
  USE MOD_DFT, ONLY : fa, zp
  USE DFT_FCN_MODULE, ONLY : chempot_res
  USE GLOBAL_X, ONLY : ngrid, ngp
  IMPLICIT NONE

#include <finclude/petscsys.h>

!  Input/output variables:
      type (userctx) user
      PetscScalar  rhop(ncomp,user%gxs:user%gxe)
      PetscScalar  rhopd_nogp(ncomp,user%xs:user%xe)
      !PetscScalar  f(ncomp,user%xs:user%xe)
      PetscScalar  fd(ncomp,user%xs:user%xe)
      PetscErrorCode ierr

!  Local variables:
      PetscInt  i
      PetscInt  k
      REAL,dimension(user%gxs:user%gxe)          :: n0,n1,n2,n3,nv1,nv2  !ngp muss groesser als fa+fa/2 sein!!
      REAL,dimension(user%gxs:user%gxe)          :: phi_dn0,phi_dn1,phi_dn2,phi_dn3,phi_dnv1,phi_dnv2
      REAL,dimension(user%gxs:user%gxe)          :: phi_dn0d,phi_dn1d,phi_dn2d,phi_dn3d,phi_dnv1d,phi_dnv2d
      REAL,dimension(user%xs:user%xe,ncomp)      :: dF_drho_FMT,dF_drho_FMTd
      REAL,dimension(user%gxs:user%gxe,ncomp)    :: rhobar,lambda,rhobard,lambdad  
      REAL,dimension(user%xs:user%xe,ncomp)      :: dF_drho_CHAIN,dF_drho_CHAINd    
      REAL :: Vext(ncomp)

      !DISP VAR
      REAL,dimension(user%gxs:user%gxe,ncomp)    :: rhop_wd,my_disp,df_disp_drk
      REAL,dimension(user%gxs:user%gxe,ncomp)    :: rhop_wdd,my_dispd
      REAL,dimension(user%gxs:user%gxe)          :: f_disp
      REAL, dimension(ncomp)                     :: dF_drho_disp
      REAL, dimension(ncomp)                     :: dF_drho_dispd



      INTRINSIC EXP
      REAL :: arg1
      REAL :: arg1d
      PetscScalar :: rhopd(ncomp,user%gxs:user%gxe)

      rhopd = 0.0
      rhopd(1:ncomp,user%xs:user%xe) = rhopd_nogp(1:ncomp,user%xs:user%xe)



!calculate weighted densities
  CALL FMT_WEIGHTED_DENSITIES_D(rhop, rhopd, n0, n1, n2, n3, nv1, nv2, &
&                         phi_dn0, phi_dn0d, phi_dn1, phi_dn1d, phi_dn2&
&                         , phi_dn2d, phi_dn3, phi_dn3d, phi_dnv1, &
&                         phi_dnv1d, phi_dnv2, phi_dnv2d, user)
!calculate averaged density rhobar and lambda (both needed for chain term)
  CALL CHAIN_AUX_D(rhop, rhopd, rhobar, rhobard, lambda, lambdad, user)
!HIER DISP!!!
  CALL DISP_WEIGHTED_DENSITIES_D(rhop, rhopd, rhop_wd, rhop_wdd, user)
  CALL DISP_MU_D(rhop_wd, rhop_wdd, f_disp, my_disp, my_dispd, &
&          df_disp_drk, user)

  fd = 0.0
  df_drho_chaind = 0.0
  df_drho_fmtd = 0.0
  df_drho_dispd = 0.0

  DO i = user%xs,user%xe
    CALL FMT_DFDRHO_D(i, fa, user, phi_dn0, phi_dn0d, phi_dn1, phi_dn1d&
&               , phi_dn2, phi_dn2d, phi_dn3, phi_dn3d, phi_dnv1, &
&               phi_dnv1d, phi_dnv2, phi_dnv2d, df_drho_fmt, &
&               df_drho_fmtd)
    CALL CHAIN_DFDRHO_D(i, rhop, rhopd, lambda, lambdad, rhobar, rhobard&
&                 , df_drho_chain, df_drho_chaind, user)

!HIER DISP!!!
    CALL DISP_DFDRHO_WDA_D(i, rhop, rhop_wd, my_disp, my_dispd, f_disp, &
&                    df_disp_drk, df_drho_disp, df_drho_dispd, user)


    vext(1:ncomp) = 0.0
    DO k=1,ncomp
      IF (zp(i) .LT. dhs(k)/2.0) vext(k) = 100000.0
!  If( zp(ngrid) - zp(i) < dhs(k)/2.0  )   Vext(k) = 100000.0
       arg1d = -df_drho_fmtd(i,k)-df_drho_chaind(i,k)-df_drho_dispd(k)
       arg1 = chempot_res(k) - vext(k) - df_drho_fmt(i, k) - &
&       df_drho_chain(i, k) - df_drho_disp(k)

      fd(k, i) = rhob(1,k)*arg1d*EXP(arg1) - rhopd(k, i)
      !f(k, i) = xx(k)*rho*EXP(arg1) - rhop(k, i)
    END DO
  END DO
END SUBROUTINE FORMFUNCTIONLOCAL_D









!------------------------------------------------------------------------------------------------
!This Subroutine calculates the Jacobi-Vector product using derivatives obtained via AD
!------------------------------------------------------------------------------------------------
Subroutine Jac_Shell_AD(Jshell,v_in,v_out)

use Global_x, only: x,snes
Use PetscManagement

#include "finclude/petsc.h90"  


!passed
        Mat                  :: Jshell
        Vec                  :: v_in        !has global size discret (NOT discret +- ghost points!!)
        Vec                  :: v_out
!local
        PetscScalar, pointer :: xd(:), rhop_loc(:,:),fd(:) !for dof2, xd and fd are twice the size as for dof1
        PetscErrorCode       :: ierr
        Type (userctx)       :: user
        DM                   :: da
        Vec                  :: rhop_local

       

!get the user context and DM which are associated with nonlinear solver 
        call SNESGetApplicationContext(snes,user,ierr)
        call SNESGetDM(snes,da,ierr)

!get local vector for x (needed because we need the ghost point values of x)
        call DMGetLocalVector(da,rhop_local,ierr)

!copy global to local for x (then x_local also contains ghost points)
        call DMGlobalToLocalBegin(da,x,INSERT_VALUES,rhop_local,ierr)
        call DMGlobalToLocalEnd(da,x,INSERT_VALUES,rhop_local,ierr)

!get pointers to the vectors x_local,v_in and v_out
        call DMDAVecGetArrayF90(da,rhop_local,rhop_loc,ierr)
        call VecGetArrayF90(v_in, xd, ierr )
        call VecGetArrayF90(v_out, fd, ierr )

!  Get local grid boundaries (dont know why this is neccessary again!)
 call DMDAGetCorners(da,       & !the distributed array 
     &   user%xs,                   & !corner index in x direction
     &   PETSC_NULL_INTEGER,        & !corner index in y direction
     &   PETSC_NULL_INTEGER,        & !corner index in z direction
     &   user%xm,                   & !width of locally owned part in x direction
     &   PETSC_NULL_INTEGER,        & !width of locally owned part in y direction
     &   PETSC_NULL_INTEGER,        & !width of locally owned part in z direction 
     &   ierr)                        !error check 
       
 call DMDAGetGhostCorners(da,  & !the distributed array
     &   user%gxs,                  & !corner index in x direction (but now counting includes ghost points) 
     &   PETSC_NULL_INTEGER,        & !corner index in y direction (but now counting includes ghost points)
     &   PETSC_NULL_INTEGER,        & !corner index in z direction (but now counting includes ghost points)
     &   user%gxm,                  & !width of locally owned part in x direction (but now including ghost points)
     &   PETSC_NULL_INTEGER,        & !width of locally owned part in y direction (but now including ghost points)
     &   PETSC_NULL_INTEGER,        & !width of locally owned part in z direction (but now including ghost points)
     &   ierr)                        !error check


!  Here we shift the starting indices up by one so that we can easily
!  use the Fortran convention of 1-based indices (rather 0-based indices).
      user%xs  = user%xs+1
      user%gxs = user%gxs+1

      user%xe  = user%xs+user%xm-1
      user%gxe = user%gxs+user%gxm-1


!---------------------------------------------------------
!call AD generated Routine 
        !x_loc: x
        !xd   : direction which the derivative is calculated for
        !fd   : the directional derivative in direction xd
       
         call FORMFUNCTIONLOCAL_D(rhop_loc,xd,fd,user,ierr)
!---------------------------------------------------------        




!restore arrays
        call DMDAVecRestoreArrayF90(da,rhop_local,rhop_loc,ierr )
        call VecRestoreArrayF90( v_in, xd, ierr )
        call VecRestoreArrayF90( v_out, fd, ierr )   
        call DMRestoreLocalVector(da,rhop_local,ierr)


End Subroutine Jac_Shell_AD




! empty subroutine for shell jacobian; probably should copy v_x to x, as they might not be same
Subroutine Jac_Matrix_Empty(snes,v_x,jac,B,flag,dummy,ierr)
        implicit none
#include "finclude/petsc.h90"
        SNES            :: snes
        Vec             :: v_x
        Mat             :: jac,B
        MatStructure    :: flag
        PetscErrorCode  :: ierr
        integer dummy(*)
End Subroutine Jac_Matrix_Empty







