!> \file mod_DFT_CHAIN_d.F90
!!This file contains the subroutines which calculate the derivatives of the contribution of
!!chain formation to the Helmholtz energy functional. These derivatives were obtained 
!!from the TAPENADE automatic differentiation online tool. 
 
 
  
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5498) - 20 Jan 2015 09:48
!
MODULE MOD_DFT_CHAIN_D
  IMPLICIT NONE
  PRIVATE 
  PUBLIC chain_aux_d
  PUBLIC chain_dfdrho_d

CONTAINS
!  Differentiation of chain_aux in forward (tangent) mode:
!   variations   of useful results: rhobar lambda
!   with respect to varying inputs: rhop
  SUBROUTINE CHAIN_AUX_D(rhop, rhopd, rhobar, rhobard, lambda, lambdad, &
&   user)
    USE BASIC_VARIABLES, ONLY : ncomp
    USE EOS_VARIABLES, Only: dhs,rho
    USE MOD_DFT, ONLY : zp, dzp, fa

   !PETSc module
   Use PetscManagement

   IMPLICIT NONE

#include <finclude/petscsys.h>


!passed
type (userctx)   :: user
PetscScalar      :: rhop(ncomp,user%gxs:user%gxe)
PetscScalar      :: rhopd(ncomp,user%gxs:user%gxe)
REAL,INTENT(OUT) :: rhobar(user%gxs:user%gxe,ncomp)
REAL,INTENT(OUT) :: rhobard(user%gxs:user%gxe,ncomp)
REAL,INTENT(OUT) :: lambda(user%gxs:user%gxe,ncomp)
REAL,INTENT(OUT) :: lambdad(user%gxs:user%gxe,ncomp)

!local
    INTEGER :: i, j, k
    REAL :: dhsk
    INTEGER :: fak, n
    REAL :: zz, dz, xlo, xhi, integral_lamb, integral_rb
    REAL :: integral_lambd, integral_rbd
    INTEGER, parameter :: NMAX = 800
    REAL, DIMENSION(NMAX) :: x_int, lamb_int, rb_int
    REAL, DIMENSION(NMAX) :: lamb_intd, rb_intd
    REAL, DIMENSION(NMAX) :: y2_lamb, y2_rb
    REAL, DIMENSION(NMAX) :: y2_lambd, y2_rbd
    REAL :: rhopjk, rhopjp1k
    REAL :: rhopjkd, rhopjp1kd
    INTRINSIC EPSILON
    REAL :: result1



    rhobard = 0.0
    lambdad = 0.0
    y2_rbd = 0.0
    y2_lambd = 0.0
!fak = maxval(fa(1:ncomp))
    DO k=1,ncomp
      dhsk = dhs(k)
      fak = fa(k) + 1

        Do i = user%xs-fak,user%xe+fak  !lambda und rhobar werden bis i+-sig gebraucht -> Schleife bis +- fa
        n = 1
        x_int = 0.0
        lamb_int = 0.0
        rb_int = 0.0
        rb_intd = 0.0
        lamb_intd = 0.0
!um lambda bei i zu berechnen, muss bis +- sig um i integriert werden -> Schleife bis +- fa 
        DO j=i-fak,i+fak
          rhopjkd = rhopd(k, j)
          rhopjk = rhop(k, j)
          rhopjp1kd = rhopd(k, j+1)
          rhopjp1k = rhop(k, j+1)
          IF (zp(i) - zp(j+1) .LT. dhsk .AND. zp(i) - zp(j) .GE. dhsk) &
&         THEN
!the position of j+1 is already within i-d while j is still outside this range in this case, the integration steplength (dz) is j
!ust the distance, which j+1 overlaps with i-d and what is integrated is the interpolated value of the integrand
!here always n=1!
            IF (n .NE. 1) THEN
              GOTO 100
            ELSE
!distance between grid points j and i
              zz = zp(j) - zp(i)
!the part of the intervall between zp(j) and zp(j+1) which is already within i-d
              dz = zp(j+1) - (zp(i)-dhsk)
!if(dz < epsilon(dz)) dz = epsilon(dz) !bei unguenstiger Kombination von sig und ngrid kann dz unter Machinengenauigkeit epsilon 
!liegen, dann ist x(2) = x(1) + dz = x(1) -> das fuehrt zu Abbruch in Spline Interpolation           
!array containing x-values for spline integration 
              x_int(n) = 0.0
!lineare interpolation analog zum FMT Teil
              lamb_intd(n) = rhopjkd + (dzp-dz)*(rhopjp1kd-rhopjkd)/dzp
              lamb_int(n) = rhopjk + (rhopjp1k-rhopjk)/dzp*(dzp-dz)
!erklärung analog wie bei n3_int in FMT Teil
              rb_intd(n) = 0.0
              rb_int(n) = 0.0
            END IF
          ELSE IF (zp(j) .GT. zp(i) - dhsk .AND. zp(j) .LE. zp(i) + dhsk&
&         ) THEN
!grid point j  within i+-d 
            n = n + 1
!first time in this If condition, dz is stil the old value from above!
            x_int(n) = x_int(n-1) + dz
            zz = zp(j) - zp(i)
            dz = dzp
            lamb_intd(n) = rhopjkd
            lamb_int(n) = rhopjk
            rb_intd(n) = (dhsk**2-zz**2)*rhopjkd
            rb_int(n) = rhopjk*(dhsk**2-zz**2)
            IF (zp(j) .LT. zp(i) + dhsk .AND. zp(j+1) .GE. zp(i) + dhsk&
&           ) THEN
!zp(j) is still within zp(i)+d but zp(j+1) is already outside zp(i)+d
              dz = zp(i) + dhsk - zp(j)
!If(dz <= epsilon(dz)) exit   !wie oben, kann auch hier bei ungluecklicher Wahl von sig und ngrid dz < eps werden und somit x(n) 
!= x(n-1) -> Abbruch in Spline interpolation. Dann einfach ngrid aendern!
              zz = zp(j) - zp(i)
              n = n + 1
              x_int(n) = x_int(n-1) + dz
              rb_intd(n) = 0.0
              rb_int(n) = 0.0
              lamb_intd(n) = rhopjkd + dz*(rhopjp1kd-rhopjkd)/dzp
              lamb_int(n) = rhopjk + (rhopjp1k-rhopjk)/dzp*dz
!            If(x_int(n) == x_int(n-1)) Then
!              n = n - 1
!              exit
!            End If  
            END IF
          END IF
        END DO
!spline integration
        xlo = x_int(1)
        xhi = x_int(n)
        CALL SPLINE_D(x_int, lamb_int, lamb_intd, n, 1.e30, 1.e30, &
&               y2_lamb, y2_lambd)
        CALL SPLINE_D(x_int, rb_int, rb_intd, n, 1.e30, 1.e30, y2_rb, &
&               y2_rbd)
        CALL SPLINT_INTEGRAL_D(x_int, lamb_int, lamb_intd, y2_lamb, &
&                        y2_lambd, n, xlo, xhi, integral_lamb, &
&                        integral_lambd)
        CALL SPLINT_INTEGRAL_D(x_int, rb_int, rb_intd, y2_rb, y2_rbd, n&
&                        , xlo, xhi, integral_rb, integral_rbd)
        lambdad(i, k) = 0.5*integral_lambd/dhsk
        lambda(i, k) = 0.5*integral_lamb/dhsk
        rhobard(i, k) = 0.75*integral_rbd/dhsk**3
        rhobar(i, k) = 0.75*integral_rb/dhsk**3
        result1 = EPSILON(dz)
        IF (lambda(i, k) .LT. result1) lambda(i, k) = EPSILON(dz)
      END DO
    END DO
    GOTO 110
 100 STOP
 110 CONTINUE
  END SUBROUTINE CHAIN_AUX_D


 

!  Differentiation of chain_dfdrho in forward (tangent) mode:
!   variations   of useful results: df_drho_chain rhop
!   with respect to varying inputs: rhobar df_drho_chain lambda
!                rhop
  SUBROUTINE CHAIN_DFDRHO_D(i, rhop, rhopd, lambda, lambdad, rhobar, &
&   rhobard, df_drho_chain, df_drho_chaind, user)
    USE BASIC_VARIABLES, ONLY : ncomp,parame
    USE EOS_VARIABLES, Only: dhs
    USE MOD_DFT, ONLY : zp, dzp, fa

   !PETSc module
   Use PetscManagement
   IMPLICIT NONE

#include <finclude/petscsys.h>


!passed
INTEGER, INTENT(IN) :: i !the grid point to calculate dFdrho at
type (userctx)   :: user
PetscScalar      :: rhop(ncomp,user%gxs:user%gxe)
PetscScalar      :: rhopd(ncomp,user%gxs:user%gxe)
REAL,INTENT(IN) :: rhobar(user%gxs:user%gxe,ncomp)
REAL,INTENT(IN) :: rhobard(user%gxs:user%gxe,ncomp)
REAL,INTENT(IN) :: lambda(user%gxs:user%gxe,ncomp)
REAL,INTENT(IN) :: lambdad(user%gxs:user%gxe,ncomp)



REAL,INTENT(OUT) :: dF_drho_CHAIN(user%xs:user%xe,ncomp)
REAL,INTENT(OUT) :: dF_drho_CHAINd(user%xs:user%xe,ncomp)


!local
    INTEGER :: j, k, n
    REAL :: dhsk
    INTEGER :: fak
    REAL :: rhopjk, rhopjp1k, logrho, xlo, xhi
    REAL :: rhopjkd, rhopjp1kd
    REAL :: ycorr(ncomp), dlny(ncomp, ncomp)
    REAL :: ycorrd(ncomp), dlnyd(ncomp, ncomp)
    INTEGER, parameter :: NMAX = 800
    REAL, DIMENSION(NMAX) :: x_int, int_1, int_2
    REAL, DIMENSION(NMAX) :: int_1d, int_2d
    REAL, DIMENSION(NMAX) :: y2_1, y2_2
    REAL, DIMENSION(NMAX) :: y2_1d, y2_2d
    REAL :: dz, zz, integral_1, integral_2
    REAL :: integral_1d, integral_2d
    REAL :: lamy
    INTRINSIC SUM
    INTRINSIC EPSILON
    INTRINSIC LOG
    REAL, DIMENSION(ncomp) :: arg1
    REAL, DIMENSION(ncomp) :: arg1d
    REAL :: result1
    REAL :: arg10
    REAL :: arg10d





    CALL CAVITY_MIX_D(rhobar(i, 1:ncomp), rhobard(i, 1:ncomp), ycorr, &
&               ycorrd, dlny, dlnyd)
    y2_1d = 0.0
    y2_2d = 0.0
    DO k=1,ncomp
      fak = fa(k)
      dhsk = dhs(k)
      n = 1
      x_int = 0.0
      int_1 = 0.0
      int_2 = 0.0
      int_1d = 0.0
      int_2d = 0.0
!es muss bis +- sig um i integriert werden 
      DO j=i-fak,i+fak
        rhopjkd = rhopd(k, j)
        rhopjk = rhop(k, j)
        rhopjp1kd = rhopd(k, j+1)
        rhopjp1k = rhop(k, j+1)
        IF (zp(i) - zp(j+1) .LT. dhsk .AND. zp(i) - zp(j) .GE. dhsk) &
&       THEN
!the position of j+1 is already within i-d while j is still outside this range in this case, the integration steplength (dz) is j
!ust the distance, which j+1 overlaps with i-d and what is integrated is the interpolated value of the integrand
!here always n=1!
          IF (n .NE. 1) THEN
            GOTO 100
          ELSE
!distance between grid points j and i
            zz = zp(j) - zp(i)
!the part of the intervall between zp(j) and zp(j+1) which is already within i-d
            dz = zp(j+1) - (zp(i)-dhsk)
!if(dz < epsilon(dz)) dz = epsilon(dz) !bei unguenstiger Kombination von sig und ngrid kann dz unter Machinengenauigkeit epsilon 
!liegen, dann ist x(2) = x(1) + dz = x(1) -> das fuehrt zu Abbruch in Spline Interpolation           
!array containing x-values for spline integration 
            x_int(n) = 0.0
!erklärung analog wie bei n3_int in FMT Teil
            int_1d(n) = 0.0
            int_1(n) = 0.0
!lineare interpolation analog zum FMT Teil
            int_2d(n) = rhopjkd*lambda(j, k) + rhopjk*lambdad(j, k) + (&
&             dzp-dz)*(rhopjp1kd*lambda(j+1, k)+rhopjp1k*lambdad(j+1, k)&
&             -rhopjkd*lambda(j, k)-rhopjk*lambdad(j, k))/dzp
            int_2(n) = rhopjk*lambda(j, k) + (rhopjp1k*lambda(j+1, k)-&
&             rhopjk*lambda(j, k))/dzp*(dzp-dz)
          END IF
        ELSE IF (zp(j) .GT. zp(i) - dhsk .AND. zp(j) .LE. zp(i) + dhsk) &
&       THEN
!grid point j  within i+-d 
          n = n + 1
!first time in this If condition, dz is stil the old value from above!
          x_int(n) = x_int(n-1) + dz
          zz = zp(j) - zp(i)
          dz = dzp
          arg1d(:) = (parame(1:ncomp,1)-1.0)*(rhopd(1:ncomp, j)*dlny(1:ncomp&
&           , k)+rhop(1:ncomp, j)*dlnyd(1:ncomp, k))
          arg1(:) = (parame(1:ncomp,1)-1.0)*rhop(1:ncomp, j)*dlny(1:ncomp, k&
&           )
          int_1d(n) = (dhsk**2-zz**2)*0.75*SUM(arg1d(:))/dhsk**3
          int_1(n) = SUM(arg1(:))*0.75/dhsk**3*(dhsk**2-zz**2)
          int_2d(n) = (rhopjkd*lambda(j, k)-rhopjk*lambdad(j, k))/lambda&
&           (j, k)**2
          int_2(n) = rhopjk/lambda(j, k)
          IF (zp(j) .LT. zp(i) + dhsk .AND. zp(j+1) .GE. zp(i) + dhsk) &
&         THEN
!zp(j) is still within zp(i)+d but zp(j+1) is already outside zp(i)+d
            dz = zp(i) + dhsk - zp(j)
!If(dz <= epsilon(dz)) exit   !wie oben, kann auch hier bei ungluecklicher Wahl von sig und ngrid dz < eps werden und somit x(n) 
!= x(n-1) -> Abbruch in Spline interpolation. Dann einfach ngrid aendern!
            zz = zp(j) - zp(i)
            n = n + 1
            x_int(n) = x_int(n-1) + dz
            int_1d(n) = 0.0
            int_1(n) = 0.0
            int_2d(n) = rhopjkd*lambda(j, k) + rhopjk*lambdad(j, k) + dz&
&             *(rhopjp1kd*lambda(j+1, k)+rhopjp1k*lambdad(j+1, k)-&
&             rhopjkd*lambda(j, k)-rhopjk*lambdad(j, k))/dzp
            int_2(n) = rhopjk*lambda(j, k) + (rhopjp1k*lambda(j+1, k)-&
&             rhopjk*lambda(j, k))/dzp*dz
!            If(x_int(n) == x_int(n-1)) Then
!              n = n - 1
!              exit
!            End If  
          END IF
        END IF
      END DO
!Spline Integration
      xlo = x_int(1)
      xhi = x_int(n)
      CALL SPLINE_D(x_int, int_1, int_1d, n, 1.e30, 1.e30, y2_1, y2_1d)
      CALL SPLINT_INTEGRAL_D(x_int, int_1, int_1d, y2_1, y2_1d, n, xlo, &
&                      xhi, integral_1, integral_1d)
      CALL SPLINE_D(x_int, int_2, int_2d, n, 1.e30, 1.e30, y2_2, y2_2d)
      CALL SPLINT_INTEGRAL_D(x_int, int_2, int_2d, y2_2, y2_2d, n, xlo, &
&                      xhi, integral_2, integral_2d)
      result1 = EPSILON(dz)
      IF (rhop(k, i) .LT. result1) THEN
        rhop = EPSILON(dz)
        rhopd = 0.0
      END IF
      arg10d = ycorrd(k)*lambda(i, k) + ycorr(k)*lambdad(i, k)
      arg10 = ycorr(k)*lambda(i, k)
      df_drho_chaind(i, k) = (parame(k,1)-1.0)*rhopd(k, i)/rhop(k, i) - (&
&       parame(k,1)-1.0)*(arg10d/arg10+0.5*integral_2d/dhsk) - integral_1d
      df_drho_chain(i, k) = (parame(k,1)-1.0)*LOG(rhop(k, i)) - (parame(k,1)-1.0&
&       )*(LOG(arg10)-1.0+0.5*integral_2/dhsk) - integral_1
    END DO
    GOTO 110
 100 STOP
 110 CONTINUE
  END SUBROUTINE CHAIN_DFDRHO_D



!  Differentiation of cavity_mix in forward (tangent) mode:
!   variations   of useful results: ycorr dlnydr
!   with respect to varying inputs: rhoi
!WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
!
!WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
!
  SUBROUTINE CAVITY_MIX_D(rhoi, rhoid, ycorr, ycorrd, dlnydr, dlnydrd)
!
    USE PARAMETERS, ONLY : pi
    USE BASIC_VARIABLES, ONLY : ncomp,parame
    USE EOS_VARIABLES, Only: dhs
    IMPLICIT NONE
!
! ----------------------------------------------------------------------
    REAL, INTENT(IN) :: rhoi(ncomp)
    REAL, INTENT(IN) :: rhoid(ncomp)
    REAL, INTENT(OUT) :: ycorr(ncomp)
    REAL, INTENT(OUT) :: ycorrd(ncomp)
! this is: d( ln( yij ) ) / d( rho(k) ) used with i=j
    REAL, INTENT(OUT) :: dlnydr(ncomp, ncomp)
    REAL, INTENT(OUT) :: dlnydrd(ncomp, ncomp)
!
! ----------------------------------------------------------------------
    INTEGER :: i, j, k
    REAL :: z0, z1, z2, z3, zms, z1_rk, z2_rk, z3_rk
    REAL :: z2d, z3d, zmsd
    REAL, DIMENSION(ncomp, ncomp) :: dij_ab, gij, gij_rk
    REAL, DIMENSION(ncomp, ncomp) :: gijd, gij_rkd
    INTRINSIC SUM
    REAL, DIMENSION(ncomp) :: arg1
    REAL, DIMENSION(ncomp) :: arg1d
! ----------------------------------------------------------------------
    arg1(:) = rhoi(1:ncomp)*parame(1:ncomp,1)
    z0 = pi/6.0*SUM(arg1(:))
    arg1(:) = rhoi(1:ncomp)*parame(1:ncomp,1)*dhs(1:ncomp)
    z1 = pi/6.0*SUM(arg1(:))
    arg1d(:) = parame(1:ncomp,1)*dhs(1:ncomp)**2*rhoid(1:ncomp)
    arg1(:) = rhoi(1:ncomp)*parame(1:ncomp,1)*dhs(1:ncomp)**2
    z2d = pi*SUM(arg1d(:))/6.0
    z2 = pi/6.0*SUM(arg1(:))
    arg1d(:) = parame(1:ncomp,1)*dhs(1:ncomp)**3*rhoid(1:ncomp)
    arg1(:) = rhoi(1:ncomp)*parame(1:ncomp,1)*dhs(1:ncomp)**3
    z3d = pi*SUM(arg1d(:))/6.0
    z3 = pi/6.0*SUM(arg1(:))
    zmsd = -z3d
    zms = 1.0 - z3
    DO i=1,ncomp
      DO j=1,ncomp
        dij_ab(i, j) = dhs(i)*dhs(j)/(dhs(i)+dhs(j))
      END DO
    END DO
    ycorrd = 0.0
    dlnydrd = 0.0
    gij_rkd = 0.0
    gijd = 0.0
    DO k=1,ncomp
      DO i=1,ncomp
        z1_rk = pi/6.0*parame(k,1)*dhs(k)
        z2_rk = pi/6.0*parame(k,1)*dhs(k)*dhs(k)
        z3_rk = pi/6.0*parame(k,1)*dhs(k)**3
!DO j = 1, ncomp
        j = i
        gijd(i, j) = ((3.0*dij_ab(i, j)*z2d*zms-3.0*dij_ab(i, j)*z2*zmsd&
&         )/zms-3.0*dij_ab(i, j)*z2*zmsd/zms)/zms**2 - zmsd/zms**2 + (&
&         2.0*2*dij_ab(i, j)**2*z2*z2d*zms**3-2.0*dij_ab(i, j)**2*z2**2*&
&         3*zms**2*zmsd)/(zms**3)**2
        gij(i, j) = 1.0/zms + 3.0*dij_ab(i, j)*z2/zms/zms + 2.0*(dij_ab(&
&         i, j)*z2)**2/zms**3
!dgijdz(i,j)= 1.0/zms/zms + 3.0*dij_ab(i,j)*z2*(1.0+z3)/z3/zms**3   &
!           + (dij_ab(i,j)*z2/zms/zms)**2 *(4.0+2.0*z3)/z3
        gij_rkd(i, j) = (-2)*(z3_rk*zmsd/zms)/zms**2 + ((3.0*dij_ab(i, j&
&         )*(2.0*z3_rk*z2d*zms-2.0*z2*z3_rk*zmsd)/zms-3.0*dij_ab(i, j)*(&
&         z2_rk+2.0*z2*z3_rk/zms)*zmsd)/zms-3.0*dij_ab(i, j)*(z2_rk+2.0*&
&         z2*z3_rk/zms)*zmsd/zms)/zms**2 + (dij_ab(i, j)**2*z2d*zms**3-&
&         dij_ab(i, j)**2*z2*3*zms**2*zmsd)*(4.0*z2_rk+6.0*z2*z3_rk/zms)&
&         /zms**6 + dij_ab(i, j)**2*z2*(6.0*z3_rk*z2d*zms-6.0*z2*z3_rk*&
&         zmsd)/zms**5
        gij_rk(i, j) = z3_rk/zms/zms + 3.0*dij_ab(i, j)*(z2_rk+2.0*z2*&
&         z3_rk/zms)/zms/zms + dij_ab(i, j)**2*z2/zms**3*(4.0*z2_rk+6.0*&
&         z2*z3_rk/zms)
!END DO
        ycorrd(i) = gijd(i, i)
        ycorr(i) = gij(i, i)
        dlnydrd(i, k) = (gij_rkd(i, i)*gij(i, i)-gij_rk(i, i)*gijd(i, i)&
&         )/gij(i, i)**2
        dlnydr(i, k) = gij_rk(i, i)/gij(i, i)
      END DO
    END DO
  END SUBROUTINE CAVITY_MIX_D

END MODULE MOD_DFT_CHAIN_D
