!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
       MODULE DAGMG_MUMPS_STRUC_DEF
!
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE DAGMG_MUMPS_STRUC
        SEQUENCE
!
! This structure contains all parameters
! for the interface to the user, plus internal
! information
!
! *****************
! INPUT PARAMETERS
! *****************
!    -----------------
!    MPI Communicator
!    -----------------
        INTEGER COMM
!    ------------------
!    Problem definition
!    ------------------
!    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite,
!        SYM=2 general symmetric)
!    Type of parallelism (PAR=1 host working, PAR=0 host not working)
        INTEGER SYM, PAR
        INTEGER JOB
!    --------------------
!    Order of Input matrix
!    --------------------
        INTEGER N
!
!    ----------------------------------------
!    Assembled input matrix : User interface
!    ----------------------------------------
        INTEGER NZ
        DOUBLE PRECISION, DIMENSION(:), POINTER :: A
        INTEGER, DIMENSION(:), POINTER :: IRN, JCN
        DOUBLE PRECISION, DIMENSION(:), POINTER :: COLSCA, ROWSCA, pad0
!
!       ------------------------------------
!       Case of distributed assembled matrix
!       matrix on entry:
!       ------------------------------------
        INTEGER NZ_loc, pad1
        INTEGER, DIMENSION(:), POINTER :: IRN_loc, JCN_loc
        DOUBLE PRECISION, DIMENSION(:), POINTER :: A_loc, pad2
!
!    ----------------------------------------
!    Unassembled input matrix: User interface
!    ----------------------------------------
        INTEGER NELT, pad3
        INTEGER, DIMENSION(:), POINTER :: ELTPTR
        INTEGER, DIMENSION(:), POINTER :: ELTVAR
        DOUBLE PRECISION, DIMENSION(:), POINTER :: A_ELT, pad4
!
!    ---------------------------------------------
!    Symmetric permutation :
!               PERM_IN if given by user (optional)
!    ---------------------------------------------
        INTEGER, DIMENSION(:), POINTER :: PERM_IN
!
!
! ******************
! INPUT/OUTPUT data
! ******************
!    --------------------------------------------------------
!    RHS / SOL_LOC
!    -------------
!       right-hand side and solution
!    -------------------------------------------------------
        DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS, REDRHS
        DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS_SPARSE
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SOL_LOC
        INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE
        INTEGER, DIMENSION(:), POINTER :: IRHS_PTR
        INTEGER, DIMENSION(:), POINTER :: ISOL_LOC
        INTEGER LRHS, NRHS, NZ_RHS, LSOL_LOC, LREDRHS
        INTEGER pad5
!    ----------------------------
!    Control parameters,
!    statistics and output data
!    ---------------------------
        INTEGER ICNTL(40)
        INTEGER INFO(40)
        INTEGER INFOG(40)
        DOUBLE PRECISION COST_SUBTREES
        DOUBLE PRECISION CNTL(15)
        DOUBLE PRECISION RINFO(20)
        DOUBLE PRECISION RINFOG(20)
!    ---------------------------------------------------------
!    Permutations computed during analysis:
!       SYM_PERM: Symmetric permutation
!       UNS_PERM: Column permutations (optionnal)
!    ---------------------------------------------------------
        INTEGER, DIMENSION(:), POINTER :: SYM_PERM, UNS_PERM
!
!    -------------------------------------
!    Case of distributed matrix on entry:
!    DMUMPS potentially provides mapping
!    -------------------------------------
        INTEGER, DIMENSION(:), POINTER :: MAPPING
!
!    -------------------------------
!    Deficiency and null space basis
!    -------------------------------
        DOUBLE PRECISION, DIMENSION(:,:), POINTER :: NULL_SPACE
        INTEGER Deficiency, pad6
!    -----
!    Schur
!    -----
        INTEGER NPROW, NPCOL, MBLOCK, NBLOCK
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
        INTEGER SIZE_SCHUR
        INTEGER, DIMENSION(:), POINTER :: LISTVAR_SCHUR
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_CINTERFACE
!    --------------
!    Version number
!    --------------
        CHARACTER(LEN=16) VERSION_NUMBER
!    -----------
!    Out-of-core
!    -----------
        CHARACTER(LEN=256) :: OOC_TMPDIR
        CHARACTER(LEN=64) :: OOC_PREFIX
!    ------------------------------------------
!    To save the matrix in matrix market format
!    ------------------------------------------
        CHARACTER(LEN=256) WRITE_PROBLEM
!
!
! **********************
! INTERNAL Working data
! *********************
        INTEGER INST_Number
!       For MPI
        INTEGER COMM_NODES, MYID_NODES, COMM_LOAD
        INTEGER  MYID, NPROCS, NSLAVES
        INTEGER ASS_IRECV
        INTEGER, DIMENSION(:), POINTER :: POIDS
        INTEGER LBUFR
        INTEGER LBUFR_BYTES
        INTEGER, DIMENSION(:), POINTER ::  BUFR
!       For analysis/facto/solve phases
        INTEGER MAXIS1, pad7
        INTEGER KEEP(500)
        INTEGER*8 KEEP8(150)
!       IS is used for the factors + workspace for contrib. blocks
        INTEGER, DIMENSION(:), POINTER :: IS
!       is1 (maxis1) contains working arrays computed
!       and used only during analysis
        INTEGER, DIMENSION(:), POINTER :: IS1
!       The following data/arrays are computed during the analysis
!       phase and used during the factorization and solve phases.
        INTEGER LNA
        INTEGER NBSA
        INTEGER,POINTER,DIMENSION(:)::STEP, NE_STEPS, ND_STEPS
!  Info for pruning tree
        INTEGER,POINTER,DIMENSION(:)::Step2node
!  ---------------------
        INTEGER,POINTER,DIMENSION(:)::FRERE_STEPS, DAD_STEPS
        INTEGER,POINTER,DIMENSION(:)::FILS, PTRAR, FRTPTR, FRTELT
        INTEGER,POINTER,DIMENSION(:)::NA, PROCNODE_STEPS
!       The two pointer arrays computed in facto and used by the solve
!          (except the factors) are PTLUST_S and PTRFAC.
        INTEGER, DIMENSION(:), POINTER :: PTLUST_S
        INTEGER(8), DIMENSION(:), POINTER :: PTRFAC
!       main real working arrays for factorization/solve phases
        DOUBLE PRECISION, DIMENSION(:), POINTER :: S
!       Information on mapping
        INTEGER, DIMENSION(:), POINTER :: PROCNODE
!       Input matrix ready for numerical assembly
!           -arrowhead format in case of assembled matrix
!           -element format otherwise
        INTEGER, DIMENSION(:), POINTER :: INTARR
        DOUBLE PRECISION, DIMENSION(:), POINTER :: DBLARR
!       Element entry: internal data
        INTEGER NELT_LOC, LELTVAR, NA_ELT, pad8
        INTEGER, DIMENSION(:), POINTER :: ELTPROC
!       Candidates and node partitionning
        INTEGER, DIMENSION(:,:), POINTER :: CANDIDATES
        INTEGER, DIMENSION(:),   POINTER :: ISTEP_TO_INIV2
        INTEGER, DIMENSION(:),   POINTER :: FUTURE_NIV2
        INTEGER, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE
        LOGICAL, DIMENSION(:), POINTER :: I_AM_CAND
!       For heterogeneous architecture
        INTEGER, DIMENSION(:), POINTER :: MEM_DIST
!       Compressed RHS
        INTEGER, DIMENSION(:),   POINTER :: POSINRHSCOMP
        DOUBLE PRECISION, DIMENSION(:), POINTER :: RHSCOMP
!       For C interface
!   Info on the subtrees to be used during factorization
        DOUBLE PRECISION, DIMENSION(:),   POINTER :: MEM_SUBTREE
        INTEGER, DIMENSION(:),   POINTER :: MY_ROOT_SBTR
        INTEGER, DIMENSION(:),   POINTER :: MY_FIRST_LEAF
        INTEGER, DIMENSION(:),   POINTER :: MY_NB_LEAF
        INTEGER, DIMENSION(:),   POINTER :: DEPTH_FIRST
        DOUBLE PRECISION, DIMENSION(:),   POINTER :: COST_TRAV
        INTEGER NBSA_LOCAL, zwave
        INTEGER(8) :: MAX_SURF_MASTER
        INTEGER :: LWK_USER, zozo
        DOUBLE PRECISION, DIMENSION(:), POINTER :: WK_USER
!    For simulating parallel out-of-core stack.
        DOUBLE PRECISION, DIMENSION(:),POINTER ::CB_SON_SIZE
!   Instance number used/managed by the C/F77 interface
        INTEGER INSTANCE_NUMBER
!    OOC management data that must persist from factorization to solve.
        INTEGER OOC_MAX_NB_NODES_FOR_ZONE
        INTEGER, DIMENSION(:,:),   POINTER :: OOC_INODE_SEQUENCE
        INTEGER(8),DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK
        INTEGER*8, DIMENSION(:,:),   POINTER :: OOC_VADDR
        INTEGER,DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES
        INTEGER,DIMENSION(:), POINTER :: OOC_NB_FILES
        CHARACTER,DIMENSION(:,:), POINTER :: OOC_FILE_NAMES
        INTEGER,DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH
!    Indices of nul pivots
        INTEGER,DIMENSION(:), POINTER :: PIVNUL_LIST
!    Internal control array
        DOUBLE PRECISION DKEEP(30)
!    Array needed to manage additionnal candidate processor
        INTEGER, DIMENSION(:,:), POINTER :: SUP_PROC
!   ------------------------
!   Root structure(internal)
!   ------------------------
        TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      END TYPE DAGMG_MUMPS_STRUC
       END MODULE DAGMG_MUMPS_STRUC_DEF
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE TOOLS_COMMON
      INTERFACE AGMG_MUMPS_733
      SUBROUTINE AGMG_MUMPS_754(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      INTEGER, POINTER    :: ARRAY(:)
      INTEGER             :: MINSIZE, LP
      INTEGER             :: INFO(*)
      LOGICAL, OPTIONAL   :: FORCE
      LOGICAL, OPTIONAL   :: COPY
      CHARACTER, OPTIONAL :: STRING*(*)
      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
      END SUBROUTINE AGMG_MUMPS_754
      SUBROUTINE AGMG_MUMPS_752(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      REAL(KIND(1.D0)), POINTER    :: ARRAY(:)
      INTEGER             :: MINSIZE, LP
      INTEGER             :: INFO(*)
      LOGICAL, OPTIONAL   :: FORCE
      LOGICAL, OPTIONAL   :: COPY
      CHARACTER, OPTIONAL :: STRING*(*)
      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
      END SUBROUTINE AGMG_MUMPS_752
      SUBROUTINE AGMG_MUMPS_750(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      REAL(KIND(1.E0)), POINTER    :: ARRAY(:)
      INTEGER             :: MINSIZE, LP
      INTEGER             :: INFO(*)
      LOGICAL, OPTIONAL   :: FORCE
      LOGICAL, OPTIONAL   :: COPY
      CHARACTER, OPTIONAL :: STRING*(*)
      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
      END SUBROUTINE AGMG_MUMPS_750
      SUBROUTINE AGMG_MUMPS_753(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      COMPLEX(KIND((1.D0,1.D0))), POINTER    :: ARRAY(:)
      INTEGER             :: MINSIZE, LP
      INTEGER             :: INFO(*)
      LOGICAL, OPTIONAL   :: FORCE
      LOGICAL, OPTIONAL   :: COPY
      CHARACTER, OPTIONAL :: STRING*(*)
      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
      END SUBROUTINE AGMG_MUMPS_753
      SUBROUTINE AGMG_MUMPS_751(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      COMPLEX(KIND((1.E0,1.E0))), POINTER    :: ARRAY(:)
      INTEGER             :: MINSIZE, LP
      INTEGER             :: INFO(*)
      LOGICAL, OPTIONAL   :: FORCE
      LOGICAL, OPTIONAL   :: COPY
      CHARACTER, OPTIONAL :: STRING*(*)
      INTEGER, OPTIONAL   :: ERRCODE, MEMCNT
      END SUBROUTINE AGMG_MUMPS_751
      END INTERFACE
      END MODULE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE AGMG_MUMPS_OOC_COMMON
      IMPLICIT NONE
      INTEGER FCT
      PARAMETER(FCT=0)
      INTEGER, PUBLIC  ::  TYPEF_L, TYPEF_U, TYPEF_CB
      PARAMETER ( TYPEF_L=1, TYPEF_U=2, TYPEF_CB=3)
      INTEGER OOC_NB_FILE_TYPE,OOC_FCT_TYPE
      INTEGER, DIMENSION(:,:),POINTER :: OOC_INODE_SEQUENCE
      INTEGER*8, DIMENSION(:,:),POINTER :: OOC_VADDR
      INTEGER,DIMENSION(:),POINTER:: KEEP_OOC
      INTEGER ICNTL1
      INTEGER*8, DIMENSION(:),ALLOCATABLE :: AddVirtLibre
      LOGICAL,SAVE :: STRAT_IO_ASYNC,WITH_BUF,SOLVE,IS_INIT_CALLED
      INTEGER, DIMENSION(:),POINTER :: STEP_OOC,PROCNODE_OOC
      INTEGER, SAVE :: MYID_OOC,SLAVEF_OOC,LOW_LEVEL_STRAT_IO
      INTEGER(8), SAVE :: HBUF_SIZE, DIM_BUF_IO
      INTEGER ERR_STR_OOC_MAX_LEN
      PARAMETER(ERR_STR_OOC_MAX_LEN = 512)
      CHARACTER*1 ERR_STR_OOC(ERR_STR_OOC_MAX_LEN)
      INTEGER DIM_ERR_STR_OOC
      TYPE IO_BLOCK
        INTEGER :: INODE
        LOGICAL :: MASTER
        INTEGER :: Typenode
        INTEGER :: NROW, NCOL, NFS
        LOGICAL :: Last
        INTEGER :: LastPiv
        INTEGER :: LastPanelWritten_L
        INTEGER :: LastPanelWritten_U
        INTEGER,POINTER,DIMENSION(:) :: INDICES
      END TYPE
      PUBLIC IO_BLOCK
      INTEGER, PUBLIC :: STRAT_WRITE_MAX, STRAT_TRY_WRITE
      PARAMETER (STRAT_WRITE_MAX=1, STRAT_TRY_WRITE=2)
      END MODULE AGMG_MUMPS_OOC_COMMON
      SUBROUTINE AGMG_MUMPS_676(INT1,INT2,BIGINT)
      IMPLICIT NONE
      INTEGER INT1,INT2
      INTEGER*8 BIGINT
      INTEGER*8 TMP1,TMP2,CONV
      PARAMETER (CONV=1073741824_8)
      TMP1=int(INT1,kind=kind(TMP1))
      TMP2=int(INT2,kind=kind(TMP2))
      BIGINT=(TMP1*CONV)+TMP2
      RETURN
      END SUBROUTINE AGMG_MUMPS_676
      SUBROUTINE AGMG_MUMPS_677(INT1,INT2,BIGINT)
      IMPLICIT NONE
      INTEGER INT1,INT2
      INTEGER*8 BIGINT
      INTEGER*8 TMP1,TMP2,CONV
      PARAMETER (CONV=1073741824_8)
      TMP1=BIGINT/CONV
      TMP2=mod(BIGINT,CONV)
      INT1=int(TMP1)
      INT2=int(TMP2)
      RETURN
      END SUBROUTINE AGMG_MUMPS_677
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE AGMG_MUMPS_STATIC_MAPPING
      IMPLICIT NONE
      PRIVATE
      PUBLIC :: AGMG_MUMPS_369, AGMG_MUMPS_393,                                   &
     &     AGMG_MUMPS_427,AGMG_MUMPS_494
      integer,pointer,dimension(:,:),SAVE::cv_cand
      integer,pointer,dimension(:),SAVE::cv_par2_nodes
      integer,SAVE::cv_slavef,cv_nb_niv2,cv_lp,cv_mp
      DOUBLE PRECISION,SAVE::cv_stack_peak
      integer,SAVE::cv_mem_strat
      integer,parameter::cv_invalid=-9999
      DOUBLE PRECISION,parameter::cv_d_invalid=-9999.D0
      integer,parameter::cv_equilib_flops=1
      integer,parameter::cv_equilib_mem=2
      integer,parameter::cv_error_memalloc = -13
      integer,parameter::cv_error_memdeloc = -96
      integer,dimension(:),allocatable,save :: mem_distribtmp
      integer, dimension(:),allocatable, save :: table_of_process
      integer,dimension(:),allocatable,save :: mem_distribmpi
      integer, save ::ke69,nb_arch_nodes
      logical,dimension(:),allocatable,save :: allowed_nodes
      integer,dimension(:),allocatable,save :: score
      type nodelist
         integer::nodenumber
         type(nodelist),pointer::next
      end type nodelist
      type alloc_arraytype
         integer, pointer, dimension(:)::t2_nodenumbers
         integer, pointer, dimension(:,:)::t2_cand
         DOUBLE PRECISION, pointer, dimension(:)::t2_candcostw(:),      &
     &                                            t2_candcostm(:)
         integer:: nmb_t2s
      end type alloc_arraytype
      type splitting_data
         integer:: new_ison,new_ifather,old_keep2
         DOUBLE PRECISION:: ncostw_oldinode,ncostm_oldinode,            &
     &                      tcostw_oldinode,tcostm_oldinode
      end type splitting_data
      type procs4node_t
         integer, dimension(:), pointer :: ind_proc
      end type procs4node_t
      DOUBLE PRECISION, pointer, dimension(:) ::                        &
     &      cv_proc_workload,                                           &
     &      cv_proc_maxwork,                                            &
     &      cv_proc_memused,                                            &
     &      cv_proc_maxmem
      type(splitting_data)::cv_last_splitting
      integer::cv_n,cv_nsteps,cv_maxlayer,                              &
     &         cv_nbsa,cv_maxnsteps,cv_maxcut,cv_maxdepth,              &
     &         cv_maxnodenmb,cv_total_amalg,cv_total_split,             &
     &         cv_bitsize_of_int,cv_size_ind_proc                       &
     &         ,cv_mixed_strat_bound,cv_dist_L0_mixed_strat_bound       &
     &         ,cv_layerl0_end,cv_layerl0_start
      integer :: layerL0_endforarrangeL0
      DOUBLE PRECISION :: mincostw
      DOUBLE PRECISION:: cv_costw_upper,cv_costm_upper,                 &
     &      cv_costw_layer0,cv_costm_layer0,cv_relax,                   &
     &      cv_costw_total,cv_costm_total,cv_l0wthresh,cv_splitthresh
      logical::cv_constr_work,cv_constr_mem
      integer,pointer,dimension(:):: cv_nodetype,cv_nodelayer,          &
     &          cv_layerl0_array,cv_proc_sorted,cv_potsplit,cv_depth
      integer,dimension(:),pointer::                                    &
     &    cv_ne,cv_nfsiz,cv_frere,cv_fils,cv_keep,cv_info,              &
     &    cv_procnode,cv_ssarbr,cv_icntl
      integer*8,dimension(:),pointer::cv_keep8
      type(alloc_arraytype),pointer,dimension(:)::cv_layer_p2node
      DOUBLE PRECISION,dimension(:),pointer:: cv_ncostw,                &
     & cv_tcostw,cv_ncostm,cv_tcostm,cv_layerworkload,cv_layermemused   &
     & ,cv_layerl0_sorted_costw
      type(procs4node_t),dimension(:),pointer :: cv_prop_map
      contains
      subroutine AGMG_MUMPS_369(n,slavef,icntl,info,                         &
     &                        ne,nfsiz,frere,fils,keep,KEEP8,           &
     &                        procnode,ssarbr,nbsa,peak,istat           &
     &     )
      implicit none
      integer,intent(in)::n,slavef
      integer, intent(inout),TARGET:: ne(n),nfsiz(n),                   &
     &         procnode(n),ssarbr(n),frere(n),fils(n),keep(500),        &
     &         icntl(40),info(40)
      INTEGER*8 KEEP8(150)
      integer,intent(out)::nbsa,istat
      integer ierr,nmb_thislayer,layernmb,mapalgo,allocok,i
      integer,pointer,dimension(:)::thislayer
      integer,parameter::memonly=1,floponly=2,hybrid=3
      DOUBLE PRECISION::                                                &
     &         maxwork,minwork,maxmem,minmem,workbalance,membalance
      DOUBLE PRECISION:: cost_root_node
      DOUBLE PRECISION,dimension(:),allocatable:: work_per_proc
      integer,dimension(:),allocatable::id_son
      logical::cont
      character (len=48):: err_rep,subname
      DOUBLE PRECISION peak
      istat=-1
      subname='DISTRIBUTE'
      cv_lp=icntl(1)
      cv_mp=icntl(3)
      nullify(thislayer)
      err_rep='INITPART1'
      call AGMG_MUMPS_478(n,slavef,                                          &
     &                   frere,fils,nfsiz,ne,keep,KEEP8,icntl,info,     &
     &                   procnode,ssarbr,peak,ierr                      &
     &     )
      if (ierr.ne.0) goto 99999
      err_rep='PROCINIT'
      call AGMG_MUMPS_391(istat=ierr)
      if (ierr.ne.0) goto 99999
      err_rep='CALCCOST'
      call AGMG_MUMPS_417(ierr)
      if (ierr.ne.0) goto 99999
      err_rep='ROOTLIST'
      call AGMG_MUMPS_394(ierr)
      if (ierr.ne.0) goto 99999
      err_rep='LAYERL0'
      call AGMG_MUMPS_381(ierr)
      if (ierr.ne.0) goto 99999
      if(cv_keep(82) .eq. 0) then
         err_rep='FIND_POTSPLIT'
         call AGMG_MUMPS_375(cv_equilib_flops,ierr)
      endif
      if (ierr.ne.0) goto 99999
      err_rep='INITPART2'
      call AGMG_MUMPS_479(ierr)
      if (ierr.ne.0) goto 99999
      err_rep='WORKMEM_'
      call AGMG_MUMPS_408(                                                   &
     &     cv_proc_workload,cv_proc_memused,                            &
     &     maxwork,minwork,maxmem,minmem)
      if(maxwork.gt.0.0D0) then
         workbalance=minwork/maxwork
      else
         workbalance=0.0D0
      endif
      if(maxmem.gt.0.0D0) then
         membalance=minmem/maxmem
      else
         membalance=0.0D0
      endif
      err_rep='mem_alloc'
      allocate(thislayer(cv_maxnodenmb),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = 2*cv_maxnsteps+cv_maxnodenmb
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'memory allocation error in ',subname
         ierr = cv_error_memalloc
         goto 99999
      end if
      cont=.TRUE.
      layernmb=0
      mapalgo=floponly
      err_rep='SELECT_TYPE3'
      call AGMG_MUMPS_396(ierr)
      if (ierr.ne.0) goto 99999
      IF (cv_keep(38) .ne. 0 .and. cv_keep(60) .eq. 0 ) THEN
        call AGMG_MUMPS_511(cv_nfsiz(keep(38)),                              &
     &               cv_nfsiz(keep(38)), cv_nfsiz(keep(38)),            &
     &               cv_keep(50), 3, cost_root_node)
        cost_root_node = cost_root_node / dble(cv_slavef)
        do i=1, cv_slavef
          cv_proc_memused(i)=cv_proc_memused(i)+                        &
     &        dble(cv_nfsiz(keep(38)))*dble(cv_nfsiz(keep(38)))/        &
     &        dble(cv_slavef)
          cv_proc_workload(i)=cv_proc_workload(i)+dble(cost_root_node)
        enddo
      ENDIF
      do while((cont).OR.(layernmb.le.cv_maxlayer))
         err_rep='FIND_THIS'
         call AGMG_MUMPS_376(layernmb,thislayer,nmb_thislayer,               &
     &                                ierr)
         if (ierr.ne.0) goto 99999
         err_rep='DO_SPLITTING'
         if(cv_keep(82) .gt. 0) then
            if(layernmb.gt.0) call AGMG_MUMPS_527                            &
     &           (layernmb,thislayer,nmb_thislayer,ierr)
         else
            if(layernmb.gt.0) call AGMG_MUMPS_370                            &
     &           (layernmb,thislayer,nmb_thislayer,ierr)
         endif
         if (ierr.ne.0) goto 99999
         err_rep='ASSIGN_TYPES'
         call AGMG_MUMPS_416(layernmb,thislayer,nmb_thislayer,               &
     &                              ierr)
         if (ierr.ne.0) goto 99999
         if(layernmb.gt.0) then
            if ((cv_keep(24).eq.1).OR.(cv_keep(24).eq.2).OR.            &
     &          (cv_keep(24).eq.4).OR.(cv_keep(24).eq.6)) then
               err_rep='COSTS_LAYER_T2'
               call AGMG_MUMPS_367(layernmb,nmb_thislayer,ierr)
            elseif((cv_keep(24).eq.8).OR.(cv_keep(24).eq.10)            &
     &             .OR.(cv_keep(24).eq.12).OR.(cv_keep(24).eq.14)       &
     &             .OR.(cv_keep(24).eq.16).OR.(cv_keep(24).eq.18)) then
               err_rep='COSTS_LAYER_T2PM'
               call AGMG_MUMPS_489(layernmb,nmb_thislayer,ierr)
            else
               err_rep='wrong strategy for COSTS_LAYER_T2'
               ierr = -9999
            endif
            if (ierr.ne.0) goto 99999
            err_rep='WORKMEM_'
            call AGMG_MUMPS_408(                                             &
     &                          cv_proc_workload,cv_proc_memused,       &
     &                                   maxwork,minwork,maxmem,minmem)
            if(maxwork.gt.0.0D0) then
               workbalance=minwork/maxwork
            else
               workbalance=0.0D0
            endif
            if(maxmem.gt.0.0D0) then
               membalance=minmem/maxmem
            else
               membalance=0.0D0
            endif
            if(mapalgo.eq.memonly) then
               err_rep='MAP_LAYER'
               call AGMG_MUMPS_387(layernmb,thislayer,                       &
     &              nmb_thislayer,cv_equilib_mem,ierr)
               if (ierr.ne.0) goto 99999
            elseif(mapalgo.eq.floponly) then
               err_rep='MAP_LAYER'
               call AGMG_MUMPS_387(layernmb,thislayer,                       &
     &              nmb_thislayer,cv_equilib_flops,ierr)
               if (ierr.ne.0) goto 99999
            elseif(mapalgo.eq.hybrid) then
               if (workbalance <= membalance) then
                  err_rep='MAP_LAYER'
                  call AGMG_MUMPS_387(layernmb,thislayer,                    &
     &                 nmb_thislayer,cv_equilib_flops,ierr)
                  if (ierr.ne.0) goto 99999
               else
                  err_rep='MAP_LAYER'
                  call AGMG_MUMPS_387(layernmb,thislayer,                    &
     &                 nmb_thislayer,cv_equilib_mem,ierr)
                  if (ierr.ne.0) goto 99999
               endif
            else
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Unknown mapalgo in ',subname
               return
            endif
      endif
         layernmb=layernmb+1
         err_rep='HIGHER_LAYER'
         call AGMG_MUMPS_377(layernmb,thislayer,                             &
     &                 nmb_thislayer,cont,ierr)
         if (ierr.ne.0) goto 99999
      end do
       if(cv_slavef.gt.4)                                               &
     &   call AGMG_MUMPS_431()
      err_rep='SETUP_CAND'
      call AGMG_MUMPS_397(ierr)
      if (ierr.ne.0) goto 99999
      err_rep='ENCODE_PROC'
      call AGMG_MUMPS_371(ierr)
      if (ierr.ne.0) goto 99999
      err_rep='STORE_GLOB'
      call AGMG_MUMPS_402(ne,nfsiz,frere,fils,keep,KEEP8,                    &
     &                         info,procnode,ssarbr,nbsa)
      err_rep='mem_dealloc'
      deallocate(thislayer,STAT=ierr)
      if (ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'Memory deallocation error in ',subname
         ierr = cv_error_memdeloc
         goto 99999
      endif
      err_rep='TERMGLOB'
      call AGMG_MUMPS_403(ierr)
      if (ierr.ne.0) goto 99999
      istat=0
      return
99999 continue
      if(cv_lp.gt.0) then
         write(cv_lp,*)'Error in ',subname,', layernmb=',layernmb
         write(cv_lp,*)'procedure reporting the error: ',err_rep
      endif
      if(ierr.eq.cv_error_memalloc) then
         info(1) = cv_info(1)
         info(2) = cv_info(2)
      endif
      istat=ierr
      return
      CONTAINS
      subroutine AGMG_MUMPS_413(                                             &
     &                       map_strat,workload,memused,accepted,       &
     &                              istat)
      implicit none
      integer,intent(in)::map_strat
      DOUBLE PRECISION,dimension(cv_slavef),intent(in)::workload,       &
     &                                                   memused
      logical,intent(out)::accepted
      integer,intent(out)::istat
      DOUBLE PRECISION maxi,mini,mean,stddev
      integer i,nmb
      intrinsic maxval,minval,count,sum
      character (len=48):: subname
      logical alternative_criterion
      DOUBLE PRECISION::                                                &
     &          MINFLOPS , MINMEM,                                      &
     &          CL_RATE, DV_RATE
      istat=-1
      if ( cv_keep(72) .EQ. 1) then
       MINFLOPS = 2.0D0
       MINMEM=50.0D0
       CL_RATE =0.8D0
       DV_RATE=0.2D0
      else
       MINFLOPS = 5.0D7
       MINMEM=5.0D6
       CL_RATE =0.8D0
       DV_RATE=0.2D0
      endif
      subname='ACCEPT_L0'
      accepted=.FALSE.
      alternative_criterion=.FALSE.
      if(map_strat.eq.cv_equilib_flops) then
         maxi=maxval(workload)
         mini=minval(workload)
         if (maxi.lt.MINFLOPS) then
            accepted=.TRUE.
         elseif(maxi.le.(dble(cv_keep(102))/dble(100))*mini)then
            accepted=.TRUE.
         endif
         if ((.NOT.accepted).AND.(alternative_criterion)) then
            mean=sum(workload)/max(dble(cv_slavef),dble(1))
            stddev=dble(0)
            do i=1,cv_slavef
               stddev=stddev+                                           &
     &               (abs(workload(i)-mean)*abs(workload(i)-mean))
            enddo
            stddev=sqrt(stddev/max(dble(cv_slavef),dble(1)))
            nmb=count(mask=abs(workload-mean)<stddev)
            if((dble(nmb)/max(dble(cv_slavef),dble(1)).gt.CL_RATE)      &
     &       .AND.(stddev.lt.DV_RATE*mean)) accepted=.TRUE.
         endif
      elseif(map_strat.eq.cv_equilib_mem) then
         maxi=maxval(memused)
         mini=minval(memused)
         if (maxi.lt.MINMEM) then
            accepted=.TRUE.
         else if(cv_slavef.lt.48) then
            if (maxi.le.dble(2)*mini) accepted=.TRUE.
         else if(cv_slavef.lt.128) then
            if (maxi.le.dble(4)*mini) accepted=.TRUE.
         else if(cv_slavef.lt.256) then
            if (maxi.le.dble(6)*mini) accepted=.TRUE.
         else if(cv_slavef.lt.512) then
            if (maxi.le.dble(8)*mini) accepted=.TRUE.
         else if(cv_slavef.gt.512) then
            if (maxi.le.dble(10)*mini) accepted=.TRUE.
         end if
      endif
      istat=0
      return
      end subroutine AGMG_MUMPS_413
      subroutine AGMG_MUMPS_414(ifather,ison,istat)
      implicit none
      integer,intent(in)::ifather,ison
      integer, intent(out)::istat
      integer in,npiv_son,in_father,in_ison,bigbrother,oldest_son,      &
     &        npiv,nfront
      DOUBLE PRECISION costm,costw
      character (len=48):: subname
      istat=-1
      subname='AMALGAMATE_SONFATH'
      if((cv_frere(ison).eq.0).or.(cv_frere(ison).eq.cv_n+1)) return
      in=ifather
      do while (cv_fils(in).gt.0)
         in=cv_fils(in)
      end do
      if (cv_fils(in).eq.0) return
      in_father=in
      in = -cv_fils(in)
      if (in.eq.ison) then
         cv_fils(in_father)=ison
         in=ison
         do while (cv_fils(in).gt.0)
            in=cv_fils(in)
         end do
         if (cv_fils(in).eq.0) then
            if(cv_frere(ison).gt.0) then
               cv_fils(in)=-cv_frere(ison)
            end if
            cv_frere(ison)=cv_n+1
         else
            in=-cv_fils(in)
            do while(cv_frere(in).gt.0)
               in=cv_frere(in)
            end do
            cv_frere(in)=cv_frere(ison)
            cv_frere(ison)=cv_n+1
         end if
      else
         oldest_son=in
         do while((cv_frere(in).ne.ison).and.(cv_frere(in).gt.0))
            in=cv_frere(in)
         end do
         if (cv_frere(in).ne.ison) return
         bigbrother=in
         cv_fils(in_father)=ison
         in=ison
         do while (cv_fils(in).gt.0)
            in=cv_fils(in)
         end do
         in_ison=in
         if (cv_fils(in).eq.0) then
            cv_frere(bigbrother)=cv_frere(ison)
            cv_frere(ison)=cv_n+1
            cv_fils(in_ison)=-oldest_son
         else
            in=-cv_fils(in_ison)
            cv_frere(bigbrother)=in
            do while(cv_frere(in).gt.0)
               in=cv_frere(in)
            end do
            cv_frere(in)=cv_frere(ison)
            cv_frere(ison)=cv_n+1
            cv_fils(in_ison)=-oldest_son
         end if
      end if
      cv_nsteps = cv_nsteps - 1
      cv_ne(ifather)=cv_ne(ifather)+cv_ne(ison)-1
      cv_ne(ison)=0
      in=ison
      npiv_son=0
      do while (in.gt.0)
         in=cv_fils(in)
         npiv_son=npiv_son+1
      end do
      cv_nfsiz(ifather)=cv_nfsiz(ifather)+npiv_son
      cv_nfsiz(ison)=0
      cv_info(5)=max(cv_info(5),cv_nfsiz(ifather))
      in=ifather
      npiv=0
      do while (in.gt.0)
         in=cv_fils(in)
         npiv=npiv+1
      end do
      nfront=cv_nfsiz(ifather)
      call AGMG_MUMPS_418(npiv,nfront,costw,costm)
      cv_ncostw(ifather)=costw
      cv_ncostm(ifather)=costm
      cv_ncostw(ison)=0.0D0
      cv_ncostm(ison)=0.0D0
      if(associated(cv_tcostw)) cv_tcostw(ison)=0.0D0
      if(associated(cv_tcostm)) cv_tcostm(ison)=0.0D0
      cv_total_amalg=cv_total_amalg+1
      call AGMG_MUMPS_436(ison,ifather,ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'PROPMAP4AMALG error in ',subname
         istat = ierr
         return
      end if
      istat = 0
      return
      end subroutine AGMG_MUMPS_414
      subroutine AGMG_MUMPS_415(map_strat,layerL0end,workload,memused,       &
     &                           procnode,istat,respect_prop)
      implicit none
      integer, intent(in)::map_strat, layerL0end
      DOUBLE PRECISION,dimension(cv_slavef),intent(out)::workload,      &
     &                                                   memused
      integer, intent(out)::procnode(cv_n),istat
      logical, intent(in), OPTIONAL:: respect_prop
      integer nmb_listnodes,i,j,ierr,                                   &
     &        nodenumber,proc
      DOUBLE PRECISION tot_work,tot_mem,work,mem
      character (len=48):: err_rep,subname
      istat=-1
      subname='ARRANGEL0'
      if ((.NOT.associated(cv_tcostw)).OR.(.NOT.associated(cv_tcostm))) &
     &   then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:tcost must be allocated in ',subname
         return
      end if
      if((map_strat.ne.cv_equilib_flops).and.                           &
     &   (map_strat.ne.cv_equilib_mem)) return
      do i=1,cv_n
         procnode(i)=cv_invalid
      end do
      do i=1,cv_slavef
         workload(i)=cv_proc_workload(i)
         memused(i)=cv_proc_memused(i)
      end do
      do i=cv_layerl0_start,layerl0end
         nodenumber=cv_layerl0_array(i)
         work=cv_tcostw(nodenumber)
         mem=cv_tcostm(nodenumber)
         err_rep='FIND_BEST_PROC'
         if(present(respect_prop)) then
            call AGMG_MUMPS_374(nodenumber,map_strat,work,mem,               &
     &           workload,memused,proc,ierr,respect_prop)
         else
            call AGMG_MUMPS_374(nodenumber,map_strat,work,mem,               &
     &           workload,memused,proc,ierr)
         endif
         if(ierr.eq.0) then
            procnode(nodenumber)=proc
         else
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            do j=1,cv_slavef
               workload(j)=cv_proc_workload(j)
               memused(j)=cv_proc_memused(j)
            end do
            do j=1,cv_n
               procnode(j)=cv_invalid
            end do
            return
         end if
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_415
      subroutine AGMG_MUMPS_416(                                             &
     &                              layernmb,thislayer,nmb_thislayer,   &
     &                                 istat)
      implicit none
      integer,intent(in)::layernmb,thislayer(cv_maxnodenmb),            &
     &                    nmb_thislayer
      integer,intent(out)::istat
      integer i,in,npiv,nfront,inode,inoderoot,par_nodes_in_layer,      &
     &        dummy,allocok
      character (len=48):: subname
      istat=-1
      subname='ASSIGN_TYPES'
      if((layernmb.lt.0).or.(layernmb.gt.cv_maxlayer)) return
      if(cv_slavef.eq.1) then
         if(layernmb.eq.0) then
            do inode=1,cv_n
               cv_nodetype(inode)=0
            end do
         end if
      else if(layernmb.eq.0) then
         do i=1,nmb_thislayer
            inode=thislayer(i)
            inoderoot=inode
            if(cv_nodetype(inode).ne.cv_invalid) cycle
            cv_nodetype(inode)=0
   30       continue
            in = inode
            do while (in .ne. 0)
               inode = in
               do while (in .gt. 0)
                  in = cv_fils(in)
               end do
               if (in.lt.0) in=-in
            end do
   10       continue
            if ( inode .ne. inoderoot ) then
               cv_nodetype(inode)=-1
               in = cv_frere(inode)
               inode = abs(in)
               if (in .lt. 0) then
                  go to 10
               else
                  go to 30
               end if
            end if
         end do
      else
         do i=1,nmb_thislayer
            inode=thislayer(i)
            in = inode
            npiv = 0
            do while (in.gt.0)
               in = cv_fils(in)
               npiv = npiv + 1
            end do
            nfront = cv_nfsiz(inode)
            if(cv_nodetype(inode).ne.cv_invalid) cycle
            if( ( AGMG_MUMPS_359(nfront,npiv)) .AND.                         &
     &           (in.ne.0)) then
               cv_nodetype(inode)=2
            else
               cv_nodetype(inode)=1
            end if
         end do
      end if
      if(layernmb.gt.0) then
         par_nodes_in_layer=0
         do i=1,nmb_thislayer
            inode=thislayer(i)
            if (cv_nodetype(inode).eq.2)                                &
     &         par_nodes_in_layer=par_nodes_in_layer+1
         enddo
         if(par_nodes_in_layer.gt.0) then
            allocate(                                                   &
     &cv_layer_p2node(layernmb)%t2_nodenumbers(par_nodes_in_layer),     &
     &cv_layer_p2node(layernmb)%t2_cand(par_nodes_in_layer,cv_slavef+1),&
     &cv_layer_p2node(layernmb)%t2_candcostw(par_nodes_in_layer),       &
     &cv_layer_p2node(layernmb)%t2_candcostm(par_nodes_in_layer),       &
     &               STAT=allocok)
            if (allocok.gt.0) then
               cv_info(1) = cv_error_memalloc
               cv_info(2) = (3+cv_slavef+1)*par_nodes_in_layer
               istat = cv_error_memalloc
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'memory allocation error in ',subname
               return
            end if
            cv_layer_p2node(layernmb)%nmb_t2s=par_nodes_in_layer
            dummy=1
            do i=1,nmb_thislayer
               inode=thislayer(i)
               if (cv_nodetype(inode).eq.2) then
                  cv_layer_p2node(layernmb)%t2_nodenumbers(dummy)=inode
                  cv_layer_p2node(layernmb)%t2_cand(dummy,:)=0
                  cv_layer_p2node(layernmb)%t2_candcostw(dummy)         &
     &                                                    =cv_d_invalid
                  cv_layer_p2node(layernmb)%t2_candcostm(dummy)         &
     &                                                    =cv_d_invalid
                  dummy=dummy+1
               endif
            enddo
         else
            nullify(cv_layer_p2node(layernmb)%t2_nodenumbers,           &
     &              cv_layer_p2node(layernmb)%t2_cand,                  &
     &              cv_layer_p2node(layernmb)%t2_candcostw,             &
     &              cv_layer_p2node(layernmb)%t2_candcostm)
         end if
      endif
      istat=0
      return
      end subroutine AGMG_MUMPS_416
      function AGMG_MUMPS_480(procs4node,procnumber)
      implicit none
      integer,intent(in)::procs4node(cv_size_ind_proc)
      integer,intent(in)::procnumber
      logical :: AGMG_MUMPS_480
      integer pos1,pos2
      pos1 = (procnumber-1)/cv_bitsize_of_int +1
      pos2 = mod(procnumber-1,cv_bitsize_of_int)
      AGMG_MUMPS_480=btest(procs4node(pos1),pos2)
      return
      end function AGMG_MUMPS_480
      function AGMG_MUMPS_481(inode,procnumber)
      implicit none
      integer, intent(in)::inode,procnumber
      logical :: AGMG_MUMPS_481
      integer pos1,pos2
      AGMG_MUMPS_481=.FALSE.
      if((procnumber.lt.1).or.(procnumber.gt.cv_slavef)) return
      if(.not.associated(cv_prop_map(inode)%ind_proc)) return
      pos1 = (procnumber-1)/cv_bitsize_of_int +1
      pos2 = mod(procnumber-1,cv_bitsize_of_int)
      AGMG_MUMPS_481=btest                                                   &
     &               (cv_prop_map(inode)%ind_proc(pos1),pos2)
      return
      end function AGMG_MUMPS_481
      subroutine AGMG_MUMPS_482(procs4node,procnumber,istat)
      implicit none
      integer, intent(inout)::procs4node(cv_size_ind_proc)
      integer,intent(in)::procnumber
      integer, intent(out)::istat
      integer pos1,pos2
      istat = -1
      if((procnumber.lt.1).or.(procnumber.gt.cv_slavef)) return
      if(cv_bitsize_of_int.le.0) return
      pos1 = (procnumber-1)/cv_bitsize_of_int +1
      pos2 = mod(procnumber-1,cv_bitsize_of_int)
      procs4node(pos1)=ibset(procs4node(pos1),pos2)
      istat = 0
      return
      end subroutine AGMG_MUMPS_482
      subroutine AGMG_MUMPS_417(istat)
      implicit none
      integer,intent(out)::istat
      integer i,ierr
      DOUBLE PRECISION :: maxcostw_root
      character (len=48):: err_rep,subname
      istat = -1
      subname='CALCCOSTS'
      if ((.NOT.associated(cv_tcostw)).OR.(.NOT.associated(cv_tcostm))) &
     &   then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:tcost must be allocated in ',subname
         return
      end if
      maxcostw_root = 0D0
      do i=1,cv_n
         if (cv_frere(i).eq.cv_n+1) then
            cv_tcostw(i)=0.0D0
            cv_ncostw(i)=0.0D0
            cv_tcostm(i)=0.0D0
            cv_ncostm(i)=0.0D0
         elseif (cv_frere(i).eq.0) then
            err_rep='TREECOSTS'
            cv_depth(i)=1
            call AGMG_MUMPS_404(i,ierr)
            maxcostw_root = max(maxcostw_root,cv_tcostw(i))
            if (ierr.ne.0) then
          if(cv_lp.gt.0)                                                &
     &    write(cv_lp,*)'Failure reported by ',err_rep, ' in ',subname
               return
            end if
         end if
      end do
      istat = 0
      mincostw = 1.0D0+maxcostw_root/(dble(cv_maxnsteps)*               &
     &              dble(10*cv_slavef) )
      return
      end subroutine AGMG_MUMPS_417
      subroutine AGMG_MUMPS_418(npiv,nfront,costw,costm)
      implicit none
      integer,intent(in)::npiv,nfront
      DOUBLE PRECISION,intent(out)::costw,costm
      character (len=48):: subname
      subname='CALCNODECOSTS'
      if((npiv.le.1).and.(nfront.le.1)) then
         costw = dble(0)
         costm = dble(1)
      else
         if(cv_keep(50).eq.0) then
            costw= 2.0D0*dble(nfront)*dble(npiv)*dble(nfront-npiv-1)    &
     &      + dble(npiv)*dble(npiv+1)*dble(2*npiv+1)/dble(3)            &
     &           + dble(2*nfront-npiv-1) * dble(npiv) / dble(2)
            costm= dble(npiv)*(dble(2*nfront)-dble(npiv))
         else
            costw= dble(npiv) *                                         &
     &            (dble(nfront)*dble(nfront)+dble(2*nfront) -           &
     &             dble(nfront+1) * dble(npiv+1) +                      &
     &             dble(npiv+1) * dble(2*npiv+1) / dble(6))
            costm= dble(npiv) * dble(nfront)
         end if
      end if
      if((costw.lt.0.0D0).or.(costm.lt.0.0D0)) then
      endif
      return
      end subroutine AGMG_MUMPS_418
      subroutine AGMG_MUMPS_367(layernmb,nmb_thislayer,istat)
      implicit none
      integer,intent(in)::layernmb,nmb_thislayer
      integer,intent(out)::istat
      integer in,inode,j,kmax,npiv,nfront,ncb,ncol,                     &
     &        min_needed,max_needed,more_than_needed,total_nmb_cand,    &
     &        nmb_type2_thislayer,fraction,                             &
     &        total_cand_layer,cand_strat, keep48_loc, WHAT_LOC
      DOUBLE PRECISION flop1,work_type2_thislayer,                      &
     &        relative_weight,workmaster,nrow
      logical force_cand
      intrinsic count,max
      character (len=48):: subname
      integer AGMG_MUMPS_497, AGMG_MUMPS_50,                                      &
     &        AGMG_MUMPS_52
      external AGMG_MUMPS_497, AGMG_MUMPS_50,                                     &
     &        AGMG_MUMPS_52
      istat=-1
      subname='COSTS_LAYER_T2'
      if (cv_keep(24).lt.1) then
          if(cv_lp.gt.0)                                                &
     &    write(cv_lp,*)'Error in ',subname,'. Wrong keep24'
         return
      endif
      force_cand=(mod(cv_keep(24),2).eq.0)
      cand_strat=cv_keep(24)/2
      nmb_type2_thislayer=cv_layer_p2node(layernmb)%nmb_t2s
      if (nmb_type2_thislayer.gt.0) then
         work_type2_thislayer=0.0D0
         do j=1,nmb_type2_thislayer
            inode=cv_layer_p2node(layernmb)%t2_nodenumbers(j)
            work_type2_thislayer=work_type2_thislayer+cv_ncostw(inode)
         end do
         if(cv_relax.le.0.0D0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Error in ',subname,'. Wrong cv_relax'
            return
         endif
         total_cand_layer=int(cv_relax*dble(cv_slavef))
         do j=1,nmb_type2_thislayer
            inode=cv_layer_p2node(layernmb)%t2_nodenumbers(j)
            nfront=cv_nfsiz(inode)
            npiv=0
            in=inode
            do while(in.gt.0)
               npiv=npiv+1
               in=cv_fils(in)
            end do
            ncb=nfront-npiv
            kmax = AGMG_MUMPS_497(cv_keep8(21),ncb)
            if (force_cand) then
              if (cv_keep(50) ==  0) then
                keep48_loc=0
              else
                keep48_loc=3
              endif
              if (cv_keep(48).EQ.5) keep48_loc = 5
               min_needed = AGMG_MUMPS_50(                                   &
     &             cv_slavef, keep48_loc,cv_keep8(21),                  &
     &             cv_keep(50),nfront,ncb)
               max_needed = AGMG_MUMPS_52(                                   &
     &             cv_slavef, keep48_loc,cv_keep8(21),                  &
     &             cv_keep(50),nfront,ncb)
               if(cand_strat.eq.1) then
                  more_than_needed = 0
               elseif (cand_strat.eq.2) then
                  if(work_type2_thislayer.gt.0.0D0) then
                  relative_weight=cv_ncostw(inode)/work_type2_thislayer
                  else
                     relative_weight = 0.0D0
                  endif
                  fraction=nint(relative_weight *                       &
     &                 dble(total_cand_layer))
                  more_than_needed=min(max(0,cv_slavef-1-min_needed),   &
     &                                 max(0,fraction-min_needed)    )
               elseif (cand_strat.eq.3) then
                  more_than_needed=cv_slavef-1-min_needed
               else
                  if(cv_lp.gt.0)                                        &
     &            write(cv_lp,*)'Unknown cand. strategy in ',subname
                  return
               endif
               total_nmb_cand=min(min_needed+more_than_needed,          &
     &              cv_slavef-1)
               total_nmb_cand=min(total_nmb_cand,max_needed)
            else
               total_nmb_cand=0
            endif
            cv_layer_p2node(layernmb)%t2_cand(j,cv_slavef+1)            &
     &                                 = total_nmb_cand
            if(cv_keep(50).eq.0) then
               flop1=dble(2*npiv)*dble(nfront)-                         &
     &              dble(npiv+nfront)*dble(npiv+1)
               flop1= dble(npiv)*flop1 +                                &
     &          dble(2 * npiv-npiv-1)*dble(npiv)/dble(2)+               &
     &          dble(npiv)*dble(npiv+1)*dble(2*npiv+1)/dble(3)
            else
               flop1=dble(npiv)*                                        &
     &         ( dble(npiv)*dble(npiv)+dble(npiv)-                      &
     &         dble(npiv*npiv+npiv+1) )+                                &
     &         (dble(npiv)*dble(npiv+1)*dble(2*npiv+1))/dble(6)
            endif
            cv_ncostw(inode)=flop1
            if(total_nmb_cand.gt.0) then
               nrow = dble(max(min(dble(ncb)/dble(total_nmb_cand),      &
     &                     dble(kmax)),                                 &
     &                 dble(ncb)/dble(cv_slavef-1)))
            elseif(cv_slavef.gt.1) then
               nrow = dble(max(dble(kmax),                              &
     &                         dble(ncb)/dble(cv_slavef-1)))
            else
               nrow = dble(ncb)
            endif
            if(cv_keep(50).eq.0) then
               flop1 = dble(npiv)*dble(nrow)+                           &
     &                 dble(nrow)*dble(npiv)*dble(2*nfront-npiv-1)
            else
               ncol= nfront
               flop1 = dble(npiv)*dble(nrow)*                           &
     &          (dble(2*ncol)-dble(nrow)-dble(npiv)+dble(1))
               workmaster = dble(npiv*npiv)*dble(npiv)/dble(3)
               if (workmaster.gt.flop1) flop1=workmaster
            endif
            cv_layer_p2node(layernmb)%t2_candcostw(j)=flop1
            if(cv_keep(50).eq.0) then
               cv_ncostm(inode)=dble(npiv)*dble(nfront)
            else
               cv_ncostm(inode)=dble(npiv)*dble(npiv)
            endif
            if(cv_keep(50).eq.0) then
               cv_layer_p2node(layernmb)%t2_candcostm(j)                &
     &                                  =dble(npiv)*dble(nrow)
            else
               cv_layer_p2node(layernmb)%t2_candcostm(j)                &
     &                                  =dble(npiv)*dble(nrow)
            endif
         end do
      endif
      istat=0
      return
      end subroutine AGMG_MUMPS_367
      subroutine AGMG_MUMPS_489(layernmb,nmb_thislayer,istat)
      implicit none
      integer,intent(in)::layernmb,nmb_thislayer
      integer,intent(out)::istat
      integer in,inode,j,jj,kmax,npiv,nfront,ncb,ncol,                  &
     &        total_nmb_cand,nmb_type2_thislayer,                       &
     &        total_cand_layer,npropmap,min_needed,                     &
     &        keep48_loc
      DOUBLE PRECISION flop1,work_type2_thislayer,                      &
     &        relative_weight,workmaster,nrow
      intrinsic count,max
      character (len=48):: subname
      integer AGMG_MUMPS_497, AGMG_MUMPS_50
      external AGMG_MUMPS_497, AGMG_MUMPS_50
      istat=-1
      subname='COSTS_LAYER_T2PM'
      if((cv_keep(24).ne.8).AND.(cv_keep(24).ne.10)                     &
     &    .AND.(cv_keep(24).ne.12).AND.(cv_keep(24).ne.14)              &
     &    .AND.(cv_keep(24).ne.16).AND.(cv_keep(24).ne.18)) then
          if(cv_lp.gt.0)                                                &
     &    write(cv_lp,*)'Error in ',subname,'. Wrong keep24'
         return
      endif
      nmb_type2_thislayer=cv_layer_p2node(layernmb)%nmb_t2s
      if (nmb_type2_thislayer.gt.0) then
         total_cand_layer=0
         work_type2_thislayer=0.0D0
         do j=1,nmb_type2_thislayer
            inode=cv_layer_p2node(layernmb)%t2_nodenumbers(j)
            work_type2_thislayer=work_type2_thislayer+cv_ncostw(inode)
            npropmap=0
            do jj=1,cv_slavef
               if( AGMG_MUMPS_481(inode,jj))                                 &
     &              npropmap=npropmap+1
            end do
            total_cand_layer=total_cand_layer+npropmap
         end do
         do j=1,nmb_type2_thislayer
            inode=cv_layer_p2node(layernmb)%t2_nodenumbers(j)
            nfront=cv_nfsiz(inode)
            npiv=0
            in=inode
            do while(in.gt.0)
               npiv=npiv+1
               in=cv_fils(in)
            end do
            ncb=nfront-npiv
            kmax = AGMG_MUMPS_497(cv_keep8(21),ncb)
            if(kmax.lt.1) then
               kmax = max(kmax,1)
            endif
            if (cv_keep(50) ==  0) then
              keep48_loc=0
            else
              keep48_loc=3
            endif
            if (cv_keep(48).EQ.5) keep48_loc = 5
            min_needed= AGMG_MUMPS_50                                        &
     &          (cv_slavef, keep48_loc,cv_keep8(21),                    &
     &           cv_keep(50),nfront,ncb)
            if(min_needed.lt.1) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Error in ',subname,'.NEG min_needed'
               return
            endif
            if ((cv_keep(24).eq.8).OR.(cv_keep(24).eq.14).OR.           &
     &          (cv_keep(24).eq.18)) then
               npropmap=0
               do jj=1,cv_slavef
                  if( AGMG_MUMPS_481(inode,jj))                              &
     &                 npropmap=npropmap+1
               end do
               total_nmb_cand=max(npropmap-1,min_needed)
            elseif(cv_keep(24).eq.10) then
               if(work_type2_thislayer.gt.0.0D0) then
                  relative_weight=cv_ncostw(inode)/work_type2_thislayer
               else
                  relative_weight = 0.0D0
               endif
               total_nmb_cand=nint(relative_weight *                    &
     &              dble(total_cand_layer))
               total_nmb_cand=max(total_nmb_cand-1,min_needed)
            elseif((cv_keep(24).eq.12).OR.(cv_keep(24).eq.16)) then
               if(layernmb.lt.cv_dist_L0_mixed_strat_bound) then
                  if(cv_mp.gt.0)then
                     write(cv_mp,*)'Strat', cv_keep(24),                &
     &                             ': use 8 on layer',layernmb
                  endif
                  npropmap=0
                  do jj=1,cv_slavef
                     if( AGMG_MUMPS_481(inode,jj))                           &
     &                    npropmap=npropmap+1
                  end do
                  total_nmb_cand=max(npropmap-1,min_needed)
               else
                  if(cv_mp.gt.0)then
                     write(cv_mp,*)'Strat', cv_keep(24),                &
     &                             ': use 10 on layer',layernmb
                  endif
                  if(work_type2_thislayer.gt.0.0D0) then
                  relative_weight=cv_ncostw(inode)/work_type2_thislayer
                  else
                     relative_weight = 0.0D0
                  endif
                  total_nmb_cand=nint(relative_weight *                 &
     &                 dble(total_cand_layer))
                  total_nmb_cand=max(total_nmb_cand-1,min_needed)
               endif
            else
               if(cv_lp.gt.0)                                           &
     &              write(cv_lp,*)'Unknown cand. strategy in ',subname
               return
            endif
            total_nmb_cand=max(total_nmb_cand,1)
            total_nmb_cand=min(total_nmb_cand,cv_slavef-1)
            total_nmb_cand=min(total_nmb_cand,ncb)
            cv_layer_p2node(layernmb)%t2_cand(j,cv_slavef+1)            &
     &                                 = total_nmb_cand
            if(cv_keep(50).eq.0) then
               flop1=dble(2*npiv)*dble(nfront)-                         &
     &              dble(npiv+nfront)*dble(npiv+1)
               flop1= dble(npiv)*flop1 +                                &
     &          dble(2 * npiv-npiv-1)*dble(npiv)/dble(2)+               &
     &          dble(npiv)*dble(npiv+1)*dble(2*npiv+1)/dble(3)
            else
               flop1=dble(npiv)*                                        &
     &         ( dble(npiv)*dble(npiv)+dble(npiv)-                      &
     &         dble(npiv*npiv+npiv+1) )+                                &
     &         (dble(npiv)*dble(npiv+1)*dble(2*npiv+1))/dble(6)
            endif
            cv_ncostw(inode)=flop1
            if(total_nmb_cand.gt.0) then
               nrow = dble(max(min(dble(ncb)/dble(total_nmb_cand),      &
     &                     dble(kmax)),                                 &
     &                 dble(ncb)/dble(cv_slavef-1)))
            elseif(cv_slavef.gt.1) then
               nrow = dble(max(dble(kmax),                              &
     &                         dble(ncb)/dble(cv_slavef-1)))
            else
               nrow = dble(ncb)
            endif
            if(cv_keep(50).eq.0) then
               flop1 = dble(npiv)*dble(nrow)+                           &
     &                 dble(nrow)*dble(npiv)*dble(2*nfront-npiv-1)
            else
               ncol= nfront
               flop1 = dble(npiv)*dble(nrow)*                           &
     &          (dble(2*ncol)-dble(nrow)-dble(npiv)+dble(1))
               workmaster = dble(npiv*npiv)*dble(npiv)/dble(3)
               if (workmaster.gt.flop1) flop1=workmaster
            endif
            cv_layer_p2node(layernmb)%t2_candcostw(j)=flop1
            if(cv_keep(50).eq.0) then
               cv_ncostm(inode)=dble(npiv)*dble(nfront)
            else
               cv_ncostm(inode)=dble(npiv)*dble(npiv)
            endif
            if(cv_keep(50).eq.0) then
               cv_layer_p2node(layernmb)%t2_candcostm(j)                &
     &                                  =dble(npiv)*dble(nrow)
            else
               cv_layer_p2node(layernmb)%t2_candcostm(j)                &
     &                                  =dble(npiv)*dble(nrow)
            endif
         end do
      endif
      istat=0
      return
      end subroutine AGMG_MUMPS_489
      subroutine AGMG_MUMPS_527(                                             &
     &     layernmb,thislayer,nmb_thislayer,                            &
     &     istat)
      implicit none
      integer,intent(in)::layernmb,thislayer(cv_maxnodenmb),            &
     &     nmb_thislayer
      integer,intent(out)::istat
      integer i,k1,k2,k3,ierr,inode,in,nfront,npiv,                     &
     &     npiv_son,ison,ifather,                                       &
     &     nmb_type2
      logical doit
      character (len=48):: err_rep,subname
      istat=-1
      subname='NEWSPLITTING'
      if((layernmb.lt.0).or.(layernmb.gt.cv_maxlayer)) return
      if (cv_slavef.eq.1) then
         return
      endif
      do i=1,nmb_thislayer
         ierr=0
         inode=thislayer(i)
         err_rep='GET_SPLIT_INKPART'
         call AGMG_MUMPS_525(inode,                                          &
     &        doit,npiv,nfront,k1,k3,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Error reported by ',                    &
     &           err_rep,' in ',subname
            istat =ierr
            return
         endif
         if(.NOT.doit) then
            cycle
         endif
         if(k3.eq.1) then
            cycle
         endif
         err_rep='GET_MEMSPLIT_INKPART'
         call AGMG_MUMPS_526(inode,                                          &
     &        doit,npiv,nfront,k2,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Error reported by ',                    &
     &           err_rep,' in ',subname
            istat =ierr
            return
         endif
         k1 = max(k1,k2)
         k1 = min(k1,k3)
         if( k1 .eq. 1) cycle
         err_rep='SPLITNODE_INKPART'
         call AGMG_MUMPS_529(inode,nfront,npiv,k1,                           &
     &        ison,ifather,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,                 &
     &           ' in ',subname
            istat = ierr
            return
         endif
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_527
      subroutine AGMG_MUMPS_525(inode,                                       &
     &     doit,npiv,nfront,k1,k3,istat)
      implicit none
      integer,intent(in)::inode
      logical,intent(out)::doit
      integer,intent(out),OPTIONAL::npiv,nfront,istat
      integer,intent(out),OPTIONAL::k1,k3
      integer in,nfr_ifather,npiv_ifather,npiv2,nfront2,npiv_son2
      integer npropmap,j,ncb,kmax,keep48_loc,nslaves_max,               &
     &     nslaves_estim,strat,kk
      DOUBLE PRECISION wk_master,wk_slave,wk_master2,wk_slave2
      integer AGMG_MUMPS_497,                                                &
     &     AGMG_MUMPS_52,                                                    &
     &     AGMG_MUMPS_50
      external AGMG_MUMPS_497
      external AGMG_MUMPS_52
      external AGMG_MUMPS_50
      doit=.FALSE.
      if(present(npiv)) npiv=cv_invalid
      if(present(nfront)) nfront=cv_invalid
      if(present(k1)) k1=1
      if(present(k3)) k3 =1
      if(present(istat)) istat=-1
      doit=.TRUE.
      if (cv_nodetype(inode) .gt. 0) then
         doit=.FALSE.
         istat = 0
         return
      endif
      if ( (cv_frere(inode).eq.0) ) then
         doit=.FALSE.
         istat = 0
         return
      endif
      nfront=cv_nfsiz(inode)
      in=inode
      npiv=0
      do while (in.gt.0)
         in=cv_fils(in)
         npiv=npiv+1
      end do
      npiv_son2 = max(npiv/2,1)
      if(npiv.le.npiv_son2) then
         doit=.FALSE.
         istat = 0
         return
      endif
      if( .not. AGMG_MUMPS_359(nfront,npiv_son2) )then
         doit=.FALSE.
         istat = 0
         return
      endif
      in = inode
      npropmap=0
      do j=1,cv_slavef
         if( AGMG_MUMPS_481(in,j)) then
            npropmap=npropmap+1
         endif
      end do
      ncb = nfront - npiv
      kmax = AGMG_MUMPS_497(cv_keep8(21),ncb)
      if (cv_keep(50) ==  0) then
         keep48_loc=0
      else
         keep48_loc=3
      endif
      if (cv_keep(48).EQ.5) keep48_loc = 5
      if(npropmap .gt. cv_keep(83)) then
         nslaves_max   = AGMG_MUMPS_52(                                      &
     &        cv_slavef, keep48_loc, cv_keep8(21),                      &
     &        cv_keep(50), nfront, ncb )
         nslaves_estim = min(npropmap,nslaves_max)
         nslaves_estim = max(nslaves_estim,1)
      else
         nslaves_max   = AGMG_MUMPS_52(                                      &
     &        cv_slavef, keep48_loc, cv_keep8(21),                      &
     &        cv_keep(50), nfront, ncb )
         nslaves_estim = AGMG_MUMPS_50(                                      &
     &     cv_slavef, keep48_loc,cv_keep8(21),                          &
     &     cv_keep(50), nfront, ncb )
         nslaves_estim = max(nslaves_estim,1)
         nslaves_estim = min(nslaves_estim,nslaves_max)
      endif
      if (cv_keep(50).eq.0) then
         wk_master = (dble(2)/dble(3))*                                 &
     &        dble(npiv)*dble(npiv)*dble(npiv)+                         &
     &        dble(npiv)*dble(npiv)*dble(nfront-npiv)
      else
         wk_master = dble(npiv)*dble(npiv)*dble(npiv)/dble(3)
      end if
      strat = cv_keep(62)
      doit = .TRUE.
      k1 = cv_keep(82)
      k3 = cv_keep(82)
      do kk=1,cv_keep(82)-1
         npiv2 = npiv/kk
         if(npiv2 .eq. 0) then
            k1 = max(1,kk-1)
            exit
         endif
         wk_master2 = wk_master / dble(kk)
         nfront2 = nfront-npiv+npiv2
         if (cv_keep(50).eq.0) then
            wk_slave2  = ( dble(npiv2)*dble(nfront-npiv2) *             &
     &           dble(2*nfront-npiv2) ) / dble(nslaves_estim)
         else
            wk_slave2 =                                                 &
     &           ( dble(npiv2)*dble(nfront2-npiv2)*dble(nfront2) )      &
     &           /   dble(nslaves_estim)
         endif
         if(wk_master2.le.                                              &
     &        (1.0D0 +dble(kk*strat)/dble(100))*wk_slave2) then
            k1 = kk
            exit
         endif
      enddo
      do kk=1,cv_keep(82)-1
         npiv2 = npiv/kk
         if(npiv2 .eq. 0) then
            k3 = max(1,kk-1)
            exit
         endif
         wk_master2 = wk_master / dble(kk)
         nfront2 = nfront
         if (cv_keep(50).eq.0) then
            wk_slave2  = ( dble(npiv2)*dble(nfront-npiv2) *             &
     &           dble(2*nfront-npiv2) ) / dble(nslaves_estim)
         else
            wk_slave2 =                                                 &
     &           ( dble(npiv2)*dble(nfront2-npiv2)*dble(nfront2) )      &
     &           /   dble(nslaves_estim)
         endif
         if(wk_master2.le.wk_slave2) then
            k3 = kk
            exit
         endif
      enddo
      if(k3 .lt. k1) then
         k3 = k1
      endif
      if(present(istat)) istat=0
      return
      end subroutine AGMG_MUMPS_525
      subroutine AGMG_MUMPS_526(inode,                                       &
     &     doit,npiv,nfront,k2,istat)
      implicit none
      integer,intent(in)::inode
      logical,intent(out)::doit
      integer,intent(out),OPTIONAL::npiv,nfront,istat
      integer,intent(out),OPTIONAL::k2
      integer in,nfr_ifather,npiv_ifather,npiv2,nfront2,npiv_son2
      integer npropmap,j,ncb,kmax,keep48_loc,nslaves_max,               &
     &     nslaves_estim,kk
      DOUBLE PRECISION mem_master
      doit=.FALSE.
      if(present(npiv)) npiv=cv_invalid
      if(present(nfront)) nfront=cv_invalid
      if(present(k2)) k2=1
      if(present(istat)) istat=-1
      doit=.TRUE.
      nfront=cv_nfsiz(inode)
      in=inode
      npiv=0
      do while (in.gt.0)
         in=cv_fils(in)
         npiv=npiv+1
      end do
      doit = .TRUE.
      k2 = cv_keep(82)
      do kk=1,cv_keep(82)-1
         npiv2 = npiv/kk
         if(npiv2 .eq. 0) then
            k2 = max(1,kk-1)
            exit
         endif
         if (cv_keep(50).eq.0) then
            mem_master  = dble(npiv2)*dble(nfront)
         else
            mem_master  = dble(npiv2)*dble(npiv2)
         endif
         if(mem_master.le.                                              &
     &        (dble(cv_mem_strat)/dble(100))*cv_stack_peak) then
            k2 = kk
            exit
         endif
      enddo
      if(present(istat)) istat=0
      return
      end subroutine AGMG_MUMPS_526
      subroutine AGMG_MUMPS_529(inode,nfront,npiv,k,                         &
     &     ison,ifather,istat)
      implicit none
      integer, intent(in)::nfront,npiv
      integer, intent(in):: k
      integer inode
      integer,intent(out)::ison,ifather
      integer, intent(out)::istat
      integer i,lev,in,in_son,in_father,in_grandpa,                     &
     &     npiv_son,nfrontk,npivk,d1,f1,e1,dk,fk,next_father
      DOUBLE PRECISION:: ncostm,ncostw,ncostm_ison,ncostw_ison,         &
     &                   ncostm_ifather,ncostw_ifather
      character (len=48):: subname
      istat=-1
      subname='SPLITNODE_INKPART'
      ison=-1
      ifather=-1
      ncostw=cv_ncostw(inode)
      ncostm=cv_ncostm(inode)
      nfrontk = nfront
      npivk = npiv
      npiv_son = npiv/k
      cv_keep(2)=max(cv_keep(2),nfront-npiv_son)
      d1 = inode
      f1 = d1
      e1 = cv_frere(d1)
      do i=1,npiv_son-1
         f1 = cv_fils(f1)
      enddo
      ison = d1
      in_son = f1
      next_father = cv_fils(in_son)
      call AGMG_MUMPS_418(npiv_son,nfrontk,                                  &
     &     ncostw_ison,ncostm_ison)
      cv_ncostw(ison)=ncostw_ison
      cv_ncostm(ison)=ncostm_ison
      if(associated(cv_tcostw)) cv_tcostw(ison) = cv_tcostw(inode)      &
     &     -ncostw +cv_ncostw(ison)
      if(associated(cv_tcostm)) cv_tcostm(ison) = cv_tcostm(inode)      &
     &     -ncostm +cv_ncostm(ison)
      do lev = 1,k-1
         ifather = next_father
         in_father = ifather
         if(lev .eq. k-1) then
            do while (cv_fils(in_father).gt.0)
               in_father=cv_fils(in_father)
            end do
         else
            do i=1,npiv_son-1
               in_father=cv_fils(in_father)
            enddo
         endif
         cv_frere(ison)=-ifather
         next_father = cv_fils(in_father)
         cv_fils(in_father)=-ison
         cv_nfsiz(ison)=nfrontk
         cv_nfsiz(ifather)=nfrontk-npiv_son
         cv_ne(ifather)=1
         cv_keep(61)=cv_keep(61)+1
         call AGMG_MUMPS_418(npiv_son,nfrontk-npiv_son,                      &
     &        ncostw_ifather,ncostm_ifather)
         cv_ncostw(ifather)=ncostw_ifather
         cv_ncostm(ifather)=ncostm_ifather
         if(associated(cv_tcostw))                                      &
     &        cv_tcostw(ifather) = cv_tcostw(ison)+cv_ncostw(ifather)
         if(associated(cv_tcostm))                                      &
     &        cv_tcostm(ifather) = cv_tcostm(ison)+cv_ncostm(ifather)
         cv_total_split=cv_total_split+1
         if(lev .gt. 1) then
            call AGMG_MUMPS_437(inode,ison,ierr)
            if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &              write(cv_lp,*)'PROPMAP4SPLIT error in ',subname
               istat = ierr
               return
            endif
         endif
         if( AGMG_MUMPS_359(nfrontk-npiv_son,npiv_son) ) then
            cv_nodetype(ifather) = 2
         else
            cv_nodetype(ifather) = 1
         endif
         nfrontk = nfrontk-npiv_son
         npivk = npivk - npiv_son
         ison = ifather
         in_son = in_father
      enddo
      dk = ifather
      fk = in_father
      if( AGMG_MUMPS_359(nfrontk,npivk) ) then
         cv_nodetype(dk) = 2
      else
         cv_nodetype(dk) = 1
      endif
      call AGMG_MUMPS_418(npivk,nfrontk,                                     &
     &     ncostw_ifather,ncostm_ifather)
      cv_ncostw(dk)=ncostw_ifather
      cv_ncostm(dk)=ncostm_ifather
      if(associated(cv_tcostw))                                         &
     &     cv_tcostw(dk) = cv_tcostw(ison)+cv_ncostw(dk)
      if(associated(cv_tcostm))                                         &
     &     cv_tcostm(dk) = cv_tcostm(ison)+cv_ncostm(dk)
      cv_fils(f1) = next_father
      cv_frere(dk) = e1
      in = e1
      do while (in.gt.0)
         in=cv_frere(in)
      end do
      in = -in
      do while(cv_fils(in).gt.0)
         in=cv_fils(in)
      end do
      in_grandpa = in
      if(cv_fils(in_grandpa).eq.-d1) then
         cv_fils(in_grandpa)=-dk
      else
         in=-cv_fils(in_grandpa)
         do while(cv_frere(in) .ne. d1)
            in=cv_frere(in)
         end do
         cv_frere(in) = dk
      end if
      ison = dk
      do lev=1,k
         do while (cv_fils(ison).gt.0)
            ison=cv_fils(ison)
         end do
         ison = -cv_fils(ison)
      enddo
      call AGMG_MUMPS_437(inode,dk,ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'PROPMAP4SPLIT error in ',subname
         istat = ierr
         return
      endif
      cv_nsteps = cv_nsteps + k-1
      istat = 0
      return
      end subroutine AGMG_MUMPS_529
      subroutine AGMG_MUMPS_370(                                             &
     &                              layernmb,thislayer,nmb_thislayer,   &
     &                              istat)
      implicit none
      integer,intent(in)::layernmb,thislayer(cv_maxnodenmb),            &
     &                    nmb_thislayer
      integer,intent(out)::istat
      integer i,ierr,inode,in,nfront,npiv,npiv_son,ison,ifather,        &
     &        nmb_type2
      logical doit
      character (len=48):: err_rep,subname
      istat=-1
      subname='DO_SPLITTING'
      if((layernmb.lt.0).or.(layernmb.gt.cv_maxlayer)) return
      if ((cv_slavef.eq.1).OR.(cv_slavef.lt.nmb_thislayer)) then
         istat=0
         return
      endif
      nmb_type2=0
      do i=1,nmb_thislayer
         inode=thislayer(i)
         nfront=cv_nfsiz(inode)
         in=inode
         npiv=0
         do while (in.gt.0)
            in=cv_fils(in)
            npiv=npiv+1
         end do
         if( AGMG_MUMPS_359(nfront,npiv))                                    &
     &                        nmb_type2=nmb_type2+1
      end do
      do i=1,nmb_thislayer
         ierr=0
         inode=thislayer(i)
         err_rep='SPLIT2HALVES'
         call AGMG_MUMPS_400(inode,                                          &
     &                              doit,npiv,nfront,npiv_son,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            istat =ierr
            return
         endif
         if(.NOT.doit) cycle
         err_rep='SPLITNODE'
         call AGMG_MUMPS_401(inode,nfront,npiv,npiv_son,                     &
     &                           ison,ifather,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            istat = ierr
            return
         endif
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_370
      subroutine AGMG_MUMPS_371(istat)
      implicit none
      integer, intent(out)::istat
      integer i,in,inode
      character (len=48):: subname
      istat=-1
      subname='ENCODE_PROCNODE'
      do i=1,cv_nbsa
         inode=cv_ssarbr(i)
         cv_nodetype(inode)=0
         in=cv_fils(inode)
         do while (in>0)
            in=cv_fils(in)
         end do
         in=-in
         do while(in.gt.0)
            call AGMG_MUMPS_406(in)
            in=cv_frere(in)
         enddo
      enddo
      do i=1,cv_n
         if (cv_frere(i).lt.cv_n+1) then
            if(cv_nodetype(i).eq.cv_invalid) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Error in ',subname
               return
            endif
            if (i.eq.cv_keep(38)) then
               cv_nodetype(i)=3
            endif
            cv_procnode(i)=(cv_nodetype(i)-1)*cv_slavef+cv_procnode(i)
            in=cv_fils(i)
            do while (in>0)
               cv_procnode(in)=cv_procnode(i)
               in=cv_fils(in)
            end do
         end if
      end do
      istat = 0
      return
      end subroutine AGMG_MUMPS_371
      subroutine AGMG_MUMPS_372(ifather,istat)
      implicit none
      integer,intent(in)::ifather
      integer,intent(out)::istat
      integer in,son,ierr,allocok,oldl0end
      logical father_has_sons,fathfound
      character (len=48):: subname
      istat=-1
      subname='FATHSON_REPLACE'
      father_has_sons=.TRUE.
      in=ifather
      do while (in.gt.0)
         in=cv_fils(in)
      end do
      if(in.eq.0) then
         cv_nodelayer(ifather)=1
         father_has_sons=.FALSE.
      end if
      if(cv_layerl0_end-cv_layerl0_start.gt.0) then
         cv_layerl0_start= cv_layerl0_start+1
      elseif(father_has_sons) then
         cv_layerl0_start= cv_layerl0_start+1
      else
         istat=1
         cv_nodelayer(ifather)=0
         return
      endif
      cv_nbsa=cv_nbsa-1
      oldl0end = cv_layerl0_end
      if (father_has_sons) then
         son=-in
         son=-in
   10    continue
         cv_layerl0_end=cv_layerl0_end+1
         if (cv_tcostw(son).GT.mincostw)                                &
     &           layerL0_endforarrangeL0 = layerL0_endforarrangeL0+1
         cv_layerl0_array(cv_layerl0_end)=son
         cv_layerl0_sorted_costw(cv_layerl0_end)=cv_tcostw(son)
         cv_nbsa=cv_nbsa+1
         if((cv_frere(son).gt.0).and.(cv_frere(son).lt.cv_n+1)) then
            son=cv_frere(son)
            goto 10
         end if
      endif
         cv_costw_layer0=cv_costw_layer0 - cv_ncostw(ifather)
         cv_costm_layer0=cv_costm_layer0 - cv_ncostm(ifather)
         cv_costw_upper=cv_costw_upper + cv_ncostw(ifather)
         cv_costm_upper=cv_costm_upper + cv_ncostm(ifather)
         if(cv_layerl0_end.gt.oldl0end) then
            call AGMG_MUMPS_459(cv_layerl0_end-oldl0end,                     &
     &            cv_layerl0_array(oldl0end+1:cv_layerl0_end),          &
     &     cv_layerl0_sorted_costw(oldl0end+1:cv_layerl0_end))
           call AGMG_MUMPS_516(                                              &
     &        cv_layerl0_start,oldl0end,oldl0end-cv_layerl0_start+1,    &
     &        oldl0end+1,cv_layerl0_end,cv_layerl0_end-oldl0end,        &
     &        cv_layerl0_array,                                         &
     &        cv_layerl0_sorted_costw)
         endif
      istat=0
      return
      end subroutine AGMG_MUMPS_372
      subroutine AGMG_MUMPS_374(inode,map_strat,work,mem,                    &
     &                       workload,memused,proc,istat,respect_prop)
!!DEC$ NOOPTIMIZE !absoft
      implicit none
      integer, intent(in)::inode,map_strat
      DOUBLE PRECISION,intent(in)::work,mem
      DOUBLE PRECISION,dimension(cv_slavef),intent(inout)::workload,    &
     &                                                     memused
      integer,intent(out):: proc,istat
      logical,intent(in),OPTIONAL::respect_prop
      integer i
      logical respect_proportional
      intrinsic huge
      DOUBLE PRECISION dummy
      character (len=48):: subname
      istat=-1
      respect_proportional=.FALSE.
      if(present(respect_prop)) respect_proportional=respect_prop
      subname='FIND_BEST_PROC'
      proc=-1
      if((map_strat.ne.cv_equilib_flops).and.                           &
     &   (map_strat.ne.cv_equilib_mem)) return
      dummy=huge(dummy)
      do i=cv_slavef,1,-1
         if (                                                           &
     &       ((.NOT.respect_proportional)                               &
     &        .OR.                                                      &
     &        (AGMG_MUMPS_481(inode,i).AND.respect_proportional))            &
     &      .AND.                                                       &
     &       (((workload(i).lt.dummy).AND.                              &
     &                         (map_strat.eq.cv_equilib_flops))         &
     &        .OR.                                                      &
     &       ((memused(i).lt.dummy).AND.                                &
     &                         (map_strat.eq.cv_equilib_mem))))then
            if((.not.cv_constr_work).or.                                &
     &         (workload(i)+work.lt.cv_proc_maxwork(i))) then
               if((.not.cv_constr_mem).or.                              &
     &            (memused(i)+mem.lt.cv_proc_maxmem(i))) then
                  proc=i
                  if(map_strat.eq.cv_equilib_flops) then
                     dummy=workload(i)
                  elseif(map_strat.eq.cv_equilib_mem) then
                     dummy=memused(i)
                  endif
               end if
            end if
         end if
      end do
      if (proc.ne.-1) then
         workload(proc)=workload(proc)+work
         memused(proc)=memused(proc)+mem
         istat=0
      end if
      return
      end subroutine AGMG_MUMPS_374
      subroutine AGMG_MUMPS_375(map_strat,istat)
      implicit none
      integer,intent(in)::map_strat
      integer,intent(out)::istat
      DOUBLE PRECISION aux_dbl,current_max,temp_max
      integer i,j,aux_int,inode,in,nfront,npiv,                         &
     &     nslaves_estim,strat,kmax,ncb,npropmap, blsize,               &
     &     nslaves_max, keep48_loc,current_max_node
      DOUBLE PRECISION wk_slave, wk_master
      DOUBLE PRECISION,DIMENSION(:), POINTER ::  costs
      logical doit
      character (len=48):: subname
      integer AGMG_MUMPS_497,                                                &
     &        AGMG_MUMPS_52
      external AGMG_MUMPS_497,                                               &
     &        AGMG_MUMPS_52
      istat=-1
      current_max_node=-9999
      current_max=0.0D0
      subname='FIND_POTSPLIT'
      if(map_strat.eq.cv_equilib_flops) then
         costs=>cv_ncostw
      elseif(map_strat.eq.cv_equilib_mem) then
         costs=>cv_ncostm
      endif
      if((cv_slavef.eq.1).OR.(cv_keep(62).lt.1))then
         cv_potsplit(1:cv_maxcut)=cv_invalid
         istat=0
         return
      end if
      current_max=huge(current_max);
      current_max_node=cv_n+1
      aux_int=1
      do i=1,min(cv_maxcut,cv_n)
         temp_max=0.0D0
         do j=1,cv_n
            if(costs(j).ge.temp_max)then
               if(((costs(j).eq.current_max).and.                       &
     &              (j.lt.current_max_node)).or.                        &
     &              (costs(j).lt.current_max))then
                  temp_max=costs(j)
                  inode=j
               endif
            endif
         end do
         current_max=costs(inode)
         current_max_node=inode
         if((inode.lt.0).OR.(inode.gt.cv_n)) cycle
         doit = .TRUE.
         if (cv_frere(inode).eq.0) cycle
         nfront = cv_nfsiz(inode)
         in = inode
         npropmap=0
         do j=1,cv_slavef
            if( AGMG_MUMPS_481(in,j)) then
               npropmap=npropmap+1
            endif
         end do
         npiv = 0
         do while(in>0)
            in = cv_fils(in)
            npiv = npiv + 1
         end do
         ncb = nfront - npiv
         kmax = AGMG_MUMPS_497(cv_keep8(21),ncb)
         if (cv_keep(50) ==  0) then
           keep48_loc=0
         else
           keep48_loc=3
         endif
         if (cv_keep(48).EQ.5) keep48_loc = 5
         nslaves_max   = AGMG_MUMPS_52(                                      &
     &        cv_slavef, keep48_loc, cv_keep8(21),                      &
     &        cv_keep(50), nfront, ncb )
         nslaves_estim = min(npropmap,nslaves_max)
         nslaves_estim = max(nslaves_estim,1)
         if (cv_keep(50).eq.0) then
            wk_master = dble(2)/dble(3)*                                &
     &                  dble(npiv)*dble(npiv)*dble(npiv)+               &
     &                  dble(npiv)*dble(npiv)*dble(nfront-npiv)
            wk_slave  = dble(npiv)*dble(nfront-npiv) *                  &
     &                  dble(2*nfront-npiv)/dble(nslaves_estim)
         else
            wk_master = dble(npiv)*dble(npiv)*dble(npiv)/dble(3)
            wk_slave  =                                                 &
     &           ( dble(npiv)*dble(nfront-npiv)*dble(nfront) )          &
     &            /   dble(nslaves_estim)
         end if
         strat = cv_keep(62)
         if(wk_master.le.                                               &
     &     ( dble(1)                                                    &
     &      +dble(strat)/dble(100) )                                    &
     &      *wk_slave) doit=.false.
         if ((cv_depth(inode).le.cv_maxdepth).and.doit) then
            cv_potsplit(aux_int)=inode
            aux_int=aux_int+1
         endif
      enddo
      cv_potsplit(aux_int:cv_maxcut)=cv_invalid
      istat=0
      return
      end subroutine AGMG_MUMPS_375
      subroutine AGMG_MUMPS_376(nmb,                                         &
     &                                   thislayer,nmb_thislayer,istat)
      implicit none
      integer, intent(in)::nmb
      integer,intent(out)::thislayer(cv_maxnodenmb),nmb_thislayer,istat
      integer i
      character (len=48):: subname
      istat=-1
      subname='FIND_THISLAYER'
      thislayer=0
      nmb_thislayer=0
      if((nmb.lt.0).or.(nmb.gt.cv_maxlayer)) return
      do i=1,cv_n
         if(cv_nodelayer(i).eq.nmb) then
            nmb_thislayer=nmb_thislayer+1
            if(nmb_thislayer.gt.cv_maxnodenmb) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Problem with nmb_thislayer in ',subname
               return
            endif
            thislayer(nmb_thislayer)=i
         end if
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_376
      subroutine AGMG_MUMPS_377(startlayer,thislayer,                        &
     &                 nmb_thislayer,cont,istat)
      implicit none
      integer,intent(in)::startlayer,nmb_thislayer
      integer,intent(in)::thislayer(cv_maxnodenmb)
      logical,intent(inout)::cont
      integer,intent(out)::istat
      integer :: visited
      integer il,i,current,in,ifather
      logical father_valid,upper_layer_exists
      character (len=48):: subname
      istat=-1
      subname='HIGHER_LAYER'
      if(.NOT.cont) return
      if(startlayer.lt.1) return
      current=startlayer-1
      visited = -current-1
         upper_layer_exists=.FALSE.
         if (current.eq.0) then
          do i=1,cv_n
            if (cv_nodelayer(i).ne.current) then
               if(cv_nodelayer(i).eq.1) then
                  upper_layer_exists=.TRUE.
                  exit
               endif
            endif
          enddo
         endif
         do il=1,nmb_thislayer
            i = thislayer(il)
            if (cv_nodelayer(i).lt.current) cycle
            in=i
            if(cv_frere(in).eq.0) cycle
            cv_nodelayer (in) = visited
               father_valid=.TRUE.
            do while(cv_frere(in).gt.0)
               if (cv_nodelayer(cv_frere(in)).gt.current) then
                  father_valid=.FALSE.
                  in = cv_frere(in)
                  cycle
               endif
               if (cv_nodelayer(cv_frere(in)).eq.visited) exit
               in=cv_frere(in)
               if (cv_nodelayer(in).eq.current)  then
                    cv_nodelayer(in) = visited
               endif
            end do
            if (.not.father_valid .or. cv_frere(in).gt.0) then
                    cycle
            endif
            ifather=-cv_frere(in)
            if(cv_nodelayer(ifather).eq.current+1) then
               cycle
            endif
            in=ifather
            do while (cv_fils(in).gt.0)
               in=cv_fils(in)
            end do
            in=-cv_fils(in)
            if(cv_nodelayer(in).gt.current) then
               father_valid=.FALSE.
            else
               father_valid=.TRUE.
               do while(cv_frere(in).gt.0)
                in=cv_frere(in)
                if(cv_nodelayer(in).gt.current) then
                       father_valid=.FALSE.
                       exit
                endif
                if(cv_nodelayer(in).eq.visited) then
                    exit
                endif
               end do
            endif
            if(father_valid) then
               cv_nodelayer(ifather)=current+1
               upper_layer_exists=.TRUE.
            end if
         end do
         if (upper_layer_exists) then
             current=current+1
             cv_maxlayer=current
             cont=.TRUE.
         else
             cv_maxlayer=current
             cont=.FALSE.
         endif
         do il=1,nmb_thislayer
            i = thislayer(il)
           if (cv_nodelayer(i).eq.visited) cv_nodelayer(i) = -visited-1
         enddo
      istat=0
      return
      end subroutine AGMG_MUMPS_377
      subroutine AGMG_MUMPS_478(n,slavef,                                    &
     &                    frere,fils,nfsiz,ne,keep,KEEP8,icntl,info,    &
     &                    procnode,ssarbr,peak,istat                    &
     &     )
      implicit none
      integer, intent(in)::n,slavef
      integer, intent(in), TARGET:: frere(n),fils(n),nfsiz(n),ne(n),    &
     &  keep(500),icntl(40),info(40),                                   &
     &  procnode(n),ssarbr(n)
      INTEGER*8, intent(in), TARGET:: KEEP8(150)
      integer,intent(out)::istat
      integer i,allocok,rest
      DOUBLE PRECISION peak
      character (len=48):: subname
      intrinsic bit_size,min,max
      istat=-1
      nullify(cv_frere,cv_fils,cv_nfsiz,cv_ne,cv_keep,cv_keep8,         &
     &        cv_icntl,cv_info,cv_procnode,cv_ssarbr)
      nullify(cv_ncostw,cv_tcostw,cv_ncostm,cv_tcostm,                  &
     &        cv_nodelayer,cv_nodetype,cv_depth,cv_potsplit,            &
     &        cv_layerworkload,cv_layermemused,cv_prop_map)
      subname='INITPART1'
      cv_n=n
      cv_slavef=slavef
      cv_stack_peak = peak
      cv_mem_strat = max((300 / cv_slavef),1)
      cv_keep=>keep
      cv_keep8=>KEEP8
      if(cv_keep(82) .lt. 0) then
         write(cv_lp,*)                                                 &
     &        'warning in mumps_static_mapping : keep(82) reset to 0'
         cv_keep(82) = 0
      endif
      if(cv_keep(83) .lt. 0) then
         write(cv_lp,*)                                                 &
     &        'warning in mumps_static_mapping : keep(83) reset to 0'
         cv_keep(83) = 0
      endif
      if(cv_keep(82) .gt. 0) then
         cv_maxcut=-99999
      else
         cv_maxcut =min(slavef,n/2)
      endif
      if(slavef.gt.1) then
         cv_mixed_strat_bound = max(cv_keep(78),1)
         cv_maxdepth = slavef
      else
         cv_maxdepth = 0
         cv_mixed_strat_bound=0
      endif
      cv_bitsize_of_int = bit_size(n)
      if(cv_bitsize_of_int.le.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Problem with bit size in ',subname
         return
      endif
      rest = mod(cv_slavef,cv_bitsize_of_int)
      if (rest.eq.0) then
         cv_size_ind_proc = cv_slavef / cv_bitsize_of_int
      else
         cv_size_ind_proc = cv_slavef / cv_bitsize_of_int + 1
      endif
      allocate(cv_ncostw(n),cv_tcostw(n),cv_ncostm(n),cv_tcostm(n),     &
     &       cv_nodelayer(n),cv_nodetype(n),cv_depth(n),                &
     &       cv_layerworkload(slavef),cv_layermemused(slavef),          &
     &       cv_prop_map(n),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = 8*n+2*cv_slavef
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'memory allocation error in ',subname
         return
      end if
      if(cv_keep(82) .eq. 0) then
         allocate(cv_potsplit(cv_maxcut),STAT=allocok)
         if (allocok.gt.0) then
            cv_info(1) = cv_error_memalloc
            cv_info(2) = cv_maxcut
            istat = cv_error_memalloc
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'memory allocation error in ',subname
            return
         end if
      endif
      cv_frere=>frere
      cv_fils=>fils
      cv_nfsiz=>nfsiz
      cv_ne=>ne
      cv_icntl=>icntl
      cv_info=>info
      cv_procnode=>procnode
      cv_ssarbr=>ssarbr
      cv_ssarbr=0
      cv_nodetype=cv_invalid
      cv_nsteps=keep(28)
      if((keep(28).gt.n).OR.(keep(28).lt.0)) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'problem with nsteps in ',subname
         return
      end if
      cv_costw_upper=0.0D0
      cv_costm_upper=0.0D0
      cv_costw_layer0=0.0D0
      cv_costm_layer0=0.0D0
      cv_costw_total=0.0D0
      cv_costm_total=0.0D0
      cv_nodelayer=n+2
      cv_depth=cv_invalid
      if(cv_keep(82) .eq. 0) then
         cv_potsplit=cv_invalid
      endif
      cv_l0wthresh=0.0D0
      cv_splitthresh=0.45D0
      cv_relax=dble(1) + dble(max(0,keep(68)))/dble(100)
      cv_maxlayer=0
      if( cv_keep(82) .gt. 0) then
         cv_maxnsteps= cv_nsteps+1
      else
         cv_maxnsteps=cv_nsteps+cv_maxcut+1
      endif
      cv_layerworkload=dble(0)
      cv_layermemused=dble(0)
      cv_total_amalg=0
      cv_total_split=0
      cv_last_splitting%new_ison=cv_invalid
      cv_last_splitting%new_ifather=cv_invalid
      cv_last_splitting%old_keep2=cv_invalid
      cv_last_splitting%ncostw_oldinode=cv_d_invalid
      cv_last_splitting%ncostm_oldinode=cv_d_invalid
      cv_last_splitting%tcostw_oldinode=cv_d_invalid
      cv_last_splitting%tcostm_oldinode=cv_d_invalid
      do i=1,cv_n
         nullify(cv_prop_map(i)%ind_proc)
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_478
      subroutine AGMG_MUMPS_479(istat)
      implicit none
      integer,intent(out)::istat
      integer i,allocok,inode,in,inoderoot,ierr
      character (len=48):: subname
      type(nodelist),pointer::nodeptr
      istat=-1
      subname='INITPART2'
      if(associated(cv_layerl0_array))deallocate(cv_layerl0_array)
      if(associated(cv_layerl0_sorted_costw))                           &
     &           deallocate(cv_layerl0_sorted_costw)
      deallocate(cv_depth,cv_tcostw,cv_tcostm,STAT=ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'Memory deallocation error in ',subname
         istat = cv_error_memdeloc
         return
      end if
      if(cv_maxnsteps.lt.1) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'problem with maxnsteps in ',subname
         return
      end if
      cv_maxnodenmb=cv_maxnsteps
      do i=1,cv_nbsa
         inode=cv_ssarbr(i)
         inoderoot=inode
  300    continue
         in = inode
         do while (in.ne.0)
            inode = in
            do while (in.gt.0)
            in = cv_fils(in)
            end do
            if (in.lt.0) in=-in
         end do
  100    continue
         if (inode.ne.inoderoot) then
            cv_maxnodenmb=cv_maxnodenmb-1
            in = cv_frere(inode)
            inode = abs(in)
            if (in.lt.0) then
               go to 100
            else
               go to 300
            end if
         end if
      end do
      if(cv_keep(82) .gt. 0) then
         cv_maxcut = min((cv_keep(82)-1)*cv_maxnodenmb,cv_n)
         cv_maxnsteps = min(cv_maxnsteps+cv_maxcut,cv_n)
         cv_maxnodenmb = cv_maxnsteps
      endif
      nullify(cv_layer_p2node)
      if(cv_maxnodenmb.lt.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'problem with maxnodenmb in ',subname
         return
      elseif(cv_maxnodenmb.lt.1) then
         cv_maxnodenmb = 1
      end if
      allocate(cv_layer_p2node(cv_maxnodenmb),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = cv_maxnodenmb
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'memory allocation error in ',subname
         return
      end if
      do i=1,cv_maxnodenmb
         nullify(cv_layer_p2node(i)%t2_nodenumbers,                     &
     &           cv_layer_p2node(i)%t2_cand,                            &
     &           cv_layer_p2node(i)%t2_candcostw,                       &
     &           cv_layer_p2node(i)%t2_candcostm)
         cv_layer_p2node(i)%nmb_t2s=0
      enddo
      istat = 0
      end subroutine AGMG_MUMPS_479
      function AGMG_MUMPS_359(nfront,npiv)
      implicit none
      logical::AGMG_MUMPS_359
      integer,intent(in)::nfront,npiv
      AGMG_MUMPS_359=.FALSE.
      if( (nfront - npiv > cv_keep(9))                                  &
     &     .and. ((npiv > cv_keep(4)).or.(.TRUE.))                      &
     &     .and. (cv_icntl(40).eq.0) ) AGMG_MUMPS_359=.TRUE.
      return
      end function AGMG_MUMPS_359
      subroutine AGMG_MUMPS_381(istat)
      implicit none
      integer,intent(out)::istat
      integer i,ierr,inode
      logical accepted,splitting_allowed
      integer,parameter::map_strat=cv_equilib_flops
      character (len=48):: err_rep,subname
      logical use_geist_ng_replace, skiparrangeL0
      INTEGER MINSIZE_L0
      istat=-1
      subname='LAYERL0'
      accepted=.FALSE.
      splitting_allowed=.TRUE.
      splitting_allowed=.FALSE.
      IF (cv_keep(72).EQ.2) THEN
       MINSIZE_L0 = 6*cv_slavef
      ELSE
       MINSIZE_L0 = 3*cv_slavef
      ENDIF
   55 continue
      skiparrangeL0 = .false.
      do while(.not.accepted)
         IF ( (    (layerL0_endforarrangeL0.LT.MINSIZE_L0)              &
     &             .OR. skiparrangeL0                                   &
     &        )                                                         &
     &        .AND.                                                     &
     &           (cv_layerl0_end.LT.cv_maxnsteps/2) ) THEN
          accepted = .false.
         ELSE
          err_rep='ARRANGEL0'
          call AGMG_MUMPS_415(map_strat, layerL0_endforarrangeL0,            &
     &                           cv_layerworkload,cv_layermemused,      &
     &                           cv_procnode,ierr)
          if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            istat = ierr
            return
          end if
          err_rep='ACCEPT_L0'
          call AGMG_MUMPS_413(map_strat,                                     &
     &                           cv_layerworkload,cv_layermemused,      &
     &                           accepted,ierr)
          if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            istat = ierr
            return
          end if
         ENDIF
         IF (cv_slavef.GT.16)                                           &
     &        skiparrangeL0 = .NOT.skiparrangeL0
         if (accepted.OR.(cv_costw_total.le.0.0D0)) then
            exit
         elseif(((cv_costw_layer0/cv_costw_total).gt.cv_l0wthresh) .AND.&
     &           (.TRUE.))then
            err_rep='MAX_TCOST_L0'
            inode = cv_layerl0_array(cv_layerl0_start)
            use_geist_ng_replace = .TRUE.
            if(use_geist_ng_replace) then
               err_rep='FATHSON_REPLACE'
               call AGMG_MUMPS_372(inode,ierr)
               if(ierr.eq.1) then
                  accepted=.TRUE.
               elseif(ierr.ne.0) then
                  if(cv_lp.gt.0)                                        &
     &            write(cv_lp,*)                                        &
     &            'Error rep. by ',err_rep,' in ',subname
                  istat = ierr
                  return
               endif
            endif
         else
            accepted=.TRUE.
         end if
      end do
      accepted=.TRUE.
      if (accepted) then
      else
         goto 55
      endif
      err_rep='LIST2LAYER'
      call AGMG_MUMPS_382(ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
         istat = ierr
         return
      end if
      err_rep='MAKE_PROPMAP'
      call AGMG_MUMPS_477(ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
         istat = ierr
         return
      end if
      if ( cv_keep(75).EQ.1 ) then
         call AGMG_MUMPS_415(map_strat, cv_layerl0_end,                      &
     &                     cv_layerworkload,cv_layermemused,            &
     &                     cv_procnode,ierr, respect_prop=.TRUE.)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Error reported by ',err_rep,' in ',subname
            istat = ierr
            return
         end if
      else if (layerL0_endforarrangeL0.LT.cv_layerl0_end) THEN
         call AGMG_MUMPS_415(map_strat, cv_layerl0_end,                      &
     &                     cv_layerworkload,cv_layermemused,            &
     &                     cv_procnode,ierr)
      endif
      call AGMG_MUMPS_386(cv_procnode)
      do i=1,cv_slavef
         cv_proc_workload(i)=cv_layerworkload(i)
         cv_proc_memused(i)=cv_layermemused(i)
      end do
      istat=0
      return
      end subroutine AGMG_MUMPS_381
      subroutine AGMG_MUMPS_382(istat)
      implicit none
      integer, intent(out)::istat
      type(nodelist),pointer::dummy
      character (len=48):: subname
      integer i,inode
      istat=-1
      subname='LIST2LAYER'
      cv_dist_L0_mixed_strat_bound=0
      cv_nbsa=0
      do i=cv_layerl0_start,cv_layerl0_end
         inode=cv_layerl0_array(i)
         if(inode.gt.0) then
         cv_dist_L0_mixed_strat_bound=max(cv_dist_L0_mixed_strat_bound  &
     &        ,max(cv_depth(inode)-cv_mixed_strat_bound,0))
         cv_nodelayer(inode)=0
         cv_nbsa=cv_nbsa+1
         cv_ssarbr(cv_nbsa)=inode
         endif
      enddo
      istat=0
      return
      end subroutine AGMG_MUMPS_382
      subroutine AGMG_MUMPS_477(istat)
      implicit none
      integer,intent(out)::istat
      integer i,pctr,pctr2,ierr,procindex(cv_size_ind_proc)
      istat = -1
      pctr=cv_n
      pctr2=cv_mixed_strat_bound
      do i=1,cv_slavef
         call AGMG_MUMPS_482(procindex,i,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)write(cv_lp,*)                                &
     &           'BIT_SET signalled error to',subname
            istat = ierr
            return
         end if
      end do
      do i=1,cv_n
         if(cv_frere(i).eq.0) then
            if(.NOT.associated(cv_prop_map(i)%ind_proc)) then
               call AGMG_MUMPS_434(i,ierr)
               if(ierr.ne.0) then
                  if(cv_lp.gt.0)                                        &
     &                 write(cv_lp,*)'PROPMAP_INIT signalled error to'  &
     &                 ,subname
                  istat = ierr
                  return
               end if
            endif
            cv_prop_map(i)%ind_proc = procindex
            call AGMG_MUMPS_433(i,pctr,ierr)
            if(ierr.ne.0) then
            if(cv_lp.gt.0)write(cv_lp,*)                                &
     &           'PROPMAP signalled error to',subname
               istat = ierr
               return
            endif
            if((cv_keep(24).eq.16).OR.(cv_keep(24).eq.18)) then
               call AGMG_MUMPS_517(i,pctr2,ierr)
               if(ierr.ne.0) then
                  if(cv_lp.gt.0)write(cv_lp,*)                          &
     &           'MOD_PROPMAP signalled error to',subname
                  istat = ierr
                  return
               endif
            endif
         endif
      end do
      istat = 0
      return
      end subroutine AGMG_MUMPS_477
      subroutine AGMG_MUMPS_387(layernmb,thislayer,                          &
     &   nmb_thislayer,map_strat,istat)
      implicit none
      integer, intent(in)::layernmb,thislayer(cv_maxnodenmb),           &
     &                     nmb_thislayer,map_strat
      integer,intent(out)::istat
      integer i,inode,j,k,ierr,nmb,aux_int,nmb_cand_needed
      DOUBLE PRECISION aux_dbl,aux_flop,aux_mem
      INTEGER candid(cv_slavef)
      integer sorted_nmb(2*nmb_thislayer)
      DOUBLE PRECISION sorted_costw(2*nmb_thislayer),                   &
     &                 sorted_costm(2*nmb_thislayer),                   &
     &                 old_workload(cv_slavef),old_memused(cv_slavef)
      character (len=48):: err_rep,subname
      logical use_propmap
      istat=-1
      subname='MAP_LAYER'
      if((cv_keep(24).eq.8).OR.(cv_keep(24).eq.10)                      &
     &   .OR.(cv_keep(24).eq.12).OR.(cv_keep(24).eq.14)                 &
     &   .OR.(cv_keep(24).eq.16).OR.(cv_keep(24).eq.18)) then
         use_propmap=.TRUE.
      else
         use_propmap=.FALSE.
      endif
      if((layernmb.lt.0).or.(layernmb.gt.cv_maxlayer)) return
      if((map_strat.ne.cv_equilib_flops).and.                           &
     &   (map_strat.ne.cv_equilib_mem)) return
      do i=1,nmb_thislayer
         inode=thislayer(i)
         if (cv_nodetype(inode).eq.3) then
            cv_procnode(inode)=1
            exit
         end if
      end do
      do i=1,cv_slavef
         old_workload(i)=cv_layerworkload(i)
         old_memused(i)=cv_layermemused(i)
      enddo
      nmb=0
      do i=1,nmb_thislayer
         inode=thislayer(i)
         if(cv_nodetype(inode).eq.1) then
            nmb=nmb+1
            sorted_nmb(nmb)=inode
            sorted_costw(nmb)=cv_ncostw(inode)
            sorted_costm(nmb)=cv_ncostm(inode)
         else if(cv_nodetype(inode).eq.2) then
            nmb=nmb+1
            do j=1,cv_layer_p2node(layernmb)%nmb_t2s
               if(cv_layer_p2node(layernmb)%t2_nodenumbers(j).ne.inode) &
     &            then
                  cycle
               else
                  sorted_costw(nmb)=                                    &
     &                 cv_layer_p2node(layernmb)%t2_candcostw(j)
                  sorted_costm(nmb)=                                    &
     &                 cv_layer_p2node(layernmb)%t2_candcostm(j)
               endif
            enddo
            if((sorted_costw(nmb).eq.cv_d_invalid).OR.                  &
     &           (sorted_costm(nmb).eq.cv_d_invalid)) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Error in ',subname
               return
            end if
            if(sorted_costw(nmb).lt.cv_ncostw(inode))then
               sorted_costw(nmb)=cv_ncostw(inode)
               sorted_costm(nmb)=cv_ncostm(inode)
               sorted_nmb(nmb)=inode
            else
               sorted_nmb(nmb)=-inode
            endif
         else if(cv_nodetype(inode).eq.3) then
            cycle
         else
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Unknown node type. Error in ',subname
            return
         end if
      end do
      if (map_strat.eq.cv_equilib_flops) then
         call AGMG_MUMPS_459(nmb,sorted_nmb(1:nmb),                          &
     &                   sorted_costw(1:nmb),sorted_costm(1:nmb))
      elseif(map_strat.eq.cv_equilib_mem) then
         call AGMG_MUMPS_459(nmb,sorted_nmb(1:nmb),                          &
     &                   sorted_costm(1:nmb),sorted_costw(1:nmb))
      endif
      do i=1,nmb
         aux_int=sorted_nmb(i)
         aux_flop=sorted_costw(i)
         aux_mem=sorted_costm(i)
         k=1
         if (aux_int.lt.0) then
            inode=-aux_int
            err_rep='SORTPROCS'
            if(use_propmap) then
               call AGMG_MUMPS_398(map_strat,                                &
     &              cv_proc_workload,cv_proc_memused,                   &
     &              inode=inode,istat=ierr)
            else
               call AGMG_MUMPS_398(map_strat,                                &
     &              cv_proc_workload,cv_proc_memused,                   &
     &              istat=ierr)
            end if
            if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)                                           &
     &         'Error reported by ',err_rep,' in ',subname
               istat = ierr
               return
            endif
            nmb_cand_needed=cv_invalid
            do j=1,cv_layer_p2node(layernmb)%nmb_t2s
               if(cv_layer_p2node(layernmb)%t2_nodenumbers(j).ne.inode) &
     &            then
                  cycle
               else
                  nmb_cand_needed=                                      &
     &                  cv_layer_p2node(layernmb)%t2_cand(j,cv_slavef+1)
                  exit
               endif
            enddo
            if(nmb_cand_needed.eq.cv_invalid) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Error in ',subname
               return
            endif
            do while((k.le.cv_slavef).and.(nmb_cand_needed.gt.0))
               if(((.not.cv_constr_work).or.                            &
     &            (cv_proc_workload(cv_proc_sorted(k))+aux_flop.lt.     &
     &             cv_proc_maxwork(cv_proc_sorted(k))))                 &
     &           .AND.((.not.cv_constr_mem).or.                         &
     &            (cv_proc_memused(cv_proc_sorted(k))+aux_mem.lt.       &
     &             cv_proc_maxmem(cv_proc_sorted(k))))                  &
     &           .AND.                                                  &
     & (cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k)).eq.0))   &
     &            then
                  cv_proc_workload(cv_proc_sorted(k))=                  &
     &                 cv_proc_workload(cv_proc_sorted(k))+aux_flop
                  cv_proc_memused(cv_proc_sorted(k))=                   &
     &                 cv_proc_memused(cv_proc_sorted(k))+aux_mem
                  cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k))&
     &                                             =inode
                  cv_layerworkload(cv_proc_sorted(k))=                  &
     &                 cv_layerworkload(cv_proc_sorted(k))+aux_flop
                  cv_layermemused(cv_proc_sorted(k))=                   &
     &                 cv_layermemused(cv_proc_sorted(k))+aux_mem
                  nmb_cand_needed=nmb_cand_needed-1
                  k=k+1
               else
                  k=k+1
                  if(k.gt.cv_slavef) then
                     if(cv_lp.gt.0)                                     &
     &                    write(cv_lp,*)'Error in ',subname
                     return
                  endif
               end if
            end do
            if(nmb_cand_needed.gt.0) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Error in ',subname
               return
            endif
            aux_flop=cv_ncostw(inode)
            aux_mem=cv_ncostm(inode)
            do while(k.le.cv_slavef)
               if(((.not.cv_constr_work).or.                            &
     &              (cv_proc_workload(cv_proc_sorted(k))+aux_flop.lt.   &
     &              cv_proc_maxwork(cv_proc_sorted(k))))                &
     &              .AND.((.not.cv_constr_mem).or.                      &
     &              (cv_proc_memused(cv_proc_sorted(k))+aux_mem.lt.     &
     &              cv_proc_maxmem(cv_proc_sorted(k))))                 &
     &              .AND.                                               &
     & (cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k)).eq.0))   &
     &              then
                  cv_procnode(inode)=cv_proc_sorted(k)
                  cv_proc_workload(cv_proc_sorted(k))=                  &
     &                 cv_proc_workload(cv_proc_sorted(k))+aux_flop
                  cv_proc_memused(cv_proc_sorted(k))=                   &
     &                 cv_proc_memused(cv_proc_sorted(k))+aux_mem
                  cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k))&
     &                 =-inode
                  cv_layerworkload(cv_proc_sorted(k))=                  &
     &                 cv_layerworkload(cv_proc_sorted(k))+aux_flop
                  cv_layermemused(cv_proc_sorted(k))=                   &
     &                 cv_layermemused(cv_proc_sorted(k))+aux_mem
                  exit
               else
                  k=k+1
                  if(k.gt.cv_slavef) then
                     if(cv_lp.gt.0)                                     &
     &                    write(cv_lp,*)'Error in ',subname
                     return
                  endif
               end if
            end do
         else
            inode=aux_int
            err_rep='SORTPROCS'
            if(use_propmap) then
               call AGMG_MUMPS_398(map_strat,                                &
     &                        cv_proc_workload,cv_proc_memused,         &
     &                        inode=inode,istat=ierr)
            else
               call AGMG_MUMPS_398(map_strat,                                &
     &                        cv_proc_workload,cv_proc_memused,         &
     &                        inode,istat=ierr)
            endif
            if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &          write(cv_lp,*)                                          &
     &          'Error reported by ',err_rep,' in ',subname
               istat = ierr
               return
            endif
            if (cv_nodetype(inode).eq.1) then
               do while(k.le.cv_slavef)
                  if((.not.cv_constr_work).or.                          &
     &               (cv_proc_workload(cv_proc_sorted(k))+aux_flop.lt.  &
     &                cv_proc_maxwork(cv_proc_sorted(k)))               &
     &            .AND.((.not.cv_constr_mem).or.                        &
     &               (cv_proc_memused(cv_proc_sorted(k))+aux_mem.lt.    &
     &                cv_proc_maxmem(cv_proc_sorted(k))))) then
                     cv_procnode(inode)=cv_proc_sorted(k)
                     cv_proc_workload(cv_proc_sorted(k))=               &
     &                    cv_proc_workload(cv_proc_sorted(k))+aux_flop
                     cv_proc_memused(cv_proc_sorted(k))=                &
     &                    cv_proc_memused(cv_proc_sorted(k))+aux_mem
                     cv_layerworkload(cv_proc_sorted(k))=               &
     &                    cv_layerworkload(cv_proc_sorted(k))+aux_flop
                     cv_layermemused(cv_proc_sorted(k))=                &
     &                    cv_layermemused(cv_proc_sorted(k))+aux_mem
                     exit
                  else
                     k=k+1
                     if(k.gt.cv_slavef) then
                        if(cv_lp.gt.0)                                  &
     &                  write(cv_lp,*)'Inconsist data in ',subname
                        return
                     endif
                  end if
               end do
            elseif (cv_nodetype(inode).eq.2)then
               do j=1,cv_layer_p2node(layernmb)%nmb_t2s
                  if(cv_layer_p2node(layernmb)%t2_nodenumbers(j).ne.    &
     &               inode) then
                     cycle
                  else
                     exit
                  endif
               enddo
               do while(k.le.cv_slavef)
                  if(((.not.cv_constr_work).or.                         &
     &               (cv_proc_workload(cv_proc_sorted(k))+aux_flop.lt.  &
     &                cv_proc_maxwork(cv_proc_sorted(k))))              &
     &              .AND.((.not.cv_constr_mem).or.                      &
     &               (cv_proc_memused(cv_proc_sorted(k))+aux_mem.lt.    &
     &                cv_proc_maxmem(cv_proc_sorted(k))))               &
     &              .AND.                                               &
     & (cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k)).eq.0))   &
     &               then
                     cv_procnode(inode)=cv_proc_sorted(k)
                     cv_proc_workload(cv_proc_sorted(k))=               &
     &                    cv_proc_workload(cv_proc_sorted(k))+aux_flop
                     cv_proc_memused(cv_proc_sorted(k))=                &
     &                     cv_proc_memused(cv_proc_sorted(k))+aux_mem
                cv_layer_p2node(layernmb)%t2_cand(j,cv_proc_sorted(k))  &
     &                                           =-inode
                     cv_layerworkload(cv_proc_sorted(k))=               &
     &                    cv_layerworkload(cv_proc_sorted(k))+aux_flop
                     cv_layermemused(cv_proc_sorted(k))=                &
     &                    cv_layermemused(cv_proc_sorted(k))+aux_mem
                     exit
                  else
                     k=k+1
                     if(k.gt.cv_slavef) then
                        if(cv_lp.gt.0)                                  &
     &                       write(cv_lp,*)'Error in ',subname
                        return
                     endif
                  end if
               end do
               nmb_cand_needed=cv_invalid
               do j=1,cv_layer_p2node(layernmb)%nmb_t2s
                  if(cv_layer_p2node(layernmb)%t2_nodenumbers(j)        &
     &                 .ne.inode)                                       &
     &                 then
                     cycle
                  else
                     nmb_cand_needed=                                   &
     &                    cv_layer_p2node(layernmb)%                    &
     &                    t2_cand(j,cv_slavef+1)
                     exit
                  endif
               enddo
               if(nmb_cand_needed.eq.cv_invalid) then
                  if(cv_lp.gt.0)                                        &
     &                 write(cv_lp,*)'Error in ',subname
                  return
               endif
               aux_flop=                                                &
     &              cv_layer_p2node(layernmb)%t2_candcostw(j)
               aux_mem=                                                 &
     &              cv_layer_p2node(layernmb)%t2_candcostm(j)
               do while((k.le.cv_slavef).and.(nmb_cand_needed.gt.0))
                  if(((.not.cv_constr_work).or.                         &
     &                 (cv_proc_workload(cv_proc_sorted(k))+aux_flop.lt.&
     &                 cv_proc_maxwork(cv_proc_sorted(k))))             &
     &                 .AND.((.not.cv_constr_mem).or.                   &
     &                 (cv_proc_memused(cv_proc_sorted(k))+aux_mem.lt.  &
     &                 cv_proc_maxmem(cv_proc_sorted(k))))              &
     &                 .AND.                                            &
     &                 (cv_layer_p2node(layernmb)%                      &
     &                 t2_cand(j,cv_proc_sorted(k)).eq.0))              &
     &                 then
                     cv_proc_workload(cv_proc_sorted(k))=               &
     &                    cv_proc_workload(cv_proc_sorted(k))+aux_flop
                     cv_proc_memused(cv_proc_sorted(k))=                &
     &                    cv_proc_memused(cv_proc_sorted(k))+aux_mem
                     cv_layer_p2node(layernmb)%                         &
     &                    t2_cand(j,cv_proc_sorted(k))                  &
     &                    =inode
                     cv_layerworkload(cv_proc_sorted(k))=               &
     &                    cv_layerworkload(cv_proc_sorted(k))+aux_flop
                     cv_layermemused(cv_proc_sorted(k))=                &
     &                    cv_layermemused(cv_proc_sorted(k))+aux_mem
                     nmb_cand_needed=nmb_cand_needed-1
                     k=k+1
                  else
                     k=k+1
                     if(k.gt.cv_slavef) then
                        if(cv_lp.gt.0)                                  &
     &                       write(cv_lp,*)'Error in ',subname
                        return
                     endif
                  end if
               end do
               if(nmb_cand_needed.gt.0) then
                  if(cv_lp.gt.0)                                        &
     &                 write(cv_lp,*)'Error in ',subname
                  return
               endif
            end if
         end if
      end do
      do i=1,cv_layer_p2node(layernmb)%nmb_t2s
         nmb_cand_needed=                                               &
     &                  cv_layer_p2node(layernmb)%t2_cand(i,cv_slavef+1)
         candid= cv_layer_p2node(layernmb)%t2_cand(i,1:cv_slavef)
         cv_layer_p2node(layernmb)%t2_cand(i,1:cv_slavef)=-1
         k=0
         do j=1,cv_slavef
            if(candid(j).gt.0) then
               k=k+1
               cv_layer_p2node(layernmb)%t2_cand(i,k)=j-1
            end if
         end do
         if (k.ne.nmb_cand_needed) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Error in ',subname
            return
         endif
      enddo
      do i=1,cv_slavef
         cv_layerworkload(i)=cv_layerworkload(i)-old_workload(i)
         cv_layermemused(i)=cv_layermemused(i)-old_memused(i)
      enddo
      istat=0
      return
      end subroutine AGMG_MUMPS_387
      recursive subroutine AGMG_MUMPS_385(inode,procnmb,                     &
     &                                       procnode)
      integer,intent(in)::inode,procnmb
      integer,intent(inout)::procnode(cv_n)
      integer in
      procnode(inode)=procnmb
      if (cv_fils(inode).eq.0) return
      in=cv_fils(inode)
      do while(in>0)
         procnode(in)=procnmb
         in=cv_fils(in)
      end do
      in=-in
      do while(in>0)
         call AGMG_MUMPS_385(in,procnmb,procnode)
         in=cv_frere(in)
      end do
      return
      end subroutine AGMG_MUMPS_385
      subroutine AGMG_MUMPS_386(procnode)
      implicit none
      integer,intent(inout)::procnode(cv_n)
      integer i,inode,procnmb
      type(nodelist),pointer::dummy
      do i=cv_layerl0_start,cv_layerl0_end
         inode=cv_layerl0_array(i)
         if(inode.gt.0) then
            procnmb=procnode(inode)
            call AGMG_MUMPS_385(inode,procnmb,procnode)
         endif
      enddo
      return
      end subroutine AGMG_MUMPS_386
      subroutine AGMG_MUMPS_389(map_strat,inode,istat)
      implicit none
      integer, intent(in)::map_strat
      integer,intent(out)::inode,istat
      type(nodelist),pointer::dummy
      character (len=48):: subname
      subname='MAX_TCOST_L0'
      inode=-1
      istat=-1
      if ((.NOT.associated(cv_tcostw)).OR.(.NOT.associated(cv_tcostm))) &
     &   then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:tcost must be allocated in ',subname
         return
      end if
      if((map_strat.ne.cv_equilib_flops).and.                           &
     &   (map_strat.ne.cv_equilib_mem)) return
      inode=cv_layerl0_array(cv_layerl0_start)
      istat=0
      return
      end subroutine AGMG_MUMPS_389
      subroutine AGMG_MUMPS_431()
      implicit none
      integer candid,inode,index,i,j,layernmb,master,nmbcand,swapper,   &
     &        totalnmb,node_of_master,node_of_candid,node_of_swapper
      DOUBLE PRECISION::mastermem,slavemem,maxmem
      logical swapthem,cand_better_master_arch,cand_better_swapper_arch
      intrinsic maxval,minval
      maxmem=maxval(cv_proc_memused(:))
      totalnmb=0
      do layernmb=cv_maxlayer,1,-1
         do i=1,cv_layer_p2node(layernmb)%nmb_t2s
            inode=cv_layer_p2node(layernmb)%t2_nodenumbers(i)
            master=cv_procnode(inode)
            if(ke69 .gt. 1) then
               allowed_nodes = .FALSE.
               call AGMG_MUMPS_476(layernmb,i)
               node_of_master = mem_distribmpi(master-1)
               if (node_of_master .lt. 0 ) then
                if(cv_mp.gt.0) write(cv_mp,*)'node_of_master_not found'
               endif
               node_of_swapper = node_of_master
            endif
            mastermem=cv_proc_memused(master)
            nmbcand=cv_layer_p2node(layernmb)%t2_cand(i,cv_slavef+1)
            swapper=master
            index=0
            do j=1,nmbcand
               candid=cv_layer_p2node(layernmb)%t2_cand(i,j)+1
               slavemem=cv_proc_memused(candid)
               if(ke69 .gt. 1) then
                  node_of_candid = mem_distribmpi(candid-1)
                  if (node_of_candid .lt. 0 ) then
                     if(cv_mp.gt.0) write(cv_mp,*)                      &
     &               'node_of_candid_not found'
                  endif
               endif
               if(ke69 .le. 1) then
                  if((slavemem.lt.mastermem) .and.                      &
     &                 (slavemem.lt.cv_proc_memused(swapper))) then
                     swapper=candid
                     index=j
                  endif
               else
                  cand_better_master_arch = (                           &
     &                    (                                             &
     &                       (slavemem.lt.mastermem) .or.               &
     &                       (.not. allowed_nodes(node_of_master))      &
     &                    )                                             &
     &                    .and. allowed_nodes(node_of_candid)           &
     &                 )
                  cand_better_swapper_arch = (                          &
     &                    (                                             &
     &                       (slavemem.lt.cv_proc_memused(swapper)) .or.&
     &                       (.not. allowed_nodes(node_of_swapper))     &
     &                    )                                             &
     &                    .and. allowed_nodes(node_of_candid)           &
     &                 )
                  if(cand_better_master_arch .and.                      &
     &                 cand_better_swapper_arch  ) then
                     swapper=candid
                     node_of_swapper = node_of_candid
                     index=j
                  endif
               endif
            enddo
            if(swapper.ne.master) then
               swapthem = .FALSE.
               if(0.75D0*mastermem.ge.cv_proc_memused(swapper))         &
     &            swapthem=.TRUE.
               if(mastermem.le.mastermem-cv_ncostm(inode)               &
     &                +cv_layer_p2node(layernmb)%t2_candcostm(i))       &
     &            swapthem=.FALSE.
               if(mastermem.le.cv_proc_memused(swapper)                 &
     &                    +cv_ncostm(inode)                             &
     &                    -cv_layer_p2node(layernmb)%t2_candcostm(i))   &
     &            swapthem=.FALSE.
               if(maxmem.le.mastermem-cv_ncostm(inode)                  &
     &                +cv_layer_p2node(layernmb)%t2_candcostm(i))       &
     &            swapthem=.FALSE.
               if(maxmem.le.cv_proc_memused(swapper)+cv_ncostm(inode)   &
     &                -cv_layer_p2node(layernmb)%t2_candcostm(i))       &
     &            swapthem=.FALSE.
               if(ke69 .gt. 1) then
                  if (.not. allowed_nodes(node_of_master)) then
                     swapthem=.TRUE.
                  endif
               endif
               if(.NOT.swapthem) cycle
               cv_proc_workload(master)=cv_proc_workload(master)        &
     &                -cv_ncostw(inode)                                 &
     &                +cv_layer_p2node(layernmb)%t2_candcostw(i)
               cv_proc_memused(master)=cv_proc_memused(master)          &
     &                -cv_ncostm(inode)                                 &
     &                +cv_layer_p2node(layernmb)%t2_candcostm(i)
               cv_proc_workload(swapper)=cv_proc_workload(swapper)      &
     &                +cv_ncostw(inode)                                 &
     &                -cv_layer_p2node(layernmb)%t2_candcostw(i)
               cv_proc_memused(swapper)=cv_proc_memused(swapper)        &
     &                +cv_ncostm(inode)                                 &
     &                -cv_layer_p2node(layernmb)%t2_candcostm(i)
               cv_layer_p2node(layernmb)%t2_cand(i,index)=master-1
               cv_procnode(inode)=swapper
               maxmem=maxval(cv_proc_memused(:))
               totalnmb = totalnmb+1
            endif
         enddo
      enddo
      end subroutine AGMG_MUMPS_431
      subroutine AGMG_MUMPS_391(maxwork,maxmem,istat)
      implicit none
      DOUBLE PRECISION,intent(in),OPTIONAL::maxwork(cv_slavef),         &
     &                                      maxmem(cv_slavef)
      integer,intent(out)::istat
      integer i,allocok
      intrinsic huge
      DOUBLE PRECISION dummy
      character (len=48):: subname
      istat=-1
      subname='PROCINIT'
      if(present(maxwork)) then
         cv_constr_work=.TRUE.
      else
         cv_constr_work=.FALSE.
      end if
      if(present(maxmem)) then
         cv_constr_mem=.TRUE.
      else
         cv_constr_mem=.FALSE.
      end if
      allocate(cv_proc_workload(cv_slavef),                             &
     &         cv_proc_maxwork(cv_slavef),                              &
     &         cv_proc_memused(cv_slavef),                              &
     &         cv_proc_maxmem(cv_slavef),                               &
     &         cv_proc_sorted(cv_slavef),                               &
     &         STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = 2*cv_slavef
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'memory allocation error in ',subname
         return
      end if
      allocate(work_per_proc(cv_slavef),id_son(cv_slavef),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = 2*cv_slavef
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'memory allocation error in ',subname
         return
      end if
      do i=1,cv_slavef
         cv_proc_workload(i)=dble(0)
         if(cv_constr_work) then
            cv_proc_maxwork(i)=maxwork(i)
         else
            cv_proc_maxwork(i)=(huge(dummy))
         endif
         cv_proc_memused(i)=dble(0)
         if(cv_constr_mem) then
            cv_proc_maxmem(i)=maxmem(i)
         else
            cv_proc_maxmem(i)=(huge(dummy))
         endif
      end do
      cv_proc_sorted=(/(i,i=1,cv_slavef)/)
      istat=0
      return
      end subroutine AGMG_MUMPS_391
      recursive subroutine AGMG_MUMPS_517                                    &
     &                    (inode,ctr,istat)
      implicit none
      integer, intent(in)::inode,ctr
      integer, intent(inout)::istat
      integer::j,k,in,in1,ierr,son,nmb_procs_inode,nmb_sons_inode,      &
     &           procs4son(cv_size_ind_proc),current,i
      character (len=48):: subname
      DOUBLE PRECISION :: relative_weight,costs_sons
      DOUBLE PRECISION :: loc_relax
      INTEGER :: depth
      logical force_cand
      DOUBLE PRECISION Y
      intrinsic random_number
      integer nmb_propmap,nmb_propmap_strict,share2,procsrest,current2
      integer k69onid
      integer procs_inode(slavef)
      if (ctr.le.0) then
         istat = 0
         return
      endif
      procs_inode=-1
      istat= -1
      if(cv_frere(inode).eq.cv_n+1) return
      subname='MOD_PROPMAP'
      if(.NOT.associated(cv_prop_map(inode)%ind_proc)) return
      nmb_procs_inode = 0
      do j=1,cv_slavef
         if( AGMG_MUMPS_481(inode,j))then
            nmb_procs_inode = nmb_procs_inode + 1
         endif
      end do
      i=0
      do j=1,cv_slavef
            if(ke69 .gt.1) then
               call AGMG_MUMPS_493(j-1,                                      &
     &              k69onid,ierr)
            else
               k69onid = j
            endif
            if(AGMG_MUMPS_481(inode,k69onid))then
               i = i + 1
               procs_inode(i)=k69onid
            endif
      end do
      if(i.ne.nmb_procs_inode)then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname                         &
     &        ,subname
         return
      endif
      if(nmb_procs_inode.eq.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname                         &
     &        ,subname
         return
      end if
      if ((cv_nodelayer(inode).eq.0).AND.                               &
     &         (cv_frere(inode).ne.cv_n+1)) then
         istat = 0
         return
      endif
      nmb_sons_inode = 0
      costs_sons = dble(0)
      force_cand=(mod(cv_keep(24),2).eq.0)
      in = inode
      do while (cv_fils(in).gt.0)
         in=cv_fils(in)
      end do
      if (cv_fils(in).eq.0) then
         istat = 0
         return
      endif
      in = -cv_fils(in)
      son=in
      do while(in.gt.0)
         nmb_sons_inode = nmb_sons_inode + 1
         if(cv_tcostw(in).le.0.0D0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Subtree costs for ',in,                 &
     &                         ' should be positive in ',subname
            return
         endif
         costs_sons = costs_sons + cv_tcostw(in)
         in=cv_frere(in)
      enddo
      if(costs_sons.le.0D0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname                         &
     &        ,subname
         return
      endif
      depth= max(cv_mixed_strat_bound - ctr,0)
      if ((cv_keep(24).eq.16).OR.(cv_keep(24).eq.18)) then
         if(depth.ge.cv_mixed_strat_bound) then
            loc_relax = dble(1)
         else
            loc_relax =  dble(1) +                                      &
     &            max(dble(cv_keep(77))/dble(100), dble(0))
         endif
      else
         loc_relax = dble(1)
      endif
      in=son
      current = 1
      do while(in.gt.0)
         if( (nmb_sons_inode.ge.nmb_procs_inode).AND.                   &
     &       (nmb_procs_inode.LT.4) ) then
            procs4son = cv_prop_map(inode)%ind_proc
         else
            do k=1,cv_size_ind_proc
               do j=0,cv_bitsize_of_int-1
                  procs4son(k)=ibclr(procs4son(k),j)
               end do
            end do
            nmb_propmap_strict=0
            do k=1,cv_slavef
               if( AGMG_MUMPS_481(in,k)) then
                  nmb_propmap_strict=nmb_propmap_strict+1
                  call AGMG_MUMPS_482(procs4son,k,ierr)
               end if
            end do
            if(costs_sons.gt.0.0D0) then
               relative_weight=cv_tcostw(in)/costs_sons
            else
               relative_weight=0.0D0
            endif
            current = nmb_propmap_strict
            share2=                                                     &
     &           max(0,nint(relative_weight*(loc_relax-dble(1))*        &
     &           dble(nmb_procs_inode)))
            procsrest=nmb_procs_inode - nmb_propmap_strict
            share2=min(share2,procsrest)
            CALL RANDOM_NUMBER(Y)
            current2=int(dble(Y)*dble(procsrest))
            k=1
            i=1
            do while((share2.gt.0).and.(i.le.2))
               do j=1,nmb_procs_inode
                  if(share2.le.0) exit
                  k69onid = procs_inode(j)
                  if(( AGMG_MUMPS_481(inode,k69onid)).AND.                   &
     &                 (.NOT.AGMG_MUMPS_480(procs4son,k69onid))) then
                     if(k.ge.current2)then
                        call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                        if(ierr.ne.0) then
                           if(cv_lp.gt.0)write(cv_lp,*)                 &
     &                          'BIT_SET signalled error to',subname
                           istat = ierr
                           return
                        end if
                        share2 = share2 - 1
                     endif
                     k=k+1
                  end if
               enddo
               i=i+1
            enddo
            if(share2.ne.0) then
               if(cv_lp.gt.0) write(cv_lp,*)                            &
     &           'Error reported in ',subname
               return
            end if
         end if
         ierr=0
         in1=in
         cv_prop_map(in1)%ind_proc=procs4son
         call AGMG_MUMPS_517(in1,ctr-1,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0) write(cv_lp,*)                               &
     &           'Error reported in ',subname
            istat=ierr
            return
         endif
         in=cv_frere(in)
      end do
      istat = 0
      return
      end subroutine AGMG_MUMPS_517
      recursive subroutine AGMG_MUMPS_433(inode,ctr,istat)
      implicit none
      integer, intent(in)::inode,ctr
      integer, intent(inout)::istat
      integer::j,k,in,in1,ierr,son,nmb_procs_inode,nmb_sons_inode,      &
     &           share,procs4son(cv_size_ind_proc),current,offset,      &
     &           in_tmp,nfront,npiv,ncb,                                &
     &           keep48_loc,min_cand_needed
      character (len=48):: subname
      DOUBLE PRECISION :: relative_weight,costs_sons, shtemp
      DOUBLE PRECISION :: costs_sons_real
      DOUBLE PRECISION :: PartofaProc
      LOGICAL          :: SkipSmallNodes
      PARAMETER (PartofaProc=0.01D0)
      DOUBLE PRECISION :: loc_relax
      INTEGER :: depth
      logical force_cand
      integer AGMG_MUMPS_497, AGMG_MUMPS_50
      external AGMG_MUMPS_497, AGMG_MUMPS_50
      DOUBLE PRECISION Y
      intrinsic random_number
      integer nmb_propmap_strict,share2,procsrest,current2
      integer k69onid,nb_free_procs,local_son_indice,nb_procs_for_sons, &
     &     ptr_upper_ro_procs
      logical upper_round_off,are_sons_treated
      DOUBLE PRECISION tmp_cost
      if (ctr.le.0) then
         istat = 0
         return
      endif
      istat= -1
      if(cv_frere(inode).eq.cv_n+1) return
      subname='PROPMAP'
      nmb_procs_inode = 0
      do j=1,cv_slavef
         if( AGMG_MUMPS_481(inode,j))                                        &
     &        nmb_procs_inode = nmb_procs_inode + 1
      end do
      if(nmb_procs_inode.eq.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname                         &
     &        ,subname
         return
      end if
      if ((cv_nodelayer(inode).eq.0).AND.                               &
     &         (cv_frere(inode).ne.cv_n+1)) then
         istat = 0
         return
      endif
      ptr_upper_ro_procs=1
      work_per_proc(1:cv_slavef)=0.0D0
      id_son(1:cv_slavef)=0
      nmb_sons_inode = 0
      costs_sons = dble(0)
      force_cand=(mod(cv_keep(24),2).eq.0)
      min_cand_needed=0
      in = inode
      do while (cv_fils(in).gt.0)
         in=cv_fils(in)
      end do
      if (cv_fils(in).eq.0) then
         istat = 0
         return
      endif
      in = -cv_fils(in)
      son=in
      do while(in.gt.0)
         nmb_sons_inode = nmb_sons_inode + 1
         if(cv_tcostw(in).le.0.0D0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Subtree costs for ',in,                 &
     &                         ' should be positive in ',subname
            return
         endif
         costs_sons = costs_sons + cv_tcostw(in)
         in=cv_frere(in)
      enddo
      costs_sons_real = costs_sons
      SkipSmallNodes = .true.
      IF (costs_sons_real.gt.0.0D0) then
       in = son
       do while (in.gt.0)
          relative_weight=cv_tcostw(in)/costs_sons_real
          shtemp = relative_weight*dble(nmb_procs_inode)
          IF (shtemp.lt.PartofaProc) THEN
            costs_sons = costs_sons - cv_tcostw(in)
          ENDIF
          in=cv_frere(in)
       enddo
       IF (costs_sons.LT. PartofaProc*costs_sons_real) THEN
         costs_sons = costs_sons_real
         SkipSmallNodes = .false.
       ENDIF
      ENDIF
      if(costs_sons.le.0.0D0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname                         &
     &        ,subname
         return
      endif
      if(cv_relax.le.0.0D0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname,'. Wrong cv_relax'
         return
      endif
      depth= max(cv_n - ctr,0)
      if(cv_keep(24).eq.8) then
         loc_relax = cv_relax
      elseif ((cv_keep(24).eq.16).OR.(cv_keep(24).eq.18)) then
         loc_relax = cv_relax
      elseif (cv_keep(24).eq.10) then
         loc_relax = cv_relax
      elseif ((cv_keep(24).eq.12).OR.(cv_keep(24).eq.14)) then
         if(depth.ge.cv_mixed_strat_bound) then
            loc_relax = cv_relax
         else
            loc_relax =  cv_relax +                                     &
     &          max(dble(cv_keep(77))/dble(100), dble(0))
         endif
      endif
      in=son
      current = 1
      local_son_indice=1
      nb_procs_for_sons=0
      upper_round_off=.FALSE.
      are_sons_treated=.TRUE.
      do while(in.gt.0)
         if( (nmb_sons_inode.ge.nmb_procs_inode).AND.                   &
     &       (nmb_procs_inode.LT.4) ) then
            procs4son = cv_prop_map(inode)%ind_proc
            are_sons_treated=.FALSE.
            nb_procs_for_sons=nmb_procs_inode
            nmb_propmap_strict=nmb_procs_inode
         elseif(nmb_procs_inode .LE. cv_keep(83)) then
            procs4son = cv_prop_map(inode)%ind_proc
            are_sons_treated=.FALSE.
            nb_procs_for_sons=nmb_procs_inode
            nmb_propmap_strict=nmb_procs_inode
         else
            do k=1,cv_size_ind_proc
               do j=0,cv_bitsize_of_int-1
                  procs4son(k)=ibclr(procs4son(k),j)
               end do
            end do
            if(costs_sons.gt.0.0D0) then
               relative_weight=cv_tcostw(in)/costs_sons
            else
               relative_weight=dble(0)
            endif
            shtemp = relative_weight*dble(nmb_procs_inode)
            IF ( (shtemp.LT.PartofaProc)                                &
     &             .AND. ( SkipSmallNodes ) )  THEN
             share = 1
             do j=current,cv_slavef
              if(ke69 .gt.1) then
               call AGMG_MUMPS_493(j-1,k69onid,ierr)
              else
               k69onid = j
              endif
              if( AGMG_MUMPS_481(inode,k69onid)) then
                  call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                  if(ierr.ne.0) then
                     if(cv_lp.gt.0)write(cv_lp,*)                       &
     &               'BIT_SET signalled error to',subname
                     istat = ierr
                     return
                  end if
                  share = share -1
                  exit
              endif
             enddo
             if (share.gt.0) then
               do j=1,current-1
                if(ke69 .gt.1) then
                 call AGMG_MUMPS_493(j-1,k69onid,ierr)
                else
                 k69onid = j
                endif
                if( AGMG_MUMPS_481(inode,k69onid)) then
                    call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                    if(ierr.ne.0) then
                       if(cv_lp.gt.0)write(cv_lp,*)                     &
     &               'BIT_SET signalled error to',subname
                       istat = ierr
                       return
                    end if
                    share = share -1
                    exit
                endif
               enddo
              endif
              if(share.ne.0) then
                 if(cv_lp.gt.0) write(cv_lp,*)                          &
     &              'Error reported in ',subname
                 return
              end if
              if(.NOT.associated(cv_prop_map(in)%ind_proc)) then
                 call AGMG_MUMPS_434(in,ierr)
              if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &              write(cv_lp,*)'PROPMAP_INIT signalled error to'     &
     &              ,subname
               istat = ierr
               return
              end if
             endif
             current  = j
             cv_prop_map(in)%ind_proc = procs4son
             in = cv_frere(in)
             cycle
            ENDIF
            share  = max(1,nint(shtemp))
            if (dble(share).ge.shtemp) then
               upper_round_off=.TRUE.
            else
               upper_round_off = .FALSE.
            endif
            share=min(share,nmb_procs_inode)
            nmb_propmap_strict=share
            nb_procs_for_sons=nb_procs_for_sons+nmb_propmap_strict
            offset=1
            do j=current,cv_slavef
               if(ke69 .gt.1) then
                  call AGMG_MUMPS_493(j-1,k69onid,ierr)
               else
                  k69onid = j
               endif
               if( AGMG_MUMPS_481(inode,k69onid)) then
                  call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                  if(ierr.ne.0) then
                     if(cv_lp.gt.0)write(cv_lp,*)                       &
     &               'BIT_SET signalled error to',subname
                     istat = ierr
                     return
                  end if
                  share = share-1
                  if(share.le.0) then
                     current = j + offset
                     if(current.gt.cv_slavef) current = 1
                     exit
                  end if
               end if
            end do
            if(share.gt.0) then
               do j=1,current-1
                  if(ke69 .gt.1) then
                     call AGMG_MUMPS_493(j-1,k69onid,ierr)
                  else
                     k69onid = j
                  endif
                  if( AGMG_MUMPS_481(inode,k69onid)) then
                     call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                     if(ierr.ne.0) then
                        if(cv_lp.gt.0)write(cv_lp,*)                    &
     &                  'BIT_SET signalled error to',subname
                        istat = ierr
                        return
                     end if
                     share = share-1
                     if(share.le.0) then
                        current = j + offset
                        if(current.gt.cv_slavef) current = 1
                        exit
                     end if
                  end if
               end do
            endif
            if(share.ne.0) then
               if(cv_lp.gt.0) write(cv_lp,*)                            &
     &              'Error reported in ',subname
               return
            end if
            if(.not.upper_round_off)then
               if(local_son_indice.lt.cv_slavef)then
                  id_son(local_son_indice)=in
                  work_per_proc(local_son_indice)=cv_tcostw(in)/        &
     &                 dble(nmb_propmap_strict)
                  local_son_indice=local_son_indice+1
                  if(local_son_indice.eq.cv_slavef)then
                     CALL AGMG_MUMPS_459(cv_slavef,id_son,                   &
     &                    work_per_proc)
                  endif
               else
                  current2=cv_slavef
                  tmp_cost=cv_tcostw(in)/dble(nmb_propmap_strict)
                  do while(current2.ge.1)
                     if(tmp_cost.lt.work_per_proc(current2))exit
                     current2=current2-1
                  enddo
                  if(current2.ne.cv_slavef)then
                     if(current2.eq.0)then
                        current2=1
                     endif
                     do j=cv_slavef-1,current2,-1
                        id_son(j+1)=id_son(j)
                        work_per_proc(j+1)=work_per_proc(j)
                     enddo
                     id_son(current2)=in
                     work_per_proc(current2)=tmp_cost
                  endif
               endif
            endif
            upper_round_off=.FALSE.
         endif
         if(.NOT.associated(cv_prop_map(in)%ind_proc)) then
            call AGMG_MUMPS_434(in,ierr)
            if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &              write(cv_lp,*)'PROPMAP_INIT signalled error to'     &
     &              ,subname
               istat = ierr
               return
            end if
         endif
         cv_prop_map(in)%ind_proc = procs4son
         in=cv_frere(in)
      end do
      if(are_sons_treated)then
         if(nb_procs_for_sons.ne.nmb_procs_inode)then
            do j=1,nmb_procs_inode-nb_procs_for_sons
               procs4son=cv_prop_map(id_son(j))%ind_proc
               do while(current.le.cv_slavef)
                  if(ke69 .gt.1) then
                     call AGMG_MUMPS_493(current-1,k69onid,ierr)
                  else
                     k69onid = current
                  endif
                  if(.NOT.AGMG_MUMPS_481(inode,k69onid)) then
                     current=current+1
                  else
                     exit
                  endif
               enddo
               call AGMG_MUMPS_482(procs4son,k69onid,ierr)
               cv_prop_map(id_son(j))%ind_proc=procs4son
            enddo
            ptr_upper_ro_procs=min(j,nmb_procs_inode-nb_procs_for_sons)
         endif
      endif
      in=son
      current = 1
      do while(in.gt.0)
         if( (nmb_sons_inode.ge.nmb_procs_inode).AND.                   &
     &       (nmb_procs_inode.LT.4) ) then
            procs4son = cv_prop_map(inode)%ind_proc
         elseif(nmb_procs_inode .LE. cv_keep(83)) then
            procs4son = cv_prop_map(inode)%ind_proc
         else
            procs4son = cv_prop_map(in)%ind_proc
            in_tmp=in
            nfront=cv_nfsiz(in_tmp)
            npiv=0
            in_tmp=in_tmp
            do while(in_tmp.gt.0)
               npiv=npiv+1
               in_tmp=cv_fils(in_tmp)
            end do
            ncb=nfront-npiv
            if (force_cand) then
               if (cv_keep(50) ==  0) then
                  keep48_loc=0
               else
                  keep48_loc=3
               endif
               if (cv_keep(48).EQ.5) keep48_loc = 5
               min_cand_needed=                                         &
     &              AGMG_MUMPS_50                                            &
     &              (cv_slavef, keep48_loc,cv_keep8(21),                &
     &              cv_keep(50),                                        &
     &              nfront,ncb)
               min_cand_needed=min(cv_slavef,min_cand_needed+1)
            else
               min_cand_needed = 0
            endif
            min_cand_needed = max(min_cand_needed, cv_keep(91))
            if(costs_sons.gt.0.0D0) then
               relative_weight=cv_tcostw(in)/costs_sons
            else
               relative_weight=dble(0)
            endif
            nmb_propmap_strict=0
            do k=1,cv_slavef
               if( AGMG_MUMPS_480(procs4son,k)) then
                  nmb_propmap_strict=nmb_propmap_strict+1
               end if
            end do
            offset=1
            share2=                                                     &
     &          max(0,nint(relative_weight*(loc_relax-dble(1))*         &
     &                                   dble(nmb_procs_inode)))
            share2 = max(share2, min_cand_needed -nmb_propmap_strict,   &
     &                   (cv_keep(83)/2) - nmb_propmap_strict)
            procsrest=nmb_procs_inode - nmb_propmap_strict
            share2=min(share2,procsrest)
            share2 = 0
            CALL RANDOM_NUMBER(Y)
            current2     =int(dble(Y)*dble(procsrest))
            nb_free_procs=1
            do j=1,cv_slavef
               if(share2.le.0) exit
               if(ke69 .gt.1) then
                     call AGMG_MUMPS_493(j-1,k69onid,ierr)
                  else
                     k69onid = j
                  endif
               if(( AGMG_MUMPS_481(inode,k69onid)).AND.                      &
     &           (.NOT.AGMG_MUMPS_480(procs4son,k69onid))) then
                  if(nb_free_procs.ge.current2)then
                     call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                     if(ierr.ne.0) then
                        if(cv_lp.gt.0)write(cv_lp,*)                    &
     &                       'BIT_SET signalled error to',subname
                        istat = ierr
                        return
                     end if
                     share2 = share2 - 1
                  endif
                  nb_free_procs=nb_free_procs+1
               end if
            end do
            if(share2.gt.0) then
               do j=1,cv_slavef
                  if(share2.le.0) exit
                  if(ke69 .gt.1) then
                     call AGMG_MUMPS_493(j-1,k69onid,ierr)
                  else
                     k69onid = j
                  endif
                  if(( AGMG_MUMPS_481(inode,k69onid)).AND.                   &
     &              (.NOT.AGMG_MUMPS_480(procs4son,k69onid))) then
                        call AGMG_MUMPS_482(procs4son,k69onid,ierr)
                        if(ierr.ne.0) then
                           if(cv_lp.gt.0)write(cv_lp,*)                 &
     &                          'BIT_SET signalled error to',subname
                           istat = ierr
                           return
                        end if
                        share2 = share2 - 1
                  end if
               end do
            endif
            if(share2.ne.0) then
               if(cv_lp.gt.0) write(cv_lp,*)                            &
     &              'Error reported in ',subname
               return
            end if
         endif
         ierr=0
         in1=in
         cv_prop_map(in1)%ind_proc = procs4son
         call AGMG_MUMPS_433(in1,ctr-1,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0) write(cv_lp,*)                               &
     &         'Error reported in ',subname
            istat=ierr
            return
         endif
         in=cv_frere(in)
      end do
      istat = 0
      return
      end subroutine AGMG_MUMPS_433
      subroutine AGMG_MUMPS_434(inode,istat)
      implicit none
      integer, intent(in)::inode
      integer, intent(out)::istat
      integer j,k,allocok
      character (len=48):: subname
      istat = -1
      if(cv_frere(inode).eq.cv_n+1) return
      subname='PROPMAP_INIT'
      if(.not.associated(                                               &
     &     cv_prop_map(inode)%ind_proc)) then
         allocate(cv_prop_map(inode)%ind_proc                           &
     &        (cv_size_ind_proc),STAT=allocok)
         if (allocok.gt.0) then
            cv_info(1) = cv_error_memalloc
            cv_info(2) = cv_size_ind_proc
            istat = cv_error_memalloc
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)                                         &
     &           'memory allocation error in ',subname
            return
         end if
      end if
      do k=1,cv_size_ind_proc
         do j=0,cv_bitsize_of_int-1
            cv_prop_map(inode)%ind_proc(k)=                             &
     &         ibclr(cv_prop_map(inode)%ind_proc(k),j)
         end do
      end do
      istat = 0
      return
      end subroutine AGMG_MUMPS_434
      subroutine AGMG_MUMPS_435(inode,istat)
      integer,intent(in)::inode
      integer,intent(out)::istat
      integer ierr
      character (len=48):: subname
      subname='PROPMAP_TERM'
      istat =-1
      if(associated(cv_prop_map(inode)%ind_proc)) then
        deallocate(cv_prop_map(inode)%ind_proc, STAT=ierr)
        if(ierr.ne.0) then
           if(cv_lp.gt.0)                                               &
     &         write(cv_lp,*)'Memory deallocation error in ', subname
               istat = cv_error_memdeloc
               return
        endif
        nullify(cv_prop_map(inode)%ind_proc)
      end if
      istat =0
      return
      end subroutine AGMG_MUMPS_435
      subroutine AGMG_MUMPS_436(ison,ifather,istat)
      implicit none
      integer,intent(in)::ison,ifather
      integer,intent(out)::istat
      character (len=48):: subname
      istat= -1
      subname='PROPMAP4AMALG'
      call AGMG_MUMPS_435(ison,ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'PROPMAP_TERM signalled error in ',         &
     &        subname
         istat = ierr
         return
      end if
      istat = 0
      return
      end subroutine AGMG_MUMPS_436
      subroutine AGMG_MUMPS_437(inode,ifather,istat)
      implicit none
      integer,intent(in)::inode,ifather
      integer,intent(out)::istat
      character (len=48):: subname
      istat= -1
      subname='PROPMAP4SPLIT'
      if((cv_frere(inode).eq.cv_n+1).OR.(cv_frere(ifather).eq.cv_n+1)   &
     &     .OR.(.NOT.associated(cv_prop_map(inode)%ind_proc))) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'tototo signalled error to'                 &
     &        ,subname
         return
      endif
      if(.NOT.associated(cv_prop_map(ifather)%ind_proc)) then
         call AGMG_MUMPS_434(ifather,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'PROPMAP_INIT signalled error to '       &
     &           ,subname
            istat = ierr
            return
         end if
      endif
      cv_prop_map(ifather)%ind_proc =                                   &
     &                    cv_prop_map(inode)%ind_proc
      istat=0
      return
      end subroutine AGMG_MUMPS_437
      subroutine AGMG_MUMPS_394(istat)
      implicit none
      integer,intent(out)::istat
      integer i,ierr,allocok
      type(nodelist),pointer::nodeptr
      character (len=48):: subname
      istat=-1
      subname='ROOTLIST'
      allocate(cv_layerl0_array(cv_maxnsteps),                          &
     &         cv_layerl0_sorted_costw(cv_maxnsteps),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = 12*cv_maxnsteps
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)                                            &
     &        'memory allocation error in ',subname
         return
      end if
      do i=1,cv_maxnsteps
         cv_layerl0_sorted_costw(i)=dble(0)
         cv_layerl0_array(i)=0
      end do
      cv_layerl0_start        = 0
      cv_layerl0_end          = 0
      layerL0_endforarrangeL0 = 0
      if ((.NOT.associated(cv_tcostw)).OR.(.NOT.associated(cv_tcostm))) &
     &   then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:tcost must be allocated in ',subname
         return
      end if
      cv_nbsa=0
      do i=1,cv_n
         if (cv_frere(i).eq.0) then
            cv_layerl0_start=1
            cv_layerl0_end=cv_layerl0_end+1
            IF (cv_tcostw(i).GT.mincostw)                               &
     &           layerL0_endforarrangeL0 = layerL0_endforarrangeL0+1
            cv_layerl0_array(cv_layerl0_end)=i
            cv_layerl0_sorted_costw(cv_layerl0_end)=cv_tcostw(i)
            cv_costw_layer0=cv_costw_layer0 + cv_tcostw(i)
            cv_costm_layer0=cv_costm_layer0 + cv_tcostm(i)
            cv_nbsa=cv_nbsa+1
         end if
      end do
      if(cv_nbsa.eq.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:no root nodes in ',subname
         return
      end if
      call AGMG_MUMPS_459(cv_layerl0_end-cv_layerl0_start+1,                 &
     &            cv_layerl0_array(cv_layerl0_start:cv_layerl0_end),    &
     &     cv_layerl0_sorted_costw(cv_layerl0_start:cv_layerl0_end))
      cv_costw_total=cv_costw_layer0
      cv_costm_total=cv_costm_layer0
      istat=0
      return
      end subroutine AGMG_MUMPS_394
      subroutine AGMG_MUMPS_396(istat)
      implicit none
      integer,intent(out)::istat
      integer i,nfront
      character (len=48):: subname
      subname='SELECT_TYPE3'
      CALL AGMG_MUMPS_712(cv_n, slavef, cv_mp, cv_icntl(13),                 &
     &     cv_keep(1), cv_frere, cv_nfsiz, istat)
      IF (istat .NE. 0) THEN
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)                                         &
     &           'Error: Can''t select type 3 node in ',subname
      ELSE IF (cv_keep(38) .ne. 0) then
        IF(cv_nodelayer(cv_keep(38)).eq.0) then
          cv_keep(38)=0
        ELSE
          cv_nodetype(cv_keep(38))=3
        ENDIF
      ENDIF
      RETURN
      end subroutine AGMG_MUMPS_396
      subroutine AGMG_MUMPS_397(istat)
      integer,intent(out)::istat
      integer i,dummy,layernmb,allocok
      character (len=48):: subname
      istat=-1
      subname='SETUP_CAND'
      cv_nb_niv2=0
      do i=1,cv_n
         if(cv_nodetype(i).eq.2) cv_nb_niv2=cv_nb_niv2+1
      end do
      cv_keep(56)=cv_nb_niv2
      nullify(cv_par2_nodes,cv_cand)
      allocate(cv_par2_nodes(cv_nb_niv2),                               &
     &         cv_cand(cv_nb_niv2,cv_slavef+1),STAT=allocok)
      if (allocok.gt.0) then
         cv_info(1) = cv_error_memalloc
         cv_info(2) = cv_nb_niv2*(cv_slavef+2)
         istat = cv_error_memalloc
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)                                            &
     &        'memory allocation error in ',subname
         return
      end if
      cv_par2_nodes=0
      cv_cand(:,:)=0
      dummy=1
      do layernmb=1,cv_maxlayer
         do i=1,cv_layer_p2node(layernmb)%nmb_t2s
            cv_par2_nodes(dummy)=                                       &
     &                  cv_layer_p2node(layernmb)%t2_nodenumbers(i)
            cv_cand(dummy,:)=cv_layer_p2node(layernmb)%t2_cand(i,:)
            dummy=dummy+1
         enddo
      enddo
      if(dummy.ne.cv_nb_niv2+1) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error in ',subname,                        &
     &        ' : dummy =',dummy,'nbniv2 =',cv_nb_niv2
         return
      endif
      istat=0
      return
      end subroutine AGMG_MUMPS_397
      subroutine AGMG_MUMPS_398(map_strat,workload,memused,                  &
     &                       inode,istat)
      implicit none
      integer,intent(in)::map_strat
      DOUBLE PRECISION,dimension(cv_slavef),intent(in)::workload,       &
     &                                                   memused
      integer, optional::inode,istat
      integer i,j,aux_int,nmb_procs,proc,pos
      character (len=48):: subname
      logical enforce_prefsort
      logical use_propmap
      logical,SAVE::init1 = .FALSE.
      logical,SAVE::init2 = .FALSE.
      logical,SAVE::init3 = .FALSE.
      subname='SORTPROCS'
      enforce_prefsort=.TRUE.
      use_propmap=present(inode)
      if(present(istat))istat=-1
      if((map_strat.ne.cv_equilib_flops).and.                           &
     &   (map_strat.ne.cv_equilib_mem)) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'error in ',subname
         return
      endif
      cv_proc_sorted=(/(i,i=1,cv_slavef)/)
      if (.not.present(inode)) then
         if(.NOT.init1) then
            init1=.TRUE.
         end if
         do i=1,cv_slavef-1
            do j=i+1,cv_slavef
               if(((workload(cv_proc_sorted(j)).lt.                     &
     &                     workload(cv_proc_sorted(i))).AND.            &
     &             (map_strat.eq.cv_equilib_flops))                     &
     &            .OR.                                                  &
     &            ((memused(cv_proc_sorted(j)).lt.                      &
     &                     memused(cv_proc_sorted(i))).AND.             &
     &             (map_strat.eq.cv_equilib_mem)))then
                  aux_int=cv_proc_sorted(j)
                  cv_proc_sorted(j)=cv_proc_sorted(i)
                  cv_proc_sorted(i)=aux_int
               end if
            end do
         end do
      else if(present(inode)) then
         if (use_propmap) then
            if(.NOT.init2) then
               init2=.TRUE.
            end if
            nmb_procs=0
            do pos=1,cv_slavef
               if( AGMG_MUMPS_481(inode,pos)) then
                  if (pos.le.nmb_procs) then
                     exit
                  else
                     nmb_procs=nmb_procs+1
                     aux_int=cv_proc_sorted(pos)
                     cv_proc_sorted(pos)=                               &
     &                    cv_proc_sorted(nmb_procs)
                     cv_proc_sorted(nmb_procs)=aux_int
                     cycle
                  end if
               end if
            end do
         end if
         do i=1,nmb_procs-1
            do j=i+1,nmb_procs
               if(((workload(cv_proc_sorted(j)).lt.                     &
     &                     workload(cv_proc_sorted(i))).AND.            &
     &             (map_strat.eq.cv_equilib_flops))                     &
     &            .OR.                                                  &
     &            ((memused(cv_proc_sorted(j)).lt.                      &
     &                     memused(cv_proc_sorted(i))).AND.             &
     &             (map_strat.eq.cv_equilib_mem)))then
                  aux_int=cv_proc_sorted(j)
                  cv_proc_sorted(j)=cv_proc_sorted(i)
                  cv_proc_sorted(i)=aux_int
               end if
            end do
         end do
         do i=nmb_procs+1,cv_slavef-1
            do j=i+1,cv_slavef
               if(((workload(cv_proc_sorted(j)).lt.                     &
     &                     workload(cv_proc_sorted(i))).AND.            &
     &             (map_strat.eq.cv_equilib_flops))                     &
     &            .OR.                                                  &
     &            ((memused(cv_proc_sorted(j)).lt.                      &
     &                     memused(cv_proc_sorted(i))).AND.             &
     &             (map_strat.eq.cv_equilib_mem)))then
                  aux_int=cv_proc_sorted(j)
                  cv_proc_sorted(j)=cv_proc_sorted(i)
                  cv_proc_sorted(i)=aux_int
               end if
            end do
         end do
         if(.NOT.enforce_prefsort) then
            if(((2.0D0*workload(cv_proc_sorted(nmb_procs+1)).lt.        &
     &           workload(cv_proc_sorted(1))).AND.                      &
     &          (map_strat.eq.cv_equilib_flops))                        &
     &         .OR.                                                     &
     &         ((2.0D0*memused(cv_proc_sorted(nmb_procs+1)).lt.         &
     &           memused(cv_proc_sorted(1))).AND.                       &
     &          (map_strat.eq.cv_equilib_mem)))then
               do i=1,cv_slavef-1
                  do j=i+1,cv_slavef
                     if(((workload(cv_proc_sorted(j)).lt.               &
     &                    workload(cv_proc_sorted(i))).AND.             &
     &                    (map_strat.eq.cv_equilib_flops))              &
     &                    .OR.                                          &
     &                    ((memused(cv_proc_sorted(j)).lt.              &
     &                    memused(cv_proc_sorted(i))).AND.              &
     &                    (map_strat.eq.cv_equilib_mem)))then
                        aux_int=cv_proc_sorted(j)
                        cv_proc_sorted(j)=cv_proc_sorted(i)
                        cv_proc_sorted(i)=aux_int
                     end if
                  end do
               end do
            endif
         end if
      endif
      if(present(istat))istat=0
      return
      end subroutine AGMG_MUMPS_398
      subroutine AGMG_MUMPS_400(inode,                                       &
     &                                 doit,npiv,nfront,npiv_son,istat)
      implicit none
      integer,intent(in)::inode
      logical,intent(out)::doit
      integer,intent(out),OPTIONAL::npiv,nfront,npiv_son,istat
      integer in,nfr_ifather,npiv_ifather,npiv2,nfront2,npiv_son2
      doit=.FALSE.
      if(present(npiv)) npiv=cv_invalid
      if(present(nfront)) nfront=cv_invalid
      if(present(npiv_son)) npiv_son=cv_invalid
      if(present(istat)) istat=-1
      if(cv_frere(inode).eq.cv_n+1) return
      doit=.TRUE.
      if ((cv_frere(inode).eq.0).AND.                                   &
     &     ((cv_keep(60).ne.0).OR.(cv_keep(53).le.0))) doit=.FALSE.
      if(cv_nodetype(inode).eq.3) doit=.FALSE.
      nfront2=cv_nfsiz(inode)
      in=inode
      npiv2=0
      do while (in.gt.0)
         in=cv_fils(in)
         npiv2=npiv2+1
      end do
      if(in.eq.0) doit=.FALSE.
      if(cv_total_split.ge.cv_maxcut) doit=.FALSE.
      if(.NOT.any(cv_potsplit.eq.inode)) doit=.FALSE.
      npiv_son2 = max(npiv2/2,1)
      if(npiv2.le.npiv_son2) doit=.FALSE.
      if(.NOT.( AGMG_MUMPS_359(nfront2,npiv_son2)))                          &
     &   doit=.FALSE.
      nfr_ifather=nfront2-npiv_son2
      npiv_ifather=npiv2-npiv_son2
      if(.NOT.                                                          &
     &     ( AGMG_MUMPS_359(nfr_ifather,npiv_ifather)))then
         doit=.FALSE.
      endif
      if ((dble(nfront2)-dble(npiv2)/dble(2)).le.dble(cv_keep(9)))      &
     &   doit=.FALSE.
      if(cv_nsteps.ge.cv_maxnsteps) doit=.FALSE.
      if(.NOT.doit) then
         if(present(npiv)) npiv=cv_invalid
         if(present(nfront)) nfront=cv_invalid
         if(present(npiv_son)) npiv_son=cv_invalid
      else
         if(present(npiv)) npiv=npiv2
         if(present(nfront)) nfront=nfront2
         if(present(npiv_son)) npiv_son=npiv_son2
      endif
      if(present(istat)) istat=0
      end subroutine AGMG_MUMPS_400
      subroutine AGMG_MUMPS_401(inode,nfront,npiv,npiv_son,                  &
     &                              ison,ifather,istat)
      implicit none
      integer, intent(in)::inode,nfront,npiv,npiv_son
      integer,intent(out)::ison,ifather
      integer, intent(out)::istat
      integer i,in,in_son,in_father,in_grandpa
      DOUBLE PRECISION:: ncostm,ncostw,ncostm_ison,ncostw_ison,         &
     &                   ncostm_ifather,ncostw_ifather
      character (len=48):: subname
      istat=-1
      subname='SPLITNODE'
      ison=-1
      ifather=-1
      ncostw=cv_ncostw(inode)
      ncostm=cv_ncostm(inode)
      if((npiv_son.ge.npiv).OR.(npiv.ge.nfront)) return
      ison=inode
      in_son = ison
      do i = 1,npiv_son-1
         in_son = cv_fils(in_son)
         if (in_son.le.0) return
      end do
      ifather = cv_fils(in_son)
      if(ifather.le.0) return
      in_father=ifather
      do while (cv_fils(in_father).gt.0)
         in_father=cv_fils(in_father)
      end do
      cv_nsteps = cv_nsteps + 1
      cv_frere(ifather)=cv_frere(inode)
      cv_frere(ison)=-ifather
      cv_fils(in_son)=cv_fils(in_father)
      cv_fils(in_father)=-ison
      in=cv_frere(ifather)
      do while (in.gt.0)
         in=cv_frere(in)
      end do
      in=-in
      do while(cv_fils(in).gt.0)
         in=cv_fils(in)
      end do
      in_grandpa = in
      if(cv_fils(in_grandpa).eq.-inode) then
         cv_fils(in_grandpa)=-ifather
      else
         in=-cv_fils(in_grandpa)
         do while(cv_frere(in).gt.0)
            if(cv_frere(in).eq.inode) then
               cv_frere(in)=ifather
            else
               in=cv_frere(in)
            end if
         end do
      end if
      cv_last_splitting%new_ison=ison
      cv_last_splitting%new_ifather=ifather
      cv_last_splitting%old_keep2=cv_keep(2)
      cv_last_splitting%ncostw_oldinode=ncostw
      cv_last_splitting%ncostm_oldinode=ncostm
      if(associated(cv_tcostw))                                         &
     &   cv_last_splitting%tcostw_oldinode=cv_tcostw(inode)
      if(associated(cv_tcostm))                                         &
     &   cv_last_splitting%tcostm_oldinode=cv_tcostm(inode)
      cv_nfsiz(ison)=nfront
      cv_nfsiz(ifather)=nfront-npiv_son
      cv_keep(2)=max(cv_keep(2),nfront-npiv_son)
      cv_ne(ifather)=1
      cv_keep(61)=cv_keep(61)+1
      call AGMG_MUMPS_418(npiv_son,nfront,                                   &
     &                            ncostw_ison,ncostm_ison)
      call AGMG_MUMPS_418(npiv-npiv_son,nfront-npiv_son,                     &
     &                            ncostw_ifather,ncostm_ifather)
      cv_ncostw(ison)=ncostw_ison
      cv_ncostm(ison)=ncostm_ison
      cv_ncostw(ifather)=ncostw_ifather
      cv_ncostm(ifather)=ncostm_ifather
      if(associated(cv_tcostw)) cv_tcostw(ison) = cv_tcostw(inode)      &
     &                 -ncostw +cv_ncostw(ison)
      if(associated(cv_tcostm)) cv_tcostm(ison) = cv_tcostm(inode)      &
     &                 -ncostm +cv_ncostm(ison)
      if(associated(cv_tcostw))                                         &
     &   cv_tcostw(ifather) = cv_tcostw(ison)+cv_ncostw(ifather)
      if(associated(cv_tcostm))                                         &
     &   cv_tcostm(ifather) = cv_tcostm(ison)+cv_ncostm(ifather)
      cv_total_split=cv_total_split+1
      call AGMG_MUMPS_437(inode,ifather,ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'PROPMAP4SPLIT error in ',subname
         istat = ierr
         return
      end if
      istat = 0
      return
      end subroutine AGMG_MUMPS_401
      subroutine AGMG_MUMPS_402(ne,nfsiz,frere,fils,keep,KEEP8,              &
     &                                info,procnode,ssarbr,nbsa)
      implicit none
      integer,dimension(cv_n),intent(inout)::ne,nfsiz,frere,fils,       &
     &                                     procnode,ssarbr
      integer, intent(inout):: keep(500),info(40),nbsa
      INTEGER*8 KEEP8(150)
      ne=cv_ne
      nfsiz=cv_nfsiz
      frere=cv_frere
      fils=cv_fils
      keep(2) =cv_keep(2)
      keep(20)=cv_keep(20)
      keep(28)=cv_nsteps
      keep(38)=cv_keep(38)
      keep(56)=cv_keep(56)
      keep(61)=cv_keep(61)
      info(5)=cv_info(5)
      info(6)=cv_nsteps
      procnode=cv_procnode
      ssarbr=cv_ssarbr
      nbsa=cv_nbsa
      end subroutine AGMG_MUMPS_402
      subroutine AGMG_MUMPS_403(istat)
      implicit none
      integer,intent(out)::istat
      integer i,ierr,layernmb
      character (len=48):: subname
      istat=-1
      subname='TERMGLOB'
      if(cv_keep(82) .eq. 0) then
         deallocate(cv_potsplit,STAT=ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'Memory deallocation error in ',subname
            istat = cv_error_memdeloc
            return
         end if
      endif
      nullify(cv_frere,cv_fils,cv_nfsiz,cv_ne,cv_keep,cv_keep8,         &
     &        cv_icntl,cv_info,cv_procnode,cv_ssarbr)
      deallocate(cv_proc_workload,cv_proc_maxwork,cv_proc_memused,      &
     &    cv_proc_maxmem,cv_nodetype,                                   &
     &    cv_nodelayer,cv_proc_sorted,                                  &
     &    cv_ncostw,cv_ncostm,                                          &
     &    cv_layerworkload,cv_layermemused,                             &
     &    STAT=ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Memory deallocation error in ',subname
         istat = cv_error_memdeloc
         return
      end if
      deallocate(work_per_proc,id_son,STAT=ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Memory deallocation error in ',subname
         istat = cv_error_memdeloc
         return
      end if
      do layernmb=1,cv_maxlayer
         if(cv_layer_p2node(layernmb)%nmb_t2s.gt.0) then
            deallocate(cv_layer_p2node(layernmb)%t2_nodenumbers,        &
     &                 cv_layer_p2node(layernmb)%t2_cand,               &
     &                 cv_layer_p2node(layernmb)%t2_candcostw,          &
     &                 cv_layer_p2node(layernmb)%t2_candcostm,          &
     &                 STAT=ierr)
            if(ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Memory deallocation error in ',           &
     &                        subname
               istat = cv_error_memdeloc
               return
            end if
         endif
      enddo
      if(associated(cv_layer_p2node)) then
         deallocate(cv_layer_p2node,STAT=ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &      write(cv_lp,*)'Memory deallocation error in ',subname
            istat = cv_error_memdeloc
            return
         end if
      end if
      do i=1,cv_n
         call AGMG_MUMPS_435(i,ierr)
         if(ierr.ne.0) then
            if(cv_lp.gt.0)                                              &
     &           write(cv_lp,*)'PROPMAP_TERM signalled error in ',      &
     &           subname
            istat = ierr
            return
         end if
      end do
      if(associated(cv_prop_map))deallocate(cv_prop_map,STAT=ierr)
      if(ierr.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Memory deallocation error in ',subname
         istat = cv_error_memdeloc
         return
      end if
      istat=0
      return
      end subroutine AGMG_MUMPS_403
      recursive subroutine AGMG_MUMPS_404(pos,istat)
      implicit none
      integer,intent(in)::pos
      integer, intent(out)::istat
      integer i,nfront,npiv,nextpos,ierr
      DOUBLE PRECISION costw,costm
      character (len=48):: subname
      istat=-1
      subname='TREECOSTS'
      if ((.NOT.associated(cv_tcostw)).OR.(.NOT.associated(cv_tcostm))) &
     &   then
         if(cv_lp.gt.0)                                                 &
     &        write(cv_lp,*)'Error:tcost must be allocated in ',subname
         return
      end if
      nfront=cv_nfsiz(pos)
      npiv=1
      nextpos=cv_fils(pos)
      do
         if(nextpos.le.0) then
            exit
         else
            npiv=npiv+1
            nextpos=cv_fils(nextpos)
         end if
      end do
      call AGMG_MUMPS_418(npiv,nfront,costw,costm)
      cv_ncostw(pos)=costw
      cv_ncostm(pos)=costm
      if (cv_ne(pos).ne.0) then
         nextpos=cv_fils(pos)
         do while(nextpos.gt.0)
            nextpos=cv_fils(nextpos)
         end do
         nextpos=-nextpos
         do i=1,cv_ne(pos)
            cv_depth(nextpos)=cv_depth(pos)+1
            call AGMG_MUMPS_404(nextpos,ierr)
            if (ierr.ne.0) then
               if(cv_lp.gt.0)                                           &
     &         write(cv_lp,*)'Failure in recursive call to ',subname
               return
            end if
            costw=costw+cv_tcostw(nextpos)
            costm=costm+cv_tcostm(nextpos)
            nextpos=cv_frere(nextpos)
         end do
      endif
      cv_tcostw(pos) = costw
      cv_tcostm(pos) = costm
      istat = 0
      end subroutine AGMG_MUMPS_404
      recursive subroutine AGMG_MUMPS_406(inode)
      implicit none
      integer, intent(in)::inode
      integer in
      cv_nodetype(inode)=-1
      in=cv_fils(inode)
      do while (in>0)
         in=cv_fils(in)
      end do
      in=-in
      do while(in.gt.0)
         call AGMG_MUMPS_406(in)
         in=cv_frere(in)
      enddo
      end subroutine AGMG_MUMPS_406
      subroutine AGMG_MUMPS_408(workload,memused,                            &
     &                                    maxwork,minwork,maxmem,minmem)
      implicit none
      DOUBLE PRECISION,dimension(cv_slavef),intent(in)::workload,       &
     &                                                  memused
      DOUBLE PRECISION,intent(out)::maxwork,minwork,maxmem,minmem
      intrinsic maxval,minval
      maxwork=maxval(workload)
      minwork=minval(workload, mask= workload > dble(0))
      maxmem=maxval(memused)
      minmem=minval(memused, mask= memused > dble(0))
      end subroutine AGMG_MUMPS_408
      subroutine AGMG_MUMPS_476(layernumber,nodenumber)
      implicit none
      integer layernumber,nodenumber
      integer i
      integer inode
      integer current_max,current_proc
      current_max = 0
      score = 0
      allowed_nodes = .FALSE.
      inode=cv_layer_p2node(layernumber)%t2_nodenumbers(nodenumber)
      do i=1,cv_layer_p2node(layernumber)%t2_cand(nodenumber,           &
     &     cv_slavef+1)
         current_proc=cv_layer_p2node(layernumber)%t2_cand(nodenumber,i)
         if ( current_proc .ge. 0) then
            score(mem_distribmpi(current_proc)) =                       &
     &           score(mem_distribmpi(current_proc)) + 1
         endif
      enddo
      current_proc = cv_procnode(inode) - 1
      score(mem_distribmpi(current_proc)) =                             &
     &     score(mem_distribmpi(current_proc)) + 1
      do i=0,nb_arch_nodes - 1
         if ( score(i) .gt. current_max ) then
            current_max = score(i)
            allowed_nodes = .FALSE.
            allowed_nodes(i) = .TRUE.
         else
            if(score(i) .eq. current_max) then
               allowed_nodes(i) = .TRUE.
            endif
         endif
      enddo
      return
      end subroutine AGMG_MUMPS_476
      end subroutine AGMG_MUMPS_369
      subroutine AGMG_MUMPS_393(par2_nodes,cand,istat)
      integer, intent(out)::par2_nodes(cv_nb_niv2),                     &
     &                      cand(cv_slavef+1,cv_nb_niv2),istat
      character (len=48):: subname
      integer iloop
      istat=-1
      subname='MUMPS_393'
      par2_nodes=cv_par2_nodes
      do iloop=1, cv_slavef+1
        cand(iloop,:)=cv_cand(:,iloop)
      enddo
      deallocate(cv_par2_nodes,cv_cand,STAT=istat)
      if(istat.ne.0) then
         if(cv_lp.gt.0)                                                 &
     &   write(cv_lp,*)'Memory deallocation error in ',subname
         istat = cv_error_memdeloc
         return
      end if
      istat = 0
      return
      end subroutine AGMG_MUMPS_393
      subroutine AGMG_MUMPS_427(                                             &
     &     total_comm,working_comm,keep69,par,                          &
     &     nbslaves,mem_distrib,informerr)
      implicit none
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      integer nbslaves
      integer, dimension(0:nbslaves-1) :: mem_distrib
      integer total_comm,working_comm,keep69,par
      integer, dimension(40) ::informerr
      integer myrank
      integer host,i,ierr
      integer,dimension(:),allocatable :: buffer_memdistrib
      ierr = 0
      myrank = -1
      host = -1
      ke69 = keep69
      cv_slavef = nbslaves
      if (ke69 .eq. 1) then
         return
      endif
      if ( allocated(mem_distribtmp) ) deallocate(mem_distribtmp )
      allocate( mem_distribtmp( 0:cv_slavef-1 ),                        &
     &          buffer_memdistrib( 0:cv_slavef-1 ), stat=ierr )
      if ( ierr .gt. 0 ) then
         if(cv_mp.gt.0) write(cv_mp,*) 'pb allocation mem_dist'
         informerr(1) = -13
         informerr(2) = cv_slavef
         return
      end if
      mem_distribtmp = -1
      call AGMG_SETIERR2( host, ierr )
      if ((par .eq. 1) .or. (host .ne. 0)) then
         call AGMG_SETIERR2( myrank, ierr )
         call AGMG_MUMPS_430(ierr,myrank,                                    &
     &        working_comm,mem_distrib(0))
         if ( ierr .ne. 0 ) then
            if(cv_mp.gt.0)                                              &
     &      write(cv_mp,*) 'pb in mumps_init_arch_parameters'
            informerr(1) = -13
            informerr(2) = cv_slavef
            return
         end if
         mem_distribtmp = mem_distrib
         call AGMG_MUMPS_429(ierr)
         if ( ierr .ne. 0 ) then
            if(cv_mp.gt.0) write(cv_mp,*)                               &
     &'pb in mumps_init_arch_parameters'
            informerr(1) = -13
            informerr(2) = cv_slavef
            return
         endif
      endif
      if(ke69 .le. 0) then
         deallocate(mem_distribtmp)
         deallocate(buffer_memdistrib)
         return
      endif
      call AGMG_COPY(mem_distribtmp(0),buffer_memdistrib(0),                     cv_slavef,AGMG_MPF_INTEGER,ierr)
      mem_distribtmp = buffer_memdistrib
      deallocate (buffer_memdistrib)
      call AGMG_MUMPS_492()
        if((cv_slavef/nb_arch_nodes) .le. 4) then
          do i = 0, cv_slavef-1
            if ( mem_distrib(i) .NE. 1 ) then
              mem_distrib(i)=max(ke69/2,2)
            endif
          enddo
        endif
        if((nb_arch_nodes .eq. 1) .or.                                  &
     &     (nb_arch_nodes .eq. cv_slavef)) then
         ke69 = 1
         keep69 = 1
         deallocate(mem_distribtmp)
         return
      endif
      if (host .eq. 0) then
         if ( allocated(mem_distribmpi) ) deallocate(mem_distribmpi )
         allocate( mem_distribmpi( 0:cv_slavef-1 ), stat=ierr )
         if ( ierr .gt. 0 ) then
            if(cv_mp.gt.0) write(cv_mp,*) 'pb allocation mem_dist'
            informerr(1) = -13
            informerr(2) = cv_slavef
            return
         endif
         call AGMG_MUMPS_495(ierr)
         if(ierr .ne. 0 ) then
            return
         endif
         mem_distribmpi = mem_distribtmp
         call AGMG_MUMPS_428(ierr)
         if ( ierr .ne. 0 ) then
            if(cv_mp.gt.0)                                              &
     &      write(cv_mp,*) 'pb in mumps_init_arch_parameters'
            informerr(1) = -13
            informerr(2) = cv_slavef
            return
         endif
      else
         deallocate(mem_distribtmp)
      endif
      return
      end subroutine AGMG_MUMPS_427
      subroutine AGMG_MUMPS_492()
      implicit none
      integer i
      nb_arch_nodes = 0
      do i=0,cv_slavef-1
         if(mem_distribtmp(i) .eq. i) then
            nb_arch_nodes = nb_arch_nodes + 1
         endif
      enddo
      return
      end subroutine AGMG_MUMPS_492
      subroutine AGMG_MUMPS_428(ierr)
      implicit none
      external AGMG_MUMPS_463
      integer i,precnode,nodecount
      integer sizesmp
      integer ierr
      ierr = 0
      sizesmp = 0
      if ( allocated(table_of_process) )                                &
     &     deallocate(table_of_process  )
      allocate( table_of_process(0:cv_slavef-1), stat=ierr )
      if ( ierr .gt. 0 ) then
         if(cv_mp.gt.0) write(cv_mp,*)                                  &
     &   'pb allocation in MUMPS_428'
         return
      end if
      do i=0,cv_slavef - 1
         table_of_process(i) = i
      enddo
      call AGMG_MUMPS_463(cv_slavef,mem_distribtmp(0),                       &
     &     table_of_process(0))
      precnode = 0
      nodecount = 0
      do i=0,cv_slavef-1
         if(mem_distribtmp(i) .eq. precnode) then
            sizesmp = sizesmp + 1
            mem_distribtmp(i) = nodecount
            mem_distribmpi(table_of_process(i)) = nodecount
         else
            score(nodecount) = sizesmp
            sizesmp = 1
            nodecount = nodecount + 1
            precnode = mem_distribtmp(i)
            mem_distribtmp(i) = nodecount
            mem_distribmpi(table_of_process(i)) = nodecount
         endif
      enddo
      score(nodecount) = sizesmp
      do i=0,cv_slavef-1
         mem_distribtmp(i) = score(mem_distribtmp(i))
      enddo
      CALL AGMG_MUMPS_466(cv_slavef,mem_distribtmp(0),                       &
     &     table_of_process(0))
      ierr = 0
      return
      end subroutine AGMG_MUMPS_428
      subroutine AGMG_MUMPS_429(ierr)
      implicit none
      integer i,j,ierr
      integer idmaster
      idmaster = -1
      ierr = 0
      do i=0,cv_slavef-1
         if (mem_distribtmp(i) .eq. 1) then
            idmaster = i
            do j=i,cv_slavef-1
               if (mem_distribtmp(j) .eq. 1) then
                  mem_distribtmp(j) = idmaster
               else
                  mem_distribtmp(j) = 0
               endif
            enddo
            return
         else
            mem_distribtmp(i) = 0
         endif
      enddo
      if(cv_mp.gt.0) write(cv_mp,*)'problem in MUMPS_429:               &
     &     cannot find a master'
      ierr = 1
      return
      end subroutine AGMG_MUMPS_429
      subroutine AGMG_MUMPS_430(ierr,myrank,working_comm,                    &
     &     mem_distrib)
      implicit none
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      integer ierr,resultlen,myrank,i,working_comm
      integer , dimension(0:cv_slavef-1) :: mem_distrib
      integer allocok
      character(len=AGMG_MPF_MAX_PROCESSOR_NAME) name
      integer, dimension(:),allocatable :: namercv
      integer, dimension(:),allocatable :: myname
      integer lenrcv
      external AGMG_MUMPS_438
      logical AGMG_MUMPS_438
      ierr = 0
      call AGMG_MPF_get_processor_name(name,resultlen,ierr)
      allocate(myname(resultlen),stat=allocok)
      if ( allocok .gt. 0 ) then
        if(cv_mp.gt.0) write(cv_mp,*)                                   &
     &  'pb allocation in compute_dist for myname'
        ierr = 1
        return
      end if
      do i=1, resultlen
         myname(i) = ichar(name(i:i))
      enddo
      do i=0, cv_slavef-1
         if(myrank .eq. i) then
            lenrcv = resultlen
         else
            lenrcv = 0
         endif
         call AGMG_SETIERR(ierr)
         allocate(namercv(lenrcv),stat=allocok)
         if ( allocok .gt. 0 ) then
            if(cv_mp.gt.0) write(cv_mp,*)                               &
     &      'pb allocation in compute_dist for namercv'
            ierr = 1
            return
         end if
         if(myrank .eq. i) then
            namercv = myname
         endif
         call AGMG_SETIERR(ierr)
         if( AGMG_MUMPS_438(myname,namercv,                                  &
     &        resultlen,lenrcv)) then
            mem_distrib(i)=1
         else
            mem_distrib(i)=ke69
         endif
         deallocate(namercv)
      enddo
      deallocate(myname)
      ierr = 0
      return
      end subroutine AGMG_MUMPS_430
      subroutine AGMG_MUMPS_493(current_proc,idarch,ierr)
      implicit none
      integer current_proc
      integer idarch,ierr
      ierr = 0
      if (current_proc .ge. cv_slavef) then
         ierr = -1
         return
      endif
      if (current_proc .lt. 0) then
         idarch = 1
         return
      else
         idarch = table_of_process(current_proc) + 1
      endif
      return
      end subroutine AGMG_MUMPS_493
      subroutine AGMG_MUMPS_494()
      if (allocated(table_of_process)) deallocate(table_of_process)
      if (allocated(allowed_nodes)) deallocate(allowed_nodes)
      if (allocated(score)) deallocate(score)
      if (allocated(mem_distribtmp)) deallocate(mem_distribtmp)
      if (allocated(mem_distribmpi)) deallocate(mem_distribmpi)
      return
      end subroutine AGMG_MUMPS_494
      subroutine AGMG_MUMPS_495(ierr)
      integer ierr
      ierr = 0
      if (allocated(allowed_nodes)) deallocate(allowed_nodes)
      allocate( allowed_nodes(0:nb_arch_nodes-1),stat=ierr)
      if ( ierr .gt. 0 ) then
         if(cv_mp.gt.0) write(cv_mp,*)                                  &
     &   'pb allocation MUMPS_495'
         ierr = -13
         return
      end if
      allowed_nodes = .FALSE.
       if (allocated(score)) deallocate(score)
      allocate( score(0:nb_arch_nodes-1),stat=ierr)
      if ( ierr .gt. 0 ) then
         if(cv_mp.gt.0) write(cv_mp,*)                                  &
     &   'pb allocation MUMPS_495'
         ierr = -13
         return
      end if
      score = 0
      ierr = 0
      return
      end subroutine AGMG_MUMPS_495
      subroutine AGMG_MUMPS_496(idproc,thenode)
      implicit none
      integer idproc,thenode
      thenode = mem_distribmpi(idproc)
      return
      end subroutine AGMG_MUMPS_496
      SUBROUTINE AGMG_MUMPS_516(start1st,end1st,dim1,                        &
     &                             start2nd,end2nd,dim2,                &
     &                             indx,                                &
     &                             val)
      implicit none
      integer, intent(in):: start1st,end1st,dim1,start2nd,end2nd,dim2
      integer, intent(inout):: indx(end2nd)
      DOUBLE PRECISION, intent(inout):: val(end2nd)
      integer::index(dim1+dim2)
      DOUBLE PRECISION ::dummy1(dim1+dim2)
      integer:: a,b,c
      a=start1st
      b=start2nd
      c=1
      do while((a.LT.end1st+1).AND.(b.LT.end2nd+1))
         if(val(a).GT.val(b))then
            index(c)=indx(a)
            dummy1(c)=val(a)
            a=a+1
            c=c+1
         else
            index(c)=indx(b)
            dummy1(c)=val(b)
            b=b+1
            c=c+1
         endif
      end do
      if(a.LT.end1st+1) then
         do while(a.LT.end1st+1)
            index(c)=indx(a)
            dummy1(c)=val(a)
            a=a+1
            c=c+1
         enddo
      elseif(b.LT.end2nd+1) then
         do while(b.LT.end2nd+1)
            index(c)=indx(b)
            dummy1(c)=val(b)
            b=b+1
            c=c+1
         enddo
      endif
      indx(start1st:end1st)=index(1:dim1)
      val(start1st:end1st)=dummy1(1:dim1)
      indx(start2nd:end2nd)=index(dim1+1:dim1+dim2)
      val(start2nd:end2nd)=dummy1(dim1+1:dim1+dim2)
      end SUBROUTINE AGMG_MUMPS_516
      SUBROUTINE AGMG_MUMPS_459(dim,indx,val1,val2)
      implicit none
      integer, intent(in):: dim
      integer, intent(inout):: indx(dim)
      DOUBLE PRECISION, intent(inout):: val1(dim)
      DOUBLE PRECISION, intent(inout),optional:: val2(dim)
      integer::index(dim),dummy1(dim)
      DOUBLE PRECISION ::dummy2(dim)
      integer, parameter :: ss = 35
      integer:: a,b,c,i,j,k,l,r,s,stackl(ss),stackr(ss)
      DOUBLE PRECISION :: w,x
      do i=1,dim
         index(i)=i
      enddo
      s = 1
      stackl(1) = 1
      stackr(1) = dim
 5511 CONTINUE
      l = stackl(s)
      r = stackr(s)
      k = (l+r) / 2
      if(l.LT.k) then
         if(s.GE.ss) stop 'maxsize of stack reached'
         s = s + 1
         stackl(s) = l
         stackr(s) = k
         goto 5511
      endif
 5512 CONTINUE
      l = stackl(s)
      r = stackr(s)
      k = (l+r) / 2
      if(k+1.LT.r) then
         if(s.GE.ss) stop 'maxsize of stack reached'
         s = s + 1
         stackl(s) = k+1
         stackr(s) = r
         goto 5511
      endif
 5513 CONTINUE
      l = stackl(s)
      r = stackr(s)
      k = (l+r) / 2
      a=l
      b=k+1
      c=1
      do while((a.LT.k+1).AND.(b.LT.r+1))
         if(val1(index(a)).GT.val1(index(b)))then
            dummy1(c)=index(a)
            a=a+1
            c=c+1
         else
            dummy1(c)=index(b)
            b=b+1
            c=c+1
         endif
      end do
      if(a.LT.k+1) then
         dummy1(c:r-l+1)=index(a:k)
      elseif(b.LT.r+1) then
         dummy1(c:r-l+1)=index(b:r)
      endif
      index(l:r)=dummy1(1:r-l+1)
      if(s.GT.1) then
         s = s - 1
         if(l.EQ.stackl(s)) goto 5512
         if(r.EQ.stackr(s)) goto 5513
      endif
      do i=1,dim
         dummy1(i)=indx(index(i))
      enddo
      indx=dummy1
      do i=1,dim
         dummy2(i)=val1(index(i))
      enddo
      val1=dummy2
      if(present(val2)) then
         do i=1,dim
            dummy2(i)=val2(index(i))
         enddo
         val2=dummy2
      endif
      return
      end subroutine AGMG_MUMPS_459
      END MODULE AGMG_MUMPS_STATIC_MAPPING
      SUBROUTINE AGMG_MUMPS_712(N, SLAVEF, MP,                               &
     &                   ICNTL13, KEEP, FRERE, ND, ISTAT)
      IMPLICIT NONE
      INTEGER, intent(in) :: N, SLAVEF, ICNTL13, MP
      INTEGER KEEP(150)
      INTEGER FRERE(N), ND(N)
      INTEGER, intent(out) :: ISTAT
      INTEGER IROOTTREE, SIZEROOT, NFRONT, I
      ISTAT = 0
      IF (KEEP(60).EQ.2 .or. KEEP(60).EQ.3 ) THEN
      ELSE
        IF((SLAVEF.EQ.1).OR.(ICNTL13.GT.0).OR.                          &
     &     (KEEP(60).NE.0)) THEN
          KEEP(38) = 0
        ELSE
         IROOTTREE=-1
         SIZEROOT=-1
         DO I=1,N
            IF (FRERE(I).EQ.0) THEN
               NFRONT = ND(I)
               IF (NFRONT .GT.SIZEROOT) THEN
                  IROOTTREE = I
                  SIZEROOT  = NFRONT
               END IF
            END IF
         END DO
         IF ((IROOTTREE.EQ.-1).OR.(SIZEROOT.EQ.-1)) THEN
            ISTAT = -1
            RETURN
         ENDIF
         IF (SIZEROOT.LE.SLAVEF) THEN
            KEEP(38) = 0
         ELSE IF((SIZEROOT.GT.KEEP(37))                                 &
     &           .AND. (KEEP(53).EQ.0)                                  &
     &           ) THEN
            IF (MP.GT.0) WRITE(MP,*) 'A root of estimated size ',       &
     &           SIZEROOT,' has been selected for Scalapack.'
            KEEP(38) = IROOTTREE
         ELSE
            KEEP(38) = 0
             IF (MP.GT.0) WRITE(MP,*)                                   &
     &          ' WARNING: Largest root node of size ', SIZEROOT,       &
     &          ' not selected for parallel execution'
         END IF
         IF ((KEEP(38).EQ.0).AND.(KEEP(53).NE.0)) THEN
            KEEP(20) = IROOTTREE
         ELSE IF (KEEP(60).EQ.0) THEN
            KEEP(20) = 0
         ENDIF
       ENDIF
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_712
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE DAGMG_MUMPS_OOC_BUFFER
      USE AGMG_MUMPS_OOC_COMMON
      IMPLICIT NONE
      PUBLIC
      INTEGER FIRST_HBUF,SECOND_HBUF
      PARAMETER (FIRST_HBUF=0, SECOND_HBUF=1)
      INTEGER,SAVE :: OOC_FCT_TYPE_LOC
      INTEGER TYPEF_L_LOC,TYPEF_U_LOC
      PARAMETER ( TYPEF_L_LOC=1, TYPEF_U_LOC=2 )
      INTEGER IO_STRAT
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: BUF_IO
      LOGICAL,SAVE :: PANEL_FLAG
      INTEGER,SAVE :: EARLIEST_WRITE_MIN_SIZE
      INTEGER(8),SAVE,DIMENSION(:), ALLOCATABLE ::                      &
     &  I_SHIFT_FIRST_HBUF, I_SHIFT_SECOND_HBUF,                        &
     &  I_SHIFT_CUR_HBUF, I_REL_POS_CUR_HBUF
      INTEGER, SAVE, DIMENSION(:), ALLOCATABLE ::                       &
     &  LAST_IOREQUEST, CUR_HBUF
      INTEGER, DIMENSION(:),ALLOCATABLE :: I_CUR_HBUF_NEXTPOS
      INTEGER,SAVE ::  I_CUR_HBUF_FSTPOS,                               &
     &  I_SUB_HBUF_FSTPOS
      INTEGER(8) :: BufferEmpty
      PARAMETER (BufferEmpty=-1_8)
      INTEGER*8, DIMENSION(:),ALLOCATABLE :: NextAddVirtBuffer
      INTEGER*8, DIMENSION(:),ALLOCATABLE :: FIRST_VADDR_IN_BUF
      CONTAINS
      SUBROUTINE DAGMG_MUMPS_689(TYPEF_ARG)
      IMPLICIT NONE
      INTEGER TYPEF_ARG
      SELECT CASE(CUR_HBUF(TYPEF_ARG))
         CASE (FIRST_HBUF)
            CUR_HBUF(TYPEF_ARG) = SECOND_HBUF
            I_SHIFT_CUR_HBUF(TYPEF_ARG) =                               &
     &           I_SHIFT_SECOND_HBUF(TYPEF_ARG)
         CASE (SECOND_HBUF)
            CUR_HBUF(TYPEF_ARG) = FIRST_HBUF
            I_SHIFT_CUR_HBUF(TYPEF_ARG) =                               &
     &           I_SHIFT_FIRST_HBUF(TYPEF_ARG)
      END SELECT
      IF(.NOT.PANEL_FLAG)THEN
         I_SUB_HBUF_FSTPOS =I_CUR_HBUF_FSTPOS
         I_CUR_HBUF_FSTPOS =I_CUR_HBUF_NEXTPOS(TYPEF_ARG)
      ENDIF
      I_REL_POS_CUR_HBUF(TYPEF_ARG) = 1_8
      RETURN
      END SUBROUTINE DAGMG_MUMPS_689
      SUBROUTINE DAGMG_MUMPS_707(TYPEF_ARG,IERR)
      IMPLICIT NONE
      INTEGER TYPEF_ARG
      INTEGER NEW_IOREQUEST
      INTEGER IERR
      IERR=0
      CALL DAGMG_MUMPS_696(TYPEF_ARG,NEW_IOREQUEST,                          &
     &     IERR)
      IF(IERR.LT.0)THEN
         RETURN
      ENDIF
      IERR=0
      CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
      IF(IERR.LT.0)THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ENDIF
      LAST_IOREQUEST(TYPEF_ARG) = NEW_IOREQUEST
      CALL DAGMG_MUMPS_689(TYPEF_ARG)
      IF(PANEL_FLAG)THEN
         NextAddVirtBuffer(TYPEF_ARG)=BufferEmpty
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_707
      SUBROUTINE DAGMG_MUMPS_675(IERR)
      IMPLICIT NONE
      INTEGER, intent(out) :: IERR
      INTEGER TYPEF_LAST
      INTEGER TYPEF_LOC
      IERR = 0
      TYPEF_LAST = OOC_FCT_TYPE_LOC
      DO TYPEF_LOC = 1, OOC_FCT_TYPE_LOC
         IERR=0
         CALL  DAGMG_MUMPS_707(TYPEF_LOC,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
         IERR=0
         CALL DAGMG_MUMPS_707(TYPEF_LOC,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_675
      SUBROUTINE DAGMG_MUMPS_696(TYPEF_ARG,IOREQUEST,                        &
     &     IERR)
      IMPLICIT NONE
      INTEGER IOREQUEST,IERR
      INTEGER TYPEF_ARG
      INTEGER TOTAL_SIZE,FIRST_INODE
      INTEGER(8) :: FROM_BUFIO_POS, SIZE
      INTEGER TYPE
      INTEGER ADDR_INT1,ADDR_INT2
      INTEGER*8 TMP_VADDR
      INTEGER SIZE_INT1,SIZE_INT2
      IERR=0
      IF (I_REL_POS_CUR_HBUF(TYPEF_ARG) == 1_8) THEN
        IOREQUEST=-1
        RETURN
      END IF
      IF(PANEL_FLAG)THEN
         TYPE=TYPEF_ARG-1
         FIRST_INODE=-9999
         TMP_VADDR=FIRST_VADDR_IN_BUF(TYPEF_ARG)
      ELSE
         TYPE=FCT
         FIRST_INODE =                                                  &
     &        OOC_INODE_SEQUENCE(I_CUR_HBUF_FSTPOS,TYPEF_ARG)
         TMP_VADDR=OOC_VADDR(STEP_OOC(FIRST_INODE),TYPEF_ARG)
      ENDIF
      FROM_BUFIO_POS=I_SHIFT_CUR_HBUF(TYPEF_ARG)+1_8
      SIZE = I_REL_POS_CUR_HBUF(TYPEF_ARG)-1_8
      CALL AGMG_MUMPS_677(ADDR_INT1,ADDR_INT2,                               &
     &     TMP_VADDR)
      CALL AGMG_MUMPS_677(SIZE_INT1,SIZE_INT2,                               &
     &     SIZE)
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_WRITE_OOC_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_696
      SUBROUTINE DAGMG_MUMPS_669(I1,I2,IERR)
      IMPLICIT NONE
      INTEGER I1,I2,IERR
      INTEGER allocok
      IERR=0
      PANEL_FLAG=.FALSE.
      IF(allocated(I_SHIFT_FIRST_HBUF))THEN
         DEALLOCATE(I_SHIFT_FIRST_HBUF)
      ENDIF
      IF(allocated(I_SHIFT_SECOND_HBUF))THEN
         DEALLOCATE(I_SHIFT_SECOND_HBUF)
      ENDIF
      IF(allocated(I_SHIFT_CUR_HBUF))THEN
         DEALLOCATE(I_SHIFT_CUR_HBUF)
      ENDIF
      IF(allocated(I_REL_POS_CUR_HBUF))THEN
         DEALLOCATE(I_REL_POS_CUR_HBUF)
      ENDIF
      IF(allocated(LAST_IOREQUEST))THEN
         DEALLOCATE(LAST_IOREQUEST)
      ENDIF
      IF(allocated(CUR_HBUF))THEN
         DEALLOCATE(CUR_HBUF)
      ENDIF
      DIM_BUF_IO = int(KEEP_OOC(100),8)
      ALLOCATE(I_SHIFT_FIRST_HBUF(OOC_NB_FILE_TYPE),                    &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      ALLOCATE(I_SHIFT_SECOND_HBUF(OOC_NB_FILE_TYPE),                   &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      ALLOCATE(I_SHIFT_CUR_HBUF(OOC_NB_FILE_TYPE),                      &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      ALLOCATE(I_REL_POS_CUR_HBUF(OOC_NB_FILE_TYPE),                    &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      ALLOCATE(LAST_IOREQUEST(OOC_NB_FILE_TYPE),                        &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      ALLOCATE(CUR_HBUF(OOC_NB_FILE_TYPE),                              &
     &     stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         I2 = OOC_NB_FILE_TYPE
         IERR=-1
         RETURN
      ENDIF
      OOC_FCT_TYPE_LOC=OOC_NB_FILE_TYPE
      ALLOCATE(BUF_IO(DIM_BUF_IO), stat=allocok)
      IF (allocok > 0) THEN
         IF (ICNTL1>0)                                                  &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         I1 = -13
         CALL AGMG_MUMPS_731(DIM_BUF_IO, I2)
         RETURN
      ENDIF
      PANEL_FLAG=(KEEP_OOC(201).EQ.1)
      IF (PANEL_FLAG) THEN
         IERR=0
         KEEP_OOC(228)=0
         IF(allocated(AddVirtLibre))THEN
            DEALLOCATE(AddVirtLibre)
         ENDIF
         ALLOCATE(AddVirtLibre(OOC_NB_FILE_TYPE), stat=allocok)
         IF (allocok > 0) THEN
            IF (ICNTL1>0)                                               &
     &      WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC_BUF_PANEL'
            IERR=-1
            I1=-13
            I2=OOC_NB_FILE_TYPE
            RETURN
         ENDIF
         AddVirtLibre(1:OOC_NB_FILE_TYPE)=0_8
         IF(allocated(NextAddVirtBuffer))THEN
            DEALLOCATE(NextAddVirtBuffer)
         ENDIF
         ALLOCATE(NextAddVirtBuffer(OOC_NB_FILE_TYPE), stat=allocok)
         IF (allocok > 0) THEN
            IF (ICNTL1>0)                                               &
     &      WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC_BUF_PANEL'
            IERR=-1
            I1=-13
            I2=OOC_NB_FILE_TYPE
            RETURN
         ENDIF
         NextAddVirtBuffer (1:OOC_NB_FILE_TYPE)  = BufferEmpty
         IF(allocated(FIRST_VADDR_IN_BUF))THEN
            DEALLOCATE(FIRST_VADDR_IN_BUF)
         ENDIF
         ALLOCATE(FIRST_VADDR_IN_BUF(OOC_NB_FILE_TYPE), stat=allocok)
         IF (allocok > 0) THEN
            IF (ICNTL1>0)                                               &
     &      WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC_BUF_PANEL'
            IERR=-1
            I1=-13
            I2=OOC_NB_FILE_TYPE
            RETURN
         ENDIF
         CALL DAGMG_MUMPS_686()
      ELSE
         CALL DAGMG_MUMPS_685()
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_669
      SUBROUTINE DAGMG_MUMPS_659()
      IMPLICIT NONE
      IF(allocated(BUF_IO))THEN
         DEALLOCATE(BUF_IO)
      ENDIF
      IF(allocated(I_SHIFT_FIRST_HBUF))THEN
         DEALLOCATE(I_SHIFT_FIRST_HBUF)
      ENDIF
      IF(allocated(I_SHIFT_SECOND_HBUF))THEN
         DEALLOCATE(I_SHIFT_SECOND_HBUF)
      ENDIF
      IF(allocated(I_SHIFT_CUR_HBUF))THEN
         DEALLOCATE(I_SHIFT_CUR_HBUF)
      ENDIF
      IF(allocated(I_REL_POS_CUR_HBUF))THEN
         DEALLOCATE(I_REL_POS_CUR_HBUF)
      ENDIF
      IF(allocated(LAST_IOREQUEST))THEN
         DEALLOCATE(LAST_IOREQUEST)
      ENDIF
      IF(allocated(CUR_HBUF))THEN
         DEALLOCATE(CUR_HBUF)
      ENDIF
      IF(PANEL_FLAG)THEN
         IF(allocated(NextAddVirtBuffer))THEN
            DEALLOCATE(NextAddVirtBuffer)
         ENDIF
         IF(allocated(AddVirtLibre))THEN
            DEALLOCATE(AddVirtLibre)
         ENDIF
         IF(allocated(FIRST_VADDR_IN_BUF))THEN
            DEALLOCATE(FIRST_VADDR_IN_BUF)
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_659
      SUBROUTINE DAGMG_MUMPS_685()
      IMPLICIT NONE
      OOC_FCT_TYPE_LOC=1
      HBUF_SIZE = DIM_BUF_IO / int(2,kind=kind(DIM_BUF_IO))
      EARLIEST_WRITE_MIN_SIZE = 0
      I_SHIFT_FIRST_HBUF(OOC_FCT_TYPE_LOC) = 0_8
      I_SHIFT_SECOND_HBUF(OOC_FCT_TYPE_LOC) = HBUF_SIZE
      LAST_IOREQUEST(OOC_FCT_TYPE_LOC) = -1
      I_CUR_HBUF_NEXTPOS = 1
      I_CUR_HBUF_FSTPOS = 1
      I_SUB_HBUF_FSTPOS = 1
      CUR_HBUF(OOC_FCT_TYPE_LOC) = SECOND_HBUF
      CALL DAGMG_MUMPS_689(OOC_FCT_TYPE_LOC)
      END SUBROUTINE DAGMG_MUMPS_685
      SUBROUTINE DAGMG_MUMPS_678(BLOCK,SIZE_OF_BLOCK,                        &
     &     IERR)
      IMPLICIT NONE
      INTEGER(8) :: SIZE_OF_BLOCK
      DOUBLE PRECISION BLOCK(SIZE_OF_BLOCK)
      INTEGER SIZE
      INTEGER, intent(out) :: IERR
      INTEGER(8) :: I
      IERR=0
      IF (I_REL_POS_CUR_HBUF(OOC_FCT_TYPE_LOC) +                        &
     &    SIZE_OF_BLOCK <= HBUF_SIZE + 1_8) THEN
      ELSE
        CALL DAGMG_MUMPS_707(OOC_FCT_TYPE_LOC,IERR)
        IF(IERR.LT.0)THEN
           RETURN
        ENDIF
      END IF
      DO I = 1_8, SIZE_OF_BLOCK
        BUF_IO(I_SHIFT_CUR_HBUF(OOC_FCT_TYPE_LOC) +                     &
     &        I_REL_POS_CUR_HBUF(OOC_FCT_TYPE_LOC) + I - 1_8) =         &
     &    BLOCK(I)
      END DO
      I_REL_POS_CUR_HBUF(OOC_FCT_TYPE_LOC) =                            &
     &     I_REL_POS_CUR_HBUF(OOC_FCT_TYPE_LOC) + SIZE_OF_BLOCK
      RETURN
      END SUBROUTINE DAGMG_MUMPS_678
      SUBROUTINE DAGMG_MUMPS_686()
      IMPLICIT NONE
      INTEGER(8) :: DIM_BUF_IO_L_OR_U
      INTEGER TYPEF, TYPEF_LAST
      INTEGER NB_DOUBLE_BUFFERS
      IF (KEEP_OOC(50) .EQ.0) THEN
        NB_DOUBLE_BUFFERS = 2
        TYPEF_LAST = 2
      ELSE
        NB_DOUBLE_BUFFERS = 1
        TYPEF_LAST = 1
      ENDIF
      DIM_BUF_IO_L_OR_U = DIM_BUF_IO /                                  &
     & int(NB_DOUBLE_BUFFERS,KIND=kind(DIM_BUF_IO_L_OR_U))
      IF(.NOT.STRAT_IO_ASYNC)THEN
         HBUF_SIZE = DIM_BUF_IO_L_OR_U
      ELSE
         HBUF_SIZE = DIM_BUF_IO_L_OR_U / 2_8
      ENDIF
      DO TYPEF = 1, TYPEF_LAST
        LAST_IOREQUEST(TYPEF) = -1
        IF (TYPEF == 1 ) THEN
          I_SHIFT_FIRST_HBUF(TYPEF) = 0_8
        ELSE
          I_SHIFT_FIRST_HBUF(TYPEF) = DIM_BUF_IO_L_OR_U
        ENDIF
        IF(.NOT.STRAT_IO_ASYNC)THEN
           I_SHIFT_SECOND_HBUF(TYPEF) = I_SHIFT_FIRST_HBUF(TYPEF)
        ELSE
           I_SHIFT_SECOND_HBUF(TYPEF) = I_SHIFT_FIRST_HBUF(TYPEF) +     &
     &          HBUF_SIZE
        ENDIF
        CUR_HBUF(TYPEF) = SECOND_HBUF
        CALL DAGMG_MUMPS_689(TYPEF)
      ENDDO
      I_CUR_HBUF_NEXTPOS = 1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_686
      SUBROUTINE DAGMG_MUMPS_706(TYPEF,IERR)
      IMPLICIT NONE
      INTEGER, INTENT(in)  :: TYPEF
      INTEGER, INTENT(out) :: IERR
      INTEGER IFLAG
      INTEGER NEW_IOREQUEST
      IERR=0
      CALL AGMG_NOCALL('MUMPS_TEST_REQUEST_C')
      IF (IFLAG.EQ.1) THEN
         IERR = 0
         CALL DAGMG_MUMPS_696(TYPEF,                                         &
     &        NEW_IOREQUEST,                                            &
     &        IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
         LAST_IOREQUEST(TYPEF) = NEW_IOREQUEST
         CALL DAGMG_MUMPS_689(TYPEF)
         NextAddVirtBuffer(TYPEF)=BufferEmpty
         RETURN
      ELSE IF(IFLAG.LT.0)THEN
         WRITE(*,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ELSE
         IERR = 1
         RETURN
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_706
      SUBROUTINE DAGMG_MUMPS_709(TYPEF,VADDR)
      IMPLICIT NONE
      INTEGER*8, INTENT(in) :: VADDR
      INTEGER, INTENT(in) :: TYPEF
      IF(I_REL_POS_CUR_HBUF(TYPEF).EQ.1_8)THEN
         FIRST_VADDR_IN_BUF(TYPEF)=VADDR
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_709
      SUBROUTINE DAGMG_MUMPS_653( STRAT, TYPEF, MonBloc,                     &
     &     AFAC, LAFAC,                                                 &
     &     AddVirtCour, IPIVBEG, IPIVEND, LPANELeff,                    &
     &     IERR)
      IMPLICIT NONE
      INTEGER,          INTENT(IN) :: TYPEF, IPIVBEG, IPIVEND, STRAT
      INTEGER(8),       INTENT(IN) :: LAFAC
      DOUBLE PRECISION, INTENT(IN) :: AFAC(LAFAC)
      INTEGER*8,        INTENT(IN) :: AddVirtCour
      TYPE(IO_BLOCK),   INTENT(IN) :: MonBloc
      INTEGER,          INTENT(OUT):: LPANELeff
      INTEGER,          INTENT(OUT):: IERR
      INTEGER   :: II, NBPIVeff
      INTEGER(8) :: IPOS, IDIAG, IDEST
      INTEGER(8) :: DeltaIPOS
      INTEGER   :: StrideIPOS
      IERR=0
      IF (STRAT.NE.STRAT_WRITE_MAX.AND.STRAT.NE.STRAT_TRY_WRITE) THEN
         write(6,*) ' DMUMPS_653: STRAT Not implemented '
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      NBPIVeff = IPIVEND - IPIVBEG + 1
      IF (MonBloc%MASTER .AND. MonBloc%TYPENODE .NE. 3) THEN
        IF (TYPEF.EQ.TYPEF_L) THEN
          LPANELeff = (MonBloc%NROW-IPIVBEG+1)*NBPIVeff
        ELSE
          LPANELeff = (MonBloc%NCOL-IPIVBEG+1)*NBPIVeff
        ENDIF
      ELSE
          LPANELeff = MonBloc%NROW*NBPIVeff
      ENDIF
      IF ( ( I_REL_POS_CUR_HBUF(TYPEF) + int(LPANELeff - 1,8)           &
     &     >                                                            &
     &     HBUF_SIZE )                                                  &
     &     .OR.                                                         &
     &     ( (AddVirtCour.NE.NextAddVirtBuffer(TYPEF)) .AND.            &
     &     (NextAddVirtBuffer(TYPEF).NE.BufferEmpty) )                  &
     &     ) THEN
         IF (STRAT.EQ.STRAT_WRITE_MAX) THEN
            CALL DAGMG_MUMPS_707(TYPEF,IERR)
         ELSE IF (STRAT.EQ.STRAT_TRY_WRITE) THEN
            CALL DAGMG_MUMPS_706(TYPEF,IERR)
            IF (IERR.EQ.1) RETURN
         ELSE
            write(6,*) 'DMUMPS_653: STRAT Not implemented'
         ENDIF
      ENDIF
      IF (IERR < 0 ) THEN
        RETURN
      ENDIF
      IF (NextAddVirtBuffer(TYPEF).EQ. BufferEmpty) THEN
         CALL DAGMG_MUMPS_709(TYPEF,AddVirtCour)
         NextAddVirtBuffer(TYPEF) = AddVirtCour
      ENDIF
      IF (MonBloc%MASTER .AND. MonBloc%TYPENODE .NE. 3) THEN
         IDIAG =  int(IPIVBEG-1,8)*int(MonBloc%NCOL,8) + int(IPIVBEG,8)
         IPOS   = IDIAG
         IDEST = I_SHIFT_CUR_HBUF(TYPEF) +                              &
     &        I_REL_POS_CUR_HBUF(TYPEF)
         IF (TYPEF.EQ.TYPEF_L) THEN
            DO II = IPIVBEG, IPIVEND
               CALL DCOPY(MonBloc%NROW-IPIVBEG+1,                       &
     &              AFAC(IPOS), MonBloc%NCOL,                           &
     &              BUF_IO(IDEST), 1)
               IDEST = IDEST + int(MonBloc%NROW-IPIVBEG+1,8)
               IPOS  = IPOS  + 1_8
            ENDDO
         ELSE
            DO II = IPIVBEG, IPIVEND
               CALL DCOPY(MonBloc%NCOL-IPIVBEG+1,                       &
     &              AFAC(IPOS), 1,                                      &
     &              BUF_IO(IDEST), 1)
               IDEST = IDEST + int(MonBloc%NCOL-IPIVBEG+1,8)
               IPOS  = IPOS  + int(MonBloc%NCOL,8)
            ENDDO
         ENDIF
      ELSE
         IDEST = I_SHIFT_CUR_HBUF(TYPEF) +                              &
     &        I_REL_POS_CUR_HBUF(TYPEF)
         IF (MonBloc%Typenode.EQ.3) THEN
           DeltaIPOS  = int(MonBloc%NROW,8)
           StrideIPOS = 1
         ELSE
           DeltaIPOS  = 1_8
           StrideIPOS = MonBloc%NCOL
         ENDIF
         IPOS  = 1_8 + int(IPIVBEG - 1,8) * DeltaIPOS
         DO II = IPIVBEG, IPIVEND
            CALL DCOPY(MonBloc%NROW,                                    &
     &           AFAC(IPOS), StrideIPOS,                                &
     &           BUF_IO(IDEST), 1)
            IDEST = IDEST+int(MonBloc%NROW,8)
            IPOS  = IPOS + DeltaIPOS
         ENDDO
      ENDIF
      I_REL_POS_CUR_HBUF(TYPEF) =                                       &
     &     I_REL_POS_CUR_HBUF(TYPEF) + int(LPANELeff,8)
      NextAddVirtBuffer(TYPEF) = NextAddVirtBuffer(TYPEF)               &
     &                         + int(LPANELeff,8)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_653
      END MODULE DAGMG_MUMPS_OOC_BUFFER
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE DAGMG_MUMPS_OOC
      USE AGMG_MUMPS_OOC_COMMON
      IMPLICIT NONE
      INTEGER NOT_IN_MEM,BEING_READ,NOT_USED,PERMUTED,USED,             &
     &     USED_NOT_PERMUTED,ALREADY_USED
      PARAMETER (NOT_IN_MEM=0,BEING_READ=-1,NOT_USED=-2,                &
     &     PERMUTED=-3,USED=-4,USED_NOT_PERMUTED=-5,ALREADY_USED=-6)
      INTEGER OOC_NODE_NOT_IN_MEM,OOC_NODE_PERMUTED,                    &
     &     OOC_NODE_NOT_PERMUTED
      PARAMETER (OOC_NODE_NOT_IN_MEM=-20,                               &
     &     OOC_NODE_PERMUTED=-21,OOC_NODE_NOT_PERMUTED=-22)
      INTEGER(8), DIMENSION(:,:),POINTER :: SIZE_OF_BLOCK
      INTEGER, DIMENSION(:),POINTER :: TOTAL_NB_OOC_NODES
      INTEGER :: OOC_SOLVE_TYPE_FCT
      INTEGER, DIMENSION(:),ALLOCATABLE :: IO_REQ
      INTEGER(8), DIMENSION(:), ALLOCATABLE:: LRLUS_SOLVE
      INTEGER(8), DIMENSION(:), ALLOCATABLE:: SIZE_SOLVE_Z,             &
     & LRLU_SOLVE_T, POSFAC_SOLVE, IDEB_SOLVE_Z, LRLU_SOLVE_B
      INTEGER, DIMENSION(:),ALLOCATABLE :: PDEB_SOLVE_Z
      INTEGER (8),SAVE :: FACT_AREA_SIZE,                               &
     &     SIZE_ZONE_SOLVE,SIZE_SOLVE_EMM,TMP_SIZE_FACT,                &
     &     MAX_SIZE_FACTOR_OOC
      INTEGER(8), SAVE :: MIN_SIZE_READ
      INTEGER, SAVE :: TMP_NB_NODES, MAX_NB_NODES_FOR_ZONE,MAX_NB_REQ,  &
     &     CURRENT_SOLVE_READ_ZONE,                                     &
     &     CUR_POS_SEQUENCE,NB_Z,SOLVE_STEP,                            &
     &     NB_ZONE_REQ,MTYPE_OOC,NB_ACT                                 &
     &     ,NB_CALLED,REQ_ACT,NB_CALL
      INTEGER*8, SAVE :: OOC_VADDR_PTR
      INTEGER*8, SAVE :: SIZE_ZONE_REQ
      DOUBLE PRECISION,SAVE :: MAX_OOC_FILE_SIZE
      INTEGER(8), DIMENSION(:), ALLOCATABLE :: SIZE_OF_READ, READ_DEST
      INTEGER,DIMENSION(:),ALLOCATABLE :: FIRST_POS_IN_READ,            &
     &     READ_MNG,REQ_TO_ZONE,POS_HOLE_T,                             &
     &     POS_HOLE_B,REQ_ID,OOC_STATE_NODE
      INTEGER DAGMG_MUMPS_ELEMENTARY_DATA_SIZE,N_OOC
      INTEGER, DIMENSION(:), ALLOCATABLE :: POS_IN_MEM, INODE_TO_POS
      INTEGER, DIMENSION(:), ALLOCATABLE :: CURRENT_POS_T,CURRENT_POS_B
      LOGICAL IS_ROOT_SPECIAL
      INTEGER SPECIAL_ROOT_NODE
      PUBLIC :: DAGMG_MUMPS_575,DAGMG_MUMPS_576,                                  &
     &     DAGMG_MUMPS_577,                                                  &
     &     DAGMG_MUMPS_578,                                                  &
     &     DAGMG_MUMPS_579,                                                  &
     &     DAGMG_MUMPS_581,DAGMG_MUMPS_582,                                       &
     &     DAGMG_MUMPS_583,DAGMG_MUMPS_584,                                       &
     &     DAGMG_MUMPS_585,DAGMG_MUMPS_586
         INTEGER, PARAMETER, PUBLIC :: TYPEF_BOTH_LU = -99976
         PUBLIC DAGMG_MUMPS_688,                                             &
     &        DAGMG_MUMPS_690
         PRIVATE DAGMG_MUMPS_695,                                            &
     &        DAGMG_MUMPS_697
      CONTAINS
      SUBROUTINE DAGMG_MUMPS_711( STRAT_IO_ARG,                              &
     & STRAT_IO_ASYNC_ARG, WITH_BUF_ARG, LOW_LEVEL_STRAT_IO_ARG )
      IMPLICIT NONE
      INTEGER, intent(out) :: LOW_LEVEL_STRAT_IO_ARG
      LOGICAL, intent(out) :: STRAT_IO_ASYNC_ARG, WITH_BUF_ARG
      INTEGER, intent(in)  :: STRAT_IO_ARG
      INTEGER TMP
      CALL AGMG_NOCALL('MUMPS_OOC_IS_ASYNC_AVAIL')
      STRAT_IO_ASYNC_ARG=.FALSE.
      WITH_BUF_ARG=.FALSE.
      IF(TMP.EQ.1)THEN
         IF((STRAT_IO_ARG.EQ.1).OR.(STRAT_IO_ARG.EQ.2))THEN
            STRAT_IO_ASYNC=.TRUE.
            WITH_BUF=.FALSE.
         ELSEIF((STRAT_IO_ARG.EQ.4).OR.(STRAT_IO_ARG.EQ.5))THEN
            STRAT_IO_ASYNC_ARG=.TRUE.
            WITH_BUF_ARG=.TRUE.
         ELSEIF(STRAT_IO_ARG.EQ.3)THEN
            STRAT_IO_ASYNC_ARG=.FALSE.
            WITH_BUF_ARG=.TRUE.
         ENDIF
         LOW_LEVEL_STRAT_IO_ARG=mod(STRAT_IO_ARG,3)
      ELSE
         LOW_LEVEL_STRAT_IO_ARG=0
         IF(STRAT_IO_ARG.GE.3)THEN
            WITH_BUF_ARG=.TRUE.
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_711
      FUNCTION DAGMG_MUMPS_579(INODE,ZONE)
      IMPLICIT NONE
      INTEGER INODE,ZONE
      LOGICAL DAGMG_MUMPS_579
      DAGMG_MUMPS_579=(LRLUS_SOLVE(ZONE).GE.                                 &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE))
      RETURN
      END FUNCTION DAGMG_MUMPS_579
      SUBROUTINE DAGMG_MUMPS_590(LA)
      IMPLICIT NONE
      INTEGER(8) :: LA
      FACT_AREA_SIZE=LA
      END SUBROUTINE DAGMG_MUMPS_590
      SUBROUTINE DAGMG_MUMPS_575(id, MAXS)
      USE DAGMG_MUMPS_STRUC_DEF
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER TMPDIR_MAX_LENGTH, PREFIX_MAX_LENGTH
      PARAMETER (TMPDIR_MAX_LENGTH=255, PREFIX_MAX_LENGTH=63)
      INTEGER(8), intent(in) :: MAXS
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER IERR
      INTEGER allocok
      INTEGER ASYNC
      CHARACTER*1 TMP_DIR(TMPDIR_MAX_LENGTH),                           &
     &            TMP_PREFIX(PREFIX_MAX_LENGTH)
      INTEGER DIM_DIR,DIM_PREFIX
      INTEGER, DIMENSION(:), ALLOCATABLE :: FILE_FLAG_TAB
      INTEGER TMP
      INTEGER K211_LOC
      ICNTL1=id%ICNTL(1)
      MAX_SIZE_FACTOR_OOC=0_8
      OOC_FCT_TYPE=1
      N_OOC=id%N
      IS_INIT_CALLED=.TRUE.
      ASYNC=0
      SOLVE=.FALSE.
      IERR=0
      IF(allocated(IO_REQ))THEN
         DEALLOCATE(IO_REQ)
      ENDIF
      IF(associated(KEEP_OOC))THEN
         NULLIFY(KEEP_OOC)
      ENDIF
      IF(associated(STEP_OOC))THEN
         NULLIFY(STEP_OOC)
      ENDIF
      IF(associated(PROCNODE_OOC))THEN
         NULLIFY(PROCNODE_OOC)
      ENDIF
      IF(associated(OOC_INODE_SEQUENCE))THEN
         NULLIFY(OOC_INODE_SEQUENCE)
      ENDIF
      IF(associated(TOTAL_NB_OOC_NODES))THEN
         NULLIFY(TOTAL_NB_OOC_NODES)
      ENDIF
      IF(associated(SIZE_OF_BLOCK))THEN
         NULLIFY(SIZE_OF_BLOCK)
      ENDIF
      IF(associated(OOC_VADDR))THEN
         NULLIFY(OOC_VADDR)
      ENDIF
      IF(allocated(I_CUR_HBUF_NEXTPOS))THEN
         DEALLOCATE(I_CUR_HBUF_NEXTPOS)
      ENDIF
      CALL DAGMG_MUMPS_588(id,IERR)
      IF(IERR.LT.0)THEN
         IF (ICNTL1 > 0)                                                &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         id%INFO(1) = IERR
         id%INFO(2) = 0
         RETURN
      ENDIF
      STEP_OOC=>id%STEP
      PROCNODE_OOC=>id%PROCNODE_STEPS
      MYID_OOC=id%MYID
      SLAVEF_OOC=id%NSLAVES
      KEEP_OOC => id%KEEP
      SIZE_OF_BLOCK=>id%OOC_SIZE_OF_BLOCK
      OOC_VADDR=>id%OOC_VADDR
      IF(id%KEEP(107).GT.0)THEN
         SIZE_SOLVE_EMM=max(id%KEEP8(19),int(dble(MAXS)*                &
     &        0.9d0*0.2d0,8))
         SIZE_ZONE_SOLVE=max(SIZE_SOLVE_EMM,                            &
     &        int((dble(MAXS)*0.9d0-                                    &
     &        dble(SIZE_SOLVE_EMM))/dble(id%KEEP(107)),8))
         IF(SIZE_ZONE_SOLVE.EQ.SIZE_SOLVE_EMM)THEN
            SIZE_SOLVE_EMM=id%KEEP8(19)
            SIZE_ZONE_SOLVE=int((dble(MAXS)*0.9d0-                      &
     &           dble(SIZE_SOLVE_EMM))/dble(id%KEEP(107)),8)
         ENDIF
      ELSE
         SIZE_ZONE_SOLVE=int(dble(MAXS)*0.9d0,8)
         SIZE_SOLVE_EMM=SIZE_ZONE_SOLVE
      ENDIF
      DAGMG_MUMPS_ELEMENTARY_DATA_SIZE = id%KEEP(35)
      SIZE_OF_BLOCK=0_8
      ALLOCATE(id%OOC_NB_FILES(OOC_NB_FILE_TYPE), stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         id%INFO(1) = -13
         id%INFO(2) = OOC_NB_FILE_TYPE
         RETURN
      ENDIF
      id%OOC_NB_FILES=0
      OOC_VADDR_PTR=0_8
      CALL DAGMG_MUMPS_711( id%KEEP(99), STRAT_IO_ASYNC,                     &
     &                                WITH_BUF, LOW_LEVEL_STRAT_IO )
      TMP_SIZE_FACT=0_8
      TMP_NB_NODES=0
      MAX_NB_NODES_FOR_ZONE=0
      OOC_INODE_SEQUENCE=>id%OOC_INODE_SEQUENCE
      ALLOCATE(I_CUR_HBUF_NEXTPOS(OOC_NB_FILE_TYPE),                    &
     &     stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         id%INFO(1) = -13
         id%INFO(2) = OOC_NB_FILE_TYPE
         RETURN
      ENDIF
      I_CUR_HBUF_NEXTPOS = 1
      IF(WITH_BUF)THEN
         CALL DAGMG_MUMPS_669(id%INFO(1),id%INFO(2),IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ENDIF
      IF(STRAT_IO_ASYNC)THEN
         ASYNC=1
      ENDIF
      DIM_ERR_STR_OOC = ERR_STR_OOC_MAX_LEN
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_INIT_ERR_STR')
      DIM_DIR=len(trim(id%OOC_TMPDIR))
      DIM_PREFIX=len(trim(id%OOC_PREFIX))
      CALL DAGMG_MUMPS_589(TMP_DIR(1),                                       &
     &     id%OOC_TMPDIR, TMPDIR_MAX_LENGTH, DIM_DIR )
      CALL DAGMG_MUMPS_589(TMP_PREFIX(1),                                    &
     &     id%OOC_PREFIX, PREFIX_MAX_LENGTH, DIM_PREFIX)
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_INIT_PREFIX')
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_INIT_TMPDIR')
      ALLOCATE(FILE_FLAG_TAB(OOC_NB_FILE_TYPE),                         &
     &     stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1 .GT. 0)                                             &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         id%INFO(1) = -13
         id%INFO(2) = OOC_NB_FILE_TYPE
         RETURN
      ENDIF
      FILE_FLAG_TAB(1:OOC_NB_FILE_TYPE)=0
      IERR=0
      TMP=int(id%KEEP8(11)/1000000_8,kind=4)+1
      IF((id%KEEP(201).EQ.1).AND.(id%KEEP(50).EQ.0))THEN
         TMP=MAX(1,TMP/2)
      ENDIF
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_INIT_OOC_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1 .GT. 0 ) THEN
           WRITE(ICNTL1,*)MYID_OOC,': PB in MUMPS_LOW_LEVEL_INIT_OOC_C'
           WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         ENDIF
         id%INFO(1) = IERR
         id%INFO(2) = 0
         RETURN
      ENDIF
      CALL AGMG_NOCALL('MUMPS_GET_MAX_FILE_SIZE_C')
      DEALLOCATE(FILE_FLAG_TAB)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_575
      SUBROUTINE DAGMG_MUMPS_576(INODE,PTRFAC,KEEP,KEEP8,                    &
     &           A,LA,SIZE,IERR)
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER INODE,KEEP(500)
      INTEGER(8) :: LA
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRFAC(KEEP(28)), SIZE
      DOUBLE PRECISION A(LA)
      INTEGER IERR,I,FLAG,NODE,ASYNC,REQUEST
      LOGICAL IO_C
      INTEGER ADDR_INT1,ADDR_INT2
      INTEGER TYPE
      INTEGER SIZE_INT1,SIZE_INT2
      TYPE=FCT
      IF(STRAT_IO_ASYNC)THEN
         ASYNC=1
      ELSE
         ASYNC=0
      ENDIF
      IERR=0
      IO_C=.TRUE.
      SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)=SIZE
      MAX_SIZE_FACTOR_OOC=max(MAX_SIZE_FACTOR_OOC,SIZE)
      OOC_VADDR(STEP_OOC(INODE),OOC_FCT_TYPE)=OOC_VADDR_PTR
      OOC_VADDR_PTR=OOC_VADDR_PTR+SIZE
      TMP_SIZE_FACT=TMP_SIZE_FACT+SIZE
      TMP_NB_NODES=TMP_NB_NODES+1
      IF(TMP_SIZE_FACT.GT.SIZE_ZONE_SOLVE)THEN
         MAX_NB_NODES_FOR_ZONE=max(MAX_NB_NODES_FOR_ZONE,TMP_NB_NODES)
         TMP_SIZE_FACT=0_8
         TMP_NB_NODES=0
      ENDIF
      IF (.NOT. WITH_BUF) THEN
         CALL AGMG_MUMPS_677(ADDR_INT1,ADDR_INT2,                            &
     &        OOC_VADDR(STEP_OOC(INODE),OOC_FCT_TYPE))
         CALL AGMG_MUMPS_677(SIZE_INT1,SIZE_INT2,                            &
     &        SIZE)
         CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_WRITE_OOC_C')
        IF(IERR.LT.0)THEN
           IF (ICNTL1.GT.0)                                             &
     &     WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
           RETURN
        ENDIF
        IF(I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE).GT.KEEP_OOC(28))THEN
             WRITE(*,*)MYID_OOC,': Internal error (37) in OOC '
           CALL AGMG_MUMPS_ABORT()
        ENDIF
        OOC_INODE_SEQUENCE(I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE),            &
     &       OOC_FCT_TYPE)=INODE
        I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE)=                               &
     &       I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE)+1
      ELSE
         IF(SIZE.LE.HBUF_SIZE)THEN
            CALL DAGMG_MUMPS_678                                             &
     &           (A(PTRFAC(STEP_OOC(INODE))),SIZE,IERR)
            OOC_INODE_SEQUENCE(I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE),        &
     &           OOC_FCT_TYPE) = INODE
            I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE) =                          &
     &           I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE) + 1
            PTRFAC(STEP_OOC(INODE))=-777777_8
            RETURN
         ELSE
            CALL DAGMG_MUMPS_707(OOC_FCT_TYPE,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            CALL DAGMG_MUMPS_707(OOC_FCT_TYPE,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            CALL AGMG_MUMPS_677(ADDR_INT1,ADDR_INT2,                         &
     &           OOC_VADDR(STEP_OOC(INODE),OOC_FCT_TYPE))
            CALL AGMG_MUMPS_677(SIZE_INT1,SIZE_INT2,                         &
     &           SIZE)
            CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_WRITE_OOC_C')
            IF(IERR.LT.0)THEN
               IF (ICNTL1.GT.0)                                         &
     &         WRITE(*,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
               RETURN
            ENDIF
            IF(I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE).GT.KEEP_OOC(28))THEN
             WRITE(*,*)MYID_OOC,': Internal error (38) in OOC '
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            OOC_INODE_SEQUENCE(I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE),        &
     &           OOC_FCT_TYPE)=INODE
            I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE)=                           &
     &           I_CUR_HBUF_NEXTPOS(OOC_FCT_TYPE)+1
            CALL DAGMG_MUMPS_689(OOC_FCT_TYPE)
         ENDIF
      END IF
      NODE=-9999
      PTRFAC(STEP_OOC(INODE))=-777777_8
      IF(STRAT_IO_ASYNC)THEN
         IERR=0
         CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
         IF(IERR.LT.0)THEN
            IF (ICNTL1 .GT. 0)                                          &
     &      WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
            RETURN
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_576
      SUBROUTINE DAGMG_MUMPS_577(DEST,INODE,IERR                             &
     &  )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR,INODE,STATUS
      DOUBLE PRECISION DEST
      INTEGER FLAG,NODE,ASYNC,REQUEST
      LOGICAL IO_C
      INTEGER ADDR_INT1,ADDR_INT2
      INTEGER TYPE
      INTEGER SIZE_INT1,SIZE_INT2
      TYPE=OOC_SOLVE_TYPE_FCT
      IF(SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)                    &
     &     .EQ.0_8)THEN
         GOTO 555
      ENDIF
      IF(STRAT_IO_ASYNC)THEN
        ASYNC=1
      ELSE
        ASYNC=0
      ENDIF
      IERR=0
      IO_C=.TRUE.
      OOC_STATE_NODE(STEP_OOC(INODE))=NOT_USED
      CALL AGMG_MUMPS_677(ADDR_INT1,ADDR_INT2,                               &
     &     OOC_VADDR(STEP_OOC(INODE),OOC_FCT_TYPE))
      CALL AGMG_MUMPS_677(SIZE_INT1,SIZE_INT2,                               &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE))
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_DIRECT_READ')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0) THEN
           WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
           WRITE(ICNTL1,*)MYID_OOC,                                     &
     &     ': Problem in MUMPS_LOW_LEVEL_DIRECT_READ'
         ENDIF
         RETURN
      ENDIF
  555 CONTINUE
      IF(.NOT.DAGMG_MUMPS_727())THEN
         IF(OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,OOC_FCT_TYPE).EQ.       &
     &        INODE)THEN
            IF(SOLVE_STEP.EQ.0)THEN
               CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
            ELSEIF(SOLVE_STEP.EQ.1)THEN
               CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
            ENDIF
            CALL DAGMG_MUMPS_728()
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_577
      SUBROUTINE DAGMG_MUMPS_591(IERR)
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER, intent(out):: IERR
      IERR=0
      IF (WITH_BUF) THEN
        CALL DAGMG_MUMPS_675(IERR)
        IF(IERR.LT.0)THEN
           RETURN
        ENDIF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_591
      SUBROUTINE DAGMG_MUMPS_592(id,IERR)
      USE DAGMG_MUMPS_OOC_BUFFER
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER, intent(out) :: IERR
      INTEGER I,SOLVE_OR_FACTO
      IERR=0
      IF(WITH_BUF)THEN
         CALL DAGMG_MUMPS_659()
      ENDIF
      IF(associated(KEEP_OOC))THEN
         NULLIFY(KEEP_OOC)
      ENDIF
      IF(associated(STEP_OOC))THEN
         NULLIFY(STEP_OOC)
      ENDIF
      IF(associated(PROCNODE_OOC))THEN
         NULLIFY(PROCNODE_OOC)
      ENDIF
      IF(associated(OOC_INODE_SEQUENCE))THEN
         NULLIFY(OOC_INODE_SEQUENCE)
      ENDIF
      IF(associated(TOTAL_NB_OOC_NODES))THEN
         NULLIFY(TOTAL_NB_OOC_NODES)
      ENDIF
      IF(associated(SIZE_OF_BLOCK))THEN
         NULLIFY(SIZE_OF_BLOCK)
      ENDIF
      IF(associated(OOC_VADDR))THEN
         NULLIFY(OOC_VADDR)
      ENDIF
      CALL AGMG_NOCALL('MUMPS_OOC_END_WRITE_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1 .GT. 0)                                             &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         GOTO 500
      ENDIF
      id%OOC_MAX_NB_NODES_FOR_ZONE=max(MAX_NB_NODES_FOR_ZONE,           &
     &     TMP_NB_NODES)
      IF(allocated(I_CUR_HBUF_NEXTPOS))THEN
         DO I=1,OOC_NB_FILE_TYPE
            id%OOC_TOTAL_NB_NODES(I)=I_CUR_HBUF_NEXTPOS(I)-1
         ENDDO
         DEALLOCATE(I_CUR_HBUF_NEXTPOS)
      ENDIF
      id%KEEP8(20)=MAX_SIZE_FACTOR_OOC
      CALL DAGMG_MUMPS_613(id,IERR)
      IF(IERR.LT.0)THEN
         GOTO 500
      ENDIF
  500 CONTINUE
      SOLVE_OR_FACTO=0
      CALL AGMG_NOCALL('MUMPS_CLEAN_IO_DATA_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_592
      SUBROUTINE DAGMG_MUMPS_588(id,IERR)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER IERR
      INTEGER I,J,I1,K
      CHARACTER*1 TMP_NAME(350)
      IERR=0
      K=1
      IF(associated(id%OOC_FILE_NAMES).AND.                             &
     &     associated(id%OOC_FILE_NAME_LENGTH))THEN
         DO I1=1,OOC_NB_FILE_TYPE
            DO I=1,id%OOC_NB_FILES(I1)
               DO J=1,id%OOC_FILE_NAME_LENGTH(K)
                  TMP_NAME(J)=id%OOC_FILE_NAMES(K,J)
               ENDDO
               CALL AGMG_NOCALL('MUMPS_OOC_REMOVE_FILE_C')
               IF(IERR.LT.0)THEN
                  IF (ICNTL1.GT.0)THEN
                     WRITE(ICNTL1,*)MYID_OOC,': ',                      &
     &                    ERR_STR_OOC(1:DIM_ERR_STR_OOC)
                     RETURN
                  ENDIF
               ENDIF
               K=K+1
            ENDDO
         ENDDO
      ENDIF
      IF(associated(id%OOC_FILE_NAMES))THEN
         DEALLOCATE(id%OOC_FILE_NAMES)
         NULLIFY(id%OOC_FILE_NAMES)
      ENDIF
      IF(associated(id%OOC_FILE_NAME_LENGTH))THEN
         DEALLOCATE(id%OOC_FILE_NAME_LENGTH)
         NULLIFY(id%OOC_FILE_NAME_LENGTH)
      ENDIF
      IF(associated(id%OOC_NB_FILES))THEN
         DEALLOCATE(id%OOC_NB_FILES)
         NULLIFY(id%OOC_NB_FILES)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_588
      SUBROUTINE DAGMG_MUMPS_587(id,IERR)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER IERR
      IERR=0
      CALL DAGMG_MUMPS_588(id,IERR)
      IF(associated(id%OOC_TOTAL_NB_NODES))THEN
         DEALLOCATE(id%OOC_TOTAL_NB_NODES)
         NULLIFY(id%OOC_TOTAL_NB_NODES)
      ENDIF
      IF(associated(id%OOC_INODE_SEQUENCE))THEN
         DEALLOCATE(id%OOC_INODE_SEQUENCE)
         NULLIFY(id%OOC_INODE_SEQUENCE)
      ENDIF
      IF(associated(id%OOC_SIZE_OF_BLOCK))THEN
         DEALLOCATE(id%OOC_SIZE_OF_BLOCK)
         NULLIFY(id%OOC_SIZE_OF_BLOCK)
      ENDIF
      IF(associated(id%OOC_VADDR))THEN
         DEALLOCATE(id%OOC_VADDR)
         NULLIFY(id%OOC_VADDR)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_587
      SUBROUTINE DAGMG_MUMPS_586(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER TMP,TMP_SIZE,I,J
      INTEGER(8) :: TMP_SIZE8
      INTEGER ZONE,INODE,SIZE,allocok,IERR,ASYNC
      EXTERNAL AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_275
      INTEGER MASTER_ROOT
      IERR=0
      ICNTL1=id%ICNTL(1)
      SOLVE=.TRUE.
      N_OOC=id%N
      IF(allocated(LRLUS_SOLVE))THEN
         DEALLOCATE(LRLUS_SOLVE)
      ENDIF
      IF(allocated(LRLU_SOLVE_T))THEN
         DEALLOCATE(LRLU_SOLVE_T)
      ENDIF
      IF(allocated(LRLU_SOLVE_B))THEN
         DEALLOCATE(LRLU_SOLVE_B)
      ENDIF
      IF(allocated(POSFAC_SOLVE))THEN
         DEALLOCATE(POSFAC_SOLVE)
      ENDIF
      IF(allocated(IDEB_SOLVE_Z))THEN
         DEALLOCATE(IDEB_SOLVE_Z)
      ENDIF
      IF(allocated(PDEB_SOLVE_Z))THEN
         DEALLOCATE(PDEB_SOLVE_Z)
      ENDIF
      IF(allocated(SIZE_SOLVE_Z))THEN
         DEALLOCATE(SIZE_SOLVE_Z)
      ENDIF
      IF(allocated(CURRENT_POS_T))THEN
         DEALLOCATE(CURRENT_POS_T)
      ENDIF
      IF(allocated(CURRENT_POS_B))THEN
         DEALLOCATE(CURRENT_POS_B)
      ENDIF
      IF(allocated(POS_HOLE_T))THEN
         DEALLOCATE(POS_HOLE_T)
      ENDIF
      IF(allocated(POS_HOLE_B))THEN
         DEALLOCATE(POS_HOLE_B)
      ENDIF
      IF(allocated(OOC_STATE_NODE))THEN
         DEALLOCATE(OOC_STATE_NODE)
      ENDIF
      IF(allocated(POS_IN_MEM))THEN
         DEALLOCATE(POS_IN_MEM)
      ENDIF
      IF(allocated(INODE_TO_POS))THEN
         DEALLOCATE(INODE_TO_POS)
      ENDIF
      IF(allocated(SIZE_OF_READ))THEN
         DEALLOCATE(SIZE_OF_READ)
      ENDIF
      IF(allocated(FIRST_POS_IN_READ))THEN
         DEALLOCATE(FIRST_POS_IN_READ)
      ENDIF
      IF(allocated(READ_DEST))THEN
         DEALLOCATE(READ_DEST)
      ENDIF
      IF(allocated(READ_MNG))THEN
         DEALLOCATE(READ_MNG)
      ENDIF
      IF(allocated(REQ_TO_ZONE))THEN
         DEALLOCATE(REQ_TO_ZONE)
      ENDIF
      IF(allocated(REQ_ID))THEN
         DEALLOCATE(REQ_ID)
      ENDIF
      IF(allocated(IO_REQ))THEN
         DEALLOCATE(IO_REQ)
      ENDIF
      IF(associated(KEEP_OOC))THEN
         NULLIFY(KEEP_OOC)
      ENDIF
      IF(associated(STEP_OOC))THEN
         NULLIFY(STEP_OOC)
      ENDIF
      IF(associated(PROCNODE_OOC))THEN
         NULLIFY(PROCNODE_OOC)
      ENDIF
      IF(associated(TOTAL_NB_OOC_NODES))THEN
         NULLIFY(TOTAL_NB_OOC_NODES)
      ENDIF
      IF(associated(SIZE_OF_BLOCK))THEN
         NULLIFY(SIZE_OF_BLOCK)
      ENDIF
      IF(associated(OOC_INODE_SEQUENCE))THEN
         NULLIFY(OOC_VADDR)
      ENDIF
      DIM_ERR_STR_OOC = ERR_STR_OOC_MAX_LEN
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_INIT_ERR_STR')
      CALL DAGMG_MUMPS_614(id)
      IF(id%INFO(1).LT.0)THEN
         RETURN
      ENDIF
      STEP_OOC=>id%STEP
      PROCNODE_OOC=>id%PROCNODE_STEPS
      SLAVEF_OOC=id%NSLAVES
      MYID_OOC=id%MYID
      KEEP_OOC => id%KEEP
      SIZE_OF_BLOCK=>id%OOC_SIZE_OF_BLOCK
      OOC_INODE_SEQUENCE=>id%OOC_INODE_SEQUENCE
      OOC_VADDR=>id%OOC_VADDR
      ALLOCATE(IO_REQ(id%KEEP(28)),                                     &
     &     stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC'
         id%INFO(1) = -13
         id%INFO(2) = id%KEEP(28)
         RETURN
      ENDIF
      DAGMG_MUMPS_ELEMENTARY_DATA_SIZE = id%KEEP(35)
      MAX_NB_NODES_FOR_ZONE=id%OOC_MAX_NB_NODES_FOR_ZONE
      TOTAL_NB_OOC_NODES=>id%OOC_TOTAL_NB_NODES
      CALL DAGMG_MUMPS_711( id%KEEP(204), STRAT_IO_ASYNC,                    &
     & WITH_BUF, LOW_LEVEL_STRAT_IO)
      IF(id%KEEP(107).GT.0)THEN
         SIZE_SOLVE_EMM=max(id%KEEP8(20),                               &
     &        FACT_AREA_SIZE / 5_8)
         SIZE_ZONE_SOLVE=max(SIZE_SOLVE_EMM,                            &
     &        int((dble(FACT_AREA_SIZE)-                                &
     &        dble(SIZE_SOLVE_EMM))/dble(id%KEEP(107)),8))
         SIZE_ZONE_SOLVE=max(SIZE_ZONE_SOLVE,0_8)
         IF(SIZE_ZONE_SOLVE.EQ.SIZE_SOLVE_EMM)THEN
            SIZE_SOLVE_EMM=id%KEEP8(20)
            SIZE_ZONE_SOLVE=int((dble(FACT_AREA_SIZE)-                  &
     &           dble(SIZE_SOLVE_EMM))/dble(id%KEEP(107)),8)
            SIZE_ZONE_SOLVE=max(SIZE_ZONE_SOLVE,0_8)
         ENDIF
      ELSE
         SIZE_ZONE_SOLVE=FACT_AREA_SIZE
         SIZE_SOLVE_EMM=SIZE_ZONE_SOLVE
      ENDIF
      IF(SIZE_SOLVE_EMM.LT.id%KEEP8(20))THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': More space needed for               &
     & solution step in DAGMG_MUMPS_586'
         id%INFO(1) = -11
         CALL AGMG_MUMPS_731(id%KEEP8(20), id%INFO(2))
      ENDIF
      TMP=MAX_NB_NODES_FOR_ZONE
      CALL AGMG_COPY(TMP,MAX_NB_NODES_FOR_ZONE,1,                                AGMG_MPF_INTEGER, IERR)
      NB_Z=KEEP_OOC(107)+1
      ALLOCATE(POS_IN_MEM(MAX_NB_NODES_FOR_ZONE*NB_Z),                  &
     &     INODE_TO_POS(KEEP_OOC(28)),                                  &
     &     stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_586'
         id%INFO(1) = -13
         id%INFO(2) = id%KEEP(28)+(MAX_NB_NODES_FOR_ZONE*NB_Z)
         RETURN
      ENDIF
      ALLOCATE(OOC_STATE_NODE(KEEP_OOC(28)),stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_586'
         id%INFO(1) = -13
         id%INFO(2) = id%KEEP(28)
         RETURN
      ENDIF
      OOC_STATE_NODE(1:KEEP_OOC(28))=0
      INODE_TO_POS=0
      POS_IN_MEM=0
      ALLOCATE(LRLUS_SOLVE(NB_Z), LRLU_SOLVE_T(NB_Z),LRLU_SOLVE_B(NB_Z),&
     &     POSFAC_SOLVE(NB_Z),IDEB_SOLVE_Z(NB_Z),                       &
     &     PDEB_SOLVE_Z(NB_Z),SIZE_SOLVE_Z(NB_Z),                       &
     &     CURRENT_POS_T(NB_Z),CURRENT_POS_B(NB_Z),                     &
     &     POS_HOLE_T(NB_Z),POS_HOLE_B(NB_Z),                           &
     &     stat=allocok)
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC_SOLVE'
         id%INFO(1) = -13
         id%INFO(2) = 9*(NB_Z+1)
         RETURN
      ENDIF
      IERR=0
      CALL AGMG_NOCALL('MUMPS_GET_MAX_NB_REQ_C')
      ALLOCATE(SIZE_OF_READ(MAX_NB_REQ),FIRST_POS_IN_READ(MAX_NB_REQ),  &
     &     READ_DEST(MAX_NB_REQ),READ_MNG(MAX_NB_REQ),                  &
     &     REQ_TO_ZONE(MAX_NB_REQ),REQ_ID(MAX_NB_REQ),stat=allocok)
      SIZE_OF_READ=-9999_8
      FIRST_POS_IN_READ=-9999
      READ_DEST=-9999_8
      READ_MNG=-9999
      REQ_TO_ZONE=-9999
      REQ_ID=-9999
      IF (allocok .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_INIT_OOC_SOLVE'
         id%INFO(1) = -13
         id%INFO(2) = 6*(NB_Z+1)
         RETURN
      ENDIF
      MIN_SIZE_READ=min(max((1024_8*1024_8)/int(id%KEEP(35),8),         &
     &                       SIZE_ZONE_SOLVE/3_8),                      &
     &                  SIZE_ZONE_SOLVE)
      TMP_SIZE8=1_8
      J=1
      DO I=1,NB_Z-1
         IDEB_SOLVE_Z(I)=TMP_SIZE8
         POSFAC_SOLVE(I)=TMP_SIZE8
         LRLUS_SOLVE(I)=SIZE_ZONE_SOLVE
         LRLU_SOLVE_T(I)=SIZE_ZONE_SOLVE
         LRLU_SOLVE_B(I)=0_8
         SIZE_SOLVE_Z(I)=SIZE_ZONE_SOLVE
         CURRENT_POS_T(I)=J
         CURRENT_POS_B(I)=J
         PDEB_SOLVE_Z(I)=J
         POS_HOLE_T(I)=J
         POS_HOLE_B(I)=J
         J=J+MAX_NB_NODES_FOR_ZONE
         TMP_SIZE8=TMP_SIZE8+SIZE_ZONE_SOLVE
      ENDDO
      IDEB_SOLVE_Z(NB_Z)=TMP_SIZE8
      PDEB_SOLVE_Z(NB_Z)=J
      POSFAC_SOLVE(NB_Z)=TMP_SIZE8
      LRLUS_SOLVE(NB_Z)=SIZE_SOLVE_EMM
      LRLU_SOLVE_T(NB_Z)=SIZE_SOLVE_EMM
      LRLU_SOLVE_B(NB_Z)=0_8
      SIZE_SOLVE_Z(NB_Z)=SIZE_SOLVE_EMM
      CURRENT_POS_T(NB_Z)=J
      CURRENT_POS_B(NB_Z)=J
      POS_HOLE_T(NB_Z)=J
      POS_HOLE_B(NB_Z)=J
      IO_REQ=-77777
      REQ_ACT=0
      OOC_STATE_NODE(1:KEEP_OOC(28))=NOT_IN_MEM
      IF(KEEP_OOC(38).NE.0)THEN
         MASTER_ROOT=AGMG_MUMPS_275(STEP_OOC( KEEP_OOC(38)),                 &
     &        PROCNODE_OOC, SLAVEF_OOC )
         SPECIAL_ROOT_NODE=KEEP_OOC(38)
      ELSEIF(KEEP_OOC(20).NE.0)THEN
         MASTER_ROOT=AGMG_MUMPS_275(STEP_OOC( KEEP_OOC(20)),                 &
     &        PROCNODE_OOC, SLAVEF_OOC )
         SPECIAL_ROOT_NODE=KEEP_OOC(20)
      ELSE
         MASTER_ROOT=-111111
         SPECIAL_ROOT_NODE=-2222222
      ENDIF
      IF ( KEEP_OOC(60).EQ.0 .AND.                                      &
     &     (                                                            &
     &     (KEEP_OOC(38).NE.0 .AND.  id%root%yes)                       &
     &     .OR.                                                         &
     &     (KEEP_OOC(20).NE.0 .AND. MYID_OOC.EQ.MASTER_ROOT))           &
     &     )                                                            &
     &     THEN
        IS_ROOT_SPECIAL = .TRUE.
      ELSE
        IS_ROOT_SPECIAL = .FALSE.
      ENDIF
      NB_ZONE_REQ=0
      SIZE_ZONE_REQ=0_8
      CURRENT_SOLVE_READ_ZONE=0
      NB_CALLED=0
      NB_CALL=0
      SOLVE_STEP=-9999
      RETURN
      END SUBROUTINE DAGMG_MUMPS_586
      SUBROUTINE DAGMG_MUMPS_585(A,LA,PTRFAC,NSTEPS,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,IERR
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER I
      IERR=0
      IF(NB_Z.GT.1)THEN
         IF(STRAT_IO_ASYNC)THEN
            DO I=1,NB_Z-1
               CALL DAGMG_MUMPS_594(A,LA,PTRFAC,NSTEPS,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
            ENDDO
         ELSE
            CALL DAGMG_MUMPS_594(A,LA,PTRFAC,NSTEPS,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_585
      SUBROUTINE DAGMG_MUMPS_594(A,LA,PTRFAC,NSTEPS,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,IERR
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER ZONE,SIZE,DEST,FLAG
      CALL DAGMG_MUMPS_603(ZONE)
      IERR=0
      CALL DAGMG_MUMPS_611(ZONE,A,LA,PTRFAC,NSTEPS,IERR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_594
      SUBROUTINE DAGMG_MUMPS_595(DEST,INDICE,SIZE,                           &
     &     ZONE,PTRFAC,NSTEPS,POS_SEQ,NB_NODES,FLAG,IERR)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER ZONE,NSTEPS,FLAG,POS_SEQ,NB_NODES
      DOUBLE PRECISION DEST
      INTEGER (8) :: INDICE, SIZE, PTRFAC(NSTEPS)
      INTEGER REQUEST,INODE,IERR
      INTEGER ADDR_INT1,ADDR_INT2
      INTEGER TYPE
      INTEGER SIZE_INT1,SIZE_INT2
      TYPE=OOC_SOLVE_TYPE_FCT
      IERR=0
      INODE=OOC_INODE_SEQUENCE(POS_SEQ,OOC_FCT_TYPE)
      CALL AGMG_MUMPS_677(ADDR_INT1,ADDR_INT2,                               &
     &     OOC_VADDR(STEP_OOC(INODE),OOC_FCT_TYPE))
      CALL AGMG_MUMPS_677(SIZE_INT1,SIZE_INT2,                               &
     &     SIZE)
      CALL AGMG_NOCALL('MUMPS_LOW_LEVEL_READ_OOC_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ENDIF
      IF(STRAT_IO_ASYNC)THEN
         CALL DAGMG_MUMPS_597(INODE,SIZE,INDICE,ZONE,                        &
     &        REQUEST,POS_SEQ,NB_NODES,FLAG,PTRFAC,NSTEPS,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ELSE
         CALL DAGMG_MUMPS_597(INODE,SIZE,INDICE,ZONE,                        &
     &        REQUEST,POS_SEQ,NB_NODES,FLAG,PTRFAC,NSTEPS,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
         CALL DAGMG_MUMPS_596(IO_REQ(STEP_OOC(INODE)),                       &
     &        PTRFAC,NSTEPS)
         REQ_ACT=REQ_ACT-1
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_595
      SUBROUTINE DAGMG_MUMPS_596(REQUEST,PTRFAC,                             &
     &     NSTEPS)
      IMPLICIT NONE
      INTEGER NSTEPS,REQUEST
      INTEGER (8) :: PTRFAC(NSTEPS)
      INTEGER (8) :: LAST, POS_IN_S, J
      INTEGER ZONE
      INTEGER POS,POS_REQ,I,TMP_NODE,POS_IN_MANAGE
      INTEGER (8) SIZE
      INTEGER STATUS
      LOGICAL DONT_USE
      EXTERNAL AGMG_MUMPS_330,AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_330,AGMG_MUMPS_275
      POS_REQ=mod(REQUEST,MAX_NB_REQ)+1
      SIZE=SIZE_OF_READ(POS_REQ)
      I=FIRST_POS_IN_READ(POS_REQ)
      POS_IN_S=READ_DEST(POS_REQ)
      POS_IN_MANAGE=READ_MNG(POS_REQ)
      ZONE=REQ_TO_ZONE(POS_REQ)
      DONT_USE=.FALSE.
      J=0_8
      DO WHILE((J.LT.SIZE).AND.(I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)))
         TMP_NODE=OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
         LAST=SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
         IF(LAST.EQ.0_8)THEN
            I=I+1
            CYCLE
         ENDIF
         IF((INODE_TO_POS(STEP_OOC(TMP_NODE)).NE.0).AND.                &
     &        (INODE_TO_POS(STEP_OOC(TMP_NODE)).LT.                     &
     &        -((N_OOC+1)*NB_Z)))THEN
            DONT_USE=                                                   &
     &           (((MTYPE_OOC.EQ.1).AND.(KEEP_OOC(50).EQ.0).AND.        &
     &           (SOLVE_STEP.EQ.1).AND.                                 &
     &           ((AGMG_MUMPS_330(STEP_OOC(TMP_NODE),PROCNODE_OOC,           &
     &           SLAVEF_OOC).EQ.2).AND.(AGMG_MUMPS_275(                      &
     &           STEP_OOC(TMP_NODE),PROCNODE_OOC,SLAVEF_OOC).NE.        &
     &           MYID_OOC)))                                            &
     &           .OR.                                                   &
     &           ((MTYPE_OOC.NE.1).AND.(KEEP_OOC(50).EQ.0).AND.         &
     &           (SOLVE_STEP.EQ.0).AND.                                 &
     &           ((AGMG_MUMPS_330(STEP_OOC(TMP_NODE),PROCNODE_OOC,           &
     &           SLAVEF_OOC).EQ.2).AND.(AGMG_MUMPS_275(                      &
     &           STEP_OOC(TMP_NODE),PROCNODE_OOC,SLAVEF_OOC).NE.        &
     &           MYID_OOC)))).OR.                                       &
     &           (OOC_STATE_NODE(STEP_OOC(TMP_NODE)).EQ.ALREADY_USED)
            IF(DONT_USE)THEN
               PTRFAC(STEP_OOC(TMP_NODE))=-POS_IN_S
            ELSE
               PTRFAC(STEP_OOC(TMP_NODE))=POS_IN_S
            ENDIF
            IF(abs(PTRFAC(STEP_OOC(TMP_NODE))).LT.                      &
     &           IDEB_SOLVE_Z(ZONE))THEN
               WRITE(*,*)MYID_OOC,': Inernal error (42) in OOC ',       &
     &              PTRFAC(STEP_OOC(TMP_NODE)),IDEB_SOLVE_Z(ZONE)
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            IF(abs(PTRFAC(STEP_OOC(TMP_NODE))).GT.                      &
     &           (IDEB_SOLVE_Z(ZONE)+SIZE_SOLVE_Z(ZONE)-1_8))THEN
               WRITE(*,*)MYID_OOC,': Inernal error (43) in OOC '
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            IF(DONT_USE)THEN
               POS_IN_MEM(POS_IN_MANAGE)=-TMP_NODE
               INODE_TO_POS(STEP_OOC(TMP_NODE))=-POS_IN_MANAGE
               IF(OOC_STATE_NODE(STEP_OOC(TMP_NODE)).NE.                &
     &              ALREADY_USED)THEN
                  OOC_STATE_NODE(STEP_OOC(TMP_NODE))=USED_NOT_PERMUTED
               ENDIF
               LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)+LAST
            ELSE
               POS_IN_MEM(POS_IN_MANAGE)=TMP_NODE
               INODE_TO_POS(STEP_OOC(TMP_NODE))=POS_IN_MANAGE
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=NOT_USED
            ENDIF
            IO_REQ(STEP_OOC(TMP_NODE))=-7777
         ELSE
            POS_IN_MEM(POS_IN_MANAGE)=0
         ENDIF
         POS_IN_S=POS_IN_S+LAST
         POS_IN_MANAGE=POS_IN_MANAGE+1
         J=J+LAST
         I=I+1
      ENDDO
      SIZE_OF_READ(POS_REQ)=-9999_8
      FIRST_POS_IN_READ(POS_REQ)=-9999
      READ_DEST(POS_REQ)=-9999_8
      READ_MNG(POS_REQ)=-9999
      REQ_TO_ZONE(POS_REQ)=-9999
      REQ_ID(POS_REQ)=-9999
      RETURN
      END SUBROUTINE DAGMG_MUMPS_596
      SUBROUTINE DAGMG_MUMPS_597(INODE,SIZE,DEST,ZONE,                       &
     &     REQUEST,POS_SEQ,NB_NODES,FLAG,PTRFAC,NSTEPS,IERR)
      IMPLICIT NONE
      INTEGER INODE,ZONE,REQUEST,FLAG,POS_SEQ,NB_NODES,NSTEPS
      INTEGER(8) :: SIZE
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER(8) :: DEST, LOCAL_DEST, J8
      INTEGER I,TMP_NUM_FILE,TMP_NODE,LOC_I,POS_REQ,NB
      INTEGER(8)::LAST
      INTEGER, intent(out) :: IERR
      IERR=0
      IF(CUR_POS_SEQUENCE.GT.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))THEN
         RETURN
      ENDIF
      NB=0
      LOCAL_DEST=DEST
      I=POS_SEQ
      POS_REQ=mod(REQUEST,MAX_NB_REQ)+1
      IF(REQ_ID(POS_REQ).NE.-9999)THEN
         CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
         IF(IERR.LT.0)THEN
            IF (ICNTL1.GT.0)                                            &
     &      WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
            RETURN
         ENDIF
         CALL DAGMG_MUMPS_596(REQUEST,PTRFAC,NSTEPS)
         REQ_ACT=REQ_ACT-1
      ENDIF
      SIZE_OF_READ(POS_REQ)=SIZE
      FIRST_POS_IN_READ(POS_REQ)=I
      READ_DEST(POS_REQ)=DEST
      IF(FLAG.EQ.0)THEN
         READ_MNG(POS_REQ)=CURRENT_POS_B(ZONE)-NB_NODES+1
      ELSEIF(FLAG.EQ.1)THEN
         READ_MNG(POS_REQ)=CURRENT_POS_T(ZONE)
      ENDIF
      REQ_TO_ZONE(POS_REQ)=ZONE
      REQ_ID(POS_REQ)=REQUEST
      J8=0_8
      IF(FLAG.EQ.0)THEN
         LOC_I=CURRENT_POS_B(ZONE)-NB_NODES+1
      ENDIF
      DO WHILE((J8.LT.SIZE).AND.(I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)))
         TMP_NODE=OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
         LAST=SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
         IF(LAST.EQ.0_8)THEN
            INODE_TO_POS(STEP_OOC(TMP_NODE))=1
            OOC_STATE_NODE(STEP_OOC(TMP_NODE))=NOT_USED
            I=I+1
            CYCLE
         ENDIF
         IF((IO_REQ(STEP_OOC(TMP_NODE)).GE.0).OR.                       &
     &        (INODE_TO_POS(STEP_OOC(TMP_NODE)).NE.0))THEN
            IF(FLAG.EQ.1)THEN
               POS_IN_MEM(CURRENT_POS_T(ZONE))=0
            ELSEIF(FLAG.EQ.0)THEN
               POS_IN_MEM(CURRENT_POS_B(ZONE))=0
            ENDIF
         ELSE
            IO_REQ(STEP_OOC(TMP_NODE))=REQUEST
            LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)-LAST
            IF(FLAG.EQ.1)THEN
               IF(POSFAC_SOLVE(ZONE).EQ.IDEB_SOLVE_Z(ZONE))THEN
                  POS_HOLE_B(ZONE)=-9999
                  CURRENT_POS_B(ZONE)=-9999
                  LRLU_SOLVE_B(ZONE)=0_8
               ENDIF
               POSFAC_SOLVE(ZONE)=POSFAC_SOLVE(ZONE)+LAST
               LRLU_SOLVE_T(ZONE)=LRLU_SOLVE_T(ZONE)-LAST
               POS_IN_MEM(CURRENT_POS_T(ZONE))=-TMP_NODE-               &
     &              ((N_OOC+1)*NB_Z)
               INODE_TO_POS(STEP_OOC(TMP_NODE))=-CURRENT_POS_T(ZONE)-   &
     &              ((N_OOC+1)*NB_Z)
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=BEING_READ
               PTRFAC(STEP_OOC(TMP_NODE))=-LOCAL_DEST
               LOCAL_DEST=LOCAL_DEST+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),  &
     &              OOC_FCT_TYPE)
            ELSEIF(FLAG.EQ.0)THEN
               LRLU_SOLVE_B(ZONE)=LRLU_SOLVE_B(ZONE)-LAST
               POS_IN_MEM(LOC_I)=-TMP_NODE-((N_OOC+1)*NB_Z)
               IF(LOC_I.EQ.POS_HOLE_T(ZONE))THEN
                  IF(POS_HOLE_T(ZONE).LT.CURRENT_POS_T(ZONE))THEN
                     POS_HOLE_T(ZONE)=POS_HOLE_T(ZONE)+1
                  ENDIF
               ENDIF
               INODE_TO_POS(STEP_OOC(TMP_NODE))=-LOC_I-((N_OOC+1)*NB_Z)
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=BEING_READ
               PTRFAC(STEP_OOC(TMP_NODE))=-LOCAL_DEST
               LOCAL_DEST=LOCAL_DEST+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),  &
     &              OOC_FCT_TYPE)
            ELSE
             WRITE(*,*)MYID_OOC,': Internal error (39) in OOC ',        &
     &                 ' Invalid Flag Value in ',                       &
     &                 ' DMUMPS_597',FLAG
               CALL AGMG_MUMPS_ABORT()
            ENDIF
         ENDIF
         IF(POS_IN_MEM(CURRENT_POS_T(ZONE)).NE.0)THEN
            IF(POS_IN_MEM(CURRENT_POS_T(ZONE)).EQ.                      &
     &           POS_IN_MEM(PDEB_SOLVE_Z(ZONE)))THEN
               IF(CURRENT_POS_T(ZONE).NE.PDEB_SOLVE_Z(ZONE))THEN
             WRITE(*,*)MYID_OOC,': Internal error (40) in OOC ',        &
     &                      CURRENT_POS_T(ZONE),                        &
     &                 PDEB_SOLVE_Z(ZONE),                              &
     &                 POS_IN_MEM(CURRENT_POS_T(ZONE)),                 &
     &                 POS_IN_MEM(PDEB_SOLVE_Z(ZONE))
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
            ENDIF
         ENDIF
         J8=J8+LAST
         IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
             WRITE(*,*)MYID_OOC,': Internal error (41) in OOC ',        &
     &           ' LRLUS_SOLVE must be (1) > 0',                        &
     &           LRLUS_SOLVE(ZONE)
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         I=I+1
         IF(FLAG.EQ.1)THEN
            CURRENT_POS_T(ZONE)=CURRENT_POS_T(ZONE)+1
            IF(CURRENT_POS_T(ZONE).GT.                                  &
     &           MAX_NB_NODES_FOR_ZONE+PDEB_SOLVE_Z(ZONE))THEN
               WRITE(*,*)MYID_OOC,': Internal error (1) in OOC '
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            POS_HOLE_T(ZONE)=CURRENT_POS_T(ZONE)
         ELSEIF(FLAG.EQ.0)THEN
            IF(POS_HOLE_B(ZONE).LT.PDEB_SOLVE_Z(ZONE))THEN
               WRITE(*,*)MYID_OOC,': Internal error (2) in OOC ',       &
     &              POS_HOLE_B(ZONE),LOC_I
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            CURRENT_POS_B(ZONE)=CURRENT_POS_B(ZONE)-1
            POS_HOLE_B(ZONE)=CURRENT_POS_B(ZONE)
            IF(POS_HOLE_B(ZONE).LT.PDEB_SOLVE_Z(ZONE))THEN
               POS_HOLE_B(ZONE)=-9999
               LRLU_SOLVE_B(ZONE)=0_8
            ENDIF
         ELSE
            WRITE(*,*)MYID_OOC,': Internal error (3) in OOC ',          &
     &       ' Invalid Flag Value in ',                                 &
     &       ' DMUMPS_597',FLAG
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         IF(FLAG.EQ.0)THEN
            LOC_I=LOC_I+1
         ENDIF
         NB=NB+1
      ENDDO
      IF(NB.NE.NB_NODES)THEN
         WRITE(*,*)MYID_OOC,': Internal error (4) in OOC ',             &
     &        ' DMUMPS_597 ',NB,NB_NODES
      ENDIF
      IF(SOLVE_STEP.EQ.0)THEN
         CUR_POS_SEQUENCE=I
      ELSE
         CUR_POS_SEQUENCE=POS_SEQ-1
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_597
      SUBROUTINE DAGMG_MUMPS_598(INODE,PTRFAC,NSTEPS,A,                      &
     &     LA,FLAG,IERR)
      IMPLICIT NONE
      INTEGER(8) :: LA
      INTEGER, intent(out):: IERR
      DOUBLE PRECISION A(LA)
      INTEGER INODE,NSTEPS
      INTEGER(8) :: PTRFAC(NSTEPS)
      LOGICAL FLAG
      INTEGER(8) FREE_SIZE, FREE_HOLE_POS
      INTEGER TMP,TMP_NODE,I,ZONE,J, FREE_HOLE_FLAG
      LOGICAL CONTIGUOUS
      INTEGER WHICH
      INTEGER(8) :: DUMMY_SIZE
      DUMMY_SIZE=1_8
      IERR = 0
      WHICH=-1
      IF(INODE_TO_POS(STEP_OOC(INODE)).LE.0)THEN
         WRITE(*,*)MYID_OOC,': Internal error (5) in OOC ',             &
     &            ' Problem in DMUMPS_598',                             &
     &        INODE, STEP_OOC(INODE), INODE_TO_POS(STEP_OOC(INODE))
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE).EQ.0_8)THEN
         INODE_TO_POS(STEP_OOC(INODE))=0
         OOC_STATE_NODE(STEP_OOC(INODE))=ALREADY_USED
         RETURN
      ENDIF
      CALL DAGMG_MUMPS_600(INODE,ZONE,PTRFAC,NSTEPS)
      TMP=INODE_TO_POS(STEP_OOC(INODE))
      INODE_TO_POS(STEP_OOC(INODE))=-TMP
      POS_IN_MEM(TMP)=-INODE
      PTRFAC(STEP_OOC(INODE))=-PTRFAC(STEP_OOC(INODE))
      IF(OOC_STATE_NODE(STEP_OOC(INODE)).NE.PERMUTED)THEN
         WRITE(*,*)MYID_OOC,': INTERNAL ERROR (53) in OOC',INODE,       &
     &        OOC_STATE_NODE(STEP_OOC(INODE))
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      OOC_STATE_NODE(STEP_OOC(INODE))=USED
      LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)+                              &
     &        SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
         WRITE(*,*)MYID_OOC,': Internal error (6) in OOC ',             &
     &        ': LRLUS_SOLVE must be (2) > 0'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(ZONE.EQ.NB_Z)THEN
         IF(INODE.NE.SPECIAL_ROOT_NODE)THEN
            CALL DAGMG_MUMPS_608(A,FACT_AREA_SIZE,                           &
     &           DUMMY_SIZE,PTRFAC,KEEP_OOC(28),ZONE,IERR)
         ENDIF
      ELSE
         FREE_HOLE_FLAG=0
         IF(SOLVE_STEP.EQ.0)THEN
            IF(TMP.GT.POS_HOLE_B(ZONE))THEN
               WHICH=0
            ELSEIF(TMP.LT.POS_HOLE_T(ZONE))THEN
               WHICH=1
            ENDIF
         ELSEIF(SOLVE_STEP.EQ.1)THEN
            IF(TMP.LT.POS_HOLE_T(ZONE))THEN
               WHICH=1
            ELSEIF(TMP.GT.POS_HOLE_B(ZONE))THEN
               WHICH=0
            ENDIF
         ENDIF
         IF(WHICH.EQ.1)THEN
            J=max(PDEB_SOLVE_Z(ZONE),POS_HOLE_T(ZONE))
            J=min(J,PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)
            FREE_SIZE=0_8
            DO I=J,TMP,-1
               IF((POS_IN_MEM(I).LT.0).AND.(POS_IN_MEM(I).GT.           &
     &              -(N_OOC+1)*NB_Z))THEN
                  TMP_NODE=-POS_IN_MEM(I)
                  FREE_SIZE=FREE_SIZE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE), &
     &                 OOC_FCT_TYPE)
               ELSEIF(POS_IN_MEM(I).NE.0)THEN
                  GOTO 666
               ENDIF
            ENDDO
            POS_HOLE_T(ZONE)=TMP
  666       CONTINUE
         ELSEIF(WHICH.EQ.0)THEN
            J=max(PDEB_SOLVE_Z(ZONE),POS_HOLE_B(ZONE))
            J=min(J,PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)
            FREE_SIZE=0_8
            DO I=J,TMP
               IF((POS_IN_MEM(I).LT.0).AND.(POS_IN_MEM(I).GT.           &
     &              -(N_OOC+1)*NB_Z))THEN
                  TMP_NODE=-POS_IN_MEM(I)
                  FREE_SIZE=FREE_SIZE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE), &
     &                 OOC_FCT_TYPE)
               ELSEIF(POS_IN_MEM(I).NE.0)THEN
                  IF(J.EQ.PDEB_SOLVE_Z(ZONE))THEN
                     POS_HOLE_B(ZONE)=-9999
                     LRLU_SOLVE_B(ZONE)=0_8
                     CURRENT_POS_B(ZONE)=-9999
                  ENDIF
                  GOTO 777
               ENDIF
            ENDDO
            POS_HOLE_B(ZONE)=TMP
  777       CONTINUE
         ENDIF
  222 CONTINUE
      IERR=0
      ENDIF
      IF((NB_Z.GT.1).AND.FLAG)THEN
         CALL DAGMG_MUMPS_601(ZONE)
         IF((LRLUS_SOLVE(ZONE).GE.MIN_SIZE_READ).OR.                    &
     &        (LRLUS_SOLVE(ZONE).GE.                                    &
     &        int(0.3D0*dble(SIZE_SOLVE_Z(ZONE)),8)))THEN
            CALL DAGMG_MUMPS_594(A,LA,PTRFAC,NSTEPS,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
         ELSE
            CALL DAGMG_MUMPS_603(ZONE)
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_598
      FUNCTION DAGMG_MUMPS_726(INODE,PTRFAC,NSTEPS,A,LA,                     &
     &     IERR)
      IMPLICIT NONE
      INTEGER INODE,NSTEPS
      INTEGER(8) :: LA
      INTEGER, INTENT(out)::IERR
      DOUBLE PRECISION A(LA)
      INTEGER (8) :: PTRFAC(NSTEPS)
      INTEGER DAGMG_MUMPS_726
      INTEGER ZONE
      IERR=0
      IF(INODE_TO_POS(STEP_OOC(INODE)).GT.0)THEN
         IF(OOC_STATE_NODE(STEP_OOC(INODE)).EQ.PERMUTED)THEN
            DAGMG_MUMPS_726=OOC_NODE_PERMUTED
         ELSE
            DAGMG_MUMPS_726=OOC_NODE_NOT_PERMUTED
         ENDIF
         IF(.NOT.DAGMG_MUMPS_727())THEN
            IF(OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,OOC_FCT_TYPE)        &
     &           .EQ.INODE)THEN
               IF(SOLVE_STEP.EQ.0)THEN
                  CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
               ELSEIF(SOLVE_STEP.EQ.1)THEN
                  CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
               ENDIF
               CALL DAGMG_MUMPS_728()
            ENDIF
         ENDIF
      ELSEIF(INODE_TO_POS(STEP_OOC(INODE)).LT.0)THEN
         IF(INODE_TO_POS(STEP_OOC(INODE)).LT.-((N_OOC+1)*NB_Z))THEN
            CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
            IF(IERR.LT.0)THEN
               IF (ICNTL1.GT.0)                                         &
     &         WRITE(ICNTL1,*)MYID_OOC,': Internal error (7) in OOC ',  &
     &                   ERR_STR_OOC(1:DIM_ERR_STR_OOC)
               RETURN
            ENDIF
            CALL DAGMG_MUMPS_596(IO_REQ(STEP_OOC(INODE)),                    &
     &           PTRFAC,NSTEPS)
            REQ_ACT=REQ_ACT-1
         ELSE
            CALL DAGMG_MUMPS_599(INODE,PTRFAC,NSTEPS)
            IF(.NOT.DAGMG_MUMPS_727())THEN
               IF(OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,OOC_FCT_TYPE).EQ. &
     &              INODE)THEN
                  IF(SOLVE_STEP.EQ.0)THEN
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
                  ELSEIF(SOLVE_STEP.EQ.1)THEN
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
                  ENDIF
                  CALL DAGMG_MUMPS_728()
               ENDIF
            ENDIF
         ENDIF
         IF(OOC_STATE_NODE(STEP_OOC(INODE)).EQ.PERMUTED)THEN
            DAGMG_MUMPS_726=OOC_NODE_PERMUTED
         ELSE
            DAGMG_MUMPS_726=OOC_NODE_NOT_PERMUTED
         ENDIF
      ELSE
         DAGMG_MUMPS_726=OOC_NODE_NOT_IN_MEM
      ENDIF
      RETURN
      END FUNCTION DAGMG_MUMPS_726
      SUBROUTINE DAGMG_MUMPS_682(INODE)
      IMPLICIT NONE
      INTEGER INODE
      IF(OOC_STATE_NODE(STEP_OOC(INODE)).NE.NOT_USED)THEN
         WRITE(*,*)MYID_OOC,': INTERNAL ERROR (51) in OOC',INODE,       &
     &        OOC_STATE_NODE(STEP_OOC(INODE))
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      OOC_STATE_NODE(STEP_OOC(INODE))=PERMUTED
      END SUBROUTINE DAGMG_MUMPS_682
      SUBROUTINE DAGMG_MUMPS_599(INODE,PTRFAC,NSTEPS)
      IMPLICIT NONE
      INTEGER INODE,NSTEPS
      INTEGER (8) :: PTRFAC(NSTEPS)
      INTEGER ZONE
      INODE_TO_POS(STEP_OOC(INODE))=-INODE_TO_POS(STEP_OOC(INODE))
      POS_IN_MEM(INODE_TO_POS(STEP_OOC(INODE)))=                        &
     &     -POS_IN_MEM(INODE_TO_POS(STEP_OOC(INODE)))
      PTRFAC(STEP_OOC(INODE))=-PTRFAC(STEP_OOC(INODE))
      IF(OOC_STATE_NODE(STEP_OOC(INODE)).EQ.USED_NOT_PERMUTED)THEN
         OOC_STATE_NODE(STEP_OOC(INODE))=NOT_USED
      ELSEIF(OOC_STATE_NODE(STEP_OOC(INODE)).EQ.USED)THEN
         OOC_STATE_NODE(STEP_OOC(INODE))=PERMUTED
      ELSE
         WRITE(*,*)MYID_OOC,': Internal error (52) in OOC',INODE,       &
     &        OOC_STATE_NODE(STEP_OOC(INODE)),                          &
     &        INODE_TO_POS(STEP_OOC(INODE))
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      CALL DAGMG_MUMPS_610(PTRFAC(STEP_OOC(INODE)),ZONE)
      IF(INODE_TO_POS(STEP_OOC(INODE)).LE.POS_HOLE_B(ZONE))THEN
         IF(INODE_TO_POS(STEP_OOC(INODE)).GT.                           &
     &        PDEB_SOLVE_Z(ZONE))THEN
            POS_HOLE_B(ZONE)=                                           &
     &           INODE_TO_POS(STEP_OOC(INODE))-1
         ELSE
            CURRENT_POS_B(ZONE)=-9999
            POS_HOLE_B(ZONE)=-9999
            LRLU_SOLVE_B(ZONE)=0_8
         ENDIF
      ENDIF
      IF(INODE_TO_POS(STEP_OOC(INODE)).GE.POS_HOLE_T(ZONE))THEN
         IF(INODE_TO_POS(STEP_OOC(INODE)).LT.                           &
     &        CURRENT_POS_T(ZONE)-1)THEN
            POS_HOLE_T(ZONE)=INODE_TO_POS(STEP_OOC(INODE))+1
         ELSE
            POS_HOLE_T(ZONE)=CURRENT_POS_T(ZONE)
         ENDIF
      ENDIF
      CALL DAGMG_MUMPS_609(INODE,PTRFAC,NSTEPS,1)
      END SUBROUTINE DAGMG_MUMPS_599
      SUBROUTINE DAGMG_MUMPS_600(INODE,ZONE,PTRFAC,NSTEPS)
      IMPLICIT NONE
      INTEGER INODE,ZONE,NSTEPS
      INTEGER (8) :: PTRFAC(NSTEPS)
      ZONE=1
      DO WHILE (ZONE.LE.NB_Z)
         IF(PTRFAC(STEP_OOC(INODE)).LT.IDEB_SOLVE_Z(ZONE))THEN
            ZONE=ZONE-1
            EXIT
         ENDIF
         ZONE=ZONE+1
      ENDDO
      IF(ZONE.EQ.NB_Z+1)THEN
         ZONE=ZONE-1
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_600
      SUBROUTINE DAGMG_MUMPS_601(ZONE)
      IMPLICIT NONE
      INTEGER ZONE
      ZONE=mod((CURRENT_SOLVE_READ_ZONE+1),NB_Z-1)+1
      END SUBROUTINE DAGMG_MUMPS_601
      SUBROUTINE DAGMG_MUMPS_603(ZONE)
      IMPLICIT NONE
      INTEGER ZONE
      IF(NB_Z.GT.1)THEN
         CURRENT_SOLVE_READ_ZONE=mod((CURRENT_SOLVE_READ_ZONE+1),NB_Z-1)
         ZONE=CURRENT_SOLVE_READ_ZONE+1
      ELSE
         ZONE=NB_Z
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_603
      SUBROUTINE DAGMG_MUMPS_578(INODE,PTRFAC,                               &
     &     KEEP,KEEP8,                                                  &
     &     A,IERR)
      IMPLICIT NONE
      INTEGER INODE,KEEP(500)
      INTEGER, intent(out)::IERR
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION A(FACT_AREA_SIZE)
      INTEGER(8) :: REQUESTED_SIZE
      INTEGER ZONE,IFLAG
      LOGICAL FLAG
      IERR=0
      IFLAG=0
      IF(SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)                    &
     &     .EQ.0_8)THEN
         INODE_TO_POS(STEP_OOC(INODE))=1
         OOC_STATE_NODE(STEP_OOC(INODE))=NOT_USED
         PTRFAC(STEP_OOC(INODE))=1
         RETURN
      ENDIF
      REQUESTED_SIZE=SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      ZONE=NB_Z
      IF(CURRENT_POS_T(ZONE).GT.                                        &
     &     (PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1))THEN
         CALL DAGMG_MUMPS_608(A,FACT_AREA_SIZE,                              &
     &        REQUESTED_SIZE,PTRFAC,KEEP(28),ZONE,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ENDIF
      IF((LRLU_SOLVE_T(ZONE).GT.SIZE_OF_BLOCK(STEP_OOC(INODE),          &
     &     OOC_FCT_TYPE)).AND.                                          &
     &     (CURRENT_POS_T(ZONE).LE.                                     &
     &     (PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)))THEN
         CALL DAGMG_MUMPS_606(INODE,PTRFAC,                                  &
     &        KEEP,KEEP8,A,ZONE)
      ELSEIF(LRLU_SOLVE_B(ZONE).GT.SIZE_OF_BLOCK(STEP_OOC(INODE),       &
     &        OOC_FCT_TYPE).AND.                                        &
     &        (CURRENT_POS_B(ZONE).GT.0))THEN
         CALL DAGMG_MUMPS_607(INODE,PTRFAC,                                  &
     &        KEEP,KEEP8,A,ZONE)
      ELSE
         IF(DAGMG_MUMPS_579(INODE,ZONE))THEN
            IF(SOLVE_STEP.EQ.0)THEN
               CALL DAGMG_MUMPS_604(A,FACT_AREA_SIZE,                        &
     &              REQUESTED_SIZE,PTRFAC,                              &
     &              KEEP(28),ZONE,IFLAG,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
               IF(IFLAG.EQ.1)THEN
                  CALL DAGMG_MUMPS_606(INODE,PTRFAC,                         &
     &                 KEEP,KEEP8,A,ZONE)
               ELSEIF(IFLAG.EQ.0)THEN
                  CALL DAGMG_MUMPS_605(A,FACT_AREA_SIZE,                     &
     &                 REQUESTED_SIZE,PTRFAC,                           &
     &                 KEEP(28),ZONE,IFLAG,IERR)
                  IF(IERR.LT.0)THEN
                     RETURN
                  ENDIF
                  IF(IFLAG.EQ.1)THEN
                     CALL DAGMG_MUMPS_607(INODE,PTRFAC,                      &
     &                    KEEP,KEEP8,A,ZONE)
                  ENDIF
               ENDIF
            ELSE
               CALL DAGMG_MUMPS_605(A,FACT_AREA_SIZE,                        &
     &              REQUESTED_SIZE,PTRFAC,                              &
     &              KEEP(28),ZONE,IFLAG,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
               IF(IFLAG.EQ.1)THEN
                  CALL DAGMG_MUMPS_607(INODE,PTRFAC,                         &
     &                 KEEP,KEEP8,A,ZONE)
               ELSEIF(IFLAG.EQ.0)THEN
                  CALL DAGMG_MUMPS_604(A,FACT_AREA_SIZE,                     &
     &                 REQUESTED_SIZE,PTRFAC,                           &
     &                 KEEP(28),ZONE,IFLAG,IERR)
                  IF(IERR.LT.0)THEN
                     RETURN
                  ENDIF
                  IF(IFLAG.EQ.1)THEN
                     CALL DAGMG_MUMPS_606(INODE,PTRFAC,                      &
     &                    KEEP,KEEP8,A,ZONE)
                  ENDIF
               ENDIF
            ENDIF
            IF(IFLAG.EQ.0)THEN
               CALL DAGMG_MUMPS_608(A,FACT_AREA_SIZE,                        &
     &              REQUESTED_SIZE,PTRFAC,KEEP(28),ZONE,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
               CALL DAGMG_MUMPS_606(INODE,PTRFAC,                            &
     &              KEEP,KEEP8,A,ZONE)
            ENDIF
         ELSE
            WRITE(*,*)MYID_OOC,': Internal error (8) in OOC ',          &
     &                         ' Not enough space for Solve',INODE,     &
     &           SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE),           &
     &           LRLUS_SOLVE(ZONE)
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
      IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
         WRITE(*,*)MYID_OOC,': Internal error (9) in OOC ',             &
     &                      ' LRLUS_SOLVE must be (3) > 0'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_578
      SUBROUTINE DAGMG_MUMPS_604(A,LA,REQUESTED_SIZE,PTRFAC,                 &
     &     NSTEPS,ZONE,FLAG,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,ZONE,FLAG
      INTEGER(8) :: REQUESTED_SIZE, LA
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER(8) :: FREE_SIZE, FREE_HOLE, FREE_HOLE_POS
      DOUBLE PRECISION A(LA)
      INTEGER I,TMP_NODE,FREE_HOLE_FLAG, J
      INTEGER, intent(out)::IERR
      LOGICAL FLAG_HOLE
      IERR=0
      FLAG=0
      IF(LRLU_SOLVE_T(ZONE).EQ.SIZE_SOLVE_Z(ZONE).AND.                  &
     &     (.NOT.(CURRENT_POS_T(ZONE)                                   &
     &     .GT.PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)))THEN
         GOTO 50
      ENDIF
      J=max(POS_HOLE_B(ZONE),PDEB_SOLVE_Z(ZONE))
      J=min(J,PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)
      DO I=POS_HOLE_T(ZONE)-1,J,-1
         IF((POS_IN_MEM(I).LT.0).AND.(POS_IN_MEM(I).GT.                 &
     &        -(N_OOC+1)*NB_Z))THEN
            TMP_NODE=-POS_IN_MEM(I)
         ELSEIF(POS_IN_MEM(I).NE.0)THEN
            EXIT
         ENDIF
      ENDDO
      POS_HOLE_T(ZONE)=I+1
      IF((POS_HOLE_T(ZONE).EQ.PDEB_SOLVE_Z(ZONE)).OR.                   &
     &     (POS_HOLE_T(ZONE).LE.POS_HOLE_B(ZONE)).OR.                   &
     &     (POS_HOLE_T(ZONE).EQ.POS_HOLE_B(ZONE)+1))THEN
         CURRENT_POS_B(ZONE)=-9999
         POS_HOLE_B(ZONE)=-9999
         LRLU_SOLVE_B(ZONE)=0_8
         POS_HOLE_T(ZONE)=PDEB_SOLVE_Z(ZONE)
      ENDIF
      FREE_HOLE=0_8
      FREE_SIZE=0_8
      FREE_HOLE_FLAG=0
      FREE_HOLE_POS=POSFAC_SOLVE(ZONE)
      DO I=CURRENT_POS_T(ZONE)-1,POS_HOLE_T(ZONE),-1
         IF((POS_IN_MEM(I).LT.0).AND.(POS_IN_MEM(I).GT.                 &
     &        -(N_OOC+1)*NB_Z))THEN
            TMP_NODE=-POS_IN_MEM(I)
            IF(FREE_HOLE_FLAG.EQ.1)THEN
               FREE_HOLE=FREE_HOLE_POS-                                 &
     &              (abs(PTRFAC(STEP_OOC(TMP_NODE)))+                   &
     &              SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
               FREE_HOLE_FLAG=0
               FREE_SIZE=FREE_SIZE+FREE_HOLE
            ENDIF
            FREE_HOLE_POS=abs(PTRFAC(STEP_OOC(TMP_NODE)))
            PTRFAC(STEP_OOC(TMP_NODE))=-777777_8
            INODE_TO_POS(STEP_OOC(TMP_NODE))=0
            OOC_STATE_NODE(STEP_OOC(TMP_NODE))=ALREADY_USED
            POS_IN_MEM(I)=0
            FREE_SIZE=FREE_SIZE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),       &
     &           OOC_FCT_TYPE)
         ELSEIF(POS_IN_MEM(I).EQ.0)THEN
            FREE_HOLE_FLAG=1
         ELSEIF(POS_IN_MEM(I).NE.0)THEN
            WRITE(*,*)MYID_OOC,': Internal error (10) in OOC ',         &
     &            ' DMUMPS_604',                                        &
     &           CURRENT_POS_T(ZONE)-1,POS_HOLE_T(ZONE),I
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDDO
      IF(POS_HOLE_T(ZONE).EQ.PDEB_SOLVE_Z(ZONE))THEN
         IF(FREE_HOLE_FLAG.EQ.0)THEN
            FREE_HOLE_FLAG=1
         ENDIF
      ENDIF
      IF(FREE_HOLE_FLAG.EQ.1)THEN
         IF(POS_HOLE_T(ZONE)-1.GT.PDEB_SOLVE_Z(ZONE))THEN
            I=POS_HOLE_T(ZONE)-1
            TMP_NODE=abs(POS_IN_MEM(I))
            IF(TMP_NODE.GT.(N_OOC+1)*NB_Z)THEN
               TMP_NODE=TMP_NODE-(N_OOC+1)*NB_Z
               CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
               IF(IERR.LT.0)THEN
                  WRITE(*,*)MYID_OOC,': Internal error (11) in OOC ',   &
     &                               ERR_STR_OOC(1:DIM_ERR_STR_OOC)
                  CALL AGMG_MUMPS_ABORT()
                  RETURN
               ENDIF
               REQ_ACT=REQ_ACT-1
               CALL DAGMG_MUMPS_596(                                         &
     &              IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
               FREE_HOLE=FREE_HOLE_POS-                                 &
     &              (abs(PTRFAC(STEP_OOC(TMP_NODE)))+                   &
     &              SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
            ELSEIF(TMP_NODE.EQ.0)THEN
               DO J=I,PDEB_SOLVE_Z(ZONE),-1
                  IF(POS_IN_MEM(J).NE.0) EXIT
               ENDDO
               IF(POS_IN_MEM(J).LT.0)THEN
                  WRITE(*,*)MYID_OOC,': Internal error (12) in OOC ',   &
     &                 ' DMUMPS_604'
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               IF(J.GE.PDEB_SOLVE_Z(ZONE))THEN
                  TMP_NODE=POS_IN_MEM(J)
                  FREE_HOLE=FREE_HOLE_POS-                              &
     &                 (abs(PTRFAC(STEP_OOC(TMP_NODE)))+                &
     &                 SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
               ELSE
                  FREE_HOLE=FREE_HOLE_POS-IDEB_SOLVE_Z(ZONE)
               ENDIF
            ELSEIF(TMP_NODE.LT.0)THEN
               WRITE(*,*)MYID_OOC,': Internal error (13) in OOC',       &
     &           ' DMUMPS_604'
               CALL AGMG_MUMPS_ABORT()
            ELSE
               FREE_HOLE=FREE_HOLE_POS-                                 &
     &              (abs(PTRFAC(STEP_OOC(TMP_NODE)))+                   &
     &              SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
            ENDIF
         ELSE
            FREE_HOLE=FREE_HOLE_POS-IDEB_SOLVE_Z(ZONE)
         ENDIF
         FREE_SIZE=FREE_SIZE+FREE_HOLE
      ENDIF
      CURRENT_POS_T(ZONE)=POS_HOLE_T(ZONE)
      LRLU_SOLVE_T(ZONE)=LRLU_SOLVE_T(ZONE)+FREE_SIZE
      POSFAC_SOLVE(ZONE)=POSFAC_SOLVE(ZONE)-FREE_SIZE
   50 CONTINUE
      IF(REQUESTED_SIZE.LE.LRLU_SOLVE_T(ZONE))THEN
         FLAG=1
      ELSE
         FLAG=0
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_604
      SUBROUTINE DAGMG_MUMPS_605(A,LA,REQUESTED_SIZE,                        &
     &     PTRFAC,NSTEPS,ZONE,FLAG,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,ZONE,FLAG
      INTEGER (8) :: REQUESTED_SIZE
      INTEGER (8) :: LA
      INTEGER (8) :: PTRFAC(NSTEPS)
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: FREE_SIZE, FREE_HOLE_POS, FREE_HOLE
      INTEGER I,J,TMP_NODE,FREE_HOLE_FLAG
      INTEGER, intent(out) :: IERR
      IERR=0
      FLAG=0
      IF(LRLU_SOLVE_B(ZONE).EQ.SIZE_SOLVE_Z(ZONE))THEN
         GOTO 50
      ENDIF
      IF(POS_HOLE_B(ZONE).EQ.-9999)THEN
         GOTO 50
      ENDIF
      J=max(PDEB_SOLVE_Z(ZONE),POS_HOLE_T(ZONE))
      J=min(J,PDEB_SOLVE_Z(ZONE)+MAX_NB_NODES_FOR_ZONE-1)
      DO I=POS_HOLE_B(ZONE)+1,J
         IF((POS_IN_MEM(I).LT.0).AND.(POS_IN_MEM(I).GT.                 &
     &        -(N_OOC+1)*NB_Z))THEN
            TMP_NODE=-POS_IN_MEM(I)
            FREE_SIZE=FREE_SIZE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),       &
     &           OOC_FCT_TYPE)
         ELSEIF(POS_IN_MEM(I).NE.0)THEN
            EXIT
         ENDIF
      ENDDO
      POS_HOLE_B(ZONE)=I-1
      IF((POS_HOLE_T(ZONE).EQ.PDEB_SOLVE_Z(ZONE)).OR.                   &
     &     (POS_HOLE_T(ZONE).LE.POS_HOLE_B(ZONE)).OR.                   &
     &     (POS_HOLE_T(ZONE).EQ.POS_HOLE_B(ZONE)+1))THEN
         CURRENT_POS_B(ZONE)=-9999
         POS_HOLE_B(ZONE)=-9999
         LRLU_SOLVE_B(ZONE)=0_8
         POS_HOLE_T(ZONE)=PDEB_SOLVE_Z(ZONE)
      ENDIF
      FREE_HOLE=0_8
      FREE_SIZE=0_8
      FREE_HOLE_FLAG=0
      FREE_HOLE_POS=IDEB_SOLVE_Z(ZONE)
      IF(POS_HOLE_B(ZONE).EQ.-9999)THEN
         GOTO 50
      ENDIF
      DO I=PDEB_SOLVE_Z(ZONE),POS_HOLE_B(ZONE)
         IF((POS_IN_MEM(I).LE.0).AND.(POS_IN_MEM(I).GT.                 &
     &        -(N_OOC+1)*NB_Z))THEN
            TMP_NODE=-POS_IN_MEM(I)
            IF(TMP_NODE.NE.0)THEN
               IF(I.EQ.PDEB_SOLVE_Z(ZONE))THEN
                  IF(abs(PTRFAC(STEP_OOC(TMP_NODE))).NE.                &
     &                 IDEB_SOLVE_Z(ZONE))THEN
                     FREE_SIZE=FREE_SIZE+abs(PTRFAC(STEP_OOC(TMP_NODE)))&
     &                    -IDEB_SOLVE_Z(ZONE)
                  ENDIF
               ENDIF
               IF(FREE_HOLE_FLAG.EQ.1)THEN
                  FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-            &
     &                 FREE_HOLE_POS
                  FREE_HOLE_FLAG=0
                  FREE_SIZE=FREE_SIZE+FREE_HOLE
               ENDIF
               FREE_HOLE_POS=abs(PTRFAC(STEP_OOC(TMP_NODE)))+           &
     &              SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
               PTRFAC(STEP_OOC(TMP_NODE))=-777777_8
               INODE_TO_POS(STEP_OOC(TMP_NODE))=0
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=ALREADY_USED
               FREE_SIZE=FREE_SIZE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),    &
     &              OOC_FCT_TYPE)
            ELSE
               FREE_HOLE_FLAG=1
            ENDIF
            POS_IN_MEM(I)=0
         ELSEIF(POS_IN_MEM(I).NE.0)THEN
            WRITE(*,*)MYID_OOC,': Internal error (14) in OOC ',         &
     &            ' DMUMPS_605',                                        &
     &           CURRENT_POS_T(ZONE)-1,POS_HOLE_B(ZONE),I,POS_IN_MEM(I)
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDDO
      IF(FREE_HOLE_FLAG.EQ.1)THEN
         IF(POS_HOLE_B(ZONE)+1.LT.CURRENT_POS_T(ZONE)-1)THEN
            I=POS_HOLE_B(ZONE)+1
            TMP_NODE=abs(POS_IN_MEM(I))
            IF(TMP_NODE.GT.(N_OOC+1)*NB_Z)THEN
               TMP_NODE=TMP_NODE-(N_OOC+1)*NB_Z
               CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
               IF(IERR.LT.0)THEN
                 WRITE(*,*)MYID_OOC,': Internal error (15) in OOC ',    &
     &                               ERR_STR_OOC(1:DIM_ERR_STR_OOC)
                 CALL AGMG_MUMPS_ABORT()
                  RETURN
               ENDIF
               REQ_ACT=REQ_ACT-1
               CALL DAGMG_MUMPS_596(                                         &
     &              IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
               FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-FREE_HOLE_POS
            ELSEIF(TMP_NODE.EQ.0)THEN
               DO J=I,CURRENT_POS_T(ZONE)-1
                  IF(POS_IN_MEM(J).NE.0) EXIT
               ENDDO
               IF(POS_IN_MEM(J).LT.0)THEN
                  WRITE(*,*)MYID_OOC,': Internal error (16) in OOC ',   &
     &                  ' DMUMPS_605'
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               IF(J.LE.CURRENT_POS_T(ZONE)-1)THEN
                  TMP_NODE=POS_IN_MEM(J)
                  FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-            &
     &                 FREE_HOLE_POS
               ELSE
                  FREE_HOLE=POSFAC_SOLVE(ZONE)-FREE_HOLE_POS
               ENDIF
            ELSEIF(TMP_NODE.LT.0)THEN
               WRITE(*,*)MYID_OOC,': Internal error (17) in OOC ',      &
     &           ' DMUMPS_605'
               CALL AGMG_MUMPS_ABORT()
            ELSE
               FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-               &
     &              FREE_HOLE_POS
            ENDIF
         ELSE
            FREE_HOLE=POSFAC_SOLVE(ZONE)-FREE_HOLE_POS
         ENDIF
         FREE_SIZE=FREE_SIZE+FREE_HOLE
      ENDIF
      LRLU_SOLVE_B(ZONE)=FREE_SIZE
      IF(POS_HOLE_B(ZONE).LT.CURRENT_POS_T(ZONE)-1)THEN
         TMP_NODE=POS_IN_MEM(POS_HOLE_B(ZONE)+1)
         IF(TMP_NODE.LT.-(N_OOC+1)*NB_Z)THEN
            TMP_NODE=abs(TMP_NODE)-(N_OOC+1)*NB_Z
            CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
            IF(IERR.LT.0)THEN
               WRITE(*,*)MYID_OOC,': Internal error (18) in OOC ',      &
     &                            ERR_STR_OOC(1:DIM_ERR_STR_OOC)
               CALL AGMG_MUMPS_ABORT()
               RETURN
            ENDIF
            REQ_ACT=REQ_ACT-1
            CALL DAGMG_MUMPS_596(                                            &
     &           IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
         ENDIF
         LRLU_SOLVE_B(ZONE)=LRLU_SOLVE_B(ZONE)+                         &
     &        (abs(PTRFAC(STEP_OOC(abs(TMP_NODE))))-IDEB_SOLVE_Z(ZONE)- &
     &        LRLU_SOLVE_B(ZONE))
      ENDIF
      CURRENT_POS_B(ZONE)=POS_HOLE_B(ZONE)
   50 CONTINUE
      IF((POS_HOLE_B(ZONE).EQ.-9999).AND.                               &
     &   (LRLU_SOLVE_B(ZONE).NE.0_8))THEN
         WRITE(*,*)MYID_OOC,': Internal error (19) in OOC ',            &
     &             'DMUMPS_605'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF((REQUESTED_SIZE.LE.LRLU_SOLVE_B(ZONE)).AND.                    &
     &     (POS_HOLE_B(ZONE).NE.-9999))THEN
         FLAG=1
      ELSE
         FLAG=0
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_605
      SUBROUTINE DAGMG_MUMPS_606(INODE,PTRFAC,                               &
     &           KEEP,KEEP8, A,ZONE)
      IMPLICIT NONE
      INTEGER INODE,KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION A(FACT_AREA_SIZE)
      INTEGER REQUESTED_SIZE
      INTEGER ZONE,IFLAG
      LOGICAL FLAG
      LRLU_SOLVE_T(ZONE)=LRLU_SOLVE_T(ZONE)-                            &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)-                              &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      PTRFAC(STEP_OOC(INODE))=POSFAC_SOLVE(ZONE)
      OOC_STATE_NODE(STEP_OOC(INODE))=NOT_USED
      IF(POSFAC_SOLVE(ZONE).EQ.IDEB_SOLVE_Z(ZONE))THEN
         POS_HOLE_B(ZONE)=-9999
         CURRENT_POS_B(ZONE)=-9999
         LRLU_SOLVE_B(ZONE)=0_8
      ENDIF
      IF(PTRFAC(STEP_OOC(INODE)).LT.IDEB_SOLVE_Z(ZONE))THEN
         WRITE(*,*)MYID_OOC,': Internal error (20) in OOC ',            &
     &                      ' Problem avec debut (2)',INODE,            &
     &              PTRFAC(STEP_OOC(INODE)),IDEB_SOLVE_Z(ZONE),ZONE
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      INODE_TO_POS(STEP_OOC(INODE))=CURRENT_POS_T(ZONE)
      POS_IN_MEM(CURRENT_POS_T(ZONE))=INODE
      IF(CURRENT_POS_T(ZONE).GT.(PDEB_SOLVE_Z(ZONE)+                    &
     &     MAX_NB_NODES_FOR_ZONE-1))THEN
         WRITE(*,*)MYID_OOC,': Internal error (21) in OOC ',            &
     &                      ' Problem with CURRENT_POS_T',              &
     &        CURRENT_POS_T(ZONE),ZONE
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      CURRENT_POS_T(ZONE)=CURRENT_POS_T(ZONE)+1
      POS_HOLE_T(ZONE)=CURRENT_POS_T(ZONE)
      POS_HOLE_T(ZONE)=CURRENT_POS_T(ZONE)
      POSFAC_SOLVE(ZONE)=POSFAC_SOLVE(ZONE)+                            &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      END SUBROUTINE DAGMG_MUMPS_606
      SUBROUTINE DAGMG_MUMPS_607(INODE,PTRFAC,                               &
     &     KEEP,KEEP8,                                                  &
     &     A,ZONE)
      IMPLICIT NONE
      INTEGER INODE,KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION A(FACT_AREA_SIZE)
      INTEGER REQUESTED_SIZE
      INTEGER ZONE,IFLAG,TMP_NODE
      LOGICAL FLAG
      IF(POS_HOLE_B(ZONE).EQ.-9999)THEN
         WRITE(*,*)MYID_OOC,': Internal error (22) in OOC ',            &
     &        ' DMUMPS_607'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)-                              &
     &     SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      LRLU_SOLVE_B(ZONE)=LRLU_SOLVE_B(ZONE)-                            &
     &        SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      PTRFAC(STEP_OOC(INODE))=IDEB_SOLVE_Z(ZONE)+                       &
     &     LRLU_SOLVE_B(ZONE)
      OOC_STATE_NODE(STEP_OOC(INODE))=NOT_USED
      IF(PTRFAC(STEP_OOC(INODE)).LT.IDEB_SOLVE_Z(ZONE))THEN
         WRITE(*,*)MYID_OOC,': Internal error (23) in OOC ',            &
     &              PTRFAC(STEP_OOC(INODE)),IDEB_SOLVE_Z(ZONE)
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      INODE_TO_POS(STEP_OOC(INODE))=CURRENT_POS_B(ZONE)
      IF(CURRENT_POS_B(ZONE).EQ.0)THEN
         WRITE(*,*)MYID_OOC,': Internal error (23b) in OOC '
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      POS_IN_MEM(CURRENT_POS_B(ZONE))=INODE
      CURRENT_POS_B(ZONE)=CURRENT_POS_B(ZONE)-1
      POS_HOLE_B(ZONE)=CURRENT_POS_B(ZONE)
      END SUBROUTINE DAGMG_MUMPS_607
      SUBROUTINE DAGMG_MUMPS_608(A,LA,REQUESTED_SIZE,PTRFAC,                 &
     &     NSTEPS,ZONE,IERR)
      IMPLICIT NONE
      INTEGER(8) :: LA, REQUESTED_SIZE
      INTEGER NSTEPS,ZONE
      INTEGER, intent(out) :: IERR
      INTEGER(8) :: PTRFAC(NSTEPS)
      DOUBLE PRECISION A(LA)
      INTEGER (8) :: APOS_FIRST_FREE,                                   &
     &               SIZE_HOLE,                                         &
     &               FREE_HOLE,                                         &
     &               FREE_HOLE_POS
      INTEGER J,I,TMP_NODE, NB_FREE, IPOS_FIRST_FREE
      INTEGER(8) :: K8, AREA_POINTER
      INTEGER FREE_HOLE_FLAG,TMPP
      IERR=0
      IF(LRLU_SOLVE_T(ZONE).EQ.SIZE_SOLVE_Z(ZONE))THEN
         RETURN
      ENDIF
      AREA_POINTER=IDEB_SOLVE_Z(ZONE)
      SIZE_HOLE=0_8
      DO I=PDEB_SOLVE_Z(ZONE),CURRENT_POS_T(ZONE)-1
         IF((POS_IN_MEM(I).LE.0).AND.                                   &
     &        (POS_IN_MEM(I).GT.-((N_OOC+1)*NB_Z))) GOTO 666
         TMP_NODE=abs(POS_IN_MEM(I))
         IF(TMP_NODE.GT.((N_OOC+1)*NB_Z))THEN
            TMP_NODE=TMP_NODE-((N_OOC+1)*NB_Z)
         ENDIF
         AREA_POINTER=AREA_POINTER+                                     &
     &        abs(SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
      ENDDO
  666 CONTINUE
      IF((I.EQ.CURRENT_POS_T(ZONE)-1).AND.                              &
     &     (PDEB_SOLVE_Z(ZONE).NE.CURRENT_POS_T(ZONE)-1))THEN
         IF((POS_IN_MEM(I).GT.0).OR.                                    &
     &        (POS_IN_MEM(I).LT.-((N_OOC+1)*NB_Z)))THEN
            WRITE(*,*)MYID_OOC,': Internal error (25) in OOC ',         &
     &                      ': There are no free blocks ',              &
     &         'in DMUMPS_608',PDEB_SOLVE_Z(ZONE),                      &
     &           CURRENT_POS_T(ZONE)
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
      IF(POS_IN_MEM(I).EQ.0)THEN
         APOS_FIRST_FREE=AREA_POINTER
         FREE_HOLE_POS=AREA_POINTER
      ELSE
         TMP_NODE=abs(POS_IN_MEM(I))
         APOS_FIRST_FREE=abs(PTRFAC(STEP_OOC(TMP_NODE)))
      ENDIF
      IF(POS_IN_MEM(PDEB_SOLVE_Z(ZONE)).NE.0)THEN
         IF(POS_IN_MEM(PDEB_SOLVE_Z(ZONE)).LT.-((N_OOC+1)*NB_Z))THEN
            TMP_NODE=abs(POS_IN_MEM(PDEB_SOLVE_Z(ZONE)))-               &
     &           ((N_OOC+1)*NB_Z)
            CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            REQ_ACT=REQ_ACT-1
            CALL DAGMG_MUMPS_596(                                            &
     &           IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
         ELSE
            TMP_NODE=abs(POS_IN_MEM(PDEB_SOLVE_Z(ZONE)))
         ENDIF
         IF(abs(PTRFAC(STEP_OOC(TMP_NODE))).NE.IDEB_SOLVE_Z(ZONE))THEN
            IF((POS_IN_MEM(I).NE.0).OR.(I.EQ.CURRENT_POS_T(ZONE)))THEN
               SIZE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-               &
     &              IDEB_SOLVE_Z(ZONE)
            ENDIF
            APOS_FIRST_FREE=IDEB_SOLVE_Z(ZONE)
            IF(POS_IN_MEM(PDEB_SOLVE_Z(ZONE)).GT.0)THEN
               DO J=PDEB_SOLVE_Z(ZONE),I-1
                  TMP_NODE=POS_IN_MEM(J)
                  IF(TMP_NODE.LE.0)THEN
                     IF(TMP_NODE.LT.-((N_OOC+1)*NB_Z))THEN
                        TMP_NODE=abs(POS_IN_MEM(J))-((N_OOC+1)*NB_Z)
                        CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
                        IF(IERR.LT.0)THEN
                           RETURN
                        ENDIF
                        REQ_ACT=REQ_ACT-1
                        CALL DAGMG_MUMPS_596(                                &
     &                       IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
                        TMP_NODE=POS_IN_MEM(J)
                     ELSE
                    WRITE(*,*)MYID_OOC,': Internal error (26) in OOC ', &
     &                      ' DMUMPS_608',TMP_NODE,                     &
     &                       J,I-1,(N_OOC+1)*NB_Z
                        CALL AGMG_MUMPS_ABORT()
                     ENDIF
                  ENDIF
                  DO K8=1_8,                                            &
     &                  SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
                     A(APOS_FIRST_FREE+K8-1_8)=                         &
     &                    A(PTRFAC(STEP_OOC(TMP_NODE))+K8-1_8)
                  ENDDO
                  PTRFAC(STEP_OOC(TMP_NODE))=APOS_FIRST_FREE
                  APOS_FIRST_FREE=APOS_FIRST_FREE+                      &
     &                 SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      NB_FREE=0
      FREE_HOLE=0_8
      FREE_HOLE_FLAG=0
      DO J=I,CURRENT_POS_T(ZONE)-1
         TMP_NODE=abs(POS_IN_MEM(J))
         IF(POS_IN_MEM(J).LT.-((N_OOC+1)*NB_Z))THEN
            TMP_NODE=TMP_NODE-((N_OOC+1)*NB_Z)
            CALL AGMG_NOCALL('MUMPS_WAIT_REQUEST')
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            REQ_ACT=REQ_ACT-1
            CALL DAGMG_MUMPS_596(                                            &
     &           IO_REQ(STEP_OOC(TMP_NODE)),PTRFAC,NSTEPS)
            TMP_NODE=abs(POS_IN_MEM(J))
         ENDIF
         IF(POS_IN_MEM(J).GT.0)THEN
            DO K8=1_8,SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
               A(APOS_FIRST_FREE+K8-1_8)=                               &
     &         A(PTRFAC(STEP_OOC(TMP_NODE))+K8-1_8)
            ENDDO
            IF(FREE_HOLE_FLAG.EQ.1)THEN
               FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-               &
     &              FREE_HOLE_POS
               FREE_HOLE_FLAG=0
               SIZE_HOLE=SIZE_HOLE+FREE_HOLE
            ENDIF
            FREE_HOLE_POS=abs(PTRFAC(STEP_OOC(TMP_NODE)))+              &
     &           SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
            PTRFAC(STEP_OOC(TMP_NODE))=APOS_FIRST_FREE
            APOS_FIRST_FREE=APOS_FIRST_FREE+                            &
     &           SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
         ELSEIF(POS_IN_MEM(J).EQ.0)THEN
            FREE_HOLE_FLAG=1
            NB_FREE=NB_FREE+1
         ELSE
            NB_FREE=NB_FREE+1
            IF(FREE_HOLE_FLAG.EQ.1)THEN
               FREE_HOLE=abs(PTRFAC(STEP_OOC(TMP_NODE)))-               &
     &              FREE_HOLE_POS
               FREE_HOLE_FLAG=0
               SIZE_HOLE=SIZE_HOLE+FREE_HOLE
            ENDIF
            FREE_HOLE_POS=abs(PTRFAC(STEP_OOC(TMP_NODE)))+              &
     &           SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)
            SIZE_HOLE=SIZE_HOLE+SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),       &
     &           OOC_FCT_TYPE)
            PTRFAC(STEP_OOC(abs(POS_IN_MEM(J))))=-77777_8
         ENDIF
      ENDDO
      IF(FREE_HOLE_FLAG.EQ.1)THEN
         FREE_HOLE=POSFAC_SOLVE(ZONE)-FREE_HOLE_POS
         FREE_HOLE_FLAG=0
         SIZE_HOLE=SIZE_HOLE+FREE_HOLE
      ENDIF
      IPOS_FIRST_FREE=I
      DO J=I,CURRENT_POS_T(ZONE)-1
         IF(POS_IN_MEM(J).LT.0)THEN
            TMP_NODE=abs(POS_IN_MEM(J))
            INODE_TO_POS(STEP_OOC(TMP_NODE))=0
            POS_IN_MEM(J)=0
            OOC_STATE_NODE(STEP_OOC(TMP_NODE))=ALREADY_USED
          ELSEIF(POS_IN_MEM(J).GT.0)THEN
             TMP_NODE=abs(POS_IN_MEM(J))
             POS_IN_MEM(IPOS_FIRST_FREE)=POS_IN_MEM(J)
             INODE_TO_POS(STEP_OOC(TMP_NODE))=IPOS_FIRST_FREE
             IPOS_FIRST_FREE=IPOS_FIRST_FREE+1
         ENDIF
      ENDDO
  777 CONTINUE
      LRLU_SOLVE_T(ZONE)=LRLU_SOLVE_T(ZONE)+SIZE_HOLE
      POSFAC_SOLVE(ZONE)=POSFAC_SOLVE(ZONE)-SIZE_HOLE
      CURRENT_POS_T(ZONE)=CURRENT_POS_T(ZONE)-NB_FREE
      POS_HOLE_T(ZONE)=CURRENT_POS_T(ZONE)
      LRLU_SOLVE_B(ZONE)=0_8
      POS_HOLE_B(ZONE)=-9999
      CURRENT_POS_B(ZONE)=-9999
      LRLU_SOLVE_B(ZONE)=0_8
      IF(LRLU_SOLVE_T(ZONE).NE.LRLUS_SOLVE(ZONE))THEN
         WRITE(*,*)MYID_OOC,': Internal error (27) in OOC ',            &
     &                 LRLU_SOLVE_T(ZONE),                              &
     &                 LRLUS_SOLVE(ZONE)
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      LRLU_SOLVE_T(ZONE)=LRLUS_SOLVE(ZONE)
      IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
         WRITE(*,*)MYID_OOC,': Internal error (28) in OOC ',            &
     &                      ' LRLUS_SOLVE must be (4) > 0'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(POSFAC_SOLVE(ZONE).LT.IDEB_SOLVE_Z(ZONE))THEN
         WRITE(*,*)MYID_OOC,': Internal error (29) in OOC ',            &
     &        POSFAC_SOLVE(ZONE),IDEB_SOLVE_Z(ZONE)
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(POSFAC_SOLVE(ZONE).NE.(IDEB_SOLVE_Z(ZONE)+SIZE_SOLVE_Z(ZONE)-  &
     &     LRLUS_SOLVE(ZONE)))THEN
         WRITE(*,*)MYID_OOC,': Internal error (30) in OOC ',            &
     &                      ' Problem avec debut POSFAC_SOLVE',         &
     &        POSFAC_SOLVE(ZONE),(SIZE_SOLVE_Z(ZONE)-                   &
     &     LRLUS_SOLVE(ZONE))+IDEB_SOLVE_Z(ZONE),LRLUS_SOLVE(ZONE)
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(POSFAC_SOLVE(ZONE).GT.                                         &
     &     (IDEB_SOLVE_Z(ZONE)+SIZE_SOLVE_Z(ZONE)-1_8))THEN
         WRITE(*,*)MYID_OOC,': Internal error (31) in OOC ',            &
     &        POSFAC_SOLVE(ZONE),IDEB_SOLVE_Z(ZONE)+                    &
     &        SIZE_SOLVE_Z(ZONE)-1_8
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_608
      SUBROUTINE DAGMG_MUMPS_581()
      IMPLICIT NONE
      IS_INIT_CALLED=.FALSE.
      END SUBROUTINE DAGMG_MUMPS_581
      SUBROUTINE DAGMG_MUMPS_609(INODE,PTRFAC,NSTEPS,FLAG)
      IMPLICIT NONE
      INTEGER INODE,NSTEPS,FLAG
      INTEGER (8) :: PTRFAC(NSTEPS)
      INTEGER ZONE
      IF((FLAG.LT.0).OR.(FLAG.GT.1))THEN
         WRITE(*,*)MYID_OOC,': Internal error (32) in OOC ',            &
     &        ' DMUMPS_609'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      CALL DAGMG_MUMPS_610(PTRFAC(STEP_OOC(INODE)),ZONE)
      IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
         WRITE(*,*)MYID_OOC,': Internal error (33) in OOC ',            &
     &        ' LRLUS_SOLVE must be (5) ++ > 0'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(FLAG.EQ.0)THEN
         LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)+                           &
     &        SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      ELSE
         LRLUS_SOLVE(ZONE)=LRLUS_SOLVE(ZONE)-                           &
     &        SIZE_OF_BLOCK(STEP_OOC(INODE),OOC_FCT_TYPE)
      ENDIF
      IF(LRLUS_SOLVE(ZONE).LT.0_8)THEN
         WRITE(*,*)MYID_OOC,': Internal error (34) in OOC ',            &
     &                      ' LRLUS_SOLVE must be (5) > 0'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_609
      SUBROUTINE DAGMG_MUMPS_610(ADDR,ZONE)
      IMPLICIT NONE
      INTEGER (8) :: ADDR
      INTEGER ZONE
      INTEGER I
      I=1
      DO WHILE (I.LE.NB_Z)
         IF(ADDR.LT.IDEB_SOLVE_Z(I))THEN
            EXIT
         ENDIF
         I=I+1
      ENDDO
      ZONE=I-1
      END SUBROUTINE DAGMG_MUMPS_610
      FUNCTION DAGMG_MUMPS_727()
      IMPLICIT NONE
      LOGICAL DAGMG_MUMPS_727
      DAGMG_MUMPS_727=.FALSE.
      IF(SOLVE_STEP.EQ.0)THEN
         IF(CUR_POS_SEQUENCE.GT.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))THEN
            DAGMG_MUMPS_727=.TRUE.
         ENDIF
      ELSEIF(SOLVE_STEP.EQ.1)THEN
         IF(CUR_POS_SEQUENCE.LT.1)THEN
            DAGMG_MUMPS_727=.TRUE.
         ENDIF
      ENDIF
      RETURN
      END FUNCTION DAGMG_MUMPS_727
      SUBROUTINE DAGMG_MUMPS_611(ZONE,A,LA,PTRFAC,NSTEPS,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,ZONE
      INTEGER(8), INTENT(IN) :: LA
      INTEGER, intent(out) :: IERR
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER(8) :: SIZE, DEST
      INTEGER(8) :: NEEDED_SIZE
      INTEGER FLAG,TMP_FLAG,POS_SEQ,TMP_NODE,                           &
     &     NB_NODES
      EXTERNAL AGMG_MUMPS_330,AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_330,AGMG_MUMPS_275
      IERR=0
      TMP_FLAG=0
      FLAG=0
      IF(DAGMG_MUMPS_727())THEN
         RETURN
      ENDIF
      IF(SOLVE_STEP.EQ.0)THEN
         IF(CUR_POS_SEQUENCE.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))THEN
            TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,               &
     &           OOC_FCT_TYPE)
            DO WHILE(SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE).GT. &
     &           SIZE_SOLVE_Z(ZONE))
               CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
               IF(DAGMG_MUMPS_727())THEN
                  RETURN
               ENDIF
               TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,            &
     &              OOC_FCT_TYPE)
            ENDDO
            CALL DAGMG_MUMPS_728()
            NEEDED_SIZE=max(MIN_SIZE_READ,                              &
     &           SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
         ELSE
            NEEDED_SIZE=MIN_SIZE_READ
         ENDIF
      ELSEIF(SOLVE_STEP.EQ.1)THEN
         IF(CUR_POS_SEQUENCE.GE.1)THEN
            TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,               &
     &           OOC_FCT_TYPE)
            DO WHILE(SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE).GT. &
     &           SIZE_SOLVE_Z(ZONE))
               CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
               IF(DAGMG_MUMPS_727())THEN
                  RETURN
               ENDIF
               TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,            &
     &              OOC_FCT_TYPE)
            ENDDO
            CALL DAGMG_MUMPS_728()
            NEEDED_SIZE=max(MIN_SIZE_READ,                              &
     &           SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE))
         ELSE
            NEEDED_SIZE=MIN_SIZE_READ
         ENDIF
      ENDIF
      IF(LRLUS_SOLVE(ZONE).LT.NEEDED_SIZE)THEN
         RETURN
      ELSEIF((LRLU_SOLVE_T(ZONE).LT.NEEDED_SIZE).AND.                   &
     &        (LRLU_SOLVE_B(ZONE).LT.NEEDED_SIZE).AND.                  &
     &        (dble(LRLUS_SOLVE(ZONE)).LT.0.3d0*                        &
     &         dble(SIZE_SOLVE_Z(ZONE)))) THEN
         RETURN
      ENDIF
      IF((LRLU_SOLVE_T(ZONE).GT.NEEDED_SIZE).AND.(SOLVE_STEP.EQ.0).AND. &
     &     ((CURRENT_POS_T(ZONE)-PDEB_SOLVE_Z(ZONE)+1).LT.              &
     &     MAX_NB_NODES_FOR_ZONE))THEN
         FLAG=1
      ELSE
         IF(SOLVE_STEP.EQ.0)THEN
            CALL DAGMG_MUMPS_604(A,FACT_AREA_SIZE,                           &
     &           NEEDED_SIZE,PTRFAC,NSTEPS,ZONE,TMP_FLAG,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            FLAG=1
            IF(TMP_FLAG.EQ.0)THEN
               CALL DAGMG_MUMPS_605(A,FACT_AREA_SIZE,                        &
     &              NEEDED_SIZE,PTRFAC,NSTEPS,ZONE,TMP_FLAG,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
               FLAG=0
            ENDIF
         ELSE
            CALL DAGMG_MUMPS_605(A,FACT_AREA_SIZE,                           &
     &           NEEDED_SIZE,PTRFAC,NSTEPS,ZONE,TMP_FLAG,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            FLAG=0
            IF(TMP_FLAG.EQ.0)THEN
               CALL DAGMG_MUMPS_604(A,FACT_AREA_SIZE,                        &
     &              NEEDED_SIZE,PTRFAC,NSTEPS,ZONE,TMP_FLAG,IERR)
               IF(IERR.LT.0)THEN
                  RETURN
               ENDIF
               FLAG=1
            ENDIF
         ENDIF
         IF(TMP_FLAG.EQ.0)THEN
            CALL DAGMG_MUMPS_608(A,FACT_AREA_SIZE,                           &
     &           NEEDED_SIZE,PTRFAC,NSTEPS,ZONE,IERR)
            IF(IERR.LT.0)THEN
               RETURN
            ENDIF
            FLAG=1
         ENDIF
      ENDIF
      CALL DAGMG_MUMPS_602(ZONE,SIZE,DEST,POS_SEQ,                           &
     &     NB_NODES,FLAG,PTRFAC,NSTEPS)
      IF(SIZE.EQ.0_8)THEN
         RETURN
      ENDIF
      NB_ZONE_REQ=NB_ZONE_REQ+1
      SIZE_ZONE_REQ=SIZE_ZONE_REQ+SIZE
      REQ_ACT=REQ_ACT+1
      CALL DAGMG_MUMPS_595(A(DEST),DEST,SIZE,ZONE,PTRFAC,NSTEPS,             &
     &     POS_SEQ,NB_NODES,FLAG,IERR)
      IF(IERR.LT.0)THEN
         RETURN
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_611
      SUBROUTINE DAGMG_MUMPS_602(ZONE,SIZE,DEST,POS_SEQ,                     &
     &     NB_NODES,FLAG,PTRFAC,NSTEPS)
      IMPLICIT NONE
      INTEGER(8) :: SIZE, DEST
      INTEGER ZONE,FLAG,POS_SEQ,NSTEPS
      INTEGER(8) :: PTRFAC(NSTEPS), MAX_SIZE, LAST, J8
      INTEGER I,TMP_NUM_FILE,START_NODE,K,TMP,MAX_NB,                   &
     &     NB_NODES
      INTEGER NB_NODES_LOC
      LOGICAL ALREADY
      IF(DAGMG_MUMPS_727())THEN
         SIZE=0_8
         RETURN
      ENDIF
      IF(FLAG.EQ.0)THEN
         MAX_SIZE=LRLU_SOLVE_B(ZONE)
         MAX_NB=max(0,CURRENT_POS_B(ZONE)-PDEB_SOLVE_Z(ZONE)+1)
      ELSEIF(FLAG.EQ.1)THEN
         MAX_SIZE=LRLU_SOLVE_T(ZONE)
         MAX_NB=MAX_NB_NODES_FOR_ZONE
      ELSE
         WRITE(*,*)MYID_OOC,': Internal error (35) in OOC ',            &
     &                      ' Unknown Flag value in ',                  &
     &         ' DMUMPS_602',FLAG
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      CALL DAGMG_MUMPS_728()
      I=CUR_POS_SEQUENCE
      START_NODE=OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
      ALREADY=.FALSE.
      NB_NODES=0
      NB_NODES_LOC=0
      IF(ZONE.EQ.NB_Z)THEN
         SIZE=SIZE_OF_BLOCK(STEP_OOC(START_NODE),OOC_FCT_TYPE)
      ELSE
         J8=0_8
         IF(FLAG.EQ.0)THEN
            K=0
         ELSEIF(FLAG.EQ.1)THEN
            K=CURRENT_POS_T(ZONE)-PDEB_SOLVE_Z(ZONE)+1
         ENDIF
         IF(SOLVE_STEP.EQ.0)THEN
            I=CUR_POS_SEQUENCE
            DO WHILE(I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))
               IF(SIZE_OF_BLOCK(STEP_OOC(OOC_INODE_SEQUENCE(I,          &
     &              OOC_FCT_TYPE)),                                     &
     &              OOC_FCT_TYPE)                                       &
     &              .NE.0_8)THEN
                  EXIT
               ENDIF
               I=I+1
            ENDDO
            CUR_POS_SEQUENCE=min(I,TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))
            I=CUR_POS_SEQUENCE
            DO WHILE((J8.LE.MAX_SIZE).AND.                              &
     &           (I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)).AND.           &
     &           (K.LT.MAX_NB) )
               LAST=SIZE_OF_BLOCK(STEP_OOC(OOC_INODE_SEQUENCE(I,        &
     &              OOC_FCT_TYPE)),                                     &
     &              OOC_FCT_TYPE)
               IF(LAST.EQ.0_8)THEN
                  IF(.NOT.ALREADY)THEN
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
                  ENDIF
                  I=I+1
                  NB_NODES_LOC=NB_NODES_LOC+1
                  CYCLE
               ENDIF
               IF((INODE_TO_POS(STEP_OOC(OOC_INODE_SEQUENCE(I,          &
     &              OOC_FCT_TYPE)))                                     &
     &              .NE.0).OR.                                          &
     &              (IO_REQ(STEP_OOC(OOC_INODE_SEQUENCE(I,              &
     &              OOC_FCT_TYPE))).GE.                                 &
     &              0))THEN
                  IF(.NOT.ALREADY)THEN
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE+1
                     I=I+1
                     CYCLE
                  ELSE
                     EXIT
                  ENDIF
               ENDIF
               ALREADY=.TRUE.
               J8=J8+LAST
               I=I+1
               K=K+1
               NB_NODES_LOC=NB_NODES_LOC+1
               NB_NODES=NB_NODES+1
            ENDDO
            IF(J8.GT.MAX_SIZE)THEN
               SIZE=J8-LAST
               NB_NODES=NB_NODES-1
               NB_NODES_LOC=NB_NODES_LOC-1
            ELSE
               SIZE=J8
            ENDIF
            DO WHILE (CUR_POS_SEQUENCE+NB_NODES_LOC-1.GE.               &
     &                             CUR_POS_SEQUENCE)
               IF(SIZE_OF_BLOCK(STEP_OOC(                               &
     &              OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE+NB_NODES-1,     &
     &              OOC_FCT_TYPE)),                                     &
     &              OOC_FCT_TYPE)                                       &
     &              .NE.0_8)THEN
                  EXIT
               ENDIF
               NB_NODES_LOC=NB_NODES_LOC-1
            ENDDO
            POS_SEQ=CUR_POS_SEQUENCE
         ELSEIF(SOLVE_STEP.EQ.1)THEN
            DO WHILE(I.GE.1)
               IF(SIZE_OF_BLOCK(STEP_OOC(OOC_INODE_SEQUENCE(I,          &
     &              OOC_FCT_TYPE)),                                     &
     &              OOC_FCT_TYPE)                                       &
     &              .NE.0_8)THEN
                  EXIT
               ENDIF
               I=I-1
            ENDDO
            CUR_POS_SEQUENCE=max(I,1)
            I=CUR_POS_SEQUENCE
            DO WHILE((J8.LE.MAX_SIZE).AND.(I.GE.1).AND.                 &
     &           (K.LT.MAX_NB))
               LAST=SIZE_OF_BLOCK(STEP_OOC(OOC_INODE_SEQUENCE(I,        &
     &              OOC_FCT_TYPE)),                                     &
     &              OOC_FCT_TYPE)
               IF(LAST.EQ.0_8)THEN
                  IF(.NOT.ALREADY)THEN
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
                  ENDIF
                  NB_NODES_LOC=NB_NODES_LOC+1
                  I=I-1
                  CYCLE
               ENDIF
               IF((INODE_TO_POS(STEP_OOC(OOC_INODE_SEQUENCE(I,          &
     &              OOC_FCT_TYPE)))                                     &
     &              .NE.0).OR.                                          &
     &              (IO_REQ(STEP_OOC(OOC_INODE_SEQUENCE(I,              &
     &              OOC_FCT_TYPE))).GE.                                 &
     &              0))THEN
                  IF(.NOT.ALREADY)THEN
                     I=I-1
                     CUR_POS_SEQUENCE=CUR_POS_SEQUENCE-1
                     CYCLE
                  ELSE
                     EXIT
                  ENDIF
               ENDIF
               ALREADY=.TRUE.
               J8=J8+LAST
               I=I-1
               K=K+1
               NB_NODES=NB_NODES+1
               NB_NODES_LOC=NB_NODES_LOC+1
            ENDDO
            IF(J8.GT.MAX_SIZE)THEN
               SIZE=J8-LAST
               NB_NODES=NB_NODES-1
               NB_NODES_LOC=NB_NODES_LOC-1
            ELSE
               SIZE=J8
            ENDIF
            I=CUR_POS_SEQUENCE-NB_NODES_LOC+1
            DO WHILE (I.LE.CUR_POS_SEQUENCE)
               IF(SIZE_OF_BLOCK(STEP_OOC(                               &
     &              OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)),                &
     &              OOC_FCT_TYPE).NE.0_8)THEN
                  EXIT
               ENDIF
               I=I+1
               NB_NODES_LOC=NB_NODES_LOC-1
            ENDDO
            POS_SEQ=CUR_POS_SEQUENCE-NB_NODES_LOC+1
         ENDIF
      ENDIF
      IF(FLAG.EQ.0)THEN
         DEST=IDEB_SOLVE_Z(ZONE)+LRLU_SOLVE_B(ZONE)-SIZE
      ELSE
         DEST=POSFAC_SOLVE(ZONE)
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_602
      SUBROUTINE DAGMG_MUMPS_582(IERR)
      IMPLICIT NONE
      INTEGER SOLVE_OR_FACTO
      INTEGER, intent(out) :: IERR
      IERR=0
      IF(allocated(LRLUS_SOLVE))THEN
         DEALLOCATE(LRLUS_SOLVE)
      ENDIF
      IF(allocated(LRLU_SOLVE_T))THEN
         DEALLOCATE(LRLU_SOLVE_T)
      ENDIF
      IF(allocated(LRLU_SOLVE_B))THEN
         DEALLOCATE(LRLU_SOLVE_B)
      ENDIF
      IF(allocated(POSFAC_SOLVE))THEN
         DEALLOCATE(POSFAC_SOLVE)
      ENDIF
      IF(allocated(IDEB_SOLVE_Z))THEN
         DEALLOCATE(IDEB_SOLVE_Z)
      ENDIF
      IF(allocated(PDEB_SOLVE_Z))THEN
         DEALLOCATE(PDEB_SOLVE_Z)
      ENDIF
      IF(allocated(SIZE_SOLVE_Z))THEN
         DEALLOCATE(SIZE_SOLVE_Z)
      ENDIF
      IF(allocated(CURRENT_POS_T))THEN
         DEALLOCATE(CURRENT_POS_T)
      ENDIF
      IF(allocated(CURRENT_POS_B))THEN
         DEALLOCATE(CURRENT_POS_B)
      ENDIF
      IF(allocated(POS_HOLE_T))THEN
         DEALLOCATE(POS_HOLE_T)
      ENDIF
      IF(allocated(POS_HOLE_B))THEN
         DEALLOCATE(POS_HOLE_B)
      ENDIF
      IF(allocated(OOC_STATE_NODE))THEN
         DEALLOCATE(OOC_STATE_NODE)
      ENDIF
      IF(allocated(POS_IN_MEM))THEN
         DEALLOCATE(POS_IN_MEM)
      ENDIF
      IF(allocated(INODE_TO_POS))THEN
         DEALLOCATE(INODE_TO_POS)
      ENDIF
      IF(allocated(IO_REQ))THEN
         DEALLOCATE(IO_REQ)
      ENDIF
      IF(allocated(SIZE_OF_READ))THEN
         DEALLOCATE(SIZE_OF_READ)
      ENDIF
      IF(allocated(FIRST_POS_IN_READ))THEN
         DEALLOCATE(FIRST_POS_IN_READ)
      ENDIF
      IF(allocated(READ_DEST))THEN
         DEALLOCATE(READ_DEST)
      ENDIF
      IF(allocated(READ_MNG))THEN
         DEALLOCATE(READ_MNG)
      ENDIF
      IF(allocated(REQ_TO_ZONE))THEN
         DEALLOCATE(REQ_TO_ZONE)
      ENDIF
      IF(allocated(REQ_ID))THEN
         DEALLOCATE(REQ_ID)
      ENDIF
      SOLVE_OR_FACTO=1
      CALL AGMG_NOCALL('MUMPS_CLEAN_IO_DATA_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         RETURN
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_582
      SUBROUTINE DAGMG_MUMPS_612(PTRFAC,NSTEPS,                              &
     &            A,LA)
      IMPLICIT NONE
      INTEGER, INTENT(in)       :: NSTEPS
      INTEGER(8), INTENT(INOUT) :: PTRFAC(NSTEPS)
      INTEGER(8), INTENT(IN)    :: LA
      DOUBLE PRECISION                   :: A(LA)
      INTEGER    :: I, TMP, ZONE, IPAS, IBEG, IEND
      INTEGER(8) :: SAVE_PTR
      LOGICAL    :: COMPRESS_TO_BE_DONE, SET_POS_SEQUENCE
      INTEGER    :: J, IERR
      INTEGER(8) :: DUMMY_SIZE
      COMPRESS_TO_BE_DONE         = .FALSE.
      DUMMY_SIZE                  = 1_8
      IERR                        = 0
      SET_POS_SEQUENCE            = .TRUE.
      IF(SOLVE_STEP.EQ.0)THEN
        IBEG = 1
        IEND = TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)
        IPAS = 1
      ELSE
        IBEG = TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)
        IEND = 1
        IPAS = -1
      ENDIF
      DO I=IBEG,IEND,IPAS
            J = OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
            TMP=INODE_TO_POS(STEP_OOC(J))
            IF(TMP.EQ.0)THEN
               IF (SET_POS_SEQUENCE) THEN
                 SET_POS_SEQUENCE = .FALSE.
                 CUR_POS_SEQUENCE = I
               ENDIF
               IF (KEEP_OOC(237).EQ.0 .AND. KEEP_OOC(235).EQ.0) THEN
                 OOC_STATE_NODE(STEP_OOC(J)) = NOT_IN_MEM
               ENDIF
               CYCLE
            ELSE IF(TMP.LT.0)THEN
               IF(TMP.GT.-(N_OOC+1)*NB_Z)THEN
                  SAVE_PTR=PTRFAC(STEP_OOC(J))
                  PTRFAC(STEP_OOC(J)) = abs(SAVE_PTR)
                  CALL DAGMG_MUMPS_600(J,                                    &
     &                 ZONE,PTRFAC,NSTEPS)
                  PTRFAC(STEP_OOC(J)) = SAVE_PTR
                  IF(ZONE.EQ.NB_Z)THEN
                     IF(J.NE.SPECIAL_ROOT_NODE)THEN
                        WRITE(*,*)MYID_OOC,': Internal error 6 ',       &
     &                       ' Node ', J,                               &
     &                       ' is in status USED in the                 &
     &                        emmergency buffer '
                        CALL AGMG_MUMPS_ABORT()
                     ENDIF
                  ENDIF
                 IF (KEEP_OOC(237).EQ.0 .AND. KEEP_OOC(235).EQ.0) THEN
                    CALL DAGMG_MUMPS_599(J,PTRFAC,NSTEPS)
                 ENDIF
               ENDIF
            ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_612
      SUBROUTINE DAGMG_MUMPS_583(PTRFAC,NSTEPS,MTYPE,                        &
     &                                    A,LA,DOPREFETCH,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS,MTYPE
      INTEGER, intent(out)::IERR
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: PTRFAC(NSTEPS)
      LOGICAL DOPREFETCH
      IERR = 0
      OOC_FCT_TYPE=1
      OOC_SOLVE_TYPE_FCT=FCT
      IF (KEEP_OOC(201).EQ.1) THEN
       OOC_FCT_TYPE=1
       OOC_SOLVE_TYPE_FCT=TYPEF_L-1
      ENDIF
      IF (KEEP_OOC(201).EQ.1) THEN
       IF((MTYPE.NE.1).AND.(KEEP_OOC(50).EQ.0))THEN
         OOC_SOLVE_TYPE_FCT=TYPEF_U-1
         OOC_FCT_TYPE=2
       ENDIF
      ENDIF
      SOLVE_STEP=0
      CUR_POS_SEQUENCE=1
      MTYPE_OOC=MTYPE
      IF ( KEEP_OOC(201).NE.1                                           &
     &  .OR. KEEP_OOC(50).NE.0                                          &
     &  ) THEN
        CALL DAGMG_MUMPS_612(PTRFAC,NSTEPS,A,LA)
      ELSE
        CALL DAGMG_MUMPS_683(KEEP_OOC(28),                                   &
     &              KEEP_OOC(38), KEEP_OOC(20) )
      ENDIF
      IF (DOPREFETCH) THEN
          CALL DAGMG_MUMPS_585(A,LA,PTRFAC,                                  &
     &                                 KEEP_OOC(28),IERR)
      ELSE
          CUR_POS_SEQUENCE = TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_583
      SUBROUTINE DAGMG_MUMPS_584(PTRFAC,NSTEPS,MTYPE,                        &
     &           I_WORKED_ON_ROOT,IROOT,A,LA,IERR)
      IMPLICIT NONE
      INTEGER NSTEPS
      INTEGER(8) :: LA
      INTEGER(8) :: PTRFAC(NSTEPS)
      INTEGER MTYPE
      INTEGER IROOT
      LOGICAL I_WORKED_ON_ROOT
      INTEGER, intent(out):: IERR
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: DUMMY_SIZE
      INTEGER ZONE
      IERR=0
      OOC_FCT_TYPE=1
      OOC_SOLVE_TYPE_FCT=FCT
      IF (KEEP_OOC(201).EQ.1) THEN
       IF(KEEP_OOC(50).EQ.0)THEN
         OOC_SOLVE_TYPE_FCT=TYPEF_U-1
         OOC_FCT_TYPE=2
       ELSE
         OOC_SOLVE_TYPE_FCT=TYPEF_L-1
         OOC_FCT_TYPE=1
       ENDIF
      ENDIF
      IF (KEEP_OOC(201).EQ.1) THEN
       IF((MTYPE.NE.1).AND.(KEEP_OOC(50).EQ.0))THEN
         OOC_FCT_TYPE=1
         OOC_SOLVE_TYPE_FCT=TYPEF_L-1
       ENDIF
      ENDIF
      SOLVE_STEP=1
      CUR_POS_SEQUENCE=TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)
      MTYPE_OOC=MTYPE
      IF ( KEEP_OOC(201).NE.1                                           &
     &  .OR. KEEP_OOC(50).NE.0                                          &
     &  ) THEN
        CALL DAGMG_MUMPS_612(PTRFAC,NSTEPS,A,LA)
        IF (I_WORKED_ON_ROOT) THEN
          CALL DAGMG_MUMPS_598( IROOT,                                       &
     &         PTRFAC, KEEP_OOC(28), A, LA,.FALSE.,IERR)
          IF (IERR .LT. 0) RETURN
          CALL DAGMG_MUMPS_600(IROOT,                                        &
     &         ZONE,PTRFAC,NSTEPS)
          IF(IROOT.EQ.NB_Z)THEN
             DUMMY_SIZE=1_8
             CALL DAGMG_MUMPS_608(A,LA,                                      &
     &            DUMMY_SIZE,PTRFAC,                                    &
     &            NSTEPS,NB_Z,IERR)
             IF (IERR .LT. 0) THEN
                WRITE(*,*)MYID_OOC,': Internal error in                 &
     &               DAGMG_MUMPS_608',                                       &
     &               IERR
                CALL AGMG_MUMPS_ABORT()
             ENDIF
          ENDIF
        ENDIF
        IF (NB_Z.GT.1) THEN
          CALL DAGMG_MUMPS_594(A,LA,PTRFAC,                                  &
     &                                  KEEP_OOC(28),IERR)
          IF (IERR .LT. 0) RETURN
        ENDIF
      ELSE
        CALL DAGMG_MUMPS_683(KEEP_OOC(28),                                   &
     &              KEEP_OOC(38), KEEP_OOC(20) )
        CALL DAGMG_MUMPS_585(A,LA,PTRFAC,KEEP_OOC(28),IERR)
        IF (IERR .LT. 0 ) RETURN
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_584
      SUBROUTINE DAGMG_MUMPS_613(id,IERR)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER, intent(out) :: IERR
      INTEGER I,DIM,J,TMP,SIZE,K,I1
      CHARACTER*1 TMP_NAME(350)
      IERR=0
      SIZE=0
      DO J=1,OOC_NB_FILE_TYPE
         TMP=J-1
         CALL AGMG_NOCALL('MUMPS_OOC_GET_NB_FILES_C')
         id%OOC_NB_FILES(J)=I
         SIZE=SIZE+I
      ENDDO
      IF(associated(id%OOC_FILE_NAMES))THEN
         DEALLOCATE(id%OOC_FILE_NAMES)
         NULLIFY(id%OOC_FILE_NAMES)
      ENDIF
      ALLOCATE(id%OOC_FILE_NAMES(SIZE,350),stat=IERR)
      IF (IERR .GT. 0) THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*) 'PB allocation in DMUMPS_613'
         IERR=-1
         IF(id%INFO(1).GE.0)THEN
            id%INFO(1) = -13
            id%INFO(2) = SIZE*350
            RETURN
         ENDIF
      ENDIF
      IF(associated(id%OOC_FILE_NAME_LENGTH))THEN
         DEALLOCATE(id%OOC_FILE_NAME_LENGTH)
         NULLIFY(id%OOC_FILE_NAME_LENGTH)
      ENDIF
      ALLOCATE(id%OOC_FILE_NAME_LENGTH(SIZE),stat=IERR)
      IF (IERR .GT. 0) THEN
         IERR=-1
         IF(id%INFO(1).GE.0)THEN
            IF (ICNTL1.GT.0)                                            &
     &      WRITE(ICNTL1,*)                                             &
     &      'PB allocation in DMUMPS_613'
            id%INFO(1) = -13
            id%INFO(2) = SIZE
            RETURN
         ENDIF
      ENDIF
      K=1
      DO I1=1,OOC_NB_FILE_TYPE
         TMP=I1-1
         DO I=1,id%OOC_NB_FILES(I1)
            CALL AGMG_NOCALL('MUMPS_OOC_GET_FILE_NAME_C')
            DO J=1,DIM+1
               id%OOC_FILE_NAMES(K,J)=TMP_NAME(J)
            ENDDO
            id%OOC_FILE_NAME_LENGTH(K)=DIM+1
            K=K+1
         ENDDO
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_613
      SUBROUTINE DAGMG_MUMPS_614(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      CHARACTER*1 TMP_NAME(350)
      INTEGER I,I1,TMP,J,K,L,DIM,IERR
      INTEGER, DIMENSION(:),ALLOCATABLE :: NB_FILES
      INTEGER K211
      ALLOCATE(NB_FILES(OOC_NB_FILE_TYPE),stat=IERR)
      IF (IERR .GT. 0) THEN
         IERR=-1
         IF(id%INFO(1).GE.0)THEN
            IF (ICNTL1.GT.0)                                            &
     &      WRITE(ICNTL1,*)                                             &
     &      'PB allocation in DMUMPS_614'
            id%INFO(1) = -13
            id%INFO(2) = OOC_NB_FILE_TYPE
            RETURN
         ENDIF
      ENDIF
      IERR=0
      NB_FILES=id%OOC_NB_FILES
      I=id%MYID
      K=id%KEEP(35)
      L=mod(id%KEEP(204),3)
      K211=id%KEEP(211)
      CALL AGMG_NOCALL('MUMPS_OOC_ALLOC_POINTERS_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         id%INFO(1)=IERR
         RETURN
      ENDIF
      CALL AGMG_NOCALL('MUMPS_OOC_INIT_VARS_C')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         id%INFO(1)=IERR
         RETURN
      ENDIF
      K=1
      DO I1=1,OOC_NB_FILE_TYPE
         DO I=1,NB_FILES(I1)
            DIM=id%OOC_FILE_NAME_LENGTH(K)
            DO J=1,DIM
               TMP_NAME(J)=id%OOC_FILE_NAMES(K,J)
            ENDDO
            TMP=I1-1
            CALL AGMG_NOCALL('MUMPS_OOC_SET_FILE_NAME_C')
            IF(IERR.LT.0)THEN
               IF (ICNTL1.GT.0)                                         &
     &         WRITE(ICNTL1,*)MYID_OOC,': ',                            &
     &         ERR_STR_OOC(1:DIM_ERR_STR_OOC)
               id%INFO(1)=IERR
               RETURN
            ENDIF
            K=K+1
         ENDDO
      ENDDO
      CALL AGMG_NOCALL('MUMPS_OOC_START_LOW_LEVEL')
      IF(IERR.LT.0)THEN
         IF (ICNTL1.GT.0)                                               &
     &   WRITE(ICNTL1,*)MYID_OOC,': ',ERR_STR_OOC(1:DIM_ERR_STR_OOC)
         id%INFO(1)=IERR
         RETURN
      ENDIF
      DEALLOCATE(NB_FILES)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_614
      SUBROUTINE DAGMG_MUMPS_589(DEST,SRC,NB,NB_EFF)
      IMPLICIT NONE
      INTEGER NB, NB_EFF
      CHARACTER(LEN=NB) SRC
      CHARACTER*1 DEST(NB)
      INTEGER I
      DO I=1,NB_EFF
         DEST(I)=SRC(I:I)
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_589
      SUBROUTINE DAGMG_MUMPS_580(IERR)
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER, intent(out) :: IERR
      IERR=0
      IF(.NOT.WITH_BUF)THEN
         RETURN
      ENDIF
      CALL DAGMG_MUMPS_707(OOC_FCT_TYPE,IERR)
      IF (IERR < 0) THEN
        RETURN
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_580
      SUBROUTINE DAGMG_MUMPS_681(IERR)
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER, intent(out) :: IERR
      IERR=0
      IF(.NOT.WITH_BUF)THEN
         RETURN
      ENDIF
      CALL DAGMG_MUMPS_707(TYPEF_L_LOC,IERR)
      IF (IERR < 0) RETURN
      IF (KEEP_OOC(50).EQ.0) THEN
         CALL DAGMG_MUMPS_707(TYPEF_U_LOC,IERR)
         IF (IERR < 0) RETURN
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_681
       SUBROUTINE DAGMG_MUMPS_683(NSTEPS,                                    &
     &     KEEP38, KEEP20)
      IMPLICIT NONE
      INTEGER MASTER
      PARAMETER(MASTER=0)
      INTEGER NSTEPS
      INTEGER I, TMPNODE, TMP, ZONE, J
      INTEGER(8) :: TMP_SIZE8
      INTEGER KEEP38, KEEP20
      INODE_TO_POS = 0
      POS_IN_MEM   = 0
      OOC_STATE_NODE(1:NSTEPS)=0
      TMP_SIZE8=1_8
      J=1
      DO I=1,NB_Z-1
         IDEB_SOLVE_Z(I)=TMP_SIZE8
         PDEB_SOLVE_Z(I)=J
         POSFAC_SOLVE(I)=TMP_SIZE8
         LRLUS_SOLVE(I) =SIZE_ZONE_SOLVE
         LRLU_SOLVE_T(I)=SIZE_ZONE_SOLVE
         LRLU_SOLVE_B(I)=0_8
         SIZE_SOLVE_Z(I)=SIZE_ZONE_SOLVE
         CURRENT_POS_T(I)=J
         CURRENT_POS_B(I)=J
         POS_HOLE_T(I)   =J
         POS_HOLE_B(I)   =J
         J = J + MAX_NB_NODES_FOR_ZONE
         TMP_SIZE8 = TMP_SIZE8 + SIZE_ZONE_SOLVE
      ENDDO
      IDEB_SOLVE_Z(NB_Z)=TMP_SIZE8
      PDEB_SOLVE_Z(NB_Z)=J
      POSFAC_SOLVE(NB_Z)=TMP_SIZE8
      LRLUS_SOLVE(NB_Z) =SIZE_SOLVE_EMM
      LRLU_SOLVE_T(NB_Z)=SIZE_SOLVE_EMM
      LRLU_SOLVE_B(NB_Z)=0_8
      SIZE_SOLVE_Z(NB_Z)=SIZE_SOLVE_EMM
      CURRENT_POS_T(NB_Z)=J
      CURRENT_POS_B(NB_Z)=J
      POS_HOLE_T(NB_Z)   =J
      POS_HOLE_B(NB_Z)   =J
      IO_REQ=-77777
      SIZE_OF_READ=-9999_8
      FIRST_POS_IN_READ=-9999
      READ_DEST=-9999_8
      READ_MNG=-9999
      REQ_TO_ZONE=-9999
      REQ_ID=-9999
      RETURN
      END SUBROUTINE DAGMG_MUMPS_683
      SUBROUTINE DAGMG_MUMPS_688                                             &
     &     ( STRAT, TYPEFile,                                           &
     &     AFAC, LAFAC, MonBloc,                                        &
     &     LNextPiv2beWritten, UNextPiv2beWritten,                      &
     &     IW, LIWFAC,                                                  &
     &     MYID, FILESIZE, IERR , LAST_CALL)
      IMPLICIT NONE
      TYPE(IO_BLOCK), INTENT(INOUT):: MonBloc
      INTEGER(8) :: LAFAC
      INTEGER,        INTENT(IN)   :: STRAT, LIWFAC,                    &
     &     MYID, TYPEFile
      INTEGER,   INTENT(INOUT)        :: IW(0:LIWFAC-1)
      DOUBLE PRECISION, INTENT(IN) :: AFAC(LAFAC)
      INTEGER,   INTENT(INOUT) :: LNextPiv2beWritten,                   &
     &     UNextPiv2beWritten
      INTEGER*8, INTENT(INOUT) :: FILESIZE
      INTEGER,   INTENT(OUT) :: IERR
      LOGICAL,   INTENT(IN)  :: LAST_CALL
      INTEGER(8) :: L_TailleEcrite, U_TailleEcrite
      INTEGER(8) :: L_AddVirtNodeI8
      INTEGER(8) :: U_AddVirtNodeI8
      INTEGER(8) :: TMPSIZE_OF_BLOCK
      INTEGER :: TempFTYPE
      LOGICAL WRITE_L, WRITE_U
      LOGICAL DO_U_FIRST
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IERR = 0
      WRITE_L =  (TYPEFile.EQ.TYPEF_BOTH_LU .OR. TYPEFile.EQ.TYPEF_L)
      WRITE_U =  (TYPEFile.EQ.TYPEF_BOTH_LU .OR. TYPEFile.EQ.TYPEF_U)
      DO_U_FIRST = .FALSE.
      IF ( TYPEFile.EQ.TYPEF_BOTH_LU ) THEN
         IF ( LNextPiv2bewritten .GT. UNextPiv2beWritten ) THEN
            DO_U_FIRST = .TRUE.
         END IF
      END IF
      IF (DO_U_FIRST) GOTO 200
  100 IF (WRITE_L) THEN
         TempFTYPE  = TYPEF_L
         IF ((MonBloc%Typenode.EQ.2).AND.(.NOT.MonBloc%MASTER))         &
     &        THEN
           TMPSIZE_OF_BLOCK = SIZE_OF_BLOCK(STEP_OOC(MonBloc%INODE),    &
     &                                      TempFTYPE)
           IF (TMPSIZE_OF_BLOCK .LT. 0_8) THEN
               TMPSIZE_OF_BLOCK = -TMPSIZE_OF_BLOCK - 1_8
           ENDIF
           LNextPiv2beWritten =                                         &
     &     int(                                                         &
     &          TMPSIZE_OF_BLOCK                                        &
     &          / int(MonBloc%NROW,8)                                   &
     &        )                                                         &
     &     + 1
         ENDIF
         CALL DAGMG_MUMPS_695( STRAT,                                        &
     &        TempFTYPE, AFAC, LAFAC, MonBloc,                          &
     &        IERR,                                                     &
     &        LNextPiv2beWritten,                                       &
     &        OOC_VADDR(STEP_OOC(MonBloc%INODE),TEMPFTYPE),             &
     &        SIZE_OF_BLOCK(STEP_OOC(MonBloc%INODE),TempFTYPE),         &
     &        FILESIZE, LAST_CALL )
         IF (IERR .LT. 0) RETURN
         IF (DO_U_FIRST) GOTO 300
      ENDIF
  200 IF (WRITE_U) THEN
         TempFTYPE  = TYPEF_U
         CALL DAGMG_MUMPS_695( STRAT,                                        &
     &        TempFTYPE, AFAC, LAFAC, MonBloc,                          &
     &        IERR,                                                     &
     &        UNextPiv2beWritten,                                       &
     &        OOC_VADDR(STEP_OOC(MonBloc%INODE),TEMPFTYPE),             &
     &        SIZE_OF_BLOCK(STEP_OOC(MonBloc%INODE),TempFTYPE),         &
     &        FILESIZE, LAST_CALL)
         IF (IERR .LT. 0) RETURN
         IF (DO_U_FIRST) GOTO 100
      ENDIF
  300 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_688
      SUBROUTINE DAGMG_MUMPS_695( STRAT, TYPEF,                              &
     &     AFAC, LAFAC, MonBloc,                                        &
     &     IERR,                                                        &
     &     LorU_NextPiv2beWritten,                                      &
     &     LorU_AddVirtNodeI8, LorUSIZE_OF_BLOCK,                       &
     &     FILESIZE, LAST_CALL                                          &
     &     )
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: STRAT
      INTEGER, INTENT(IN) :: TYPEF
      INTEGER(8), INTENT(INOUT) :: FILESIZE
      INTEGER(8), INTENT(IN) :: LAFAC
      DOUBLE PRECISION, INTENT(IN) :: AFAC(LAFAC)
      INTEGER, INTENT(INOUT) :: LorU_NextPiv2beWritten
      INTEGER(8), INTENT(INOUT) :: LorU_AddVirtNodeI8
      INTEGER(8), INTENT(INOUT) :: LorUSIZE_OF_BLOCK
      TYPE(IO_BLOCK), INTENT(INOUT) :: MonBloc
      INTEGER, INTENT(OUT)  :: IERR
      LOGICAL, INTENT(IN)   :: LAST_CALL
      INTEGER NNMAX
      INTEGER(8) :: TOTSIZE, EFFSIZE
      INTEGER(8) :: TailleEcrite
      INTEGER SIZE_PANEL
      INTEGER(8) :: AddVirtCour
      LOGICAL VIRT_ADD_RESERVED_BEF_CALL
      LOGICAL VIRTUAL_ADDRESS_JUST_RESERVED
      LOGICAL HOLE_PROCESSED_BEFORE_CALL
      LOGICAL TMP_ESTIM
      INTEGER ICUR, INODE_CUR, ILAST
      INTEGER(8) :: ADDR_LAST
      IERR = 0
      IF (TYPEF == TYPEF_L ) THEN
         NNMAX = MonBloc%NROW
      ELSE
         NNMAX = MonBloc%NCOL
      ENDIF
      SIZE_PANEL = DAGMG_MUMPS_690(NNMAX)
      IF ( (.NOT.MonBloc%Last) .AND.                                    &
     &     (MonBloc%LastPiv-LorU_NextPiv2beWritten+1.LT.SIZE_PANEL))    &
     &     THEN
        RETURN
      ENDIF
      TMP_ESTIM = .TRUE.
      TOTSIZE = DAGMG_MUMPS_725                                              &
     &          (MonBloc%NFS, NNMAX, SIZE_PANEL, MonBloc, TMP_ESTIM)
      IF (MonBloc%Last) THEN
           TMP_ESTIM=.FALSE.
           EFFSIZE = DAGMG_MUMPS_725                                         &
     &     (MonBloc%LastPiv, NNMAX, SIZE_PANEL, MonBloc, TMP_ESTIM)
      ELSE
            EFFSIZE = -1034039740327_8
      ENDIF
      IF (MonBloc%Typenode.EQ.3.AND. MonBloc%NFS.NE.MonBloc%NCOL) THEN
         WRITE(*,*) 'Internal error in DMUMPS_695 for type3',           &
     &   MonBloc%NFS,MonBloc%NCOL
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (MonBloc%Typenode.EQ.3.AND. TYPEF.NE.TYPEF_L) THEN
         WRITE(*,*) 'Internal error in DMUMPS_695,TYPEF=',              &
     &   TYPEF, 'for typenode=3'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (MonBloc%Typenode.EQ.2.AND.                                    &
     &     TYPEF.EQ.TYPEF_U.AND.                                        &
     &     .NOT. MonBloc%MASTER ) THEN
         WRITE(*,*) 'Internal error in DMUMPS_695',                     &
     &   MonBloc%MASTER,MonBloc%TYPENODE, TYPEF
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      HOLE_PROCESSED_BEFORE_CALL  = (LorUSIZE_OF_BLOCK .LT. 0_8)
      IF (HOLE_PROCESSED_BEFORE_CALL.AND.(.NOT.MonBloc%Last)) THEN
          WRITE(6,*) ' Internal error  in DMUMPS_695 ',                 &
     &    ' last is false after earlier calls with last=true'
          CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (HOLE_PROCESSED_BEFORE_CALL) THEN
        LorUSIZE_OF_BLOCK = - LorUSIZE_OF_BLOCK - 1_8
        TOTSIZE = -99999999_8
      ENDIF
      VIRTUAL_ADDRESS_JUST_RESERVED = .FALSE.
      VIRT_ADD_RESERVED_BEF_CALL =                                      &
     &                    ( LorUSIZE_OF_BLOCK .NE. 0_8 .OR.             &
     &                      HOLE_PROCESSED_BEFORE_CALL )
      IF (MonBloc%Last .AND. .NOT. HOLE_PROCESSED_BEFORE_CALL) THEN
        KEEP_OOC(228) = max(KEEP_OOC(228),                              &
     &        (MonBloc%LastPiv+SIZE_PANEL-1) / SIZE_PANEL)
        IF (VIRT_ADD_RESERVED_BEF_CALL) THEN
            IF (AddVirtLibre(TYPEF).EQ.                                 &
     &           (LorU_AddVirtNodeI8+TOTSIZE) ) THEN
              AddVirtLibre(TYPEF) = LorU_AddVirtNodeI8 + EFFSIZE
            ENDIF
        ELSE
            VIRTUAL_ADDRESS_JUST_RESERVED = .TRUE.
            IF (EFFSIZE .EQ. 0_8) THEN
              LorU_AddVirtNodeI8 = -9999_8
            ELSE
              LorU_AddVirtNodeI8  = AddVirtLibre(TYPEF)
            ENDIF
            AddVirtLibre(TYPEF) = AddVirtLibre(TYPEF) + EFFSIZE
        ENDIF
      ELSE
        IF (.NOT. VIRT_ADD_RESERVED_BEF_CALL                            &
     &    ) THEN
          LorU_AddVirtNodeI8 = AddVirtLibre(TYPEF)
          AddVirtLibre(TYPEF) = AddVirtLibre(TYPEF) + TOTSIZE
        ENDIF
      ENDIF
      AddVirtCour = LorU_AddVirtNodeI8 + LorUSIZE_OF_BLOCK
      CALL DAGMG_MUMPS_697( STRAT, TYPEF, MonBloc,                           &
     &     SIZE_PANEL,                                                  &
     &     AFAC, LAFAC,                                                 &
     &     LorU_NextPiv2beWritten, AddVirtCour,                         &
     &     TailleEcrite,                                                &
     &     IERR )
      IF ( IERR .LT. 0 ) RETURN
      LorUSIZE_OF_BLOCK = LorUSIZE_OF_BLOCK + TailleEcrite
      IF (LorUSIZE_OF_BLOCK.EQ.0_8 ) THEN
        IF ( .NOT. VIRT_ADD_RESERVED_BEF_CALL                           &
     &    .AND. .NOT. VIRTUAL_ADDRESS_JUST_RESERVED )                   &
     &    THEN
          AddVirtLibre(TYPEF) = AddVirtLibre(TYPEF) - TOTSIZE
          LorU_AddVirtNodeI8 = 0_8
        ENDIF
      ELSE IF (.NOT. VIRT_ADD_RESERVED_BEF_CALL ) THEN
          VIRTUAL_ADDRESS_JUST_RESERVED = .TRUE.
      ENDIF
      IF ( VIRTUAL_ADDRESS_JUST_RESERVED) THEN
         OOC_INODE_SEQUENCE(I_CUR_HBUF_NEXTPOS(TYPEF),                  &
     &        TYPEF) = MonBloc%INODE
         I_CUR_HBUF_NEXTPOS(TYPEF) = I_CUR_HBUF_NEXTPOS(TYPEF) + 1
         IF (MonBloc%Last) THEN
           MAX_SIZE_FACTOR_OOC=max(MAX_SIZE_FACTOR_OOC,EFFSIZE)
           TMP_SIZE_FACT=TMP_SIZE_FACT+EFFSIZE
         ELSE
           MAX_SIZE_FACTOR_OOC=max(MAX_SIZE_FACTOR_OOC,TOTSIZE)
           TMP_SIZE_FACT=TMP_SIZE_FACT+TOTSIZE
         ENDIF
         TMP_NB_NODES=TMP_NB_NODES+1
         IF(TMP_SIZE_FACT.GT.SIZE_ZONE_SOLVE)THEN
            MAX_NB_NODES_FOR_ZONE=max(MAX_NB_NODES_FOR_ZONE,            &
     &           TMP_NB_NODES)
            TMP_SIZE_FACT=0_8
            TMP_NB_NODES=0
         ENDIF
      ENDIF
      IF (MonBloc%Last) THEN
        LorUSIZE_OF_BLOCK = - LorUSIZE_OF_BLOCK - 1_8
      ENDIF
      IF (LAST_CALL) THEN
        IF (.NOT.MonBloc%Last) THEN
          WRITE(6,*) ' Internal error in DMUMPS_695 ',                  &
     &               ' LAST and LAST_CALL are incompatible '
         CALL AGMG_MUMPS_ABORT()
        ENDIF
        LorUSIZE_OF_BLOCK = - LorUSIZE_OF_BLOCK - 1_8
        ICUR      = I_CUR_HBUF_NEXTPOS(TYPEF) - 1
        INODE_CUR = OOC_INODE_SEQUENCE(ICUR,TYPEF)
        ADDR_LAST = AddVirtLibre(TYPEF)
        IF (INODE_CUR .NE. MonBloc%INODE) THEN
   10     CONTINUE
          ILAST = ICUR
          IF ( OOC_VADDR(STEP_OOC(INODE_CUR),TYPEF) .NE. -9999_8) THEN
            ADDR_LAST = OOC_VADDR(STEP_OOC(INODE_CUR), TYPEF)
          ENDIF
          ICUR = ICUR - 1
          INODE_CUR = OOC_INODE_SEQUENCE(ICUR,TYPEF)
          IF (INODE_CUR .EQ. MonBloc%INODE) THEN
            LorUSIZE_OF_BLOCK = ADDR_LAST -                             &
     &                          OOC_VADDR(STEP_OOC(INODE_CUR),TYPEF)
          ELSE
            IF (ICUR .LE. 1) THEN
              WRITE(*,*) "Internal error in DAGMG_MUMPS_695"
              WRITE(*,*) "Did not find current node in sequence"
              CALL AGMG_MUMPS_ABORT()
            ENDIF
            GOTO 10
          ENDIF
        ENDIF
        FILESIZE  = FILESIZE + LorUSIZE_OF_BLOCK
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_695
      SUBROUTINE DAGMG_MUMPS_697(                                            &
     &     STRAT, TYPEF, MonBloc,                                       &
     &     SIZE_PANEL,                                                  &
     &     AFAC, LAFAC,                                                 &
     &     NextPiv2beWritten, AddVirtCour,                              &
     &     TailleEcrite, IERR )
      USE DAGMG_MUMPS_OOC_BUFFER
      IMPLICIT NONE
      INTEGER,       INTENT(IN) :: STRAT, TYPEF, SIZE_PANEL
      INTEGER(8)                :: LAFAC
      INTEGER*8,     INTENT(IN) ::  AddVirtCour
      DOUBLE PRECISION, INTENT(IN) :: AFAC(LAFAC)
      INTEGER,       INTENT(INOUT) :: NextPiv2beWritten
      TYPE(IO_BLOCK),INTENT(INOUT) :: MonBloc
      INTEGER(8),      INTENT(OUT) :: TailleEcrite
      INTEGER, INTENT(OUT)  :: IERR
      INTEGER   :: I, NBeff, LPANELeff, IEND
      INTEGER*8 :: AddVirtDeb
      IERR = 0
      TailleEcrite = 0_8
      AddVirtDeb   = AddVirtCour
      I = NextPiv2beWritten
      IF ( NextPiv2beWritten .GT. MonBloc%LastPiv ) THEN
        RETURN
      ENDIF
   10 CONTINUE
      NBeff  = min(SIZE_PANEL,MonBloc%LastPiv-I+1 )
      IF ((NBeff.NE.SIZE_PANEL) .AND. (.NOT.MonBloc%Last)) THEN
         GOTO 20
      ENDIF
      IF (TYPEF.EQ.TYPEF_L.AND.MonBloc%MASTER.AND.                      &
     &     KEEP_OOC(50).EQ.2 .AND. MonBloc%Typenode.NE.3) THEN
         IF (MonBloc%INDICES(NBeff+I-1) < 0)                            &
     &        THEN
            NBeff=NBeff+1
         ENDIF
      ENDIF
      IEND   = I + NBeff -1
      CALL DAGMG_MUMPS_653( STRAT, TYPEF, MonBloc,                           &
     &     AFAC, LAFAC,                                                 &
     &     AddVirtDeb, I, IEND, LPANELeff,                              &
     &     IERR)
      IF ( IERR .LT. 0 ) THEN
        RETURN
      ENDIF
      IF ( IERR .EQ. 1 ) THEN
         IERR=0
         GOTO 20
      ENDIF
      IF (TYPEF .EQ. TYPEF_L) THEN
         MonBloc%LastPanelWritten_L = MonBloc%LastPanelWritten_L+1
      ELSE
         MonBloc%LastPanelWritten_U = MonBloc%LastPanelWritten_U+1
      ENDIF
      AddVirtDeb   = AddVirtDeb + int(LPANELeff,8)
      TailleEcrite = TailleEcrite + int(LPANELeff,8)
      I=I+NBeff
      IF ( I .LE. MonBloc%LastPiv ) GOTO 10
   20 CONTINUE
      NextPiv2beWritten = I
      RETURN
      END SUBROUTINE DAGMG_MUMPS_697
      INTEGER(8) FUNCTION DAGMG_MUMPS_725                                    &
     &      (NFSorNPIV, NNMAX, SIZE_PANEL, MonBloc, ESTIM)
      IMPLICIT NONE
      TYPE(IO_BLOCK), INTENT(IN):: MonBloc
      INTEGER, INTENT(IN) :: NFSorNPIV, NNMAX, SIZE_PANEL
      LOGICAL, INTENT(IN) :: ESTIM
      INTEGER :: I, NBeff
      INTEGER(8) :: TOTSIZE
      TOTSIZE = 0_8
      IF (NFSorNPIV.EQ.0) GOTO 100
      IF (.NOT. MonBloc%MASTER .OR. MonBloc%TYPENODE.EQ.3) THEN
        TOTSIZE = int(NFSorNPIV,8) * int(NNMAX,8)
      ELSE
        I = 1
   10   CONTINUE
        NBeff = min(SIZE_PANEL, NFSorNPIV-I+1)
        IF (KEEP_OOC(50).EQ.2) THEN
          IF (ESTIM) THEN
            NBeff = NBeff + 1
          ELSE
             IF (MonBloc%INDICES(I+NBeff-1) < 0) THEN
            NBeff = NBeff + 1
            ENDIF
          ENDIF
        ENDIF
        TOTSIZE = TOTSIZE +                                             &
     &           int(NNMAX-I+1,8) * int(NBeff,8)
        I = I + NBeff
        IF ( I .LE. NFSorNPIV ) GOTO 10
      ENDIF
  100 CONTINUE
      DAGMG_MUMPS_725 = TOTSIZE
      RETURN
      END FUNCTION DAGMG_MUMPS_725
      INTEGER FUNCTION DAGMG_MUMPS_690( NNMAX )
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: NNMAX
      INTEGER DAGMG_MUMPS_748
      DAGMG_MUMPS_690=DAGMG_MUMPS_748(                                            &
     &     HBUF_SIZE, NNMAX, KEEP_OOC(227),KEEP_OOC(50))
      RETURN
      END FUNCTION DAGMG_MUMPS_690
      SUBROUTINE DAGMG_MUMPS_728()
      IMPLICIT NONE
      INTEGER I,TMP_NODE
      IF(.NOT.DAGMG_MUMPS_727())THEN
         IF(SOLVE_STEP.EQ.0)THEN
            I=CUR_POS_SEQUENCE
            TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,               &
     &           OOC_FCT_TYPE)
            DO WHILE ((I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE)).AND.      &
     &           (SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)        &
     &           .EQ.0_8))
               INODE_TO_POS(STEP_OOC(TMP_NODE))=1
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=NOT_USED
               I=I+1
               IF(I.LE.TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))THEN
                  TMP_NODE=OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
               ENDIF
            ENDDO
            CUR_POS_SEQUENCE=min(I,TOTAL_NB_OOC_NODES(OOC_FCT_TYPE))
         ELSE
            I=CUR_POS_SEQUENCE
            TMP_NODE=OOC_INODE_SEQUENCE(CUR_POS_SEQUENCE,               &
     &           OOC_FCT_TYPE)
            DO WHILE ((I.GE.1).AND.                                     &
     &           (SIZE_OF_BLOCK(STEP_OOC(TMP_NODE),OOC_FCT_TYPE)        &
     &           .EQ.0_8))
               INODE_TO_POS(STEP_OOC(TMP_NODE))=1
               OOC_STATE_NODE(STEP_OOC(TMP_NODE))=NOT_USED
               I=I-1
               IF(I.GE.1)THEN
                  TMP_NODE=OOC_INODE_SEQUENCE(I,OOC_FCT_TYPE)
               ENDIF
            ENDDO
            CUR_POS_SEQUENCE=max(I,1)
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_728
      END MODULE DAGMG_MUMPS_OOC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
        MODULE DAGMG_MUMPS_COMM_BUFFER
        PRIVATE
        PUBLIC :: DAGMG_MUMPS_61, DAGMG_MUMPS_528,                                &
     &   DAGMG_MUMPS_53 ,       DAGMG_MUMPS_57 ,                                  &
     &   DAGMG_MUMPS_55, DAGMG_MUMPS_59,                                          &
     &   DAGMG_MUMPS_54,DAGMG_MUMPS_58,                                           &
     &   DAGMG_MUMPS_66,     DAGMG_MUMPS_78,                                      &
     &   DAGMG_MUMPS_62,       DAGMG_MUMPS_68,                                    &
     &   DAGMG_MUMPS_71, DAGMG_MUMPS_70,                                          &
     &   DAGMG_MUMPS_67,                                                     &
     &   DAGMG_MUMPS_65,                                                     &
     &   DAGMG_MUMPS_64,                                                     &
     &   DAGMG_MUMPS_72,                                                     &
     &   DAGMG_MUMPS_648,                                                    &
     &   DAGMG_MUMPS_76,                                                     &
     &   DAGMG_MUMPS_73, DAGMG_MUMPS_74,                                          &
     &   DAGMG_MUMPS_63,DAGMG_MUMPS_77,                                           &
     &   DAGMG_MUMPS_60,                                                     &
     &   DAGMG_MUMPS_524, DAGMG_MUMPS_469,                                        &
     &   DAGMG_MUMPS_460, DAGMG_MUMPS_502,                                        &
     &   DAGMG_MUMPS_519                                                     &
     &   ,DAGMG_MUMPS_620                                                    &
     &   ,DAGMG_MUMPS_617
        INTEGER NEXT, REQ, CONTENT, OVHSIZE
        PARAMETER( NEXT = 0, REQ = 1, CONTENT = 2, OVHSIZE = 2 )
        INTEGER, SAVE :: SIZEofINT, SIZEofREAL, BUF_MYID
        TYPE DAGMG_MUMPS_COMM_BUFFER_TYPE
          INTEGER LBUF, HEAD, TAIL,LBUF_INT, ILASTMSG
          INTEGER, DIMENSION(:),POINTER :: CONTENT
        END TYPE DAGMG_MUMPS_COMM_BUFFER_TYPE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ), SAVE :: BUF_CB
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ), SAVE :: BUF_SMALL
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ), SAVE :: BUF_LOAD
        INTEGER, SAVE :: SIZE_RBUF_BYTES
        INTEGER BUF_LMAX_ARRAY
        DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: BUF_MAX_ARRAY
        PUBLIC :: BUF_LMAX_ARRAY, BUF_MAX_ARRAY
      CONTAINS
        SUBROUTINE DAGMG_MUMPS_528( MYID )
        IMPLICIT NONE
        INTEGER MYID
        BUF_MYID  = MYID
        RETURN
        END SUBROUTINE DAGMG_MUMPS_528
        SUBROUTINE DAGMG_MUMPS_61( IntSize, RealSize )
        IMPLICIT NONE
        INTEGER IntSize, RealSize
        SIZEofINT = IntSize
        SIZEofREAL = RealSize
        NULLIFY(BUF_CB  %CONTENT)
        NULLIFY(BUF_SMALL%CONTENT)
        NULLIFY(BUF_LOAD%CONTENT)
        BUF_CB%LBUF     = 0
        BUF_CB%LBUF_INT = 0
        BUF_CB%HEAD     = 1
        BUF_CB%TAIL     = 1
        BUF_CB%ILASTMSG = 1
        BUF_SMALL%LBUF     = 0
        BUF_SMALL%LBUF_INT = 0
        BUF_SMALL%HEAD     = 1
        BUF_SMALL%TAIL     = 1
        BUF_SMALL%ILASTMSG = 1
        BUF_LOAD%LBUF     = 0
        BUF_LOAD%LBUF_INT = 0
        BUF_LOAD%HEAD     = 1
        BUF_LOAD%TAIL     = 1
        BUF_LOAD%ILASTMSG = 1
        RETURN
        END SUBROUTINE DAGMG_MUMPS_61
        SUBROUTINE DAGMG_MUMPS_53( SIZE, IERR )
        IMPLICIT NONE
        INTEGER SIZE, IERR
        CALL DAGMG_MUMPS_2( BUF_CB, SIZE, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_53
        SUBROUTINE DAGMG_MUMPS_55( SIZE, IERR )
        IMPLICIT NONE
        INTEGER SIZE, IERR
        CALL DAGMG_MUMPS_2( BUF_SMALL, SIZE, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_55
        SUBROUTINE DAGMG_MUMPS_54( SIZE, IERR )
        IMPLICIT NONE
        INTEGER SIZE, IERR
        INTEGER stat
        CALL DAGMG_MUMPS_2( BUF_LOAD, SIZE, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_54
        SUBROUTINE DAGMG_MUMPS_58( IERR )
        IMPLICIT NONE
        INTEGER IERR
        CALL DAGMG_MUMPS_3( BUF_LOAD, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_58
        SUBROUTINE DAGMG_MUMPS_620()
        IMPLICIT NONE
        IF (allocated( BUF_MAX_ARRAY)) DEALLOCATE( BUF_MAX_ARRAY )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_620
        SUBROUTINE DAGMG_MUMPS_617(NFS4FATHER,IERR)
        IMPLICIT NONE
        INTEGER IERR, NFS4FATHER
        IERR = 0
        IF (allocated( BUF_MAX_ARRAY)) THEN
          IF (BUF_LMAX_ARRAY .GE. NFS4FATHER) RETURN
          DEALLOCATE( BUF_MAX_ARRAY )
        ENDIF
        ALLOCATE(BUF_MAX_ARRAY(NFS4FATHER),stat=IERR)
        BUF_LMAX_ARRAY=NFS4FATHER
        RETURN
        END SUBROUTINE DAGMG_MUMPS_617
        SUBROUTINE DAGMG_MUMPS_57( IERR )
        IMPLICIT NONE
        INTEGER IERR
        CALL DAGMG_MUMPS_3( BUF_CB, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_57
        SUBROUTINE DAGMG_MUMPS_59( IERR )
        IMPLICIT NONE
        INTEGER IERR
        CALL DAGMG_MUMPS_3( BUF_SMALL, IERR )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_59
        SUBROUTINE DAGMG_MUMPS_2( BUF, SIZE, IERR )
        IMPLICIT NONE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: BUF
        INTEGER SIZE, IERR
        IERR         = 0
        BUF%LBUF     = SIZE
        BUF%LBUF_INT = ( SIZE + SIZEofINT - 1 ) / SIZEofINT
        IF ( associated ( BUF%CONTENT ) ) DEALLOCATE( BUF%CONTENT )
        ALLOCATE( BUF%CONTENT( BUF%LBUF_INT ), stat = IERR )
        IF (IERR .NE. 0) THEN
          NULLIFY( BUF%CONTENT )
          IERR         = -1
          BUF%LBUF     =  0
          BUF%LBUF_INT =  0
        END IF
        BUF%HEAD     = 1
        BUF%TAIL     = 1
        BUF%ILASTMSG = 1
        RETURN
        END SUBROUTINE DAGMG_MUMPS_2
        SUBROUTINE DAGMG_MUMPS_3( BUF, IERR )
        IMPLICIT NONE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: BUF
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER IERR
        INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
        LOGICAL FLAG
        IF ( .NOT. associated ( BUF%CONTENT ) ) THEN
          BUF%HEAD     = 1
          BUF%LBUF     = 0
          BUF%LBUF_INT = 0
          BUF%TAIL     = 1
          BUF%ILASTMSG = 1
          RETURN
        END IF
        DO WHILE ( BUF%HEAD.NE.0 .AND. BUF%HEAD .NE. BUF%TAIL )
          CALL AGMG_MPF_TEST(BUF%CONTENT( BUF%HEAD + REQ ), FLAG,            &
     &                  STATUS, IERR)
          IF ( .not. FLAG ) THEN
            WRITE(*,*) '** Warning: trying to cancel a request.'
            WRITE(*,*) '** This might be problematic on SGI'
            CALL AGMG_SETIERR( IERR )
            CALL AGMG_SETIERR( IERR )
          END IF
          BUF%HEAD = BUF%CONTENT( BUF%HEAD + NEXT )
        END DO
        DEALLOCATE( BUF%CONTENT )
        NULLIFY( BUF%CONTENT )
        BUF%LBUF     = 0
        BUF%LBUF_INT = 0
        BUF%HEAD     = 1
        BUF%TAIL     = 1
        BUF%ILASTMSG = 1
        RETURN
        END SUBROUTINE DAGMG_MUMPS_3
        SUBROUTINE DAGMG_MUMPS_66( NBROWS_ALREADY_SENT,                      &
     &                                INODE, FPERE, NFRONT, LCONT,      &
     &                                NASS, NPIV,                       &
     &                                IWROW, IWCOL, A, COMPRESSCB,      &
     &                                DEST, TAG, COMM, IERR )
        IMPLICIT NONE
        INTEGER DEST, TAG, COMM, IERR
        INTEGER NBROWS_ALREADY_SENT
        INTEGER INODE, FPERE, NFRONT, LCONT, NASS, NPIV
        INTEGER IWROW( LCONT ), IWCOL( LCONT )
        DOUBLE PRECISION A( * )
        LOGICAL COMPRESSCB
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER NBROWS_PACKET
        INTEGER POSITION, IREQ, IPOS, I, J1
        INTEGER SIZE1, SIZE2, SIZE_PACK, SIZE_AV, SIZE_AV_REALS
        INTEGER IZERO, IONE
        INTEGER SIZECB
        INTEGER LCONT_SENT
        INTEGER DEST2(1)
        PARAMETER( IZERO = 0, IONE = 1 )
        LOGICAL RECV_BUF_SMALLER_THAN_SEND
        DEST2(1) = DEST
        IERR = 0
        IF (COMPRESSCB) THEN
          SIZECB = (LCONT*(LCONT+1))/2
        ELSE
          SIZECB = LCONT*LCONT
        ENDIF
      IF (NBROWS_ALREADY_SENT == 0) THEN
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
      ELSE
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
      ENDIF
      CALL DAGMG_MUMPS_79( BUF_CB, SIZE_AV )
      IF ( SIZE_AV .LT. SIZE_RBUF_BYTES ) THEN
        RECV_BUF_SMALLER_THAN_SEND = .FALSE.
      ELSE
        SIZE_AV = SIZE_RBUF_BYTES
        RECV_BUF_SMALLER_THAN_SEND = .TRUE.
      ENDIF
      SIZE_AV_REALS = ( SIZE_AV - SIZE1 ) / SIZEofREAL
      IF (SIZE_AV_REALS < 0 ) THEN
        NBROWS_PACKET = 0
      ELSE
        IF (COMPRESSCB) THEN
          NBROWS_PACKET = int( ( sqrt(                                  &
     &                     (2.0D0*dble(NBROWS_ALREADY_SENT)-1.0D0)*     &
     &                     (2.0D0*dble(NBROWS_ALREADY_SENT)-1.0D0)      &
     &                     + 8.0D0 * dble(SIZE_AV_REALS))               &
     &                  - 2.0D0 * dble(NBROWS_ALREADY_SENT) + 1.0D0 )   &
     &                  /2.0D0 )
        ELSE
          NBROWS_PACKET = SIZE_AV_REALS / LCONT
        ENDIF
      ENDIF
   10 CONTINUE
      NBROWS_PACKET = max(0,                                            &
     &          min(NBROWS_PACKET, LCONT - NBROWS_ALREADY_SENT))
      IF (NBROWS_PACKET .EQ. 0 .AND. LCONT .NE. 0) THEN
        IF (RECV_BUF_SMALLER_THAN_SEND) THEN
          IERR = -3
          GOTO 100
        ELSE
          IERR = -1
          GOTO 100
        ENDIF
      ENDIF
      IF (COMPRESSCB) THEN
        SIZECB = (NBROWS_ALREADY_SENT*NBROWS_PACKET)+(NBROWS_PACKET     &
     &           *(NBROWS_PACKET+1))/2
      ELSE
        SIZECB = NBROWS_PACKET * LCONT
      ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE_PACK = SIZE1 + SIZE2
       IF (SIZE_PACK .GT. SIZE_AV ) THEN
          NBROWS_PACKET = NBROWS_PACKET - 1
          IF (NBROWS_PACKET > 0) THEN
             GOTO 10
          ELSE
             IF (RECV_BUF_SMALLER_THAN_SEND) THEN
               IERR=-3
               GOTO 100
             ELSE
               IERR = -1
               GOTO 100
             ENDIF
          ENDIF
       ENDIF
       IF (NBROWS_PACKET + NBROWS_ALREADY_SENT.NE.LCONT .AND.           &
     &   SIZE_PACK  .LT. SIZE_RBUF_BYTES / 4                            &
     &  .AND.                                                           &
     &   .NOT. RECV_BUF_SMALLER_THAN_SEND)                              &
     &   THEN
           IERR = -1
           GOTO 100
       ENDIF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE_PACK, IERR,             &
     &                 IONE , DEST2                                     &
     &               )
        IF (IERR .EQ. -1 .OR. IERR .EQ. -2) THEN
          NBROWS_PACKET = NBROWS_PACKET - 1
          IF ( NBROWS_PACKET > 0 )  GOTO 10
        ENDIF
        IF ( IERR .LT. 0 ) GOTO 100
          IF (SIZE_PACK.GT.SIZE_RBUF_BYTES ) THEN
             IERR = -3
             RETURN
          ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (COMPRESSCB) THEN
          LCONT_SENT=-LCONT
        ELSE
          LCONT_SENT=LCONT
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
      IF (NBROWS_ALREADY_SENT == 0) THEN
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
       ENDIF
        IF ( LCONT .NE. 0 ) THEN
          J1 = 1 + NBROWS_ALREADY_SENT * NFRONT
          IF (COMPRESSCB) THEN
           DO I = NBROWS_ALREADY_SENT+1,                                &
     &            NBROWS_ALREADY_SENT+NBROWS_PACKET
            CALL AGMG_NOCALL('MPI_PACK')
             J1 = J1 + NFRONT
           END DO
          ELSE
           DO I = NBROWS_ALREADY_SENT+1,                                &
     &            NBROWS_ALREADY_SENT+NBROWS_PACKET
            CALL AGMG_NOCALL('MPI_PACK')
             J1 = J1 + NFRONT
           END DO
          ENDIF
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE_PACK .LT. POSITION ) THEN
          WRITE(*,*) 'Try_send_cb: SIZE, POSITION = ', SIZE_PACK,       &
     &               POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE_PACK .NE. POSITION )                                  &
     &  CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        NBROWS_ALREADY_SENT = NBROWS_ALREADY_SENT + NBROWS_PACKET
        IF (NBROWS_ALREADY_SENT .NE. LCONT ) THEN
          IERR = -1
          RETURN
        ENDIF
  100   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_66
        SUBROUTINE DAGMG_MUMPS_72( NRHS, INODE, IFATH,                       &
     &             EFF_CB_SIZE, LD_CB, LD_PIV, NPIV, CB, SOL,           &
     &             DEST, COMM, IERR )
        IMPLICIT NONE
        INTEGER NRHS, INODE, IFATH, EFF_CB_SIZE, LD_CB, LD_PIV, NPIV
        INTEGER DEST, COMM, IERR
        DOUBLE PRECISION CB( LD_CB*(NRHS-1)+EFF_CB_SIZE )
        DOUBLE PRECISION SOL( max(1, LD_PIV*(NRHS-1)+NPIV) )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE, SIZE1, SIZE2, K
        INTEGER POSITION, IREQ, IPOS
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1) = DEST
        IERR = 0
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 IONE , DEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        DO K = 1, NRHS
               CALL AGMG_NOCALL('MPI_PACK')
        END DO
        IF ( NPIV .GT. 0 ) THEN
          DO K=1, NRHS
          CALL AGMG_NOCALL('MPI_PACK')
          ENDDO
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) 'Try_send_master2slave: SIZE, POSITION = ',        &
     &               SIZE, POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION ) CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_72
        SUBROUTINE DAGMG_MUMPS_78( NRHS, NODE1, NODE2, NCB, LDW,             &
     &             LONG,                                                &
     &             IW, W,                                               &
     &             DEST, TAG, COMM, IERR )
        IMPLICIT NONE
        INTEGER LDW, DEST, TAG, COMM, IERR
        INTEGER NRHS, NODE1, NODE2, NCB, LONG
        INTEGER IW( max( 1, LONG ) )
        DOUBLE PRECISION W( max( 1, LDW * NRHS ) )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER POSITION, IREQ, IPOS
        INTEGER SIZE1, SIZE2, SIZE, K
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1)=DEST
        IERR = 0
        IF ( NODE2 .EQ. 0 ) THEN
         CALL AGMG_NOCALL('MPI_PACK_SIZE')
        ELSE
         CALL AGMG_NOCALL('MPI_PACK_SIZE')
        END IF
        SIZE2 = 0
        IF ( LONG .GT. 0 ) THEN
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
        END IF
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 IONE , DEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( NODE2 .NE. 0 ) THEN
          CALL AGMG_NOCALL('MPI_PACK')
          CALL AGMG_NOCALL('MPI_PACK')
        END IF
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( LONG .GT. 0 ) THEN
          CALL AGMG_NOCALL('MPI_PACK')
          DO K=1, NRHS
          CALL AGMG_NOCALL('MPI_PACK')
          END DO
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE .NE. POSITION ) CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_78
        SUBROUTINE DAGMG_MUMPS_62( I, DEST, TAG, COMM, IERR )
        IMPLICIT NONE
        INTEGER I
        INTEGER DEST, TAG, COMM, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER IPOS, IREQ, MSG_SIZE, POSITION
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1)=DEST
        IERR = 0
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL DAGMG_MUMPS_4( BUF_SMALL, IPOS, IREQ, MSG_SIZE, IERR,           &
     &                 IONE , DEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
         write(6,*) ' Internal error in DMUMPS_62',                     &
     &       ' Buf size (bytes)= ',BUF_SMALL%LBUF
         RETURN
        ENDIF
        POSITION=0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_ISEND')
        RETURN
        END SUBROUTINE DAGMG_MUMPS_62
        SUBROUTINE DAGMG_MUMPS_469(FLAG)
        LOGICAL FLAG
        LOGICAL FLAG1, FLAG2, FLAG3
        CALL DAGMG_MUMPS_468( BUF_SMALL, FLAG1 )
        CALL DAGMG_MUMPS_468( BUF_CB, FLAG2 )
        CALL DAGMG_MUMPS_468( BUF_LOAD, FLAG3 )
        FLAG = FLAG1 .AND. FLAG2 .AND. FLAG3
        RETURN
        END SUBROUTINE DAGMG_MUMPS_469
        SUBROUTINE DAGMG_MUMPS_468( B, FLAG )
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: B
        LOGICAL :: FLAG
        INTEGER SIZE_AVAIL
        CALL DAGMG_MUMPS_79(B, SIZE_AVAIL)
        FLAG = ( B%HEAD == B%TAIL )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_468
        SUBROUTINE DAGMG_MUMPS_79( B, SIZE_AV )
        IMPLICIT NONE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: B
        INTEGER SIZE_AV
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER IERR
        INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
        LOGICAL FLAG
        IF ( B%HEAD .NE. B%TAIL ) THEN
   10     CONTINUE
          CALL AGMG_MPF_TEST( B%CONTENT( B%HEAD + REQ ), FLAG, STATUS, IERR )
          IF ( FLAG ) THEN
            B%HEAD = B%CONTENT( B%HEAD + NEXT )
            IF ( B%HEAD .EQ. 0 ) B%HEAD = B%TAIL
            IF ( B%HEAD .NE. B%TAIL ) GOTO 10
          END IF
        END IF
        IF ( B%HEAD .EQ. B%TAIL ) THEN
          B%HEAD = 1
          B%TAIL = 1
          B%ILASTMSG = 1
        END IF
        IF ( B%HEAD .LE. B%TAIL ) THEN
           SIZE_AV = max( B%LBUF_INT - B%TAIL, B%HEAD - 2 )
        ELSE
           SIZE_AV = B%HEAD - B%TAIL - 1
        END IF
        SIZE_AV = min(SIZE_AV - OVHSIZE, SIZE_AV)
        SIZE_AV = SIZE_AV * SIZEofINT
        RETURN
        END SUBROUTINE DAGMG_MUMPS_79
        SUBROUTINE DAGMG_MUMPS_4( B, IPOS, IREQ, MSG_SIZE, IERR,             &
     &    NDEST , PDEST                                                 &
     &         )
        IMPLICIT NONE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: B
        INTEGER, INTENT(IN)        :: MSG_SIZE
        INTEGER, INTENT(OUT)       :: IPOS, IREQ, IERR
        INTEGER NDEST
        INTEGER, INTENT(IN)        :: PDEST(max(1,NDEST))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER MSG_SIZE_INT
        INTEGER IBUF
        LOGICAL FLAG
        INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
        IERR = 0
        IF ( B%HEAD .NE. B%TAIL ) THEN
   10     CONTINUE
          CALL AGMG_MPF_TEST( B%CONTENT( B%HEAD + REQ ), FLAG, STATUS, IERR )
          IF ( FLAG ) THEN
            B%HEAD = B%CONTENT( B%HEAD + NEXT )
            IF ( B%HEAD .EQ. 0 ) B%HEAD = B%TAIL
            IF ( B%HEAD .NE. B%TAIL ) GOTO 10
          END IF
        END IF
        IF ( B%HEAD .EQ. B%TAIL ) THEN
          B%HEAD = 1
          B%TAIL = 1
          B%ILASTMSG = 1
        END iF
        MSG_SIZE_INT = ( MSG_SIZE + ( SIZEofINT - 1 ) ) / SIZEofINT
        MSG_SIZE_INT = MSG_SIZE_INT + OVHSIZE
        FLAG = (     ( B%HEAD .LE. B%TAIL )                             &
     &               .AND. (                                            &
     &                 ( MSG_SIZE_INT .LE. B%LBUF_INT - B%TAIL )        &
     &                 .OR. ( MSG_SIZE_INT .LE. B%HEAD - 2 ) ) )        &
     &         .OR.                                                     &
     &               ( ( B%HEAD .GT. B%TAIL )                           &
     &               .AND. ( MSG_SIZE_INT .LE. B%HEAD - B%TAIL - 1 ) )
        IF ( .NOT. FLAG                                                 &
     &    ) THEN
          IERR = -1
          IF ( MSG_SIZE_INT .GT. B%LBUF_INT - 1 ) then
            IERR = -2
          ENDIF
          IPOS = -1
          IREQ = -1
          RETURN
        END IF
        IF ( B%HEAD .LE. B%TAIL ) THEN
          IF ( MSG_SIZE_INT .LE. B%LBUF_INT - B%TAIL + 1 ) THEN
            IBUF = B%TAIL
          ELSE IF ( MSG_SIZE_INT .LE. B%HEAD - 1 ) THEN
            IBUF = 1
          END IF
        ELSE
          IBUF = B%TAIL
        END IF
        B%CONTENT( B%ILASTMSG + NEXT ) = IBUF
        B%ILASTMSG = IBUF
        B%TAIL = IBUF + MSG_SIZE_INT
        B%CONTENT( IBUF + NEXT ) = 0
        IPOS = IBUF + CONTENT
        IREQ = IBUF + REQ
        RETURN
        END SUBROUTINE DAGMG_MUMPS_4
        SUBROUTINE DAGMG_MUMPS_1( BUF, SIZE )
        IMPLICIT NONE
        TYPE ( DAGMG_MUMPS_COMM_BUFFER_TYPE ) :: BUF
        INTEGER SIZE
        INTEGER SIZE_INT
        SIZE_INT = ( SIZE + SIZEofINT - 1 ) / SIZEofINT
        SIZE_INT = SIZE_INT + OVHSIZE
        BUF%TAIL = BUF%ILASTMSG + SIZE_INT
        RETURN
        END SUBROUTINE DAGMG_MUMPS_1
      SUBROUTINE DAGMG_MUMPS_68(                                             &
     &             INODE, NBPROCFILS, NLIG, ILIG, NCOL, ICOL,           &
     &             NASS, NSLAVES, LIST_SLAVES,                          &
     &             DEST, NFRONT, COMM, IERR )
      IMPLICIT NONE
        INTEGER COMM, IERR, NFRONT
        INTEGER INODE
        INTEGER NLIG, NCOL, NASS, NSLAVES
        INTEGER NBPROCFILS, DEST
        INTEGER ILIG( NLIG )
        INTEGER ICOL( NCOL )
        INTEGER LIST_SLAVES( NSLAVES )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE, POSITION, IPOS, IREQ
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1) = DEST
        IERR = 0
        SIZE = ( 6 + NLIG + NCOL + NSLAVES + 1 ) * SIZEofINT
        IF (SIZE.GT.SIZE_RBUF_BYTES ) THEN
         IERR = -2
         RETURN
        END IF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 IONE , DEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        POSITION = IPOS
        BUF_CB%CONTENT( POSITION ) = INODE
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NBPROCFILS
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NLIG
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NCOL
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NASS
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NFRONT
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NSLAVES
        POSITION = POSITION + 1
        IF (NSLAVES.GT.0) THEN
         BUF_CB%CONTENT( POSITION: POSITION + NSLAVES - 1 ) =           &
     &   LIST_SLAVES( 1: NSLAVES )
         POSITION = POSITION + NSLAVES
        ENDIF
        BUF_CB%CONTENT( POSITION:POSITION + NLIG - 1 ) = ILIG
        POSITION = POSITION + NLIG
        BUF_CB%CONTENT( POSITION:POSITION + NCOL - 1 ) = ICOL
        POSITION = POSITION + NCOL
        POSITION = POSITION - IPOS
        IF ( POSITION * SIZEofINT .NE. SIZE ) THEN
          WRITE(*,*) 'Error in DMUMPS_68 :',                            &
     &               ' wrong estimated size'
          CALL AGMG_MUMPS_ABORT()
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        RETURN
        END SUBROUTINE DAGMG_MUMPS_68
        SUBROUTINE DAGMG_MUMPS_70( NBROWS_ALREADY_SENT,                      &
     &  IPERE, ISON, NROW,                                              &
     &  IROW, NCOL, ICOL, VAL, LDA, NELIM, TYPE_SON,                    &
     &  NSLAVES, SLAVES, DEST, COMM, IERR,                              &
     &  SLAVEF, KEEP,KEEP8, INIV2, TAB_POS_IN_PERE )
        IMPLICIT NONE
        INTEGER NBROWS_ALREADY_SENT
        INTEGER LDA, NELIM, TYPE_SON
        INTEGER IPERE, ISON, NROW, NCOL, NSLAVES
        INTEGER IROW( NROW )
        INTEGER ICOL( NCOL )
        INTEGER SLAVES( NSLAVES )
        DOUBLE PRECISION VAL(LDA, *)
        INTEGER IPOS, IREQ, DEST, COMM, IERR
        INTEGER SLAVEF, KEEP(500), INIV2
        INTEGER*8 KEEP8(150)
        INTEGER TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE1, SIZE2, SIZE3, SIZE_PACK, POSITION, I
        INTEGER NBROWS_PACKET, NCOL_SEND
        INTEGER SIZE_AV
        LOGICAL RECV_BUF_SMALLER_THAN_SEND
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1) = DEST
        IERR = 0
        IF ( NELIM .NE. NROW ) THEN
          WRITE(*,*) 'Error in TRY_SEND_MAITRE2:',NELIM, NROW
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF (NBROWS_ALREADY_SENT .EQ. 0) THEN
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          IF ( ( KEEP(48).NE. 0 ).AND.(TYPE_SON .eq. 2 )) THEN
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          ELSE
            SIZE3 = 0
          ENDIF
          SIZE1=SIZE1+SIZE3
        ELSE
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
        ENDIF
        IF ( KEEP(50).ne.0  .AND. TYPE_SON .eq. 2 ) THEN
          NCOL_SEND = NROW
        ELSE
          NCOL_SEND = NCOL
        ENDIF
        CALL DAGMG_MUMPS_79( BUF_CB, SIZE_AV )
        IF (SIZE_AV .LT. SIZE_RBUF_BYTES) THEN
          RECV_BUF_SMALLER_THAN_SEND = .FALSE.
        ELSE
          RECV_BUF_SMALLER_THAN_SEND = .TRUE.
        ENDIF
        SIZE_AV = min(SIZE_AV, SIZE_RBUF_BYTES)
        IF (NROW .GT. 0 ) THEN
         NBROWS_PACKET = (SIZE_AV - SIZE1) / NCOL_SEND / SIZEofREAL
         NBROWS_PACKET = min(NBROWS_PACKET, NROW - NBROWS_ALREADY_SENT)
         NBROWS_PACKET = max(NBROWS_PACKET, 0)
        ELSE
          NBROWS_PACKET =0
        ENDIF
        IF (NBROWS_PACKET .EQ. 0 .AND. NROW .NE. 0) THEN
          IF (RECV_BUF_SMALLER_THAN_SEND) THEN
              IERR=-3
              GOTO 100
          ELSE
              IERR=-1
              GOTO 100
          ENDIF
        ENDIF
   10   CONTINUE
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE_PACK = SIZE1 + SIZE2
        IF (SIZE_PACK .GT. SIZE_AV) THEN
          NBROWS_PACKET = NBROWS_PACKET - 1
          IF ( NBROWS_PACKET .GT. 0 ) THEN
            GOTO 10
          ELSE
            IF (RECV_BUF_SMALLER_THAN_SEND) THEN
                IERR = -3
                GOTO 100
            ELSE
                IERR = -1
                GOTO 100
            ENDIF
          ENDIF
        ENDIF
       IF (NBROWS_PACKET + NBROWS_ALREADY_SENT.NE.NROW .AND.            &
     &   SIZE_PACK - SIZE1  .LT. ( SIZE_RBUF_BYTES - SIZE1 ) / 2        &
     &  .AND.                                                           &
     &   .NOT. RECV_BUF_SMALLER_THAN_SEND)                              &
     &   THEN
           IERR = -1
           GOTO 100
       ENDIF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE_PACK, IERR,             &
     &                 IONE , DEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
          GOTO 100
        ENDIF
        IF (SIZE_PACK .GT. SIZE_RBUF_BYTES) THEN
          IERR=-3
             GOTO 100
        ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (NBROWS_ALREADY_SENT .EQ. 0) THEN
          IF (NSLAVES.GT.0) THEN
            CALL AGMG_NOCALL('MPI_PACK')
          ENDIF
          CALL AGMG_NOCALL('MPI_PACK')
          CALL AGMG_NOCALL('MPI_PACK')
          IF ( ( KEEP(48).NE. 0 ).AND.(TYPE_SON .eq. 2 ) ) THEN
            CALL AGMG_NOCALL('MPI_PACK')
          ENDIF
        ENDIF
        IF (NBROWS_PACKET.GE.1) THEN
          DO I=NBROWS_ALREADY_SENT+1,                                   &
     &                   NBROWS_ALREADY_SENT+NBROWS_PACKET
            CALL AGMG_NOCALL('MPI_PACK')
          ENDDO
        ENDIF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE_PACK .LT. POSITION ) THEN
          write(*,*) 'Try_send_maitre2, SIZE,POSITION=',                &
     &                SIZE_PACK,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE_PACK .NE. POSITION )                                  &
     &    CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        NBROWS_ALREADY_SENT = NBROWS_ALREADY_SENT + NBROWS_PACKET
        IF ( NBROWS_ALREADY_SENT .NE. NROW ) THEN
          IERR = -1
        ENDIF
  100   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_70
        SUBROUTINE DAGMG_MUMPS_67(NBROWS_ALREADY_SENT,                       &
     &  DESC_IN_LU,                                                     &
     &  IPERE, NFRONT_PERE, NASS_PERE, NFS4FATHER,                      &
     &  NSLAVES_PERE,                                                   &
     &  ISON, NBROW, LMAP, MAPROW, PERM, IW_CBSON, A_CBSON,             &
     &  ISLAVE, PDEST, PDEST_MASTER, COMM, IERR,                        &
     & KEEP,KEEP8, STEP, N, SLAVEF,                                     &
     & ISTEP_TO_INIV2, TAB_POS_IN_PERE,                                 &
     & COMPRESSCB )
        IMPLICIT NONE
        INTEGER NBROWS_ALREADY_SENT
        INTEGER IPERE, ISON, NBROW
        INTEGER PDEST, ISLAVE, COMM, IERR
        INTEGER PDEST_MASTER, NASS_PERE, NSLAVES_PERE,                  &
     &       NFRONT_PERE, LMAP
        INTEGER MAPROW( LMAP ), PERM( max(1, NBROW ))
        INTEGER IW_CBSON( * )
        DOUBLE PRECISION A_CBSON( * )
        LOGICAL DESC_IN_LU, COMPRESSCB
       INTEGER   KEEP(500), N , SLAVEF
       INTEGER*8 KEEP8(150)
       INTEGER   STEP(N),                                               &
     &          ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER NFS4FATHER,SIZE3,PS1,NCA,OFFSET,LROW1
      INTEGER(8) :: ASIZE
      LOGICAL COMPUTE_MAX
      DOUBLE PRECISION TMP
      INTEGER NBROWS_PACKET
      INTEGER MAX_ROW_LENGTH
      INTEGER LROW, NELIM
      INTEGER(8) :: SIZFR, ITMP8
      INTEGER NPIV, NFRONT, HS
      INTEGER SIZE_PACK, SIZE1, SIZE2, POSITION,I
      INTEGER SIZE_INTEGERS, B, SIZE_REALS, TMPSIZE, ONEorTWO, SIZE_AV
      INTEGER NBINT, L
      INTEGER(8) :: APOS, SHIFTCB_SON, LDA_SON8
      INTEGER IPOS_IN_SLAVE
      INTEGER STATE_SON
      INTEGER INDICE_PERE, NROW, IPOS, IREQ, NOSLA
      INTEGER IONE, J, THIS_ROW_LENGTH
      INTEGER SIZE_DESC_BANDE, DESC_BANDE_BYTES
      LOGICAL RECV_BUF_SMALLER_THAN_SEND
      LOGICAL NOT_ENOUGH_SPACE
      INTEGER PDEST2(1)
      PARAMETER ( IONE=1 )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO = 0.0D0)
      IF (NBROWS_ALREADY_SENT == 0) THEN
        IF (KEEP(219).NE.0) THEN
          CALL DAGMG_MUMPS_617(NFS4FATHER,IERR)
          IF (IERR .NE. 0) THEN
            IERR         = -4
            RETURN
          ENDIF
        ENDIF
      ENDIF
      PDEST2(1) = PDEST
      IERR   = 0
      LROW   = IW_CBSON( 1 + KEEP(IXSZ))
      NELIM  = IW_CBSON( 2 + KEEP(IXSZ))
      NPIV   = IW_CBSON( 4 + KEEP(IXSZ))
      IF ( NPIV .LT. 0 ) THEN
          NPIV = 0
      END IF
      NROW   = IW_CBSON( 3 + KEEP(IXSZ))
      NFRONT = LROW + NPIV
      HS     = 6 + IW_CBSON( 6 + KEEP(IXSZ)) + KEEP(IXSZ)
      CALL AGMG_MUMPS_729( SIZFR, IW_CBSON( 1 + XXR ) )
      STATE_SON = IW_CBSON(1+XXS)
      IF (STATE_SON .EQ. S_NOLCBCONTIG) THEN
               LDA_SON8    = int(LROW,8)
               SHIFTCB_SON = int(NPIV,8)*int(NROW,8)
      ELSE IF (STATE_SON .EQ. S_NOLCLEANED) THEN
               LDA_SON8    = int(LROW,8)
               SHIFTCB_SON = 0_8
      ELSE
               LDA_SON8     = int(NFRONT,8)
               SHIFTCB_SON = int(NPIV,8)
      ENDIF
      CALL DAGMG_MUMPS_79( BUF_CB, SIZE_AV )
      IF (PDEST .EQ. PDEST_MASTER) THEN
        SIZE_DESC_BANDE=0
      ELSE
        SIZE_DESC_BANDE=(7+SLAVEF+KEEP(127)*2)
        SIZE_DESC_BANDE=SIZE_DESC_BANDE+int(dble(KEEP(12))*             &
     &                  dble(SIZE_DESC_BANDE)/100.0D0)
        SIZE_DESC_BANDE=max(SIZE_DESC_BANDE,                            &
     &     7+NSLAVES_PERE+NFRONT_PERE+NFRONT_PERE-NASS_PERE)
      ENDIF
      DESC_BANDE_BYTES=SIZE_DESC_BANDE*SIZEofINT
      IF ( SIZE_AV .LT. SIZE_RBUF_BYTES-DESC_BANDE_BYTES ) THEN
        RECV_BUF_SMALLER_THAN_SEND = .FALSE.
      ELSE
        RECV_BUF_SMALLER_THAN_SEND = .TRUE.
        SIZE_AV = SIZE_RBUF_BYTES-DESC_BANDE_BYTES
      ENDIF
      SIZE1=0
      IF (NBROWS_ALREADY_SENT==0) THEN
          IF (KEEP(219).NE.0) THEN
            COMPUTE_MAX = KEEP(50).EQ.2 .AND.                           &
     &           PDEST.EQ.PDEST_MASTER
            IF(COMPUTE_MAX) THEN
               CALL AGMG_NOCALL('MPI_PACK_SIZE')
               IF(NFS4FATHER .GT. 0) THEN
                CALL AGMG_NOCALL('MPI_PACK_SIZE')
               ENDIF
               SIZE1 = SIZE1+PS1
            ENDIF
          ENDIF
      ENDIF
      IF (KEEP(50) .EQ. 0) THEN
        ONEorTWO = 1
      ELSE
        ONEorTWO = 2
      ENDIF
      IF (PDEST .EQ.PDEST_MASTER) THEN
        L = 0
      ELSE IF (KEEP(50) .EQ. 0) THEN
        L = LROW
      ELSE
        L = LROW + PERM(1) - LMAP + NBROWS_ALREADY_SENT - 1
        ONEorTWO=ONEorTWO+1
      ENDIF
      NBINT = 6 + L
      CALL AGMG_NOCALL('MPI_PACK_SIZE')
      SIZE1 = SIZE1 + TMPSIZE
      SIZE_AV = SIZE_AV - SIZE1
      NOT_ENOUGH_SPACE=.FALSE.
      IF (SIZE_AV .LT.0 ) THEN
        NBROWS_PACKET = 0
        NOT_ENOUGH_SPACE=.TRUE.
      ELSE
        IF ( KEEP(50) .EQ. 0 ) THEN
          NBROWS_PACKET =                                               &
     &       SIZE_AV / ( ONEorTWO*SIZEofINT+LROW*SIZEofREAL)
        ELSE
          B = 2 * ONEorTWO +                                            &
     &      ( 1 + 2 *  LROW + 2 * PERM(1) + 2 * NBROWS_ALREADY_SENT )   &
     &      * SIZEofREAL / SIZEofINT
          NBROWS_PACKET=int((dble(-B)+sqrt((dble(B)*dble(B))+           &
     &        dble(4)*dble(2*SIZE_AV)/dble(SIZEofINT) *                 &
     &        dble(SIZEofREAL/SIZEofINT)))*                             &
     &        dble(SIZEofINT) / dble(2) / dble(SIZEofREAL))
        ENDIF
      ENDIF
   10 CONTINUE
      NBROWS_PACKET = max( 0,                                           &
     &           min( NBROWS_PACKET, NBROW - NBROWS_ALREADY_SENT))
      NOT_ENOUGH_SPACE = NOT_ENOUGH_SPACE .OR.                          &
     &                   (NBROWS_PACKET .EQ.0.AND. NBROW.NE.0)
      IF (NOT_ENOUGH_SPACE) THEN
        IF (RECV_BUF_SMALLER_THAN_SEND) THEN
          IERR = -3
          GOTO 100
        ELSE
          IERR = -1
          GOTO 100
        ENDIF
      ENDIF
      IF (KEEP(50).EQ.0) THEN
        MAX_ROW_LENGTH = -99999
        SIZE_REALS = NBROWS_PACKET * LROW
      ELSE
        SIZE_REALS = (  LROW + PERM(1) + NBROWS_ALREADY_SENT ) *        &
     &  NBROWS_PACKET + ( NBROWS_PACKET * ( NBROWS_PACKET + 1) ) / 2
        MAX_ROW_LENGTH = LROW+PERM(1)-LMAP+NBROWS_ALREADY_SENT          &
     &                 + NBROWS_PACKET-1
      ENDIF
      SIZE_INTEGERS = ONEorTWO* NBROWS_PACKET
      CALL AGMG_NOCALL('MPI_PACK_SIZE')
      CALL AGMG_NOCALL('MPI_PACK_SIZE')
      IF (SIZE2 + SIZE3 .GT. SIZE_AV ) THEN
         NBROWS_PACKET = NBROWS_PACKET -1
         IF (NBROWS_PACKET .GT. 0 ) THEN
           GOTO 10
         ELSE
           IF (RECV_BUF_SMALLER_THAN_SEND) THEN
             IERR = -3
             GOTO 100
           ELSE
             IERR = -1
             GOTO 100
           ENDIF
         ENDIF
      ENDIF
        SIZE_PACK = SIZE1 + SIZE2 + SIZE3
        IF (NBROWS_PACKET + NBROWS_ALREADY_SENT.NE.NBROW .AND.          &
     &    SIZE_PACK  .LT. SIZE_RBUF_BYTES / 4 .AND.                     &
     &    .NOT. RECV_BUF_SMALLER_THAN_SEND)                             &
     &    THEN
            IERR = -1
            GOTO 100
        ENDIF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE_PACK, IERR,             &
     &                 IONE , PDEST2                                    &
     &               )
        IF (IERR .EQ. -1 .OR. IERR.EQ. -2) THEN
          NBROWS_PACKET = NBROWS_PACKET - 1
          IF (NBROWS_PACKET > 0 ) GOTO 10
        ENDIF
        IF ( IERR .LT. 0 ) GOTO 100
          IF (SIZE_PACK.GT.SIZE_RBUF_BYTES ) THEN
             IERR = -3
             GOTO 100
          ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (KEEP(50)==0) THEN
        CALL AGMG_NOCALL('MPI_PACK')
        ELSE
        CALL AGMG_NOCALL('MPI_PACK')
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( PDEST .NE. PDEST_MASTER ) THEN
          IF (KEEP(50)==0) THEN
          CALL AGMG_NOCALL('MPI_PACK')
          ELSE
           IF (MAX_ROW_LENGTH > 0) THEN
           CALL AGMG_NOCALL('MPI_PACK')
           ENDIF
          ENDIF
        END IF
        DO J=NBROWS_ALREADY_SENT+1,NBROWS_ALREADY_SENT+NBROWS_PACKET
           I = PERM(J)
           INDICE_PERE=MAPROW(I)
           CALL AGMG_MUMPS_47(                                               &
     &          KEEP,KEEP8, IPERE, STEP, N, SLAVEF,                     &
     &          ISTEP_TO_INIV2, TAB_POS_IN_PERE,                        &
     &          NASS_PERE,                                              &
     &          NFRONT_PERE - NASS_PERE,                                &
     &          NSLAVES_PERE,                                           &
     &          INDICE_PERE,                                            &
     &          NOSLA,                                                  &
     &          IPOS_IN_SLAVE )
           INDICE_PERE = IPOS_IN_SLAVE
           CALL AGMG_NOCALL('MPI_PACK')
        ENDDO
        DO J=NBROWS_ALREADY_SENT+1,NBROWS_ALREADY_SENT+NBROWS_PACKET
           I = PERM(J)
           INDICE_PERE=MAPROW(I)
           CALL AGMG_MUMPS_47(                                               &
     &          KEEP,KEEP8, IPERE, STEP, N, SLAVEF,                     &
     &          ISTEP_TO_INIV2, TAB_POS_IN_PERE,                        &
     &          NASS_PERE,                                              &
     &          NFRONT_PERE - NASS_PERE,                                &
     &          NSLAVES_PERE,                                           &
     &          INDICE_PERE,                                            &
     &          NOSLA,                                                  &
     &          IPOS_IN_SLAVE )
          IF (KEEP(50).ne.0) THEN
            THIS_ROW_LENGTH = LROW + I - LMAP
            CALL AGMG_NOCALL('MPI_PACK')
         ELSE
            THIS_ROW_LENGTH = LROW
         ENDIF
         IF (DESC_IN_LU) THEN
            IF ( COMPRESSCB ) THEN
             IF (NELIM.EQ.0) THEN
               ITMP8 = int(I,8)
             ELSE
               ITMP8 = int(NELIM+I,8)
             ENDIF
             APOS = ITMP8 * (ITMP8-1_8) / 2_8 + 1_8
            ELSE
             APOS = int(I+NELIM-1, 8) * int(LROW,8) + 1_8
            ENDIF
         ELSE
            IF ( COMPRESSCB ) THEN
             IF ( LROW .EQ. NROW )  THEN
               ITMP8 = int(I,8)
               APOS  = ITMP8 * (ITMP8-1_8)/2_8 + 1_8
             ELSE
               ITMP8 = int(I + LROW - NROW,8)
               APOS  = ITMP8 * (ITMP8-1_8)/2_8 + 1_8 -                  &
     &                 int(LROW - NROW, 8) * int(LROW-NROW+1,8) / 2_8
             ENDIF
            ELSE
             APOS = int( I - 1, 8 ) * LDA_SON8 + SHIFTCB_SON + 1_8
            ENDIF
         ENDIF
         CALL AGMG_NOCALL('MPI_PACK')
        ENDDO
      IF (NBROWS_ALREADY_SENT == 0) THEN
      IF (KEEP(219).NE.0) THEN
        IF(COMPUTE_MAX) THEN
           CALL AGMG_NOCALL('MPI_PACK')
           IF(NFS4FATHER .GT. 0) THEN
              BUF_MAX_ARRAY(1:NFS4FATHER) = ZERO
              IF(MAPROW(NROW) .GT. NASS_PERE) THEN
                 DO PS1=1,NROW
                    IF(MAPROW(PS1).GT.NASS_PERE) EXIT
                 ENDDO
                 IF (DESC_IN_LU) THEN
                   IF (COMPRESSCB) THEN
                    APOS = int(NELIM+PS1,8) * int(NELIM+PS1-1,8) /      &
     &                     2_8 + 1_8
                    NCA  = -44444
                    ASIZE  = int(NROW,8) * int(NROW+1,8)/2_8 -          &
     &                       int(NELIM+PS1,8) * int(NELIM+PS1-1,8)/2_8
                    LROW1  = PS1 + NELIM
                   ELSE
                    APOS = int(PS1+NELIM-1,8) * int(LROW,8) + 1_8
                    NCA = LROW
                    ASIZE = int(NCA,8) * int(NROW-PS1+1,8)
                    LROW1 = LROW
                   ENDIF
                 ELSE
                    IF (COMPRESSCB) THEN
                      IF (NPIV.NE.0) THEN
         WRITE(*,*) "Error in PARPIV/DAGMG_MUMPS_67"
                        CALL AGMG_MUMPS_ABORT()
                      ENDIF
                      LROW1=LROW-NROW+PS1
                      ITMP8 = int(PS1 + LROW - NROW,8)
                      APOS = ITMP8 * (ITMP8 - 1_8) / 2_8 + 1_8 -        &
     &                       int(LROW-NROW,8)*int(LROW-NROW+1,8)/2_8
                      ASIZE = int(LROW,8)*int(LROW+1,8)/2_8 -           &
     &                       ITMP8*(ITMP8-1_8)/2_8
                      NCA   = -555555
                    ELSE
                      APOS = int(PS1-1,8) * LDA_SON8 + 1_8 + SHIFTCB_SON
                      NCA = int(LDA_SON8)
                      ASIZE = SIZFR - (SHIFTCB_SON -                    &
     &                                 int(PS1-1,8) * LDA_SON8)
                      LROW1=-666666
                    ENDIF
                 ENDIF
                 IF ( NROW-PS1+1 .NE. 0 ) THEN
                   CALL DAGMG_MUMPS_618(                                     &
     &                A_CBSON(APOS),ASIZE,NCA,NROW-PS1+1,               &
     &                BUF_MAX_ARRAY,NFS4FATHER,COMPRESSCB,LROW1)
                 ENDIF
              ENDIF
              CALL AGMG_NOCALL('MPI_PACK')
           ENDIF
        ENDIF
      ENDIF
      ENDIF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE_PACK.LT. POSITION ) THEN
          WRITE(*,*) ' contniv2: SIZE, POSITION =',SIZE_PACK, POSITION
          WRITE(*,*) ' NBROW, LROW = ', NBROW, LROW
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE_PACK .NE. POSITION )                                  &
     &  CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        NBROWS_ALREADY_SENT=NBROWS_ALREADY_SENT + NBROWS_PACKET
        IF (NBROWS_ALREADY_SENT .NE. NBROW ) THEN
           IERR = -1
        ENDIF
  100   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_67
        SUBROUTINE DAGMG_MUMPS_71(                                           &
     &                INODE, NFRONT, NASS1, NFS4FATHER,                 &
     &                ISON, MYID, NSLAVES, SLAVES_PERE,                 &
     &                TROW, NCBSON,                                     &
     &                COMM, IERR,                                       &
     &                DEST, NDEST, SLAVEF,                              &
     &                KEEP,KEEP8, STEP, N,                              &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE                   &
     &                                  )
        IMPLICIT NONE
      INTEGER INODE, NFRONT, NASS1, NCBSON, NSLAVES,                    &
     &          NDEST
      INTEGER SLAVEF, MYID, ISON
      INTEGER TROW( NCBSON )
      INTEGER DEST( NDEST )
      INTEGER SLAVES_PERE( NSLAVES )
      INTEGER COMM, IERR
      INTEGER KEEP(500), N
      INTEGER*8 KEEP8(150)
      INTEGER STEP(N),                                                  &
     &        ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE_AV, IDEST, NSEND, SIZE, NFS4FATHER
        INTEGER TROW_SIZE, POSITION, INDX, INIV2
        INTEGER IPOS, IREQ
        INTEGER IONE
        PARAMETER ( IONE=1 )
        INTEGER NASS_SON
        NASS_SON = -99998
        IERR = 0
        IF ( NDEST .eq. 1 ) THEN
          IF ( DEST(1).EQ.MYID )  GOTO 500
          SIZE = SIZEofINT * ( 7 + NSLAVES + NCBSON )
          IF (( NSLAVES.GT.0 ) .AND. (KEEP(48).NE.0) ) THEN
             SIZE = SIZE + SIZEofINT * ( NSLAVES + 1 )
          ENDIF
          CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                &
     &                 IONE, DEST                                       &
     &                 )
          IF (IERR .LT. 0 ) THEN
             RETURN
          ENDIF
          IF (SIZE.GT.SIZE_RBUF_BYTES ) THEN
             IERR = -3
             RETURN
          END IF
              POSITION = IPOS
              BUF_CB%CONTENT( POSITION ) = INODE
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = ISON
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NSLAVES
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NFRONT
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NASS1
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NCBSON
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NFS4FATHER
              POSITION = POSITION + 1
              IF (( NSLAVES.GT.0 ) .AND. (KEEP(48).NE.0) ) THEN
                INIV2 = ISTEP_TO_INIV2 ( STEP(INODE) )
                BUF_CB%CONTENT( POSITION: POSITION + NSLAVES )          &
     &          =  TAB_POS_IN_PERE(1:NSLAVES+1,INIV2)
                POSITION = POSITION + NSLAVES + 1
              ENDIF
              IF ( NSLAVES .NE. 0 ) THEN
                BUF_CB%CONTENT( POSITION: POSITION + NSLAVES - 1 )      &
     &          = SLAVES_PERE( 1: NSLAVES )
                POSITION = POSITION + NSLAVES
              END IF
              BUF_CB%CONTENT( POSITION:POSITION+NCBSON-1 ) =            &
     &        TROW( 1: NCBSON )
              POSITION = POSITION + NCBSON
              POSITION = POSITION - IPOS
              IF ( POSITION * SIZEofINT .NE. SIZE ) THEN
                WRITE(*,*) 'Error in DMUMPS_71 :',                      &
     &                     ' wrong estimated size'
                CALL AGMG_MUMPS_ABORT()
              END IF
              CALL AGMG_NOCALL('MPI_ISEND')
        ELSE
          NSEND = 0
          DO IDEST = 1, NDEST
            IF ( DEST( IDEST ) .ne. MYID ) NSEND = NSEND + 1
          END DO
          SIZE = SIZEofINT *                                            &
     &         ( ( OVHSIZE + 7 + NSLAVES )* NSEND + NCBSON )
          IF (( NSLAVES.GT.0 ) .AND. (KEEP(48).NE.0) ) THEN
           SIZE = SIZE + SIZEofINT * NSEND*( NSLAVES + 1 )
          ENDIF
          CALL DAGMG_MUMPS_79( BUF_CB, SIZE_AV )
          IF ( SIZE_AV .LT. SIZE ) THEN
            IERR = -1
            RETURN
          END IF
          DO IDEST= 1, NDEST
            CALL AGMG_MUMPS_49(                                              &
     &                KEEP,KEEP8, ISON, STEP, N, SLAVEF,                &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                IDEST, NCBSON,                                    &
     &                NDEST,                                            &
     &                TROW_SIZE, INDX  )
            SIZE = SIZEofINT * ( NSLAVES + TROW_SIZE + 7 )
            IF (( NSLAVES.GT.0 ) .AND. (KEEP(48).NE.0) ) THEN
             SIZE = SIZE + SIZEofINT * ( NSLAVES + 1 )
            ENDIF
            IF ( MYID .NE. DEST( IDEST ) ) THEN
              CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,            &
     &                       IONE, DEST(IDEST)                          &
     &                     )
              IF ( IERR .LT. 0 )  THEN
                 WRITE(*,*) 'Problem in DMUMPS_4: IERR<0'
                 CALL AGMG_MUMPS_ABORT()
              END IF
              IF (SIZE.GT.SIZE_RBUF_BYTES) THEN
                 IERR = -3
                 RETURN
              ENDIF
              POSITION = IPOS
              BUF_CB%CONTENT( POSITION ) = INODE
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = ISON
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NSLAVES
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NFRONT
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NASS1
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = TROW_SIZE
              POSITION = POSITION + 1
              BUF_CB%CONTENT( POSITION ) = NFS4FATHER
              POSITION = POSITION + 1
              IF (( NSLAVES.GT.0 ) .AND. (KEEP(48).NE.0) ) THEN
                INIV2 = ISTEP_TO_INIV2 ( STEP(INODE) )
                BUF_CB%CONTENT( POSITION: POSITION + NSLAVES )          &
     &          =  TAB_POS_IN_PERE(1:NSLAVES+1,INIV2)
                POSITION = POSITION + NSLAVES + 1
              ENDIF
              IF ( NSLAVES .NE. 0 ) THEN
                BUF_CB%CONTENT( POSITION: POSITION + NSLAVES - 1 )      &
     &          = SLAVES_PERE( 1: NSLAVES )
                POSITION = POSITION + NSLAVES
              END IF
              BUF_CB%CONTENT( POSITION:POSITION+TROW_SIZE-1 ) =         &
     &        TROW( INDX: INDX + TROW_SIZE - 1 )
              POSITION = POSITION + TROW_SIZE
              POSITION = POSITION - IPOS
              IF ( POSITION * SIZEofINT .NE. SIZE ) THEN
               WRITE(*,*) ' ERROR 1 in TRY_SEND_MAPLIG:',               &
     &          'Wrong estimated size'
               CALL AGMG_MUMPS_ABORT()
              END IF
              CALL AGMG_NOCALL('MPI_ISEND')
            END IF
          END DO
        END IF
  500   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_71
        SUBROUTINE DAGMG_MUMPS_65( INODE, NFRONT,                            &
     &             NCOL, NPIV, FPERE, LASTBL, IPIV, VAL,                &
     &             PDEST, NDEST, KEEP50, NB_BLOC_FAC, COMM, IERR )
        IMPLICIT NONE
        INTEGER INODE, NCOL, NPIV, FPERE, NFRONT, NDEST
        INTEGER IPIV( NPIV )
        DOUBLE PRECISION VAL( NFRONT, * )
        INTEGER PDEST( NDEST )
        INTEGER   KEEP50, NB_BLOC_FAC, COMM, IERR
        LOGICAL LASTBL
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER POSITION, IREQ, IPOS, SIZE1, SIZE2, SIZE,               &
     &          IDEST, IPOSMSG, I
        INTEGER NPIVSENT
        INTEGER SSS, SS2
        IERR = 0
        IF ( LASTBL ) THEN
          IF ( KEEP50 .eq. 0 ) THEN
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
          ELSE
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
          END IF
        ELSE
          IF ( KEEP50 .eq. 0 ) THEN
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          ELSE
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
          END IF
        END IF
        SIZE2 = 0
        IF (NPIV.GT.0)                                                  &
     &    CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 NDEST , PDEST                                    &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        IF (SIZE.GT.SIZE_RBUF_BYTES) THEN
          SSS = 0
          IF ( LASTBL ) THEN
           IF ( KEEP50 .eq. 0 ) THEN
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
           ELSE
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
           END IF
          ELSE
           IF ( KEEP50 .eq. 0 ) THEN
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
           ELSE
            CALL AGMG_NOCALL('MPI_PACK_SIZE')
           END IF
          END IF
          IF (NPIV.GT.0)                                                &
     &    CALL AGMG_NOCALL('MPI_PACK_SIZE')
          SSS = SSS + SS2
          IF (SSS.GT.SIZE_RBUF_BYTES) THEN
           IERR = -2
           RETURN
          ENDIF
        ENDIF
        BUF_CB%ILASTMSG = BUF_CB%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_CB%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =            &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_CB%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        NPIVSENT = NPIV
        IF (LASTBL) NPIVSENT = -NPIV
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( LASTBL .or. KEEP50.ne.0 ) THEN
          CALL AGMG_NOCALL('MPI_PACK')
        END IF
        IF ( LASTBL .AND. KEEP50 .NE. 0 ) THEN
            CALL AGMG_NOCALL('MPI_PACK')
            CALL AGMG_NOCALL('MPI_PACK')
        END IF
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( NPIV.GT.0) THEN
          CALL AGMG_NOCALL('MPI_PACK')
          DO I = 1, NPIV
            CALL AGMG_NOCALL('MPI_PACK')
          END DO
        ENDIF
        DO IDEST = 1, NDEST
        IF ( KEEP50.eq.0) THEN
        CALL AGMG_NOCALL('MPI_ISEND')
        ELSE
        CALL AGMG_NOCALL('MPI_ISEND')
        END IF
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error sending blocfacto : size < position'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION ) CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_65
        SUBROUTINE DAGMG_MUMPS_64( INODE,                                    &
     &             NPIV, FPERE, IPOSK, JPOSK, UIP21K, NCOLU,            &
     &             NDEST, PDEST, COMM, IERR )
        IMPLICIT NONE
        INTEGER INODE, NCOLU, IPOSK, JPOSK, NPIV, NDEST, FPERE
        DOUBLE PRECISION UIP21K( NPIV, NCOLU )
        INTEGER PDEST( NDEST )
        INTEGER   COMM, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER POSITION, IREQ, IPOS, SIZE1, SIZE2, SIZE,               &
     &          IDEST, IPOSMSG, SSS, SS2
        IERR = 0
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        IF (SIZE.GT.SIZE_RBUF_BYTES) THEN
         CALL AGMG_NOCALL('MPI_PACK_SIZE')
         CALL AGMG_NOCALL('MPI_PACK_SIZE')
         SSS = SSS+SS2
         IF (SSS.GT.SIZE_RBUF_BYTES) THEN
           IERR = -2
           RETURN
         ENDIF
        END IF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 NDEST, PDEST                                     &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_CB%ILASTMSG = BUF_CB%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_CB%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =            &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_CB%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        DO IDEST = 1, NDEST
        CALL AGMG_NOCALL('MPI_ISEND')
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error sending blfac slave : size < position'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION ) CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_64
        SUBROUTINE DAGMG_MUMPS_648( N, ISON,                                 &
     &             NBCOL_SON, NBROW_SON, INDCOL_SON, INDROW_SON,        &
     &             LD_SON, VAL_SON, TAG, SUBSET_ROW, SUBSET_COL,        &
     &             NSUBSET_ROW, NSUBSET_COL,                            &
     &             NPROW, NPCOL, MBLOCK, RG2L_ROW, RG2L_COL,            &
     &             NBLOCK, PDEST, COMM, IERR ,                          &
     &             TAB, TABSIZE, TRANSP, SIZE_PACK,                     &
     &             N_ALREADY_SENT )
        IMPLICIT NONE
        INTEGER N, ISON, NBCOL_SON, NBROW_SON, NSUBSET_ROW, NSUBSET_COL
        INTEGER NPROW, NPCOL, MBLOCK, NBLOCK, LD_SON
        INTEGER PDEST, TAG, COMM, IERR
        INTEGER INDCOL_SON( NBCOL_SON ), INDROW_SON( NBROW_SON )
        INTEGER SUBSET_ROW( * ), SUBSET_COL( * )
        INTEGER RG2L_ROW( N ), RG2L_COL( N )
        INTEGER(8), INTENT(IN) :: TABSIZE
        INTEGER SIZE_PACK
        DOUBLE PRECISION VAL_SON( LD_SON, * ), TAB(*)
        LOGICAL TRANSP
        INTEGER N_ALREADY_SENT
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER NSUBSET_OTHER, NSUBSET_TOT
        INTEGER SIZE1, SIZE2, SIZE_AV, POSITION
        INTEGER IREQ, IPOS, ITAB
        INTEGER ISUB, JSUB, I, J
        INTEGER ILOC_ROOT, JLOC_ROOT
        INTEGER IPOS_ROOT, JPOS_ROOT
        INTEGER IONE
        LOGICAL RECV_BUF_SMALLER_THAN_SEND
        INTEGER PDEST2(1)
        PARAMETER ( IONE=1 )
        INTEGER N_PACKET
        PDEST2(1) = PDEST
        IERR = 0
        IF ( NSUBSET_ROW * NSUBSET_COL .NE. 0 ) THEN
          CALL DAGMG_MUMPS_79( BUF_CB, SIZE_AV )
          IF (SIZE_AV .LT. SIZE_RBUF_BYTES) THEN
            RECV_BUF_SMALLER_THAN_SEND = .FALSE.
          ELSE
            RECV_BUF_SMALLER_THAN_SEND = .TRUE.
            SIZE_AV = SIZE_RBUF_BYTES
          ENDIF
          SIZE_AV = min(SIZE_AV, SIZE_RBUF_BYTES)
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          IF (.NOT.TRANSP) THEN
            NSUBSET_TOT  = NSUBSET_ROW
            NSUBSET_OTHER=NSUBSET_COL
          ELSE
            NSUBSET_TOT  = NSUBSET_COL
            NSUBSET_OTHER=NSUBSET_ROW
          ENDIF
          N_PACKET =                                                    &
     &    (SIZE_AV - SIZE1 ) / ( SIZEofINT + NSUBSET_OTHER * SIZEofREAL)
   10     CONTINUE
          N_PACKET = min( N_PACKET,                                     &
     &                    NSUBSET_TOT-N_ALREADY_SENT )
          IF (N_PACKET .LE. 0) THEN
            IF (RECV_BUF_SMALLER_THAN_SEND) THEN
              IERR=-3
              GOTO 100
            ELSE
              IERR = -1
              GOTO 100
            ENDIF
          ENDIF
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
          SIZE_PACK = SIZE1 + SIZE2
          IF (SIZE_PACK .GT. SIZE_AV) THEN
            N_PACKET = N_PACKET - 1
            IF ( N_PACKET > 0 ) THEN
              GOTO 10
            ELSE
              IF (RECV_BUF_SMALLER_THAN_SEND) THEN
                IERR = -3
                GOTO 100
              ELSE
                IERR = -1
                GOTO 100
              ENDIF
            ENDIF
          ENDIF
          IF (N_PACKET + N_ALREADY_SENT .NE. NSUBSET_TOT .AND.          &
     &      SIZE_PACK .LT. SIZE_RBUF_BYTES / 4                          &
     &      .AND. .NOT. RECV_BUF_SMALLER_THAN_SEND)                     &
     &      THEN
            IERR = -1
            GOTO 100
          ENDIF
        ELSE
          N_PACKET = 0
          CALL AGMG_NOCALL('MPI_PACK_SIZE')
        END IF
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE_PACK, IERR,             &
     &                 IONE, PDEST2                                     &
     &               )
        IF ( IERR .LT. 0 ) GOTO 100
        IF ( SIZE_PACK.GT.SIZE_RBUF_BYTES ) THEN
             IERR = -3
             GOTO 100
        ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( .NOT. TRANSP ) THEN
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        ELSE
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        END IF
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF ( NSUBSET_ROW * NSUBSET_COL .NE. 0 ) THEN
          IF ( .NOT. TRANSP ) THEN
            DO ISUB = N_ALREADY_SENT+1, N_ALREADY_SENT+N_PACKET
              I         = SUBSET_ROW( ISUB )
              IPOS_ROOT = RG2L_ROW( INDROW_SON( I ) )
              ILOC_ROOT = MBLOCK                                        &
     &                 * ( ( IPOS_ROOT - 1 ) / ( MBLOCK * NPROW ) )     &
     &                 + mod( IPOS_ROOT - 1, MBLOCK ) + 1
              CALL AGMG_NOCALL('MPI_PACK')
            END DO
            DO JSUB = 1, NSUBSET_COL
              J         = SUBSET_COL( JSUB )
              JPOS_ROOT = RG2L_COL( INDCOL_SON( J ) )
              JLOC_ROOT = NBLOCK                                        &
     &                  * ( ( JPOS_ROOT - 1 ) / ( NBLOCK * NPCOL ) )    &
     &                  + mod( JPOS_ROOT - 1, NBLOCK ) + 1
              CALL AGMG_NOCALL('MPI_PACK')
            END DO
          ELSE
            DO JSUB = N_ALREADY_SENT+1, N_ALREADY_SENT+N_PACKET
              J         = SUBSET_COL( JSUB )
              IPOS_ROOT = RG2L_COL( INDCOL_SON( J ) )
              ILOC_ROOT = MBLOCK                                        &
     &                 * ( ( IPOS_ROOT - 1 ) / ( MBLOCK * NPROW ) )     &
     &                 + mod( IPOS_ROOT - 1, MBLOCK ) + 1
              CALL AGMG_NOCALL('MPI_PACK')
            END DO
            DO ISUB = 1, NSUBSET_ROW
              I         = SUBSET_ROW( ISUB )
              JPOS_ROOT = RG2L_ROW( INDROW_SON( I ) )
              JLOC_ROOT = NBLOCK                                        &
     &                  * ( ( JPOS_ROOT - 1 ) / ( NBLOCK * NPCOL ) )    &
     &                  + mod( JPOS_ROOT - 1, NBLOCK ) + 1
              CALL AGMG_NOCALL('MPI_PACK')
            END DO
          END IF
          IF ( TABSIZE.GE.int(N_PACKET,8)*int(NSUBSET_OTHER,8) ) THEN
            IF ( .NOT. TRANSP ) THEN
              ITAB = 1
              DO ISUB = N_ALREADY_SENT+1,                               &
     &                  N_ALREADY_SENT+N_PACKET
                I         = SUBSET_ROW( ISUB )
                DO JSUB = 1, NSUBSET_COL
                  J              = SUBSET_COL( JSUB )
                  TAB( ITAB )    = VAL_SON(J,I)
                  ITAB           = ITAB + 1
                END DO
              END DO
              CALL AGMG_NOCALL('MPI_PACK')
            ELSE
              ITAB = 1
              DO JSUB = N_ALREADY_SENT+1, N_ALREADY_SENT+N_PACKET
                J = SUBSET_COL( JSUB )
                DO ISUB = 1, NSUBSET_ROW
                  I         = SUBSET_ROW( ISUB )
                  TAB( ITAB ) = VAL_SON( J, I )
                  ITAB = ITAB + 1
                END DO
              END DO
              CALL AGMG_NOCALL('MPI_PACK')
            END IF
          ELSE
            IF ( .NOT. TRANSP ) THEN
              DO ISUB = N_ALREADY_SENT+1, N_ALREADY_SENT+N_PACKET
                I         = SUBSET_ROW( ISUB )
                DO JSUB = 1, NSUBSET_COL
                  J         = SUBSET_COL( JSUB )
                  CALL AGMG_NOCALL('MPI_PACK')
                END DO
              END DO
            ELSE
              DO JSUB = N_ALREADY_SENT+1, N_ALREADY_SENT+N_PACKET
                J = SUBSET_COL( JSUB )
                DO ISUB = 1, NSUBSET_ROW
                  I         = SUBSET_ROW( ISUB )
                  CALL AGMG_NOCALL('MPI_PACK')
                END DO
              END DO
            END IF
          ENDIF
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE_PACK .LT. POSITION ) THEN
          WRITE(*,*) ' Error sending contribution to root:Size<positn'
          WRITE(*,*) ' Size,position=',SIZE_PACK,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE_PACK .NE. POSITION )                                  &
     &  CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        N_ALREADY_SENT = N_ALREADY_SENT + N_PACKET
        IF (NSUBSET_ROW * NSUBSET_COL .NE. 0) THEN
          IF ( N_ALREADY_SENT.NE.NSUBSET_TOT ) IERR = -1
        ENDIF
  100   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_648
        SUBROUTINE DAGMG_MUMPS_76( ISON, NELIM,                              &
     &             NELIM_ROW, NELIM_COL, NSLAVES, SLAVES,               &
     &             DEST, COMM, IERR )
        INTEGER ISON, NELIM
        INTEGER NSLAVES, DEST, COMM, IERR
        INTEGER NELIM_ROW( NELIM ), NELIM_COL( NELIM )
        INTEGER SLAVES( NSLAVES )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE, POSITION, IPOS, IREQ
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1) = DEST
        IERR = 0
        SIZE = ( 3 + NSLAVES + 2 * NELIM ) * SIZEofINT
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 IONE, DEST2                                      &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
          IF (SIZE.GT.SIZE_RBUF_BYTES) THEN
             IERR = -3
             RETURN
          ENDIF
        POSITION = IPOS
        BUF_CB%CONTENT( POSITION ) = ISON
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NELIM
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION ) = NSLAVES
        POSITION = POSITION + 1
        BUF_CB%CONTENT( POSITION: POSITION + NELIM - 1 ) = NELIM_ROW
        POSITION = POSITION + NELIM
        BUF_CB%CONTENT( POSITION: POSITION + NELIM - 1 ) = NELIM_COL
        POSITION = POSITION + NELIM
        BUF_CB%CONTENT( POSITION: POSITION + NSLAVES - 1 ) = SLAVES
        POSITION = POSITION + NSLAVES
        POSITION = POSITION - IPOS
        IF ( POSITION * SIZEofINT .NE. SIZE ) THEN
          WRITE(*,*) 'Error in DMUMPS_BUF_SEND_ROOT_NELIM_INDICES:',    &
     &               'wrong estimated size'
           CALL AGMG_MUMPS_ABORT()
        END IF
        CALL AGMG_NOCALL('MPI_ISEND')
        RETURN
        END SUBROUTINE DAGMG_MUMPS_76
        SUBROUTINE DAGMG_MUMPS_74( ISON, NELIM_ROOT,                         &
     &             DEST, COMM, IERR )
        IMPLICIT NONE
        INTEGER ISON, NELIM_ROOT, DEST, COMM, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER IPOS, IREQ, SIZE
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        DEST2(1)=DEST
        IERR = 0
        SIZE = 2 * SIZEofINT
   10   CONTINUE
        CALL DAGMG_MUMPS_4( BUF_SMALL, IPOS, IREQ, SIZE, IERR,               &
     &                 IONE, DEST2                                      &
     &               )
        IF ( IERR .LT. 0 ) THEN
          WRITE(*,*) 'Internal error 1 with small buffers '
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_SMALL%CONTENT( IPOS )     = ISON
        BUF_SMALL%CONTENT( IPOS + 1 ) = NELIM_ROOT
        CALL AGMG_NOCALL('MPI_ISEND')
        RETURN
        END SUBROUTINE DAGMG_MUMPS_74
        SUBROUTINE DAGMG_MUMPS_73                                            &
     &  ( TOT_ROOT_SIZE, TOT_CONT2RECV, DEST, COMM, IERR )
        IMPLICIT NONE
        INTEGER TOT_ROOT_SIZE, TOT_CONT2RECV, DEST, COMM, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER SIZE, IPOS, IREQ
        INTEGER IONE
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        IERR = 0
        DEST2(1) = DEST
        SIZE = 2 * SIZEofINT
        CALL DAGMG_MUMPS_4( BUF_SMALL, IPOS, IREQ, SIZE, IERR,               &
     &                 IONE, DEST2                                      &
     &               )
        IF ( IERR .LT. 0 ) THEN
          WRITE(*,*) 'Internal error 2 with small buffers '
           CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_SMALL%CONTENT( IPOS     ) = TOT_ROOT_SIZE
        BUF_SMALL%CONTENT( IPOS + 1 ) = TOT_CONT2RECV
        CALL AGMG_NOCALL('MPI_ISEND')
        RETURN
        END SUBROUTINE DAGMG_MUMPS_73
        SUBROUTINE DAGMG_MUMPS_63                                            &
     &             ( NRHS, INODE, W, LW, LD_W, DEST,MSGTAG,COMM,IERR )
        IMPLICIT NONE
        INTEGER NRHS, INODE,LW,COMM,IERR,DEST,MSGTAG, LD_W
        DOUBLE PRECISION W(LD_W, *)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER SIZE, SIZE1, SIZE2
        INTEGER POSITION, IREQ, IPOS
        INTEGER IONE, K
        INTEGER DEST2(1)
        PARAMETER ( IONE=1 )
        IERR = 0
        DEST2(1) = DEST
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_CB, IPOS, IREQ, SIZE, IERR,                  &
     &                 IONE, DEST2                                      &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        DO K=1, NRHS
        CALL AGMG_NOCALL('MPI_PACK')
        END DO
        CALL AGMG_NOCALL('MPI_ISEND')
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) 'Try_update: SIZE, POSITION = ',                   &
     &               SIZE, POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION ) CALL DAGMG_MUMPS_1( BUF_CB, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_63
        SUBROUTINE DAGMG_MUMPS_77                                            &
     &             ( BDC_SBTR,BDC_MEM,BDC_MD, COMM, NPROCS, LOAD,       &
     &               MEM,SBTR_CUR,                                      &
     &               LU_USAGE,                                          &
     &               FUTURE_NIV2,                                       &
     &               MYID, IERR)
        IMPLICIT NONE
        INTEGER COMM, NPROCS, MYID, IERR
        INTEGER FUTURE_NIV2(NPROCS)
        DOUBLE PRECISION LU_USAGE
        DOUBLE PRECISION LOAD
        DOUBLE PRECISION MEM,SBTR_CUR
        LOGICAL BDC_MEM,BDC_SBTR,BDC_MD
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER POSITION, IREQ, IPOS, SIZE1, SIZE2, SIZE
        INTEGER I, NDEST, IDEST, IPOSMSG, WHAT, NREALS
        INTEGER IZERO
        INTEGER MYID2(1)
        PARAMETER ( IZERO=0 )
        IERR = 0
        MYID2(1) = MYID
        NDEST = NPROCS - 1
        NDEST = 0
        DO I = 1, NPROCS
          IF ( I .NE. MYID + 1 .AND. FUTURE_NIV2(I).NE.0) THEN
            NDEST = NDEST + 1
          ENDIF
        ENDDO
        IF ( NDEST .eq. 0 ) THEN
           RETURN
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        NREALS = 1
        IF (BDC_MEM) THEN
          NREALS = 2
        ENDIf
        IF (BDC_SBTR)THEN
          NREALS = 3
        ENDIF
        IF(BDC_MD)THEN
           NREALS=NREALS+1
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_LOAD, IPOS, IREQ, SIZE, IERR,                &
     &                  IZERO, MYID2                                    &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_LOAD%ILASTMSG = BUF_LOAD%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_LOAD%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =          &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_LOAD%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        WHAT = 0
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (BDC_MEM) THEN
          CALL AGMG_NOCALL('MPI_PACK')
        END IF
        IF (BDC_SBTR) THEN
          CALL AGMG_NOCALL('MPI_PACK')
        END IF
        IF(BDC_MD)THEN
           CALL AGMG_NOCALL('MPI_PACK')
        ENDIF
        IDEST = 0
        DO I = 0, NPROCS - 1
        IF ( I .NE. MYID .AND. FUTURE_NIV2(I+1) .NE. 0) THEN
            IDEST = IDEST + 1
            CALL AGMG_NOCALL('MPI_ISEND')
          END IF
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error in DMUMPS_77'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION )                                       &
     &  CALL DAGMG_MUMPS_1( BUF_LOAD, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_77
        SUBROUTINE DAGMG_MUMPS_460                                           &
     &             ( WHAT, COMM, NPROCS,                                &
     &               FUTURE_NIV2,                                       &
     &               LOAD,UPD_LOAD,                                     &
     &               MYID, IERR)
        IMPLICIT NONE
        INTEGER COMM, NPROCS, MYID, IERR, WHAT
        DOUBLE PRECISION LOAD,UPD_LOAD
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER POSITION, IREQ, IPOS, SIZE1, SIZE2, SIZE
        INTEGER I, NDEST, IDEST, IPOSMSG, NREALS
        INTEGER IZERO
        INTEGER MYID2(1)
        INTEGER FUTURE_NIV2(NPROCS)
        PARAMETER ( IZERO=0 )
        IERR = 0
        IF (WHAT .NE. 2 .AND. WHAT .NE. 3 .AND.                         &
     &       WHAT.NE.6.AND. WHAT.NE.8 .AND.WHAT.NE.9.AND.               &
     &       WHAT.NE.17) THEN
          WRITE(*,*)                                                    &
     &  "Internal error 1 in DAGMG_MUMPS_460",WHAT
        END IF
        MYID2(1) = MYID
        NDEST = NPROCS - 1
        NDEST = 0
        DO I = 1, NPROCS
          IF ( I .NE. MYID + 1 .AND. FUTURE_NIV2(I).NE.0) THEN
            NDEST = NDEST + 1
          ENDIF
        ENDDO
        IF ( NDEST .eq. 0 ) THEN
           RETURN
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        IF((WHAT.NE.17).AND.(WHAT.NE.10))THEN
           NREALS = 1
        ELSE
           NREALS = 2
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1 + SIZE2
        CALL DAGMG_MUMPS_4( BUF_LOAD, IPOS, IREQ, SIZE, IERR,                &
     &                  IZERO, MYID2                                    &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_LOAD%ILASTMSG = BUF_LOAD%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_LOAD%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =          &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_LOAD%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF((WHAT.EQ.17).OR.(WHAT.EQ.10))THEN
           CALL AGMG_NOCALL('MPI_PACK')
        ENDIF
        IDEST = 0
        DO I = 0, NPROCS - 1
          IF ( I .NE. MYID .AND. FUTURE_NIV2(I+1) .NE. 0) THEN
            IDEST = IDEST + 1
            CALL AGMG_NOCALL('MPI_ISEND')
          END IF
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error in DMUMPS_460'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION )                                       &
     &  CALL DAGMG_MUMPS_1( BUF_LOAD, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_460
        SUBROUTINE DAGMG_MUMPS_519                                           &
     &             ( WHAT, COMM, NPROCS,                                &
     &               FATHER_NODE,INODE,NCB,K81,                         &
     &               MYID,REMOTE, IERR)
        IMPLICIT NONE
        INTEGER COMM, NPROCS, MYID, IERR, WHAT,REMOTE
        INTEGER FATHER_NODE,INODE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER POSITION, IREQ, IPOS, SIZE
        INTEGER I, NDEST, IDEST, IPOSMSG
        INTEGER IZERO,NCB,K81
        INTEGER MYID2(1)
        PARAMETER ( IZERO=0 )
        MYID2(1) = MYID
        NDEST = 1
        IF ( NDEST .eq. 0 ) THEN
           RETURN
        ENDIF
        IF((K81.EQ.2).OR.(K81.EQ.3))THEN
           CALL AGMG_NOCALL('MPI_PACK_SIZE')
        ELSE
           CALL AGMG_NOCALL('MPI_PACK_SIZE')
        ENDIF
        CALL DAGMG_MUMPS_4( BUF_LOAD, IPOS, IREQ, SIZE, IERR,                &
     &                  IZERO, MYID2                                    &
     &               )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_LOAD%ILASTMSG = BUF_LOAD%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_LOAD%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =          &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_LOAD%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF((K81.EQ.2).OR.(K81.EQ.3))THEN
           CALL AGMG_NOCALL('MPI_PACK')
           CALL AGMG_NOCALL('MPI_PACK')
        ENDIF
        IDEST = 1
        CALL AGMG_NOCALL('MPI_ISEND')
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error in DMUMPS_519'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION )                                       &
     &  CALL DAGMG_MUMPS_1( BUF_LOAD, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_519
        SUBROUTINE DAGMG_MUMPS_502( COMM, MYID, NPROCS,                      &
     &  MAX_SURF_MASTER,IERR)
        IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        INTEGER IPOS, IREQ, IDEST, IPOSMSG, POSITION, I
        INTEGER COMM, MYID, IERR, NPROCS
        DOUBLE PRECISION MAX_SURF_MASTER
        INTEGER IZERO
        INTEGER MYID2(1)
        PARAMETER ( IZERO=0 )
        INTEGER NDEST, NINTS, NREALS, SIZE, SIZE1, SIZE2
        INTEGER WHAT
        IERR = 0
        MYID2(1) = MYID
        NDEST = NPROCS - 1
        NINTS = 1 + ( NDEST-1 ) * OVHSIZE
        NREALS = 1
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE=SIZE1+SIZE2
        CALL DAGMG_MUMPS_4( BUF_LOAD, IPOS, IREQ, SIZE, IERR,                &
     &       IZERO, MYID2 )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_LOAD%ILASTMSG = BUF_LOAD%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_LOAD%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =          &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_LOAD%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        WHAT = 4
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IDEST = 0
        DO I = 0, NPROCS - 1
           IF ( I .ne. MYID ) THEN
              IDEST = IDEST + 1
              CALL AGMG_NOCALL('MPI_ISEND')
           END IF
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error in DMUMPS_524'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION )                                       &
     &  CALL DAGMG_MUMPS_1( BUF_LOAD, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_502
        SUBROUTINE DAGMG_MUMPS_524( BDC_MEM,                                 &
     &      COMM, MYID, NPROCS,                                         &
     &      FUTURE_NIV2,                                                &
     &      NSLAVES,                                                    &
     &      LIST_SLAVES,INODE,                                          &
     &      MEM_INCREMENT, FLOPS_INCREMENT,CB_BAND, WHAT,               &
     &      IERR )
        IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        LOGICAL BDC_MEM
        INTEGER COMM, MYID, NPROCS, NSLAVES, IERR
        INTEGER FUTURE_NIV2(NPROCS)
        INTEGER LIST_SLAVES(NSLAVES),INODE
        DOUBLE PRECISION MEM_INCREMENT(NSLAVES)
        DOUBLE PRECISION FLOPS_INCREMENT(NSLAVES)
        DOUBLE PRECISION CB_BAND(NSLAVES)
        INTEGER NDEST, NINTS, NREALS, SIZE1, SIZE2, SIZE
        INTEGER IPOS, IPOSMSG, IREQ, POSITION
        INTEGER I, IDEST, WHAT
        INTEGER IZERO
        INTEGER MYID2(1)
        PARAMETER ( IZERO=0 )
        MYID2(1)=MYID
        IERR = 0
        NDEST = 0
        DO I = 1, NPROCS
          IF ( I .NE. MYID + 1 .AND. FUTURE_NIV2(I).NE.0) THEN
            NDEST = NDEST + 1
          ENDIF
        ENDDO
        IF ( NDEST == 0 ) THEN
           RETURN
        ENDIF
        NINTS = 2 +  NSLAVES + ( NDEST - 1 ) * OVHSIZE + 1
        NREALS = NSLAVES
        IF (BDC_MEM) NREALS = NREALS + NSLAVES
        IF(WHAT.EQ.19) THEN
           NREALS = NREALS + NSLAVES
        ENDIF
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        CALL AGMG_NOCALL('MPI_PACK_SIZE')
        SIZE = SIZE1+SIZE2
        CALL DAGMG_MUMPS_4( BUF_LOAD, IPOS, IREQ, SIZE, IERR,                &
     &       IZERO, MYID2 )
        IF ( IERR .LT. 0 ) THEN
           RETURN
        ENDIF
        BUF_LOAD%ILASTMSG = BUF_LOAD%ILASTMSG + ( NDEST - 1 ) * OVHSIZE
        IPOS = IPOS - OVHSIZE
        DO IDEST = 1, NDEST - 1
          BUF_LOAD%CONTENT( IPOS + ( IDEST - 1 ) * OVHSIZE ) =          &
     &    IPOS + IDEST * OVHSIZE
        END DO
        BUF_LOAD%CONTENT( IPOS + ( NDEST - 1 ) * OVHSIZE ) = 0
        IPOSMSG = IPOS + OVHSIZE * NDEST
        POSITION = 0
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (BDC_MEM) THEN
          CALL AGMG_NOCALL('MPI_PACK')
        END IF
        IF(WHAT.EQ.19)THEN
           CALL AGMG_NOCALL('MPI_PACK')
        ENDIF
        IDEST = 0
        DO I = 0, NPROCS - 1
        IF ( I .NE. MYID .AND. FUTURE_NIV2(I+1) .NE. 0) THEN
            IDEST = IDEST + 1
            CALL AGMG_NOCALL('MPI_ISEND')
          END IF
        END DO
        SIZE = SIZE - ( NDEST - 1 ) * OVHSIZE * SIZEofINT
        IF ( SIZE .LT. POSITION ) THEN
          WRITE(*,*) ' Error in DMUMPS_524'
          WRITE(*,*) ' Size,position=',SIZE,POSITION
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( SIZE .NE. POSITION )                                       &
     &  CALL DAGMG_MUMPS_1( BUF_LOAD, POSITION )
        RETURN
        END SUBROUTINE DAGMG_MUMPS_524
        SUBROUTINE DAGMG_MUMPS_60                                            &
     &             ( DAGMG_MUMPS_LBUFR_BYTES)
        IMPLICIT NONE
        INTEGER DAGMG_MUMPS_LBUFR_BYTES
        SIZE_RBUF_BYTES = DAGMG_MUMPS_LBUFR_BYTES
        RETURN
      END SUBROUTINE DAGMG_MUMPS_60
      END MODULE DAGMG_MUMPS_COMM_BUFFER
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      MODULE DAGMG_MUMPS_LOAD
      implicit none
      PUBLIC :: DAGMG_MUMPS_188, DAGMG_MUMPS_185,                                 &
     &       DAGMG_MUMPS_189,                                                &
     &       DAGMG_MUMPS_184, DAGMG_MUMPS_190,                                    &
     &       DAGMG_MUMPS_183, DAGMG_MUMPS_187,                                    &
     &       DAGMG_MUMPS_186,                                                &
     &       DAGMG_MUMPS_409,                                                &
     &       DAGMG_MUMPS_384, DAGMG_MUMPS_461,                                    &
     &       DAGMG_MUMPS_467, DAGMG_MUMPS_471,                                    &
     &       DAGMG_MUMPS_472,                                                &
     &       DAGMG_MUMPS_500,                                                &
     &       DAGMG_MUMPS_501,                                                &
     &       DAGMG_MUMPS_520,                                                &
     &       DAGMG_MUMPS_513,                                                &
     &       DAGMG_MUMPS_514, DAGMG_MUMPS_512                                     &
     &       ,DAGMG_MUMPS_533,                                               &
     &       CLEAN_POOL_MEM_INFO,COMPUTE_MAX_MEM,                       &
     &       CHECK_MEM_CONST_FOR_POOL,DAGMG_MUMPS_554,                       &
     &       DAGMG_MUMPS_553,                                                &
     &       DAGMG_MUMPS_555
      DOUBLE PRECISION, DIMENSION(:),                                   &
     &       ALLOCATABLE, SAVE, PRIVATE :: LOAD_FLOPS
      INTEGER, DIMENSION(:), ALLOCATABLE, SAVE, PRIVATE :: BUF_LOAD_RECV
      INTEGER, SAVE, PRIVATE :: LBUF_LOAD_RECV, LBUF_LOAD_RECV_BYTES
      INTEGER, SAVE, PRIVATE :: K50, K69, K35
      INTEGER(8), SAVE, PRIVATE :: MAX_SURF_MASTER
      LOGICAL, SAVE, PRIVATE :: BDC_MEM, BDC_POOL, BDC_SBTR,            &
     &     BDC_POOL_MNG,                                                &
     &     BDC_M2_MEM,BDC_M2_FLOPS,BDC_MD,REMOVE_NODE_FLAG,             &
     &     REMOVE_NODE_FLAG_MEM
      DOUBLE PRECISION, SAVE, PRIVATE :: REMOVE_NODE_COST,              &
     &     REMOVE_NODE_COST_MEM
      INTEGER, SAVE, PRIVATE :: SBTR_WHICH_M
      DOUBLE PRECISION, DIMENSION(:),                                   &
     &       ALLOCATABLE, TARGET, SAVE, PRIVATE :: WLOAD
      INTEGER, DIMENSION(:), ALLOCATABLE, SAVE, PRIVATE :: FUTURE_NIV2
      DOUBLE PRECISION, SAVE, PRIVATE :: DELTA_LOAD, DELTA_MEM
      INTEGER(8), SAVE, PRIVATE :: CHECK_MEM
      INTEGER, DIMENSION(:), ALLOCATABLE, SAVE, TARGET, PRIVATE ::      &
     &          IDWLOAD
      DOUBLE PRECISION, SAVE, PRIVATE :: COST_SUBTREE
      DOUBLE PRECISION, SAVE, PRIVATE :: ALPHA
      DOUBLE PRECISION, SAVE, PRIVATE :: BETA
      INTEGER, SAVE, PRIVATE :: MYID, NPROCS, COMM_LD
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, SAVE,                &
     &           PRIVATE :: POOL_MEM
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, PRIVATE,             &
     &           SAVE :: SBTR_MEM
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE,                      &
     &           PRIVATE, SAVE :: SBTR_CUR
      INTEGER, DIMENSION(:), ALLOCATABLE,                               &
     &           PRIVATE, SAVE :: NB_SON
      DOUBLE PRECISION,                                                 &
     &           PRIVATE, SAVE :: SBTR_CUR_LOCAL
      DOUBLE PRECISION,                                                 &
     &           PRIVATE, SAVE :: PEAK_SBTR_CUR_LOCAL
      DOUBLE PRECISION,                                                 &
     &           PRIVATE, SAVE :: MAX_PEAK_STK
      DOUBLE PRECISION, SAVE,                                           &
     &           PRIVATE :: POOL_LAST_COST_SENT
      DOUBLE PRECISION, SAVE,                                           &
     &           PRIVATE :: MIN_DIFF
      INTEGER, SAVE :: POS_ID,POS_MEM
      INTEGER, DIMENSION(:), ALLOCATABLE, SAVE :: CB_COST_ID
      INTEGER(8), DIMENSION(:), ALLOCATABLE, SAVE                       &
     &           :: CB_COST_MEM
      PUBLIC :: CB_COST_ID, CB_COST_MEM,POS_MEM,POS_ID
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: LU_USAGE
      INTEGER(8), DIMENSION(:), ALLOCATABLE, SAVE,                      &
     &        PRIVATE::MD_MEM, TAB_MAXS
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, SAVE ::MEM_SUBTREE
      INTEGER  :: NB_SUBTREES,NIV1_FLAG
      INTEGER, PRIVATE  :: INDICE_SBTR,INDICE_SBTR_ARRAY
      INTEGER,SAVE :: INSIDE_SUBTREE
      PUBLIC :: NB_SUBTREES,MEM_SUBTREE,INSIDE_SUBTREE,NIV1_FLAG
      DOUBLE PRECISION, SAVE, PRIVATE :: DM_SUMLU,                      &
     &                   DM_THRES_MEM
      DOUBLE PRECISION, DIMENSION(:),                                   &
     &   ALLOCATABLE, SAVE , PRIVATE:: DM_MEM
      INTEGER, SAVE, PRIVATE :: POOL_SIZE,ID_MAX_M2
      DOUBLE PRECISION, SAVE, PRIVATE :: MAX_M2,TMP_M2
      INTEGER, DIMENSION(:),ALLOCATABLE,SAVE, PRIVATE:: POOL_NIV2
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE,SAVE,                  &
     &      PRIVATE :: POOL_NIV2_COST, NIV2
      DOUBLE PRECISION, SAVE, PRIVATE  ::      CHK_LD
      INTEGER, DIMENSION(:),POINTER, SAVE, PRIVATE  ::                  &
     &         KEEP_LOAD, PROCNODE_LOAD, STEP_TO_NIV2_LOAD
      INTEGER*8, DIMENSION(:), POINTER, SAVE, PRIVATE:: KEEP8_LOAD
      INTEGER, DIMENSION(:),POINTER, SAVE ::                            &
     &         FILS_LOAD, STEP_LOAD,                                    &
     &         FRERE_LOAD, ND_LOAD,                                     &
     &         NE_LOAD,DAD_LOAD
      INTEGER, DIMENSION(:,:),POINTER, SAVE, PRIVATE :: CAND_LOAD
      INTEGER, DIMENSION(:),POINTER, SAVE,                              &
     &         PRIVATE :: MY_FIRST_LEAF,MY_NB_LEAF, MY_ROOT_SBTR
      INTEGER, DIMENSION(:),ALLOCATABLE,SAVE,                           &
     &         PRIVATE ::SBTR_FIRST_POS_IN_POOL
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE,SAVE,                  &
     &         PRIVATE ::SBTR_PEAK_ARRAY,                               &
     &     SBTR_CUR_ARRAY
      INTEGER, SAVE,                                                    &
     &         PRIVATE :: N_LOAD
      DOUBLE PRECISION,DIMENSION(:),POINTER, SAVE :: COST_TRAV
      INTEGER, DIMENSION(:),POINTER, SAVE :: DEPTH_FIRST_LOAD
      PUBLIC :: DEPTH_FIRST_LOAD,COST_TRAV, FILS_LOAD,STEP_LOAD,        &
     &     FRERE_LOAD, ND_LOAD,NE_LOAD,DAD_LOAD
      INTEGER, SAVE     :: ROOT_CURRENT_SUBTREE,CURRENT_BEST,           &
     &     SECOND_CURRENT_BEST
      PUBLIC :: ROOT_CURRENT_SUBTREE,CURRENT_BEST,                      &
     &     SECOND_CURRENT_BEST
      CONTAINS
      SUBROUTINE DAGMG_MUMPS_188( COST_SUBTREE_ARG, K64, K66,                &
     &     MAXS )
      IMPLICIT NONE
      DOUBLE PRECISION COST_SUBTREE_ARG
      INTEGER K64, K66
      INTEGER(8)::MAXS
      DOUBLE PRECISION T64, T66
      T64 = max ( dble(K64), dble(1) )
      T64 = min ( T64, dble(1000)  )
      T66 = max (dble(K66), dble(100))
      MIN_DIFF     =  ( T64 / dble(1000)  )*                            &
     &                  T66 * dble(1000000)
      DM_THRES_MEM = dble(MAXS/1000_8)
      COST_SUBTREE = COST_SUBTREE_ARG
      END SUBROUTINE DAGMG_MUMPS_188
      SUBROUTINE DAGMG_MUMPS_472(                                            &
     &  NCBSON_MAX, SLAVEF,                                             &
     &  KEEP,KEEP8,ICNTL,                                               &
     &  CAND_OF_NODE,                                                   &
     &  MEM_DISTRIB, NCB, NFRONT, NSLAVES_NODE,                         &
     &  TAB_POS, SLAVES_LIST, SIZE_SLAVES_LIST,INODE)
       IMPLICIT NONE
      INTEGER, intent(in) :: KEEP(500),SIZE_SLAVES_LIST
      INTEGER*8 KEEP8(150)
      INTEGER, intent(in) :: ICNTL(40)
      INTEGER, intent(in) :: SLAVEF, NFRONT, NCB
      INTEGER, intent(in) :: CAND_OF_NODE(SLAVEF+1)
      INTEGER, intent(in) :: MEM_DISTRIB(0:SLAVEF-1),INODE
      INTEGER, intent(in) :: NCBSON_MAX
      INTEGER, intent(out):: SLAVES_LIST(SIZE_SLAVES_LIST)
      INTEGER, intent(out):: TAB_POS(SLAVEF+2)
      INTEGER, intent(out):: NSLAVES_NODE
      INTEGER i
      INTEGER LP,MP
      LP=ICNTL(4)
      MP=ICNTL(2)
      IF ( KEEP(48) == 0 .OR. KEEP(48) .EQ. 3 ) THEN
         CALL DAGMG_MUMPS_499(                                               &
     &        SLAVEF,                                                   &
     &        KEEP,KEEP8,                                               &
     &        CAND_OF_NODE,                                             &
     &        MEM_DISTRIB, NCB, NFRONT, NSLAVES_NODE,                   &
     &        TAB_POS, SLAVES_LIST, SIZE_SLAVES_LIST)
      ELSE IF ( KEEP(48) == 4 ) THEN
         CALL DAGMG_MUMPS_504(                                               &
     &        SLAVEF,                                                   &
     &        KEEP,KEEP8,                                               &
     &        CAND_OF_NODE,                                             &
     &        MEM_DISTRIB, NCB, NFRONT, NSLAVES_NODE,                   &
     &        TAB_POS, SLAVES_LIST, SIZE_SLAVES_LIST,MYID)
         DO i=1,NSLAVES_NODE
            IF(TAB_POS(i+1)-TAB_POS(i).LE.0)THEN
               WRITE(*,*)'probleme de partition dans                    &
     &DAGMG_MUMPS_545'
               CALL AGMG_MUMPS_ABORT()
            ENDIF
         ENDDO
      ELSE IF ( KEEP(48) == 5 ) THEN
         CALL DAGMG_MUMPS_518(                                               &
     &        NCBSON_MAX,                                               &
     &        SLAVEF,                                                   &
     &        KEEP,KEEP8,                                               &
     &        CAND_OF_NODE,                                             &
     &        MEM_DISTRIB, NCB, NFRONT, NSLAVES_NODE,                   &
     &        TAB_POS, SLAVES_LIST, SIZE_SLAVES_LIST,MYID,INODE,        &
     &        MP,LP)
         DO i=1,NSLAVES_NODE
            IF(TAB_POS(i+1)-TAB_POS(i).LE.0)THEN
               WRITE(*,*)'problem with partition in                     &
     &DAGMG_MUMPS_518'
               CALL AGMG_MUMPS_ABORT()
            ENDIF
         ENDDO
      ELSE
        WRITE(*,*) "Strategy 6 not implemented"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_472
      SUBROUTINE DAGMG_MUMPS_499(                                            &
     &  SLAVEF,                                                         &
     &  KEEP,KEEP8,                                                     &
     &  CAND_OF_NODE,                                                   &
     &  MEM_DISTRIB, NCB, NFRONT, NSLAVES_NODE,                         &
     &  TAB_POS, SLAVES_LIST, SIZE_SLAVES_LIST)
      IMPLICIT NONE
      INTEGER, intent(in) :: KEEP(500),SIZE_SLAVES_LIST
      INTEGER*8 KEEP8(150)
      INTEGER, intent(in) :: SLAVEF, NFRONT, NCB
      INTEGER, intent(in) :: CAND_OF_NODE(SLAVEF+1)
      INTEGER, intent(in) :: MEM_DISTRIB(0:SLAVEF-1)
      INTEGER, intent(out):: SLAVES_LIST(SIZE_SLAVES_LIST)
      INTEGER, intent(out):: TAB_POS(SLAVEF+2)
      INTEGER, intent(out):: NSLAVES_NODE
      INTEGER ITEMP, NMB_OF_CAND, NSLAVES_LESS
      DOUBLE PRECISION MSG_SIZE
      LOGICAL FORCE_CAND
      INTEGER  AGMG_MUMPS_12
      EXTERNAL AGMG_MUMPS_12
      IF ( KEEP(48) == 0 .AND. KEEP(50) .NE. 0) THEN
      write(*,*) "Internal error 2 in DAGMG_MUMPS_499."
      CALL AGMG_MUMPS_ABORT()
      END IF
      IF ( KEEP(48) == 3 .AND. KEEP(50) .EQ. 0) THEN
      write(*,*) "Internal error 3 in DAGMG_MUMPS_499."
      CALL AGMG_MUMPS_ABORT()
      END IF
      MSG_SIZE = dble( NFRONT - NCB ) * dble(NCB)
      IF ( KEEP(24) == 0 .OR. KEEP(24) == 1 ) THEN
        FORCE_CAND = .FALSE.
      ELSE
        FORCE_CAND = (mod(KEEP(24),2).eq.0)
      END IF
      IF (FORCE_CAND) THEN
        ITEMP=DAGMG_MUMPS_409                                                &
     &       (MEM_DISTRIB(0:SLAVEF-1),                                  &
     &        CAND_OF_NODE,                                             &
     &        KEEP(69), SLAVEF, MSG_SIZE,                               &
     &        NMB_OF_CAND )
      ELSE
        ITEMP=DAGMG_MUMPS_186(KEEP(69),MEM_DISTRIB,MSG_SIZE)
        NMB_OF_CAND = SLAVEF - 1
      END IF
      NSLAVES_LESS = max(ITEMP,1)
      NSLAVES_NODE = AGMG_MUMPS_12(KEEP8(21), KEEP(48),                      &
     &          KEEP(50),SLAVEF,                                        &
     &          NCB, NFRONT, NSLAVES_LESS, NMB_OF_CAND)
      CALL AGMG_MUMPS_441(                                                   &
     &            KEEP,KEEP8, SLAVEF,                                   &
     &            TAB_POS,                                              &
     &            NSLAVES_NODE, NFRONT, NCB                             &
     &             )
      IF (FORCE_CAND) THEN
        CALL DAGMG_MUMPS_384(MEM_DISTRIB(0),                                 &
     &       CAND_OF_NODE, SLAVEF, NSLAVES_NODE,                        &
     &       SLAVES_LIST)
      ELSE
        CALL DAGMG_MUMPS_189(MEM_DISTRIB(0),                                 &
     &       MSG_SIZE, SLAVES_LIST, NSLAVES_NODE)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_499
      SUBROUTINE DAGMG_MUMPS_185( id, MEMORY_MD_ARG, MAXS )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER(8), intent(in) :: MEMORY_MD_ARG
      INTEGER(8), intent(in) :: MAXS
      INTEGER K34_LOC,K35_LOC
      INTEGER allocok, IERR, i, BUF_LOAD_SIZE
      DOUBLE PRECISION :: MAX_SBTR
      DOUBLE PRECISION ZERO
      DOUBLE PRECISION MEMORY_SENT
      INTEGER,DIMENSION(:),POINTER:: KEEP
      PARAMETER( ZERO=0.0d0 )
      INTEGER WHAT
      INTEGER(8) MEMORY_MD, LA
      STEP_TO_NIV2_LOAD=>id%ISTEP_TO_INIV2
      CAND_LOAD=>id%CANDIDATES
      ND_LOAD=>id%ND_STEPS
      KEEP_LOAD=>id%KEEP
      KEEP     =>id%KEEP
      KEEP8_LOAD=>id%KEEP8
      FILS_LOAD=>id%FILS
      FRERE_LOAD=>id%FRERE_STEPS
      DAD_LOAD=>id%DAD_STEPS
      PROCNODE_LOAD=>id%PROCNODE_STEPS
      STEP_LOAD=>id%STEP
      NE_LOAD=>id%NE_STEPS
      N_LOAD=id%N
      ROOT_CURRENT_SUBTREE=-9999
      MEMORY_MD=MEMORY_MD_ARG
      LA=MAXS
      MAX_SURF_MASTER=id%MAX_SURF_MASTER+                               &
     & (int(id%KEEP(12),8)*int(id%MAX_SURF_MASTER,8)/int(100,8))
      COMM_LD = id%COMM_LOAD
      K69  = KEEP(69)
      IF ( KEEP(47) .le. 0 .OR. KEEP(47) .gt. 4 ) THEN
        write(*,*) "Internal error 1 in DAGMG_MUMPS_185"
        CALL AGMG_MUMPS_ABORT()
      END IF
      CHK_LD=dble(0)
      BDC_MEM      = ( KEEP(47) >= 2 )
      BDC_POOL     = ( KEEP(47) >= 3 )
      BDC_SBTR     = ( KEEP(47) >= 4 )
      BDC_M2_MEM   = ( ( KEEP(80) == 2 .OR. KEEP(80) == 3 )             &
     &             .AND. KEEP(47) == 4 )
      BDC_M2_FLOPS   = ( KEEP(80) == 1                                  &
     &             .AND. KEEP(47) .GE. 1 )
      BDC_MD       = (KEEP(86)==1)
      SBTR_WHICH_M       = KEEP(90)
      REMOVE_NODE_FLAG=.FALSE.
      REMOVE_NODE_FLAG_MEM=.FALSE.
      REMOVE_NODE_COST_MEM=dble(0)
      REMOVE_NODE_COST=dble(0)
      IF (KEEP(80) .LT. 0 .OR. KEEP(80)>3) THEN
        WRITE(*,*) "Unimplemented KEEP(80) Strategy"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF ((KEEP(80) == 2 .OR. KEEP(80)==3 ).AND. KEEP(47).NE.4)         &
     &  THEN
        WRITE(*,*) "Internal error 3 in DAGMG_MUMPS_185"
         CALL AGMG_MUMPS_ABORT()
      END IF
      IF (KEEP(81) == 1 .AND. KEEP(47) < 2) THEN
        WRITE(*,*) "Internal error 2 in DAGMG_MUMPS_185"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      BDC_POOL_MNG = ((KEEP(81) == 1).AND.(KEEP(47) >= 2))
      IF(KEEP(76).EQ.4)THEN
         DEPTH_FIRST_LOAD=>id%DEPTH_FIRST
      ENDIF
      IF(KEEP(76).EQ.5)THEN
         COST_TRAV=>id%COST_TRAV
      ENDIF
      IF (BDC_M2_MEM.OR.BDC_M2_FLOPS) THEN
         ALLOCATE(NIV2(id%NSLAVES), NB_SON(KEEP(28)),                   &
     &            POOL_NIV2(100),POOL_NIV2_COST(100),                   &
     &            stat=allocok)
         NB_SON=id%NE_STEPS
         NIV2=dble(0)
         IF (allocok > 0) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = id%NSLAVES + KEEP(28) + 200
           RETURN
         ENDIF
      ENDIF
      K50      = id%SYM
      CALL AGMG_SETIERR2( MYID, IERR )
      NPROCS = id%NSLAVES
      DM_SUMLU=ZERO
      POOL_SIZE=0
      IF(BDC_MD)THEN
         IF ( allocated(MD_MEM) ) DEALLOCATE(MD_MEM)
         ALLOCATE( MD_MEM( 0: NPROCS - 1 ), stat=allocok )
         IF ( allocok .gt. 0 ) THEN
            WRITE(*,*) 'PB allocation in DMUMPS_185'
            id%INFO(1) = -13
            id%INFO(2) = NPROCS
            RETURN
         END IF
         IF ( allocated(TAB_MAXS) ) DEALLOCATE(TAB_MAXS)
         ALLOCATE( TAB_MAXS( 0: NPROCS - 1 ), stat=allocok )
         IF ( allocok .gt. 0 ) THEN
            WRITE(*,*) 'PB allocation in DMUMPS_185'
            id%INFO(1) = -13
            id%INFO(2) = NPROCS
            RETURN
         END IF
         TAB_MAXS=0_8
         IF ( allocated(LU_USAGE) ) DEALLOCATE(LU_USAGE)
         ALLOCATE( LU_USAGE( 0: NPROCS - 1 ), stat=allocok )
         IF ( allocok .gt. 0 ) THEN
            WRITE(*,*) 'PB allocation in DMUMPS_185'
            id%INFO(1) = -13
            id%INFO(2) = NPROCS
            RETURN
         END IF
         LU_USAGE=dble(0)
         MD_MEM=int(0,8)
      ENDIF
      IF((KEEP(81).EQ.2).OR.(KEEP(81).EQ.3))THEN
         ALLOCATE(CB_COST_MEM(2*2000*id%NSLAVES),                       &
     &            stat=allocok)
         IF (allocok > 0) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = id%NSLAVES
           RETURN
         ENDIF
         CB_COST_MEM=int(0,8)
         ALLOCATE(CB_COST_ID(2000*3),                                   &
     &            stat=allocok)
         IF (allocok > 0) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = id%NSLAVES
           RETURN
         ENDIF
         CB_COST_ID=0
         POS_MEM=1
         POS_ID=1
      ENDIF
      ALLOCATE(FUTURE_NIV2(NPROCS), stat=allocok)
      IF (allocok > 0 ) THEN
         WRITE(*,*) 'PB allocation in DMUMPS_185'
         id%INFO(1) = -13
         id%INFO(2) = NPROCS
         RETURN
      ENDIF
      DO i = 1, NPROCS
        FUTURE_NIV2(i) = id%FUTURE_NIV2(i)
        IF(BDC_MD)THEN
           IF(FUTURE_NIV2(i).EQ.0)THEN
              MD_MEM(i-1)=999999999_8
           ENDIF
        ENDIF
      ENDDO
      DELTA_MEM=ZERO
      DELTA_LOAD=ZERO
      CHECK_MEM=0_8
      IF(BDC_SBTR.OR.BDC_POOL_MNG)THEN
         NB_SUBTREES=id%NBSA_LOCAL
         IF (allocated(MEM_SUBTREE)) DEALLOCATE(MEM_SUBTREE)
         ALLOCATE(MEM_SUBTREE(id%NBSA_LOCAL),stat=allocok)
         DO i=1,id%NBSA_LOCAL
            MEM_SUBTREE(i)=id%MEM_SUBTREE(i)
         ENDDO
         MY_FIRST_LEAF=>id%MY_FIRST_LEAF
         MY_NB_LEAF=>id%MY_NB_LEAF
         MY_ROOT_SBTR=>id%MY_ROOT_SBTR
         IF (allocated(SBTR_FIRST_POS_IN_POOL))                         &
     &        DEALLOCATE(SBTR_FIRST_POS_IN_POOL)
         ALLOCATE(SBTR_FIRST_POS_IN_POOL(id%NBSA_LOCAL),stat=allocok)
         INSIDE_SUBTREE=0
         PEAK_SBTR_CUR_LOCAL = dble(0)
         SBTR_CUR_LOCAL      = dble(0)
         IF (allocated(SBTR_PEAK_ARRAY)) DEALLOCATE(SBTR_PEAK_ARRAY)
         ALLOCATE(SBTR_PEAK_ARRAY(id%NBSA_LOCAL),stat=allocok)
         SBTR_PEAK_ARRAY=dble(0)
         IF (allocated(SBTR_CUR_ARRAY)) DEALLOCATE(SBTR_CUR_ARRAY)
         ALLOCATE(SBTR_CUR_ARRAY(id%NBSA_LOCAL),stat=allocok)
         SBTR_CUR_ARRAY=dble(0)
         INDICE_SBTR_ARRAY=1
         NIV1_FLAG=0
         INDICE_SBTR=1
      ENDIF
      IF ( allocated(LOAD_FLOPS) ) DEALLOCATE( LOAD_FLOPS )
      ALLOCATE( LOAD_FLOPS( 0: NPROCS - 1 ), stat=allocok )
      IF ( allocok .gt. 0 ) THEN
         WRITE(*,*) 'PB allocation in DMUMPS_185'
         id%INFO(1) = -13
         id%INFO(2) = NPROCS
         RETURN
      END IF
      IF ( allocated(WLOAD) ) DEALLOCATE( WLOAD )
      ALLOCATE( WLOAD( NPROCS ), stat=allocok )
      IF ( allocok .gt. 0 ) THEN
         WRITE(*,*) 'PB allocation in DMUMPS_185'
         id%INFO(1) = -13
         id%INFO(2) = NPROCS
         RETURN
      END IF
      IF ( allocated(IDWLOAD) ) DEALLOCATE( IDWLOAD )
      ALLOCATE( IDWLOAD( NPROCS ), stat=allocok )
      IF ( allocok .gt. 0 ) THEN
         WRITE(*,*) 'PB allocation in DMUMPS_185'
         id%INFO(1) = -13
         id%INFO(2) = NPROCS
         RETURN
      END IF
      IF ( BDC_MEM ) THEN
        IF ( allocated(DM_MEM) ) DEALLOCATE( DM_MEM )
        ALLOCATE( DM_MEM( 0:NPROCS-1 ), stat=allocok )
        IF ( allocok .gt. 0 ) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = NPROCS
           RETURN
        END IF
      END IF
      IF ( BDC_POOL ) THEN
        IF ( allocated(POOL_MEM) ) DEALLOCATE(POOL_MEM)
        ALLOCATE( POOL_MEM(0: NPROCS -1), stat=allocok)
        IF ( allocok .gt. 0 ) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = NPROCS
           RETURN
        END IF
        POOL_MEM = dble(0)
        POOL_LAST_COST_SENT = dble(0)
      END IF
      IF ( BDC_SBTR ) THEN
        IF ( allocated(SBTR_MEM) ) DEALLOCATE(SBTR_MEM)
        ALLOCATE( SBTR_MEM(0: NPROCS -1), stat=allocok)
        IF ( allocok .gt. 0 ) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = NPROCS
           RETURN
        END IF
        IF ( allocated(SBTR_CUR) ) DEALLOCATE(SBTR_CUR)
        ALLOCATE( SBTR_CUR(0: NPROCS -1), stat=allocok)
        IF ( allocok .gt. 0 ) THEN
           WRITE(*,*) 'PB allocation in DMUMPS_185'
           id%INFO(1) = -13
           id%INFO(2) = NPROCS
           RETURN
        END IF
        SBTR_CUR = dble(0)
        SBTR_MEM = dble(0)
      END IF
      CALL AGMG_MUMPS_546(K34_LOC,K35_LOC)
      K35  = K35_LOC
      BUF_LOAD_SIZE = K34_LOC * 2 * ( NPROCS - 1 ) +                    &
     &                NPROCS * ( K35_LOC + K34_LOC )
      IF (BDC_MEM) THEN
        BUF_LOAD_SIZE = BUF_LOAD_SIZE + NPROCS * K35_LOC
      END IF
      IF (BDC_SBTR)THEN
        BUF_LOAD_SIZE = BUF_LOAD_SIZE + NPROCS * K35_LOC
      ENDIF
      LBUF_LOAD_RECV = (BUF_LOAD_SIZE+K34_LOC)/K34_LOC
      LBUF_LOAD_RECV_BYTES = LBUF_LOAD_RECV * K34_LOC
      IF ( allocated(BUF_LOAD_RECV) ) DEALLOCATE(BUF_LOAD_RECV)
      ALLOCATE( BUF_LOAD_RECV( LBUF_LOAD_RECV), stat=allocok)
      IF ( allocok > 0 ) THEN
        WRITE(*,*) 'PB allocation in DMUMPS_185'
        id%INFO(1) = -13
        id%INFO(2) = LBUF_LOAD_RECV
        RETURN
      ENDIF
      BUF_LOAD_SIZE = BUF_LOAD_SIZE * 20
      CALL DAGMG_MUMPS_54( BUF_LOAD_SIZE, IERR )
      IF ( IERR .LT. 0 ) THEN
         id%INFO(1) = -13
         id%INFO(2) = BUF_LOAD_SIZE
         RETURN
      END IF
      DO i = 0, NPROCS - 1
         LOAD_FLOPS( i ) = ZERO
      END DO
      IF ( BDC_MEM ) THEN
        DO i = 0, NPROCS - 1
          DM_MEM( i )=ZERO
        END DO
      ENDIF
      CALL DAGMG_MUMPS_425(KEEP(69))
      IF(BDC_MD)THEN
         MAX_SBTR=0.0D0
         IF(BDC_SBTR)THEN
            DO i=1,id%NBSA_LOCAL
               MAX_SBTR=max(id%MEM_SUBTREE(i),MAX_SBTR)
            ENDDO
         ENDIF
         MD_MEM(MYID)=MEMORY_MD
         WHAT=8
         CALL DAGMG_MUMPS_460( WHAT,                                         &
     &        COMM_LD, NPROCS,                                          &
     &        FUTURE_NIV2,                                              &
     &        dble(MEMORY_MD),dble(0) ,MYID, IERR  )
         WHAT=9
         MEMORY_SENT = dble(LA-MAX_SURF_MASTER)-MAX_SBTR                &
     &      - max( dble(LA) * dble(3) / dble(100),                      &
     &      dble(2) * dble(max(KEEP(5),KEEP(6))) * dble(KEEP(127)))
         IF (KEEP(12) > 25) THEN
           MEMORY_SENT = MEMORY_SENT -                                  &
     &                   dble(KEEP(12))*0.2d0*dble(LA)/100.0d0
         ENDIF
         TAB_MAXS(MYID)=int(MEMORY_SENT,8)
         CALL DAGMG_MUMPS_460( WHAT,                                         &
     &        COMM_LD, NPROCS,                                          &
     &        FUTURE_NIV2,                                              &
     &        MEMORY_SENT,                                              &
     &        dble(0),MYID, IERR  )
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_185
      SUBROUTINE DAGMG_MUMPS_190( CHECK_FLOPS,PROCESS_BANDE,                 &
     &     INC_LOAD, KEEP,KEEP8 )
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      DOUBLE PRECISION INC_LOAD
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      LOGICAL PROCESS_BANDE
      INTEGER CHECK_FLOPS
      INTEGER IERR
      DOUBLE PRECISION ZERO, SEND_MEM, SEND_LOAD,SBTR_TMP
      PARAMETER( ZERO=0.0d0 )
      INTRINSIC max, abs
      IF (INC_LOAD == 0.0D0) THEN
         IF(REMOVE_NODE_FLAG)THEN
            REMOVE_NODE_FLAG=.FALSE.
         ENDIF
         RETURN
      ENDIF
      IF((CHECK_FLOPS.NE.0).AND.                                        &
     &     (CHECK_FLOPS.NE.1).AND.(CHECK_FLOPS.NE.2))THEN
         WRITE(*,*)MYID,': Bad value for CHECK_FLOPS'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF(CHECK_FLOPS.EQ.1)THEN
         CHK_LD=CHK_LD+INC_LOAD
      ELSE
         IF(CHECK_FLOPS.EQ.2)THEN
            RETURN
         ENDIF
      ENDIF
      IF ( PROCESS_BANDE ) THEN
         RETURN
      ENDIF
      LOAD_FLOPS( MYID ) = max( LOAD_FLOPS( MYID ) + INC_LOAD, ZERO)
      IF(BDC_M2_FLOPS.AND.REMOVE_NODE_FLAG)THEN
         IF(INC_LOAD.NE.REMOVE_NODE_COST)THEN
            IF(INC_LOAD.GT.REMOVE_NODE_COST)THEN
               DELTA_LOAD = DELTA_LOAD +                                &
     &              (INC_LOAD-REMOVE_NODE_COST)
               GOTO 888
            ELSE
               DELTA_LOAD = DELTA_LOAD -                                &
     &              (REMOVE_NODE_COST-INC_LOAD)
               GOTO 888
            ENDIF
         ENDIF
         GOTO 333
      ENDIF
      DELTA_LOAD = DELTA_LOAD + INC_LOAD
  888 CONTINUE
      IF ( DELTA_LOAD > MIN_DIFF .OR. DELTA_LOAD < -MIN_DIFF) THEN
         SEND_LOAD = DELTA_LOAD
         IF (BDC_MEM) THEN
           SEND_MEM = DELTA_MEM
         ELSE
           SEND_MEM = ZERO
         END IF
         IF(BDC_SBTR)THEN
           SBTR_TMP=SBTR_CUR(MYID)
         ELSE
           SBTR_TMP=dble(0)
         ENDIF
  111    CONTINUE
         CALL DAGMG_MUMPS_77( BDC_SBTR,BDC_MEM,                              &
     &        BDC_MD,COMM_LD, NPROCS,                                   &
     &        SEND_LOAD,                                                &
     &        SEND_MEM,SBTR_TMP,                                        &
     &        DM_SUMLU,                                                 &
     &        FUTURE_NIV2,                                              &
     &        MYID, IERR )
           IF ( IERR == -1 )THEN
             CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
             GOTO 111
           ELSE IF ( IERR .NE.0 ) THEN
             WRITE(*,*) "Internal Error in DAGMG_MUMPS_190",IERR
             CALL AGMG_MUMPS_ABORT()
           ENDIF
         IF ( IERR .EQ. 0 ) THEN
           DELTA_LOAD = ZERO
           IF (BDC_MEM) DELTA_MEM  = ZERO
         END IF
      ENDIF
  333 CONTINUE
      IF(REMOVE_NODE_FLAG)THEN
         REMOVE_NODE_FLAG=.FALSE.
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_190
      SUBROUTINE DAGMG_MUMPS_471( SSARBR,                                    &
     &           PROCESS_BANDE_ARG, MEM_VALUE, NEW_LU, INC_MEM_ARG,     &
     &           KEEP,KEEP8,LRLU)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER(8), INTENT(IN) :: MEM_VALUE, INC_MEM_ARG, NEW_LU,LRLU
      LOGICAL, INTENT(IN) :: PROCESS_BANDE_ARG, SSARBR
      INTEGER IERR, KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION ZERO, SEND_MEM, TMP_MEM, SBTR_TMP
      PARAMETER( ZERO=0.0d0 )
      INTRINSIC max, abs
      INTEGER(8) :: INC_MEM
      LOGICAL PROCESS_BANDE
      INTEGER i
      PROCESS_BANDE=PROCESS_BANDE_ARG
      INC_MEM = INC_MEM_ARG
      IF ( PROCESS_BANDE .AND. NEW_LU .NE. 0_8) THEN
        WRITE(*,*) " Internal Error in DAGMG_MUMPS_471."
        WRITE(*,*) " NEW_LU must be zero if called from PROCESS_BANDE"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      DM_SUMLU = DM_SUMLU + dble(NEW_LU)
      IF(KEEP_LOAD(201).EQ.0)THEN
         CHECK_MEM = CHECK_MEM + INC_MEM
      ELSEIF(KEEP_LOAD(201).EQ.1)THEN
         CHECK_MEM = CHECK_MEM + INC_MEM - NEW_LU
      ELSEIF(KEEP_LOAD(201).EQ.2)THEN
         CHECK_MEM = CHECK_MEM + INC_MEM - NEW_LU
      ENDIF
      IF ( MEM_VALUE .NE. CHECK_MEM ) THEN
         WRITE(*,*)MYID,                                                &
     &   ':Problem with increments in DMUMPS_471',                      &
     &   CHECK_MEM, MEM_VALUE, INC_MEM,NEW_LU
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (PROCESS_BANDE) THEN
         RETURN
      ENDIF
      IF(BDC_POOL_MNG) THEN
         IF(SBTR_WHICH_M.EQ.0)THEN
            IF (SSARBR) SBTR_CUR_LOCAL = SBTR_CUR_LOCAL+                &
     &                                   dble(INC_MEM-NEW_LU)
         ELSE
            IF (SSARBR) SBTR_CUR_LOCAL = SBTR_CUR_LOCAL+                &
     &                                   dble(INC_MEM)
         ENDIF
      ENDIF
      IF ( .NOT. BDC_MEM ) THEN
         RETURN
      ENDIF
      IF (BDC_SBTR .AND. SSARBR) THEN
         IF((SBTR_WHICH_M.EQ.0).AND.(KEEP(201).NE.0))THEN
            SBTR_CUR(MYID) = SBTR_CUR(MYID)+dble(INC_MEM-NEW_LU)
         ELSE
            SBTR_CUR(MYID) = SBTR_CUR(MYID)+dble(INC_MEM)
         ENDIF
         SBTR_TMP = SBTR_CUR(MYID)
      ELSE
        SBTR_TMP=dble(0)
      ENDIF
      IF ( NEW_LU > 0_8 ) THEN
        INC_MEM = INC_MEM - NEW_LU
      ENDIF
      DM_MEM( MYID ) = DM_MEM(MYID) + dble(INC_MEM)
      MAX_PEAK_STK=max(MAX_PEAK_STK,DM_MEM(MYID))
      IF(BDC_M2_MEM.AND.REMOVE_NODE_FLAG_MEM)THEN
         IF(dble(INC_MEM).NE.REMOVE_NODE_COST_MEM)THEN
            IF(dble(INC_MEM).GT.REMOVE_NODE_COST_MEM)THEN
               DELTA_MEM = DELTA_MEM +                                  &
     &              (dble(INC_MEM)-REMOVE_NODE_COST_MEM)
               GOTO 888
            ELSE
               DELTA_MEM = DELTA_MEM -                                  &
     &              (REMOVE_NODE_COST_MEM-dble(INC_MEM))
               GOTO 888
            ENDIF
         ENDIF
         GOTO 333
      ENDIF
      DELTA_MEM = DELTA_MEM + dble(INC_MEM)
  888 CONTINUE
      IF ((KEEP(48).NE.5).OR.                                           &
     &     ((KEEP(48).EQ.5).AND.(abs(DELTA_MEM)                         &
     &      .GE.0.1d0*dble(LRLU))))THEN
         IF ( abs(DELTA_MEM) > DM_THRES_MEM ) THEN
            SEND_MEM = DELTA_MEM
  111       CONTINUE
            CALL DAGMG_MUMPS_77(                                             &
     &           BDC_SBTR,                                              &
     &           BDC_MEM,BDC_MD, COMM_LD,                               &
     &           NPROCS,                                                &
     &           DELTA_LOAD,                                            &
     &           SEND_MEM,SBTR_TMP,                                     &
     &           DM_SUMLU,                                              &
     &           FUTURE_NIV2,                                           &
     &           MYID,IERR )
            IF ( IERR == -1 )THEN
               CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
               GOTO 111
           ELSE IF ( IERR .NE. 0 ) THEN
             WRITE(*,*) "Internal Error in DAGMG_MUMPS_471",IERR
             CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF ( IERR .EQ. 0 ) THEN
             DELTA_LOAD = ZERO
             DELTA_MEM  = ZERO
           END IF
         ENDIF
      ENDIF
  333 CONTINUE
      IF(REMOVE_NODE_FLAG_MEM)THEN
         REMOVE_NODE_FLAG_MEM=.FALSE.
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_471
      INTEGER FUNCTION DAGMG_MUMPS_186( K69, MEM_DISTRIB,MSG_SIZE )
      IMPLICIT NONE
      INTEGER i, NLESS, K69
      INTEGER, DIMENSION(0:NPROCS-1) :: MEM_DISTRIB
      DOUBLE PRECISION LREF
      DOUBLE PRECISION MSG_SIZE
      NLESS = 0
      DO i=1,NPROCS
         IDWLOAD(i) = i - 1
      ENDDO
      WLOAD(1:NPROCS) = LOAD_FLOPS(0:NPROCS-1)
      IF(BDC_M2_FLOPS)THEN
         DO i=1,NPROCS
            WLOAD(i)=WLOAD(i)+NIV2(i)
         ENDDO
      ENDIF
      IF(K69 .gt. 1) THEN
         CALL DAGMG_MUMPS_426(MEM_DISTRIB,MSG_SIZE,IDWLOAD,NPROCS)
      ENDIF
      LREF = LOAD_FLOPS(MYID)
      DO i=1, NPROCS
         IF (WLOAD(i).LT.LREF) NLESS=NLESS+1
      ENDDO
      DAGMG_MUMPS_186 = NLESS
      RETURN
      END FUNCTION DAGMG_MUMPS_186
      SUBROUTINE DAGMG_MUMPS_189(MEM_DISTRIB,MSG_SIZE,DEST,                  &
     &     NSLAVES)
      IMPLICIT NONE
      INTEGER NSLAVES
      INTEGER DEST(NSLAVES)
      INTEGER, DIMENSION(0:NPROCS - 1) :: MEM_DISTRIB
      INTEGER i,J,NBDEST
      DOUBLE PRECISION MSG_SIZE
      IF ( NSLAVES.eq.NPROCS-1 ) THEN
        J = MYID+1
        DO i=1,NSLAVES
           J=J+1
           IF (J.GT.NPROCS) J=1
           DEST(i) = J - 1
        ENDDO
      ELSE
        DO i=1,NPROCS
           IDWLOAD(i) = i - 1
        ENDDO
        CALL AGMG_MUMPS_558(NPROCS, WLOAD, IDWLOAD)
         NBDEST = 0
         DO i=1, NSLAVES
            J = IDWLOAD(i)
            IF (J.NE.MYID) THEN
               NBDEST = NBDEST+1
               DEST(NBDEST) = J
            ENDIF
         ENDDO
         IF (NBDEST.NE.NSLAVES) THEN
            DEST(NSLAVES) = IDWLOAD(NSLAVES+1)
         ENDIF
         IF(BDC_MD)THEN
            J=NSLAVES+1
            do i=NSLAVES+1,NPROCS
               IF(IDWLOAD(i).NE.MYID)THEN
                  DEST(J)= IDWLOAD(i)
                  J=J+1
               ENDIF
            end do
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_189
      SUBROUTINE DAGMG_MUMPS_184( IPROC, LOAD_IPROC )
      IMPLICIT NONE
      INTEGER, intent(in) :: IPROC
      DOUBLE PRECISION, intent(out) :: LOAD_IPROC
      LOAD_IPROC = LOAD_FLOPS( IPROC )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_184
      SUBROUTINE DAGMG_MUMPS_183( INFO1, IERR )
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER, intent(in) :: INFO1
      INTEGER, intent(out) :: IERR
      IERR=0
      DEALLOCATE( LOAD_FLOPS )
      DEALLOCATE( WLOAD )
      DEALLOCATE( IDWLOAD )
      DEALLOCATE(FUTURE_NIV2)
      IF(BDC_MD)THEN
         DEALLOCATE(MD_MEM)
         DEALLOCATE(LU_USAGE)
         DEALLOCATE(TAB_MAXS)
      ENDIF
      IF ( BDC_MEM ) DEALLOCATE( DM_MEM )
      IF ( BDC_POOL) DEALLOCATE( POOL_MEM )
      IF ( BDC_SBTR) THEN
         DEALLOCATE( SBTR_MEM )
         DEALLOCATE( SBTR_CUR )
         DEALLOCATE(SBTR_FIRST_POS_IN_POOL)
         NULLIFY(MY_FIRST_LEAF)
         NULLIFY(MY_NB_LEAF)
         NULLIFY(MY_ROOT_SBTR)
      ENDIF
      IF(KEEP_LOAD(76).EQ.4)THEN
         NULLIFY(DEPTH_FIRST_LOAD)
      ENDIF
      IF(KEEP_LOAD(76).EQ.5)THEN
         NULLIFY(COST_TRAV)
      ENDIF
      IF (BDC_M2_MEM.OR.BDC_M2_FLOPS) THEN
        DEALLOCATE(NB_SON,POOL_NIV2,POOL_NIV2_COST, NIV2)
      END IF
      IF((KEEP_LOAD(81).EQ.2).OR.(KEEP_LOAD(81).EQ.3))THEN
         DEALLOCATE(CB_COST_MEM)
         DEALLOCATE(CB_COST_ID)
      ENDIF
      NULLIFY(ND_LOAD)
      NULLIFY(KEEP_LOAD)
      NULLIFY(KEEP8_LOAD)
      NULLIFY(FILS_LOAD)
      NULLIFY(FRERE_LOAD)
      NULLIFY(PROCNODE_LOAD)
      NULLIFY(STEP_LOAD)
      NULLIFY(NE_LOAD)
      NULLIFY(CAND_LOAD)
      NULLIFY(STEP_TO_NIV2_LOAD)
      NULLIFY(DAD_LOAD)
      IF (BDC_SBTR.OR.BDC_POOL_MNG) THEN
         DEALLOCATE(MEM_SUBTREE)
         DEALLOCATE(SBTR_PEAK_ARRAY)
         DEALLOCATE(SBTR_CUR_ARRAY)
      ENDIF
      CALL DAGMG_MUMPS_58( IERR )
      CALL DAGMG_MUMPS_150( MYID, COMM_LD,                                   &
     &     BUF_LOAD_RECV, LBUF_LOAD_RECV,                               &
     &     LBUF_LOAD_RECV_BYTES )
      DEALLOCATE(BUF_LOAD_RECV)
      END SUBROUTINE DAGMG_MUMPS_183
      SUBROUTINE DAGMG_MUMPS_467(COMM, KEEP)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR, MSGTAG, MSGLEN, MSGSOU,COMM
      INTEGER KEEP(500)
      INTEGER STATUS(AGMG_MPF_STATUS_SIZE)
      LOGICAL FLAG
   10 CONTINUE
      CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG, COMM,               &
     &     FLAG, STATUS, IERR )
      IF (FLAG) THEN
        KEEP(65)=KEEP(65)+1
        MSGTAG = STATUS( AGMG_MPF_TAG )
        MSGSOU = STATUS( AGMG_MPF_SOURCE )
        IF ( MSGTAG .NE. UPDATE_LOAD) THEN
          write(*,*) "Internal error 1 in DAGMG_MUMPS_467",                  &
     &    MSGTAG
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        CALL AGMG_NOCALL('MPI_GET_COUNT')
        IF ( MSGLEN > LBUF_LOAD_RECV_BYTES ) THEN
          write(*,*) "Internal error 2 in DAGMG_MUMPS_467",                  &
     &    MSGLEN, LBUF_LOAD_RECV_BYTES
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        CALL AGMG_NOCALL('MPI_RECV')
        CALL DAGMG_MUMPS_187( MSGSOU, BUF_LOAD_RECV,                         &
     &  LBUF_LOAD_RECV, LBUF_LOAD_RECV_BYTES )
        GOTO 10
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_467
      RECURSIVE SUBROUTINE DAGMG_MUMPS_187                                   &
     &   ( MSGSOU, BUFR, LBUFR, LBUFR_BYTES )
      IMPLICIT NONE
      INTEGER MSGSOU, LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER POSITION, IERR, WHAT, NSLAVES, i
      DOUBLE PRECISION LOAD_RECEIVED
      INTEGER INODE_RECEIVED,K,J,SON,NSLAVES_TEMP,POS_TEMP,             &
     &     NCB_RECEIVED
      DOUBLE PRECISION SURF
      INTEGER, POINTER, DIMENSION (:) :: LIST_SLAVES
      DOUBLE PRECISION, POINTER, DIMENSION (:) :: LOAD_INCR
      LOGICAL FLAG_LEADER
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      POSITION = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      IF ( WHAT == 0 ) THEN
        CALL AGMG_NOCALL('MPI_UNPACK')
      LOAD_FLOPS( MSGSOU ) = LOAD_FLOPS(MSGSOU) + LOAD_RECEIVED
        IF ( BDC_MEM ) THEN
          CALL AGMG_NOCALL('MPI_UNPACK')
          DM_MEM(MSGSOU)  = DM_MEM(MSGSOU) + LOAD_RECEIVED
          MAX_PEAK_STK=max(MAX_PEAK_STK,DM_MEM(MSGSOU))
        END IF
        IF(BDC_SBTR)THEN
          CALL AGMG_NOCALL('MPI_UNPACK')
          SBTR_CUR(MSGSOU)=LOAD_RECEIVED
        ENDIF
        IF(BDC_MD)THEN
           CALL AGMG_NOCALL('MPI_UNPACK')
           IF(KEEP_LOAD(201).EQ.0)THEN
              LU_USAGE(MSGSOU)=LOAD_RECEIVED
           ENDIF
        ENDIF
      ELSEIF (( WHAT == 1).OR.(WHAT.EQ.19)) THEN
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        LIST_SLAVES => IDWLOAD
        LOAD_INCR => WLOAD
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        DO i = 1, NSLAVES
            LOAD_FLOPS(LIST_SLAVES(i)) =                                &
     &      LOAD_FLOPS(LIST_SLAVES(i)) +                                &
     &      LOAD_INCR(i)
        END DO
        IF ( BDC_MEM ) THEN
          CALL AGMG_NOCALL('MPI_UNPACK')
          DO i = 1, NSLAVES
              DM_MEM(LIST_SLAVES(i)) = DM_MEM(LIST_SLAVES(i)) +         &
     &        LOAD_INCR(i)
              MAX_PEAK_STK=max(MAX_PEAK_STK,DM_MEM(LIST_SLAVES(i)))
          END DO
        END IF
        IF(WHAT.EQ.19)THEN
           CALL AGMG_NOCALL('MPI_UNPACK')
           CALL CLEAN_POOL_MEM_INFO(INODE_RECEIVED)
           CB_COST_ID(POS_ID)=INODE_RECEIVED
           CB_COST_ID(POS_ID+1)=NSLAVES
           CB_COST_ID(POS_ID+2)=POS_MEM
           POS_ID=POS_ID+3
           DO i=1,NSLAVES
              WRITE(*,*)MYID,':',LIST_SLAVES(i),'->',LOAD_INCR(i)
              CB_COST_MEM(POS_MEM)=int(LIST_SLAVES(i),8)
              POS_MEM=POS_MEM+1
              CB_COST_MEM(POS_MEM)=int(LOAD_INCR(i),8)
              POS_MEM=POS_MEM+1
           ENDDO
        ENDIF
        NULLIFY( LIST_SLAVES )
        NULLIFY( LOAD_INCR )
      ELSE IF (WHAT == 2 ) THEN
        IF ( .not. BDC_POOL ) THEN
          WRITE(*,*) "Internal error 2 in DAGMG_MUMPS_187"
          CALL AGMG_MUMPS_ABORT()
        END IF
        CALL AGMG_NOCALL('MPI_UNPACK')
        POOL_MEM(MSGSOU)=LOAD_RECEIVED
      ELSE IF ( WHAT == 3 ) THEN
        IF ( .NOT. BDC_SBTR) THEN
          WRITE(*,*) "Internal error 3 in DAGMG_MUMPS_187"
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        CALL AGMG_NOCALL('MPI_UNPACK')
        SBTR_MEM(MSGSOU)=SBTR_MEM(MSGSOU)+LOAD_RECEIVED
      ELSE IF (WHAT == 4) THEN
        FUTURE_NIV2(MSGSOU+1)=0
        IF(BDC_MD)THEN
           CALL AGMG_NOCALL('MPI_UNPACK')
          MD_MEM(MSGSOU)=999999999_8
          TAB_MAXS(MSGSOU)=TAB_MAXS(MSGSOU)+int(SURF,8)
        ENDIF
        IF(BDC_M2_MEM.OR.BDC_M2_FLOPS)THEN
        ENDIF
      ELSE IF (WHAT == 5) THEN
         IF((.NOT.BDC_M2_MEM).AND.(.NOT.BDC_M2_FLOPS))THEN
            WRITE(*,*) "Internal error 7 in DAGMG_MUMPS_187"
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         CALL AGMG_NOCALL('MPI_UNPACK')
         IF(BDC_M2_MEM) THEN
            CALL PROCESS_NIV2_MEM_MSG(INODE_RECEIVED)
         ELSEIF(BDC_M2_FLOPS) THEN
            CALL PROCESS_NIV2_FLOPS_MSG(INODE_RECEIVED)
         ENDIF
         IF((KEEP_LOAD(81).EQ.2).OR.(KEEP_LOAD(81).EQ.3))THEN
            CALL AGMG_NOCALL('MPI_UNPACK')
               CALL AGMG_NOCALL('MPI_UNPACK')
            IF(AGMG_MUMPS_330(STEP_LOAD(INODE_RECEIVED),                     &
     &           PROCNODE_LOAD,NPROCS).EQ.1)THEN
               CB_COST_ID(POS_ID)=INODE_RECEIVED
               CB_COST_ID(POS_ID+1)=1
               CB_COST_ID(POS_ID+2)=POS_MEM
               POS_ID=POS_ID+3
               CB_COST_MEM(POS_MEM)=int(MSGSOU,8)
               POS_MEM=POS_MEM+1
               CB_COST_MEM(POS_MEM)=int(NCB_RECEIVED,8)*                &
     &              int(NCB_RECEIVED,8)
               POS_MEM=POS_MEM+1
            ENDIF
         ENDIF
      ELSE IF ( WHAT == 6 ) THEN
         IF((.NOT.BDC_M2_MEM).AND.(.NOT.BDC_M2_FLOPS))THEN
            WRITE(*,*) "Internal error 8 in DAGMG_MUMPS_187"
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         CALL AGMG_NOCALL('MPI_UNPACK')
         IF(BDC_M2_MEM) THEN
            NIV2(MSGSOU+1) = LOAD_RECEIVED
         ELSEIF(BDC_M2_FLOPS) THEN
            NIV2(MSGSOU+1) = NIV2(MSGSOU+1) + LOAD_RECEIVED
            IF(NIV2(MSGSOU+1).LT.0.0D0)THEN
               IF(abs(NIV2(MSGSOU+1)).LE.                               &
     &              sqrt(epsilon(LOAD_RECEIVED)))THEN
                  NIV2(MSGSOU+1)=0.0D0
               ELSE
                  WRITE(*,*)'problem with NIV2_FLOPS message',          &
     &                 NIV2(MSGSOU+1),MSGSOU,LOAD_RECEIVED
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
            ENDIF
         ENDIF
      ELSEIF(WHAT == 17)THEN
         CALL AGMG_NOCALL('MPI_UNPACK')
         IF(BDC_M2_MEM) THEN
            NIV2(MSGSOU+1) = LOAD_RECEIVED
            CALL AGMG_NOCALL('MPI_UNPACK')
            IF(BDC_MD)THEN
               DM_MEM(MYID)=DM_MEM(MYID)+LOAD_RECEIVED
            ELSEIF(BDC_POOL)THEN
               POOL_MEM(MSGSOU)=LOAD_RECEIVED
            ENDIF
         ELSEIF(BDC_M2_FLOPS) THEN
            NIV2(MSGSOU+1) = NIV2(MSGSOU+1) + LOAD_RECEIVED
            IF(NIV2(MSGSOU+1).LT.0.0D0)THEN
               WRITE(*,*)'problem with NIV2_FLOPS message',             &
     &              NIV2(MSGSOU+1),MSGSOU,LOAD_RECEIVED
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            CALL AGMG_NOCALL('MPI_UNPACK')
            LOAD_FLOPS( MSGSOU ) = LOAD_FLOPS(MSGSOU) + LOAD_RECEIVED
         ENDIF
      ELSEIF ( WHAT == 7 ) THEN
         IF(.NOT.BDC_MD)THEN
            WRITE(*,*)MYID,': Internal error 4                          &
     &in DAGMG_MUMPS_187'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        LIST_SLAVES => IDWLOAD
        LOAD_INCR => WLOAD
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        DO i = 1, NSLAVES
            MD_MEM(LIST_SLAVES(i)) =                                    &
     &      MD_MEM(LIST_SLAVES(i)) +                                    &
     &      int(LOAD_INCR(i),8)
            IF(FUTURE_NIV2(LIST_SLAVES(i)+1).EQ.0)THEN
               MD_MEM(LIST_SLAVES(i))=999999999_8
            ENDIF
        END DO
      ELSEIF ( WHAT == 8 ) THEN
         IF(.NOT.BDC_MD)THEN
            WRITE(*,*)MYID,': Internal error 5                          &
     &in DAGMG_MUMPS_187'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
        CALL AGMG_NOCALL('MPI_UNPACK')
        MD_MEM(MSGSOU)=MD_MEM(MSGSOU)+int(LOAD_RECEIVED,8)
        IF(FUTURE_NIV2(MSGSOU+1).EQ.0)THEN
           MD_MEM(MSGSOU)=999999999_8
        ENDIF
      ELSEIF ( WHAT == 9 ) THEN
         IF(.NOT.BDC_MD)THEN
            WRITE(*,*)MYID,': Internal error 6                          &
     &in DAGMG_MUMPS_187'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
        CALL AGMG_NOCALL('MPI_UNPACK')
        TAB_MAXS(MSGSOU)=int(LOAD_RECEIVED,8)
      ELSE
          WRITE(*,*) "Internal error 1 in DAGMG_MUMPS_187"
          CALL AGMG_MUMPS_ABORT()
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_187
      integer function DAGMG_MUMPS_409                                       &
     &                 (MEM_DISTRIB,CAND,                               &
     &                  K69,                                            &
     &                  SLAVEF,MSG_SIZE,                                &
     &                  NMB_OF_CAND )
      implicit none
      integer, intent(in) :: K69, SLAVEF
      INTEGER, intent(in) :: CAND(SLAVEF+1)
      INTEGER, DIMENSION(0:NPROCS - 1), intent(in) :: MEM_DISTRIB
      INTEGER, intent(out) :: NMB_OF_CAND
      integer i,nless
      DOUBLE PRECISION lref
      DOUBLE PRECISION MSG_SIZE
      nless = 0
      NMB_OF_CAND=CAND(SLAVEF+1)
      do i=1,NMB_OF_CAND
         WLOAD(i)=LOAD_FLOPS(CAND(i))
         IF(BDC_M2_FLOPS)THEN
            WLOAD(i)=WLOAD(i)+NIV2(CAND(i)+1)
         ENDIF
      end do
      IF(K69 .gt. 1) THEN
         CALL DAGMG_MUMPS_426(MEM_DISTRIB,MSG_SIZE,                          &
     &        CAND,NMB_OF_CAND)
      ENDIF
      lref = LOAD_FLOPS(MYID)
      do i=1, NMB_OF_CAND
         if (WLOAD(i).lt.lref) nless=nless+1
      end do
      DAGMG_MUMPS_409 = nless
      return
      end function DAGMG_MUMPS_409
      subroutine DAGMG_MUMPS_384                                             &
     &           (MEM_DISTRIB,CAND,                                     &
     &            SLAVEF,                                               &
     &            nslaves_inode, DEST)
      implicit none
      integer, intent(in) :: nslaves_inode, SLAVEF
      integer, intent(in) :: CAND(SLAVEF+1)
      integer, dimension(0:NPROCS - 1), intent(in) :: MEM_DISTRIB
      integer, intent(out) :: DEST(CAND(SLAVEF+1))
      integer i,j,NMB_OF_CAND,deficit,nextproc
      DOUBLE PRECISION lref
      external AGMG_MUMPS_558
      NMB_OF_CAND = CAND(SLAVEF+1)
      if(nslaves_inode.ge.NPROCS .or.                                   &
     &   nslaves_inode.gt.NMB_OF_CAND) then
         write(*,*)'Internal error in DMUMPS_384',                      &
     &   nslaves_inode, NPROCS, NMB_OF_CAND
         CALL AGMG_MUMPS_ABORT()
      end if
      if (nslaves_inode.eq.NPROCS-1) then
         j=MYID+1
         do i=1,nslaves_inode
            if(j.ge.NPROCS) j=0
            DEST(i)=j
            j=j+1
         end do
      else
        do i=1,NMB_OF_CAND
               IDWLOAD(i)=i
        end do
        call AGMG_MUMPS_558(NMB_OF_CAND,                                     &
     &       WLOAD(1:NMB_OF_CAND),IDWLOAD(1:NMB_OF_CAND) )
        do i=1,nslaves_inode
           DEST(i)= CAND(IDWLOAD(i))
        end do
        IF(BDC_MD)THEN
           do i=nslaves_inode+1,NMB_OF_CAND
              DEST(i)= CAND(IDWLOAD(i))
           end do
        ENDIF
      end if
      return
      end subroutine DAGMG_MUMPS_384
      SUBROUTINE DAGMG_MUMPS_425(K69)
      IMPLICIT NONE
      INTEGER K69
      IF (K69 .LE. 4) THEN
         ALPHA = 0.0d0
         BETA = 0.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 5) THEN
         ALPHA = 0.5d0
         BETA = 50000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 6) THEN
         ALPHA = 0.5d0
         BETA = 100000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 7) THEN
         ALPHA = 0.5d0
         BETA = 150000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 8) THEN
         ALPHA = 1.0d0
         BETA = 50000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 9) THEN
         ALPHA = 1.0d0
         BETA = 100000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 10) THEN
         ALPHA = 1.0d0
         BETA = 150000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 11) THEN
         ALPHA = 1.5d0
         BETA = 50000.0d0
         RETURN
      ENDIF
      IF (K69 .EQ. 12) THEN
         ALPHA = 1.5d0
         BETA = 100000.0d0
         RETURN
      ENDIF
      ALPHA = 1.5d0
      BETA = 150000.0d0
      RETURN
      END SUBROUTINE DAGMG_MUMPS_425
      SUBROUTINE DAGMG_MUMPS_426(MEM_DISTRIB,MSG_SIZE,ARRAY_ADM,LEN)
      IMPLICIT NONE
      INTEGER i,J,LEN,COUNTMORE,COUNTLOCLESS
      INTEGER, DIMENSION(0:NPROCS-1) :: MEM_DISTRIB
      DOUBLE PRECISION MSG_SIZE,FORBIGMSG
      INTEGER ARRAY_ADM(LEN)
      DOUBLE PRECISION MY_LOAD
      FORBIGMSG = 1.0d0
      IF (K69 .lt.2) THEN
         RETURN
      ENDIF
      IF(BDC_M2_FLOPS)THEN
         MY_LOAD=LOAD_FLOPS(MYID)+NIV2(MYID+1)
      ELSE
         MY_LOAD=LOAD_FLOPS(MYID)
      ENDIF
      IF((MSG_SIZE * dble(K35) ) .gt. 3200000.0d0) THEN
         FORBIGMSG = 2.0d0
      ENDIF
      IF (K69 .le. 4) THEN
         DO i = 1,LEN
            IF ((MEM_DISTRIB(ARRAY_ADM(i)) .EQ. 1) .AND.                &
     &      WLOAD(i) .LT. MY_LOAD ) THEN
               WLOAD(i) = WLOAD(i)/MY_LOAD
            ELSE
              IF ( MEM_DISTRIB(ARRAY_ADM(i)) .NE. 1 ) THEN
                WLOAD(i) = WLOAD(i) *                                   &
     &              dble(MEM_DISTRIB(ARRAY_ADM(i)))                     &
     &              * FORBIGMSG                                         &
     &              + dble(2)
              ENDIF
            ENDIF
         ENDDO
         RETURN
      ENDIF
      DO i = 1,LEN
         IF ((MEM_DISTRIB(ARRAY_ADM(i)) .EQ. 1) .AND.                   &
     &        WLOAD(i) .LT. MY_LOAD ) THEN
            WLOAD(i) = WLOAD(i) /  MY_LOAD
         ELSE
            IF(MEM_DISTRIB(ARRAY_ADM(i)) .NE. 1) THEN
               WLOAD(i) = (WLOAD(i) +                                   &
     &              ALPHA * MSG_SIZE * dble(K35)  +                     &
     &              BETA) * FORBIGMSG
            ENDIF
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_426
      SUBROUTINE DAGMG_MUMPS_461(MYID, SLAVEF, COMM,                         &
     &     TAB_POS, NASS, KEEP,KEEP8, LIST_SLAVES, NSLAVES,INODE)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: MYID, SLAVEF, COMM, NASS, NSLAVES
      INTEGER, INTENT (IN) :: TAB_POS(SLAVEF+2)
      INTEGER, INTENT (IN) :: LIST_SLAVES( NSLAVES )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER NCB, NFRONT, NBROWS_SLAVE
      INTEGER i, IERR,WHAT,INODE
      DOUBLE PRECISION MEM_INCREMENT ( NSLAVES )
      DOUBLE PRECISION FLOPS_INCREMENT( NSLAVES )
      DOUBLE PRECISION CB_BAND( NSLAVES )
      IF((KEEP(81).NE.2).AND.(KEEP(81).NE.3))THEN
         WHAT=1
      ELSE
         WHAT=19
      ENDIF
      FUTURE_NIV2(MYID+1) = FUTURE_NIV2(MYID+1) - 1
      IF ( FUTURE_NIV2(MYID+1) < 0 ) THEN
        WRITE(*,*) "Internal error in DAGMG_MUMPS_461"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF ( FUTURE_NIV2(MYID + 1) == 0 ) THEN
  112   CONTINUE
        CALL DAGMG_MUMPS_502(COMM,MYID,SLAVEF,                               &
     &       dble(MAX_SURF_MASTER),IERR)
        IF (IERR == -1 ) THEN
          CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
          GOTO 112
        ELSE IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) "Internal Error in DAGMG_MUMPS_461",                    &
     &    IERR
          CALL AGMG_MUMPS_ABORT()
        ENDIF
      TAB_MAXS(MYID) = TAB_MAXS(MYID) + int(MAX_SURF_MASTER,8)
      ENDIF
      IF ( NSLAVES /= TAB_POS(SLAVEF + 2) ) THEN
        write(*,*) "Error 1 in DAGMG_MUMPS_461",                             &
     &             NSLAVES, TAB_POS(SLAVEF+2)
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      NCB = TAB_POS(NSLAVES+1) - 1
      NFRONT = NCB + NASS
      DO i = 1, NSLAVES
         NBROWS_SLAVE = TAB_POS(i+1) - TAB_POS(i)
         IF ( KEEP(50) == 0 ) THEN
            FLOPS_INCREMENT( i ) = (dble(NBROWS_SLAVE)*dble( NASS ))+   &
     &           dble(NBROWS_SLAVE) * dble(NASS) *                      &
     &           dble(2*NFRONT-NASS-1)
         ELSE
            FLOPS_INCREMENT( i ) = dble(NBROWS_SLAVE) * dble(NASS ) *   &
     &           dble( 2 * ( NASS + TAB_POS(i+1) - 1 )                  &
     &           - NBROWS_SLAVE - NASS + 1 )
         ENDIF
         IF ( BDC_MEM ) THEN
            IF ( KEEP(50) == 0 ) THEN
               MEM_INCREMENT( i ) = dble(NBROWS_SLAVE) *                &
     &              dble(NFRONT)
            ELSE
               MEM_INCREMENT( i ) = dble(NBROWS_SLAVE) *                &
     &              dble( NASS + TAB_POS(i+1) - 1 )
            END IF
         ENDIF
         IF((KEEP(81).NE.2).AND.(KEEP(81).NE.3))THEN
            CB_BAND(i)=dble(-999999)
         ELSE
            IF ( KEEP(50) == 0 ) THEN
               CB_BAND( i ) = dble(NBROWS_SLAVE) *                      &
     &              dble(NFRONT-NASS)
            ELSE
               CB_BAND( i ) = dble(NBROWS_SLAVE) *                      &
     &              dble(TAB_POS(i+1)-1)
            END IF
         ENDIF
      END DO
      IF((KEEP(81).EQ.2).OR.(KEEP(81).EQ.3))THEN
         CB_COST_ID(POS_ID)=INODE
         CB_COST_ID(POS_ID+1)=NSLAVES
         CB_COST_ID(POS_ID+2)=POS_MEM
         POS_ID=POS_ID+3
         DO i=1,NSLAVES
            CB_COST_MEM(POS_MEM)=int(LIST_SLAVES(i),8)
            POS_MEM=POS_MEM+1
            CB_COST_MEM(POS_MEM)=int(CB_BAND(i),8)
            POS_MEM=POS_MEM+1
         ENDDO
      ENDIF
  111 CONTINUE
      CALL DAGMG_MUMPS_524(BDC_MEM, COMM, MYID, SLAVEF,                      &
     &     FUTURE_NIV2,                                                 &
     &     NSLAVES, LIST_SLAVES,INODE,                                  &
     &     MEM_INCREMENT,                                               &
     &     FLOPS_INCREMENT,CB_BAND, WHAT,IERR)
        IF ( IERR == -1 ) THEN
          CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
          GOTO 111
        ELSE IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) "Internal Error in DAGMG_MUMPS_461",                    &
     &    IERR
          CALL AGMG_MUMPS_ABORT()
        ENDIF
      IF (FUTURE_NIV2(MYID+1) .NE. 0) THEN
        DO i = 1, NSLAVES
          LOAD_FLOPS(LIST_SLAVES(i)) = LOAD_FLOPS(LIST_SLAVES(i))       &
     &       +  FLOPS_INCREMENT(i)
          IF ( BDC_MEM ) THEN
            DM_MEM(LIST_SLAVES(i)) = DM_MEM(LIST_SLAVES(i))             &
     &       +  MEM_INCREMENT(i)
          END IF
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_461
      SUBROUTINE DAGMG_MUMPS_500(                                            &
     &     POOL, LPOOL,                                                 &
     &     PROCNODE, KEEP,KEEP8, SLAVEF, COMM, MYID, STEP, N,           &
     &     ND, FILS )
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER LPOOL, SLAVEF, COMM, MYID
      INTEGER N, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER POOL( LPOOL ), PROCNODE( KEEP(28) ), STEP( N )
      INTEGER ND( KEEP(28) ), FILS( N )
      INTEGER i, INODE, NELIM, NFR, LEVEL, IERR, WHAT
      DOUBLE PRECISION COST
      INTEGER NBINSUBTREE,NBTOP,INSUBTREE
      LOGICAL AGMG_MUMPS_167
      INTEGER AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_167, AGMG_MUMPS_330
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      INSUBTREE   = POOL(LPOOL - 2)
      IF(BDC_MD)THEN
         RETURN
      ENDIF
      IF((KEEP(76).EQ.0).OR.(KEEP(76).EQ.2))THEN
         IF(NBTOP.NE.0)THEN
            DO i = LPOOL-NBTOP-2, min(LPOOL-3,LPOOL-NBTOP-2+3)
               INODE = POOL( i )
               IF (INODE .LE. N .AND. INODE .GE. 1 ) THEN
                  GOTO 20
               END IF
            END DO
            COST=dble(0)
            GOTO 30
         ELSE
            DO i = NBINSUBTREE, max(1,NBINSUBTREE-3), -1
               INODE = POOL( i )
               IF (INODE .LE. N .AND. INODE .GE. 1 ) THEN
                  GOTO 20
               END IF
            END DO
            COST=dble(0)
            GOTO 30
         ENDIF
      ELSE
         IF(KEEP(76).EQ.1)THEN
            IF(INSUBTREE.EQ.1)THEN
               DO i = NBINSUBTREE, max(1,NBINSUBTREE-3), -1
                  INODE = POOL( i )
                  IF (INODE .LE. N .AND. INODE .GE. 1 ) THEN
                     GOTO 20
                  END IF
               END DO
               COST=dble(0)
               GOTO 30
            ELSE
               DO i = LPOOL-NBTOP-2, min(LPOOL-3,LPOOL-NBTOP-2+3)
                  INODE = POOL( i )
                  IF (INODE .LE. N .AND. INODE .GE. 1 ) THEN
                     GOTO 20
                  END IF
               END DO
               COST=dble(0)
               GOTO 30
            ENDIF
         ELSE
            WRITE(*,*)                                                  &
     &      'Internal error: Unknown pool management strategy'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
   20 CONTINUE
        i = INODE
        NELIM = 0
   10   CONTINUE
        IF ( i > 0 ) THEN
          NELIM = NELIM + 1
          i = FILS(i)
          GOTO 10
        ENDIF
        NFR = ND( STEP(INODE) )
        LEVEL = AGMG_MUMPS_330( STEP(INODE), PROCNODE, SLAVEF )
        IF (LEVEL .EQ. 1) THEN
          COST = dble( NFR ) * dble( NFR )
        ELSE
          IF ( KEEP(50) == 0 ) THEN
            COST = dble( NFR ) * dble( NELIM )
          ELSE
            COST = dble( NELIM ) * dble( NELIM )
          ENDIF
        ENDIF
   30 CONTINUE
      IF ( abs(POOL_LAST_COST_SENT-COST).GT.DM_THRES_MEM ) THEN
        WHAT = 2
  111   CONTINUE
        CALL DAGMG_MUMPS_460( WHAT,                                          &
     &         COMM, SLAVEF,                                            &
     &               FUTURE_NIV2,                                       &
     &         COST, dble(0),MYID, IERR  )
        POOL_LAST_COST_SENT = COST
        POOL_MEM(MYID)=COST
        IF ( IERR == -1 )THEN
          CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
          GOTO 111
        ELSE IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) "Internal Error in DAGMG_MUMPS_500",                    &
     &    IERR
          CALL AGMG_MUMPS_ABORT()
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_500
      SUBROUTINE DAGMG_MUMPS_501(                                            &
     &     OK,INODE,POOL,LPOOL,MYID,SLAVEF,COMM,KEEP,KEEP8)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER LPOOL,MYID,SLAVEF,COMM,INODE
      INTEGER POOL(LPOOL),KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER WHAT,IERR
      LOGICAL OK
      DOUBLE PRECISION ZERO,COST
      LOGICAL FLAG
      PARAMETER(ZERO = 0.0d0)
      EXTERNAL AGMG_MUMPS_283,AGMG_MUMPS_170
      LOGICAL AGMG_MUMPS_283,AGMG_MUMPS_170
      IF((INODE.LE.0).OR.(INODE.GT.N_LOAD)) THEN
         RETURN
      ENDIF
      IF(.NOT.AGMG_MUMPS_170(STEP_LOAD(INODE),                               &
     &     PROCNODE_LOAD,NPROCS))THEN
         RETURN
      ENDIF
      IF(AGMG_MUMPS_283(STEP_LOAD(INODE),PROCNODE_LOAD,NPROCS))THEN
         IF(NE_LOAD(STEP_LOAD(INODE)).EQ.0)THEN
            RETURN
         ENDIF
      ENDIF
      FLAG=.FALSE.
      IF(INDICE_SBTR.LE.NB_SUBTREES)THEN
         IF(INODE.EQ.MY_FIRST_LEAF(INDICE_SBTR))THEN
            FLAG=.TRUE.
         ENDIF
      ENDIF
      IF(FLAG)THEN
         SBTR_PEAK_ARRAY(INDICE_SBTR_ARRAY)=MEM_SUBTREE(INDICE_SBTR)
         SBTR_CUR_ARRAY(INDICE_SBTR_ARRAY)=SBTR_CUR(MYID)
         INDICE_SBTR_ARRAY=INDICE_SBTR_ARRAY+1
         WHAT = 3
         IF(dble(MEM_SUBTREE(INDICE_SBTR)).GE.DM_THRES_MEM)THEN
  111       CONTINUE
            CALL DAGMG_MUMPS_460(                                            &
     &           WHAT, COMM, SLAVEF,                                    &
     &           FUTURE_NIV2,                                           &
     &           dble(MEM_SUBTREE(INDICE_SBTR)), dble(0),MYID, IERR  )
            IF ( IERR == -1 )THEN
               CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
               GOTO 111
            ELSE IF ( IERR .NE. 0 ) THEN
               WRITE(*,*)                                               &
     &         "Internal Error 1 in DAGMG_MUMPS_501",                        &
     &         IERR
               CALL AGMG_MUMPS_ABORT()
            ENDIF
         ENDIF
         SBTR_MEM(MYID)=SBTR_MEM(MYID)+                                 &
     &        dble(MEM_SUBTREE(INDICE_SBTR))
         INDICE_SBTR=INDICE_SBTR+1
         IF(INSIDE_SUBTREE.EQ.0)THEN
            INSIDE_SUBTREE=1
         ENDIF
      ELSE
         IF(INODE.EQ.MY_ROOT_SBTR(INDICE_SBTR-1))THEN
            WHAT = 3
            COST=-SBTR_PEAK_ARRAY(INDICE_SBTR_ARRAY-1)
            IF(abs(COST).GE.DM_THRES_MEM)THEN
  112          CONTINUE
               CALL DAGMG_MUMPS_460(                                         &
     &              WHAT, COMM, SLAVEF,                                 &
     &              FUTURE_NIV2,                                        &
     &              COST, dble(0) ,MYID,IERR  )
               IF ( IERR == -1 )THEN
                  CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
                  GOTO 112
               ELSE IF ( IERR .NE. 0 ) THEN
                  WRITE(*,*)                                            &
     &        "Internal Error 3 in DAGMG_MUMPS_501",                         &
     &        IERR
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
            ENDIF
            INDICE_SBTR_ARRAY=INDICE_SBTR_ARRAY-1
            SBTR_MEM(MYID)=SBTR_MEM(MYID)-                              &
     &           SBTR_PEAK_ARRAY(INDICE_SBTR_ARRAY)
            SBTR_CUR(MYID)=SBTR_CUR_ARRAY(INDICE_SBTR_ARRAY)
            IF(INDICE_SBTR_ARRAY.EQ.1)THEN
               SBTR_CUR(MYID)=dble(0)
               INSIDE_SUBTREE=0
            ENDIF
         ENDIF
         ENDIF
  666 CONTINUE
      END SUBROUTINE DAGMG_MUMPS_501
      SUBROUTINE DAGMG_MUMPS_504                                             &
     &      (SLAVEF,KEEP,KEEP8,PROCS,MEM_DISTRIB,NCB,NFRONT,            &
     &       NSLAVES_NODE,TAB_POS,                                      &
     &       SLAVES_LIST,SIZE_SLAVES_LIST,MYID)
      IMPLICIT NONE
      INTEGER, intent(in) :: KEEP(500),SIZE_SLAVES_LIST
      INTEGER*8 KEEP8(150)
      INTEGER, intent(in) :: SLAVEF, NFRONT, NCB,MYID
      INTEGER, intent(in) :: PROCS(SLAVEF+1)
      INTEGER, intent(in) :: MEM_DISTRIB(0:SLAVEF-1)
      INTEGER, intent(out):: SLAVES_LIST(SIZE_SLAVES_LIST)
      INTEGER, intent(out):: TAB_POS(SLAVEF+2)
      INTEGER, intent(out):: NSLAVES_NODE
      INTEGER NUMBER_OF_PROCS,K47, K48, K50
      INTEGER(8) :: K821
      DOUBLE PRECISION DK821
      INTEGER J, NSLAVES, NSLAVES_REAL, ISLAVE
      INTEGER KMIN, KMAX, BLSIZE, NPIV,                                 &
     &        KMINSURF, NSLAVES_max
      DOUBLE PRECISION WK_MASTER, WK_SLAVE
      INTEGER OTHERS,CHOSEN,SMALL_SET,ACC
      DOUBLE PRECISION SOMME,TMP_SUM
      INTEGER AFFECTED
      INTEGER ADDITIONNAL_ROWS,BLOCK_SIZE,i,X,REF,POS
      INTEGER(8)::TOTAL_MEM
      LOGICAL FORCE_CAND
      DOUBLE PRECISION TEMP(SLAVEF),SUB(SLAVEF),PEAK,MAX_TEMP
      INTEGER TEMP_ID(SLAVEF),NB_ROWS(SLAVEF),SUB_ID(SLAVEF),M2(SLAVEF)
      EXTERNAL AGMG_MPF_WTIME
      DOUBLE PRECISION AGMG_MPF_WTIME
      IF (KEEP8(21) .GT. 0_8) THEN
      write(*,*)MYID,                                                   &
     & ": Internal Error 1 in DAGMG_MUMPS_504"
      CALL AGMG_MUMPS_ABORT()
      ENDIF
      K821=abs(KEEP8(21))
      DK821=dble(K821)
      K50=KEEP(50)
      K48=KEEP(48)
      K47=KEEP(47)
      IF ( KEEP(24) == 0 .OR. KEEP(24) == 1 ) THEN
        FORCE_CAND = .FALSE.
      ELSE
        FORCE_CAND = (mod(KEEP(24),2).eq.0)
      END IF
      IF(K48.NE.4)THEN
         WRITE(*,*)'DMUMPS_COMPUTE_PARTI_ACTV_MEM_K821                  &
     &      should be called with KEEP(48) different from 4'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
         KMIN=1
         KMAX=int(K821/int(NFRONT,8))
         IF(FORCE_CAND)THEN
            DO i=1,PROCS(SLAVEF+1)
               WLOAD(i)=DM_MEM(PROCS(i))
               IDWLOAD(i)=PROCS(i)
            ENDDO
            NUMBER_OF_PROCS=PROCS(SLAVEF+1)
            OTHERS=NUMBER_OF_PROCS
         ELSE
            NUMBER_OF_PROCS=SLAVEF
            WLOAD(1:SLAVEF) = DM_MEM(0:NUMBER_OF_PROCS-1)
            DO i=1,NUMBER_OF_PROCS
               IDWLOAD(i) = i - 1
            ENDDO
            OTHERS=NUMBER_OF_PROCS-1
         ENDIF
         NB_ROWS=0
         CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, WLOAD, IDWLOAD)
         TOTAL_MEM=int(NCB,8)*int(NFRONT,8)
         SOMME=dble(0)
         J=1
         PEAK=dble(0)
         DO i=1,NUMBER_OF_PROCS
            IF((IDWLOAD(i).NE.MYID))THEN
               PEAK=max(PEAK,WLOAD(i))
               TEMP_ID(J)=IDWLOAD(i)
               TEMP(J)=WLOAD(i)
                IF(BDC_SBTR)THEN
                   TEMP(J)=TEMP(J)+SBTR_MEM(IDWLOAD(i))-                &
     &                  SBTR_CUR(IDWLOAD(i))
                ENDIF
                IF(BDC_POOL)THEN
                   TEMP(J)=TEMP(J)+POOL_MEM(TEMP_ID(J))
                ENDIF
                IF(BDC_M2_MEM)THEN
                   TEMP(J)=TEMP(J)+NIV2(TEMP_ID(J)+1)
                ENDIF
                J=J+1
            ENDIF
         ENDDO
         NUMBER_OF_PROCS=J-1
         CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, TEMP, TEMP_ID)
         IF(K50.EQ.0)THEN
           PEAK=max(PEAK,                                               &
     &       DM_MEM(MYID)+dble(NFRONT)*dble(NFRONT-NCB))
         ELSE
           PEAK=max(PEAK,                                               &
     &       DM_MEM(MYID)+dble(NFRONT-NCB)*dble(NFRONT-NCB))
         ENDIF
         PEAK=max(PEAK,TEMP(OTHERS))
         SOMME=dble(0)
         DO i=1,NUMBER_OF_PROCS
           SOMME=SOMME+TEMP(OTHERS)-TEMP(i)
         ENDDO
         IF(SOMME.LE.dble(TOTAL_MEM)) THEN
            GOTO 096
         ENDIF
   96    CONTINUE
         SOMME=dble(0)
         DO i=1,OTHERS
            SOMME=SOMME+TEMP(OTHERS)-TEMP(i)
         ENDDO
         IF(dble(TOTAL_MEM).GE.SOMME) THEN
  887       CONTINUE
            AFFECTED=0
            CHOSEN=0
            ACC=0
            DO i=1,OTHERS
               IF(K50.EQ.0)THEN
                  IF((TEMP(OTHERS)-TEMP(i)).GT.DK821)THEN
                     TMP_SUM=DK821
                  ELSE
                     TMP_SUM=TEMP(OTHERS)-TEMP(i)
                  ENDIF
                  X=int(TMP_SUM/dble(NFRONT))
                  IF((ACC+X).GT.NCB) X=NCB-ACC
               ENDIF
               IF(K50.NE.0)THEN
                  IF((TEMP(OTHERS)-TEMP(i)).GT.DK821)THEN
                     TMP_SUM=DK821
                  ELSE
                     TMP_SUM=TEMP(OTHERS)-TEMP(i)
                  ENDIF
                  X=int((-dble(NFRONT-NCB+ACC)                          &
     &                 +sqrt(((dble(NFRONT-NCB+ACC)*                    &
     &                 dble(NFRONT-NCB+ACC))+dble(4)*                   &
     &                 (TMP_SUM))))/                                    &
     &                 dble(2))
                  IF((ACC+X).GT.NCB) X=NCB-ACC
                  IF(X.LE.0) THEN
                     WRITE(*,*)"Internal Error 2 in                     &
     &                    DAGMG_MUMPS_504"
                     CALL AGMG_MUMPS_ABORT()
                  ENDIF
               ENDIF
               NB_ROWS(i)=X
               CHOSEN=CHOSEN+1
               ACC=ACC+X
               IF(NCB-ACC.LT.KMIN) GOTO 111
               IF(NCB.EQ.ACC) GOTO 111
               ENDDO
  111          CONTINUE
               IF((ACC.GT.NCB))THEN
                  X=0
                  DO i=1,OTHERS
                     X=X+NB_ROWS(i)
                  ENDDO
                  WRITE(*,*)'NCB=',NCB,',SOMME=',X
                  WRITE(*,*)MYID,                                       &
     &               ": Internal Error 3 in DAGMG_MUMPS_504"
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               IF((NCB.NE.ACC))THEN
                  IF(K50.NE.0)THEN
                     IF(CHOSEN.NE.0)THEN
                        ADDITIONNAL_ROWS=NCB-ACC
                        NB_ROWS(CHOSEN)=NB_ROWS(CHOSEN)+ADDITIONNAL_ROWS
                     ELSE
                        TMP_SUM=dble(TOTAL_MEM)/dble(NUMBER_OF_PROCS)
                        CHOSEN=0
                        ACC=0
                        DO i=1,OTHERS
                           X=int((-dble(NFRONT-NCB+ACC)                 &
     &                          +sqrt(((dble(NFRONT-NCB+ACC)*           &
     &                          dble(NFRONT-NCB+ACC))+dble(4)*          &
     &                          (TMP_SUM))))/                           &
     &                          dble(2))
                           IF((ACC+X).GT.NCB) X=NCB-ACC
                           NB_ROWS(i)=X
                           CHOSEN=CHOSEN+1
                           ACC=ACC+X
                           IF(NCB-ACC.LT.KMIN) GOTO 002
                           IF(NCB.EQ.ACC) GOTO 002
                        ENDDO
    2                   CONTINUE
                        IF(ACC.LT.NCB)THEN
                           NB_ROWS(CHOSEN)=NB_ROWS(CHOSEN)+(NCB-ACC)
                        ENDIF
                     ENDIF
                     GOTO 333
                  ENDIF
                  ADDITIONNAL_ROWS=NCB-ACC
                  DO i=CHOSEN,1,-1
                     IF(int(dble(ADDITIONNAL_ROWS)/                     &
     &                    dble(i)).NE.0)THEN
                        GOTO 222
                     ENDIF
                  ENDDO
  222             CONTINUE
                  X=int(dble(ADDITIONNAL_ROWS)/dble(i))
                  DO J=1,i
                     NB_ROWS(J)=NB_ROWS(J)+X
                     ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                  ENDDO
                  IF(ADDITIONNAL_ROWS.NE.0) THEN
                     NB_ROWS(1)=NB_ROWS(1)+ADDITIONNAL_ROWS
                  ENDIF
               ENDIF
  333          CONTINUE
               IF(NB_ROWS(CHOSEN).EQ.0) CHOSEN=CHOSEN-1
               GOTO 889
            ELSE
               DO i=OTHERS,1,-1
                  SOMME=dble(0)
                  DO J=1,i
                     SOMME=SOMME+TEMP(J)
                  ENDDO
                  SOMME=(dble(i)*TEMP(i))-SOMME
                  IF(dble(TOTAL_MEM).GE.SOMME) GOTO 444
               ENDDO
  444          CONTINUE
               REF=i
               DO J=1,i
                  IF(TEMP(J).EQ.TEMP(i)) THEN
                     SMALL_SET=J
                     GOTO 123
                  ENDIF
               ENDDO
  123          CONTINUE
               IF(i.EQ.1)THEN
                  NB_ROWS(i)=NCB
                  CHOSEN=1
                  GOTO 666
               ENDIF
  323          CONTINUE
               AFFECTED=0
               CHOSEN=0
               ACC=0
               DO i=1,SMALL_SET
                  IF(K50.EQ.0)THEN
                     IF((TEMP(SMALL_SET)-TEMP(i)).GT.DK821)THEN
                        TMP_SUM=DK821
                     ELSE
                        TMP_SUM=TEMP(SMALL_SET)-TEMP(i)
                     ENDIF
                     X=int(TMP_SUM/dble(NFRONT))
                     IF((ACC+X).GT.NCB) X=NCB-ACC
                  ENDIF
                  IF(K50.NE.0)THEN
                     IF((TEMP(SMALL_SET)-TEMP(i)).GT.DK821)THEN
                        TMP_SUM=DK821
                     ELSE
                        TMP_SUM=TEMP(SMALL_SET)-TEMP(i)
                     ENDIF
                      X=int((-dble(NFRONT-NCB+ACC)                      &
     &                  +sqrt(((dble(NFRONT-NCB+ACC)*                   &
     &                  dble(NFRONT-NCB+ACC))+dble(4)*                  &
     &                  (TMP_SUM))))/                                   &
     &                  dble(2))
                     IF(X.LT.0)THEN
                        WRITE(*,*)MYID,                                 &
     &             ': Internal error 4 in DMUMPS_504'
                        CALL AGMG_MUMPS_ABORT()
                     ENDIF
                     IF((ACC+X).GT.NCB) X=NCB-ACC
                  ENDIF
                  NB_ROWS(i)=X
                  ACC=ACC+X
                  CHOSEN=CHOSEN+1
                  IF(NCB-ACC.LT.KMIN) GOTO 888
                  IF(NCB.EQ.ACC) GOTO 888
                  IF(ACC.GT.NCB) THEN
                    WRITE(*,*)MYID,                                     &
     &            ': Internal error 5 in DMUMPS_504'
                    CALL AGMG_MUMPS_ABORT()
                  ENDIF
               ENDDO
  888          CONTINUE
               SOMME=dble(0)
               X=NFRONT-NCB
               IF((ACC.GT.NCB))THEN
                  WRITE(*,*)MYID,                                       &
     &           ':Internal error 6 in DMUMPS_504'
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               IF((ACC.LT.NCB))THEN
                  IF(K50.NE.0)THEN
                     IF(SMALL_SET.LT.OTHERS)THEN
                       SMALL_SET=REF+1
                       REF=SMALL_SET
                       GOTO 323
                     ELSE
                       NB_ROWS(CHOSEN)=NB_ROWS(CHOSEN)+NCB-ACC
                       GOTO 666
                     ENDIF
                 ENDIF
                 ADDITIONNAL_ROWS=NCB-ACC
                 i=CHOSEN+1
                 DO WHILE ((ADDITIONNAL_ROWS.NE.0)                      &
     &                .AND.(i.LE.NUMBER_OF_PROCS))
                    J=1
                    X=int(ADDITIONNAL_ROWS/(i-1))
                    IF((X.EQ.0).AND.(ADDITIONNAL_ROWS.NE.0))THEN
                       DO WHILE ((J.LT.i).AND.(ADDITIONNAL_ROWS.GT.0))
                         NB_ROWS(J)=NB_ROWS(J)+1
                         ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-1
                         J=J+1
                       ENDDO
                       IF(ADDITIONNAL_ROWS.NE.0)THEN
                          WRITE(*,*)MYID,                               &
     &             ':Internal error 7 in DMUMPS_504'
                         CALL AGMG_MUMPS_ABORT()
                      ENDIF
                      GOTO 047
                    ENDIF
                    IF((TEMP(1)+dble((NB_ROWS(1)+X)*NFRONT)).LE.        &
     &                   TEMP(i))THEN
                       DO WHILE ((ADDITIONNAL_ROWS.NE.0)                &
     &                      .AND.(J.LT.i))
                          AFFECTED=X
                          IF((AFFECTED+NB_ROWS(J)).GT.                  &
     &                         KMAX)THEN
                             AFFECTED=KMAX-NB_ROWS(J)
                          ENDIF
                          NB_ROWS(J)=NB_ROWS(J)+AFFECTED
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-            &
     &                         AFFECTED
                          J=J+1
                       ENDDO
                    ELSE
                       DO WHILE ((ADDITIONNAL_ROWS.NE.0)                &
     &                      .AND.(J.LE.i))
                          AFFECTED=int((TEMP(i)-(TEMP(J)+               &
     &                         (dble(NB_ROWS(J))*dble(NFRONT))))        &
     &                         /dble(NFRONT))
                          IF((AFFECTED+NB_ROWS(J)).GT.KMAX)THEN
                             AFFECTED=KMAX-NB_ROWS(J)
                          ENDIF
                          IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                             AFFECTED=ADDITIONNAL_ROWS
                          ENDIF
                          NB_ROWS(J)=NB_ROWS(J)+AFFECTED
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-AFFECTED
                          J=J+1
                       ENDDO
                    ENDIF
                    i=i+1
                 ENDDO
   47            CONTINUE
                 IF((ADDITIONNAL_ROWS.EQ.0).AND.                        &
     &                (i.LT.NUMBER_OF_PROCS))THEN
                    CHOSEN=i-1
                 ELSE
                    CHOSEN=i-2
                 ENDIF
                 IF((CHOSEN.EQ.NUMBER_OF_PROCS-1).AND.                  &
     &                 (ADDITIONNAL_ROWS.NE.0))THEN
                    DO i=1,CHOSEN
                       NB_ROWS(i)=NB_ROWS(i)+1
                       ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-1
                       IF(ADDITIONNAL_ROWS.EQ.0) GOTO 048
                    ENDDO
   48               CONTINUE
                 ENDIF
                 IF((CHOSEN.EQ.NUMBER_OF_PROCS-1).AND.                  &
     &                (ADDITIONNAL_ROWS.NE.0))THEN
                    i=CHOSEN+1
                    DO WHILE ((ADDITIONNAL_ROWS.NE.0)                   &
     &                   .AND.(i.LE.NUMBER_OF_PROCS))
                       J=1
                       DO WHILE ((ADDITIONNAL_ROWS.NE.0)                &
     &                      .AND.(J.LE.i))
                          AFFECTED=int((TEMP(i)-(TEMP(J)+               &
     &                         (dble(NB_ROWS(J))*                       &
     &                         dble(NFRONT))))/dble(NFRONT))
                          IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                             AFFECTED=ADDITIONNAL_ROWS
                          ENDIF
                          NB_ROWS(J)=NB_ROWS(J)+AFFECTED
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-AFFECTED
                          J=J+1
                       ENDDO
                       i=i+1
                    ENDDO
                    CHOSEN=i-2
                 ENDIF
   49            CONTINUE
              ENDIF
  666         CONTINUE
              SOMME=dble(0)
              X=0
              POS=0
              DO i=1,CHOSEN
                 IF(K50.NE.0) THEN
                    IF((TEMP(i)+dble(NB_ROWS(i))                        &
     &                   *dble(X+NB_ROWS(i)+NFRONT-NCB))                &
     &                   .GT.PEAK)THEN
                       SMALL_SET=SMALL_SET+1
                    ENDIF
                 ENDIF
                 IF(K50.EQ.0) THEN
                    IF((TEMP(i)+dble(NB_ROWS(i))*dble(NFRONT))          &
     &                   .GT.PEAK)THEN
                       SMALL_SET=SMALL_SET+1
                    ENDIF
                 ENDIF
                 X=X+NB_ROWS(i)
                 SOMME=SOMME+ dble(NB_ROWS(i))
              ENDDO
           ENDIF
  889      CONTINUE
           J=CHOSEN
           X=0
           DO i=J,1,-1
             IF(NB_ROWS(i).EQ.0)THEN
                IF(X.EQ.1)THEN
                  WRITE(*,*)MYID,                                       &
     &         ':Internal error 12 in DMUMPS_504'
                  CALL AGMG_MUMPS_ABORT()
                ENDIF
                CHOSEN=CHOSEN-1
             ELSE
                  IF(NB_ROWS(i).GT.0)THEN
                    X=1
                  ELSE
                    WRITE(*,*)                                          &
     &            'Internal error 13 in DMUMPS_504'
                    CALL AGMG_MUMPS_ABORT()
                  ENDIF
             ENDIF
          ENDDO
           NSLAVES_NODE=CHOSEN
           TAB_POS(NSLAVES_NODE+1)= NCB+1
           TAB_POS(SLAVEF+2) = CHOSEN
           POS=1
           DO i=1,CHOSEN
              SLAVES_LIST(i)=TEMP_ID(i)
              TAB_POS(i)=POS
              POS=POS+NB_ROWS(i)
              IF(NB_ROWS(i).LE.0)THEN
                WRITE(*,*)                                              &
     &          'Internal error 14 in DMUMPS_504'
                 CALL AGMG_MUMPS_ABORT()
              ENDIF
           ENDDO
           DO i=CHOSEN+1,NUMBER_OF_PROCS
              SLAVES_LIST(i)=TEMP_ID(i)
           ENDDO
           IF(POS.NE.(NCB+1))THEN
              WRITE(*,*)                                                &
     &        'Internal error 15 in DMUMPS_504'
             CALL AGMG_MUMPS_ABORT()
           ENDIF
      END SUBROUTINE DAGMG_MUMPS_504
      SUBROUTINE DAGMG_MUMPS_518                                             &
     &      (NCBSON_MAX,SLAVEF,KEEP,KEEP8,                              &
     &       PROCS,MEM_DISTRIB,NCB,NFRONT,                              &
     &       NSLAVES_NODE,TAB_POS,                                      &
     &       SLAVES_LIST,SIZE_SLAVES_LIST,MYID,INODE,MP,LP)
      IMPLICIT NONE
      INTEGER, intent(in) :: KEEP(500),SIZE_SLAVES_LIST
      INTEGER*8 KEEP8(150)
      INTEGER, intent(in) :: SLAVEF, NFRONT, NCB,MYID
      INTEGER, intent(in) :: NCBSON_MAX
      INTEGER, intent(in) :: PROCS(SLAVEF+1)
      INTEGER, intent(in) :: MEM_DISTRIB(0:SLAVEF-1),INODE
      INTEGER, intent(in) :: MP,LP
      INTEGER, intent(out):: SLAVES_LIST(SIZE_SLAVES_LIST)
      INTEGER, intent(out):: TAB_POS(SLAVEF+2)
      INTEGER, intent(out):: NSLAVES_NODE
      INTEGER NUMBER_OF_PROCS,K47,K48, K50,K83,K69
      INTEGER(8) :: K821
      INTEGER J, NSLAVES, NSLAVES_REAL, ISLAVE
      INTEGER KMIN, KMAX, BLSIZE, NPIV,                                 &
     &        KMINSURF, NSLAVES_max
      DOUBLE PRECISION WK_MASTER, WK_SLAVE
      INTEGER OTHERS,CHOSEN,SMALL_SET,ACC
      DOUBLE PRECISION SOMME,TMP_SUM,DELTA,A,B,C,MASTER_WORK
      INTEGER AFFECTED
      INTEGER ADDITIONNAL_ROWS,BLOCK_SIZE,i,X,REF,POS,NELIM,NB_DIFF
      INTEGER*8 X8
      LOGICAL FORCE_CAND,SMP
      DOUBLE PRECISION BANDE_K821
      INTEGER NB_SAT,NB_ZERO
      DOUBLE PRECISION TEMP(SLAVEF),SUB(SLAVEF),PEAK,TOTAL_COST,        &
     &     MAX_MEM_ALLOW,MAX_FLOPS_ALLOW
      INTEGER TEMP_ID(SLAVEF),NB_ROWS(SLAVEF),M2(SLAVEF),               &
     &     NB_ROWS_SMP(SLAVEF)
      INTEGER NSLAVES_REF,NCB_FILS
      EXTERNAL AGMG_MPF_WTIME,AGMG_MUMPS_442
      INTEGER AGMG_MUMPS_442
      INTEGER POS_MIN_LOAD,SIZE_MY_SMP,WHAT,ADDITIONNAL_ROWS_SPECIAL
      LOGICAL HAVE_TYPE1_SON
      DOUBLE PRECISION MIN_LOAD,MAX_LOAD,TEMP_MAX_LOAD
      DOUBLE PRECISION AGMG_MPF_WTIME
      DOUBLE PRECISION BUF_SIZE,NELIM_MEM_SIZE
      DOUBLE PRECISION MEM_SIZE_STRONG(SLAVEF),MEM_SIZE_WEAK(SLAVEF)
      INTEGER AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_330
      K821=abs(KEEP8(21))
      TEMP_MAX_LOAD=dble(0)
      K50=KEEP(50)
      K48=KEEP(48)
      K47=KEEP(47)
      K83=KEEP(83)
      K69=0
      NCB_FILS=NCBSON_MAX
      IF(int(NCB_FILS,8)*int(min(NCB,NCB_FILS),8).GT.K821)THEN
         HAVE_TYPE1_SON=.TRUE.
      ELSE
         HAVE_TYPE1_SON=.FALSE.
      ENDIF
      SMP=(K69.NE.0)
      IF ( KEEP(24) == 0 .OR. KEEP(24) == 1 ) THEN
        FORCE_CAND = .FALSE.
      ELSE
        FORCE_CAND = (mod(KEEP(24),2).eq.0)
      END IF
      NELIM=NFRONT-NCB
         KMAX=int(K821/int(NCB,8))
         IF(FORCE_CAND)THEN
           DO i=1,PROCS(SLAVEF+1)
              WLOAD(i)=LOAD_FLOPS(PROCS(i))
              IDWLOAD(i)=PROCS(i)
              IF (WLOAD(i) < -0.5d0 ) THEN
                 IF((MP.GT.0).AND.(LP.GE.2))THEN
                    WRITE(MP,*)MYID,': Warning: negative load ',        &
     &                   WLOAD(i)
                 ENDIF
              ENDIF
              WLOAD(i)=max(WLOAD(i),0.0d0)
           ENDDO
           NUMBER_OF_PROCS=PROCS(SLAVEF+1)
            OTHERS=NUMBER_OF_PROCS
         ELSE
            NUMBER_OF_PROCS=SLAVEF
            WLOAD(1:SLAVEF) = LOAD_FLOPS(0:NUMBER_OF_PROCS-1)
            DO i=1,NUMBER_OF_PROCS
               IDWLOAD(i) = i - 1
               IF (WLOAD(i) < -0.5d0 ) THEN
                  IF((MP.GT.0).AND.(LP.GE.2))THEN
                     WRITE(MP,*)MYID,': Negative load ',                &
     &                    WLOAD(i)
                  ENDIF
               ENDIF
               WLOAD(i)=max(WLOAD(i),0.0d0)
            ENDDO
            OTHERS=NUMBER_OF_PROCS-1
         ENDIF
         KMAX=int(NCB/OTHERS)
         KMIN=AGMG_MUMPS_442(int(NCB,8)*int(KMAX,8),K50,KMAX,NCB)
         NB_ROWS=0
         CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, WLOAD, IDWLOAD)
         IF(K50.EQ.0)THEN
            TOTAL_COST=dble( NELIM ) * dble ( NCB ) +                   &
     &           dble(NCB) * dble(NELIM)*dble(2*NFRONT-NELIM-1)
         ELSE
            TOTAL_COST=dble(NELIM) * dble ( NCB ) *                     &
     &           dble(NFRONT+1)
         ENDIF
         CALL AGMG_MUMPS_511(NFRONT,NELIM,NELIM,K50,                         &
     &        2,MASTER_WORK)
         SOMME=dble(0)
         J=1
         IF(FORCE_CAND.AND.(NUMBER_OF_PROCS.GT.K83))THEN
            MASTER_WORK=dble(KEEP(88))*MASTER_WORK/dble(100)
         ENDIF
         IF(FORCE_CAND.AND.(NUMBER_OF_PROCS.LE.K83))THEN
            MASTER_WORK=dble(KEEP(87))*MASTER_WORK/dble(100)
         ENDIF
         IF(MASTER_WORK.LT.dble(1))THEN
            MASTER_WORK=dble(1)
         ENDIF
         NSLAVES_REF=int(TOTAL_COST/MASTER_WORK)+1
         IF(FORCE_CAND)THEN
            NSLAVES_REF=min(NSLAVES_REF,NUMBER_OF_PROCS)
         ELSE
            NSLAVES_REF=min(NSLAVES_REF,NUMBER_OF_PROCS-1)
         ENDIF
        DO i=1,NUMBER_OF_PROCS
           IF((IDWLOAD(i).NE.MYID))THEN
              TEMP_ID(J)=IDWLOAD(i)
              TEMP(J)=WLOAD(i)
              IF(BDC_M2_FLOPS)THEN
                 TEMP(J)=TEMP(J)+NIV2(TEMP_ID(J)+1)
              ENDIF
              J=J+1
           ENDIF
        ENDDO
        NUMBER_OF_PROCS=J-1
        CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, TEMP, TEMP_ID)
        SOMME=dble(0)
        TMP_SUM=dble(0)
        DO i=1,OTHERS
            SOMME=SOMME+TEMP(OTHERS)-TEMP(i)
            TMP_SUM=TMP_SUM+TEMP(i)
        ENDDO
         TMP_SUM=(TMP_SUM/dble(OTHERS))+                                &
     &        (TOTAL_COST/dble(OTHERS))
         SIZE_MY_SMP=OTHERS
         MIN_LOAD=TEMP(1)
         POS_MIN_LOAD=1
         IF(.NOT.SMP) MAX_LOAD=TEMP(OTHERS)
         IF(SMP)THEN
            J=1
            DO i=1,OTHERS
               IF(MEM_DISTRIB(TEMP_ID(i)).EQ.1)THEN
                  IF(TEMP(i).LE.TMP_SUM)THEN
                     WLOAD(J)=TEMP(i)
                     IDWLOAD(J)=TEMP_ID(i)
                     J=J+1
                  ELSE
                  ENDIF
               ENDIF
            ENDDO
            MAX_LOAD=WLOAD(J-1)
            SIZE_MY_SMP=J-1
            DO i=1,OTHERS
               IF((MEM_DISTRIB(TEMP_ID(i)).NE.1).OR.                    &
     &              ((MEM_DISTRIB(TEMP_ID(i)).EQ.1).AND.                &
     &              (TEMP(i).GE.TMP_SUM)))THEN
                  WLOAD(J)=TEMP(i)
                  IDWLOAD(J)=TEMP_ID(i)
                  J=J+1
               ENDIF
            ENDDO
            TEMP=WLOAD
            TEMP_ID=IDWLOAD
         ENDIF
        IF(BDC_MD)THEN
           BUF_SIZE=dble(K821)
           IF (KEEP(201).EQ.2) THEN
              A=dble(int((dble(KEEP(100))/dble(2))/dble(NELIM)))
              IF(K50.EQ.0)THEN
                 BUF_SIZE=min(BUF_SIZE,A*dble(NCB))
              ELSE
                 BUF_SIZE=min(BUF_SIZE,A*A)
              ENDIF
           ENDIF
           BUF_SIZE=dble(K821)
           DO i=1,NUMBER_OF_PROCS
              A=dble(MD_MEM(TEMP_ID(i)))/                               &
     &             dble(NELIM)
              A=A*dble(NFRONT)
              IF(K50.EQ.0)THEN
                 B=dble(int(dble(NCB)/dble(NUMBER_OF_PROCS))+1)*        &
     &                dble(NFRONT)
              ELSE
                 WHAT = 5
                 CALL AGMG_MUMPS_503(WHAT, KEEP,KEEP8, NCB,                  &
     &                NFRONT, min(NCB,OTHERS), J, X8)
                 B=dble(X8)+(dble(J)*dble(NELIM))
              ENDIF
              NELIM_MEM_SIZE=A+B
              MEM_SIZE_WEAK(i)=NELIM_MEM_SIZE
            IF((SBTR_WHICH_M.EQ.0).OR.(.NOT.BDC_SBTR))THEN
               IF(BDC_M2_MEM)THEN
                  MEM_SIZE_STRONG(i)=                                   &
     &                 dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-   &
     &                 LU_USAGE(TEMP_ID(i))-NIV2(TEMP_ID(i)+1)
               ELSE
                  MEM_SIZE_STRONG(i)=                                   &
     &                 dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-   &
     &                 LU_USAGE(TEMP_ID(i))
               ENDIF
            ELSE
               IF(BDC_SBTR)THEN
                  IF(BDC_M2_MEM)THEN
                     MEM_SIZE_STRONG(i)=                                &
     &                    dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-&
     &                    LU_USAGE(TEMP_ID(i))-NIV2(TEMP_ID(i)+1)-      &
     &                    (SBTR_MEM(TEMP_ID(i))-SBTR_CUR(TEMP_ID(i)))
                  ELSE
                     MEM_SIZE_STRONG(i)=                                &
     &                    dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-&
     &                    LU_USAGE(TEMP_ID(i))-                         &
     &                    (SBTR_MEM(TEMP_ID(i))-SBTR_CUR(TEMP_ID(i)))
                  ENDIF
               ENDIF
            ENDIF
            IF(min(MEM_SIZE_STRONG(i),MEM_SIZE_WEAK(i)).LT.dble(0))THEN
                IF(MEM_SIZE_STRONG(i).LT.0.0d0)THEN
                   MEM_SIZE_STRONG(i)=dble(0)
                ELSE
                   MEM_SIZE_WEAK(i)=dble(0)
                ENDIF
             ENDIF
          ENDDO
       ELSE
          BUF_SIZE=dble(K821)
          DO i=1,NUMBER_OF_PROCS
            IF((SBTR_WHICH_M.EQ.0).OR.(.NOT.BDC_SBTR))THEN
               IF(BDC_M2_MEM)THEN
                  MEM_SIZE_STRONG(i)=                                   &
     &                 dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-   &
     &                 LU_USAGE(TEMP_ID(i))-NIV2(TEMP_ID(i)+1)
               ELSE
                  MEM_SIZE_STRONG(i)=                                   &
     &                 dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-   &
     &                 LU_USAGE(TEMP_ID(i))
               ENDIF
            ELSE
               IF(BDC_SBTR)THEN
                  IF(BDC_M2_MEM)THEN
                     MEM_SIZE_STRONG(i)=                                &
     &                    dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-&
     &                    LU_USAGE(TEMP_ID(i))-NIV2(TEMP_ID(i)+1)-      &
     &                    (SBTR_MEM(TEMP_ID(i))-SBTR_CUR(TEMP_ID(i)))
                  ELSE
                     MEM_SIZE_STRONG(i)=                                &
     &                    dble(TAB_MAXS(TEMP_ID(i)))-DM_MEM(TEMP_ID(i))-&
     &                    LU_USAGE(TEMP_ID(i))-                         &
     &                    (SBTR_MEM(TEMP_ID(i))-SBTR_CUR(TEMP_ID(i)))
                  ENDIF
               ENDIF
            ENDIF
            MEM_SIZE_STRONG(i)=max(dble(0),MEM_SIZE_STRONG(i))
            MEM_SIZE_WEAK(i)=huge(MEM_SIZE_WEAK(i))
          ENDDO
       ENDIF
       IF((((NUMBER_OF_PROCS.LE.K83).AND.FORCE_CAND).AND.               &
     &      (TOTAL_COST.GE.SOMME)).OR.                                  &
     &      (.NOT.FORCE_CAND).OR.                                       &
     &      (((NUMBER_OF_PROCS+1).GT.K83).AND.FORCE_CAND))THEN
               REF=NSLAVES_REF
               SMALL_SET=NSLAVES_REF
               IF(.NOT.SMP)THEN
                  DO i=NSLAVES_REF,1,-1
                     SOMME=dble(0)
                     DO J=1,i
                        SOMME=SOMME+TEMP(J)
                     ENDDO
                     SOMME=(dble(i)*TEMP(i))-SOMME
                     IF(TOTAL_COST.GE.SOMME) GOTO 444
                  ENDDO
  444             CONTINUE
                  REF=i
                  SMALL_SET=REF
                  MAX_LOAD=TEMP(SMALL_SET)
               ELSE
                  X=min(SIZE_MY_SMP,NSLAVES_REF)
  450             CONTINUE
                  SOMME=dble(0)
                  DO J=1,X
                     SOMME=SOMME+(TEMP(X)-TEMP(J))
                  ENDDO
                  IF(SOMME.GT.TOTAL_COST)THEN
                     X=X-1
                     GOTO 450
                  ELSE
                     IF(X.LT.SIZE_MY_SMP) THEN
                        REF=X
                        SMALL_SET=REF
                        MAX_LOAD=TEMP(SMALL_SET)
                     ELSE
                        X=min(SIZE_MY_SMP,NSLAVES_REF)
                        J=X+1
                        MAX_LOAD=TEMP(X)
                        TMP_SUM=MAX_LOAD
                        DO i=X+1,OTHERS
                           IF(TEMP(i).GT.MAX_LOAD)THEN
                              SOMME=SOMME+(dble(i-1)*(TEMP(i)-MAX_LOAD))
                              TMP_SUM=MAX_LOAD
                              MAX_LOAD=TEMP(i)
                           ELSE
                              SOMME=SOMME+(MAX_LOAD-TEMP(i))
                           ENDIF
                           IF(i.EQ.NSLAVES_REF)THEN
                              SMALL_SET=NSLAVES_REF
                              REF=SMALL_SET
                              GOTO 323
                           ENDIF
                           IF(SOMME.GT.TOTAL_COST)THEN
                              REF=i-1
                              SMALL_SET=i-1
                              MAX_LOAD=TMP_SUM
                              GOTO 323
                           ENDIF
                        ENDDO
                     ENDIF
                  ENDIF
               ENDIF
  323          CONTINUE
               MAX_LOAD=dble(0)
               DO i=1,SMALL_SET
                  MAX_LOAD=max(MAX_LOAD,TEMP(i))
               ENDDO
               TEMP_MAX_LOAD=MAX_LOAD
               NB_ROWS=0
               TMP_SUM=dble(0)
               CHOSEN=0
               ACC=0
               NB_SAT=0
               NB_ZERO=0
               DO i=1,SMALL_SET
                  IF(K50.EQ.0)THEN
                     X=int(BUF_SIZE/dble(NCB+1))-1
                     BANDE_K821=dble(X)*dble(NFRONT)
                  ELSE
                     A=dble(1)
                     B=dble(ACC+2)
                     C=-BUF_SIZE+dble(ACC+NELIM)
                     DELTA=(B*B)-(dble(4)*A*C)
                     X=int((-B+sqrt(DELTA))/(dble(2)*A))
                     IF(X.GT.NCB-ACC) X=NCB-ACC
                     BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                  ENDIF
                  IF(HAVE_TYPE1_SON)THEN
                     IF(K50.EQ.0)THEN
                        X=int((BUF_SIZE-dble(NFRONT))/dble(NFRONT+1))
                        BANDE_K821=dble(X)*dble(NFRONT)
                     ELSE
                        A=dble(1)
                        B=dble(ACC+2+NELIM)
                        C=-BUF_SIZE+dble(ACC+NELIM)
                        DELTA=(B*B)-(dble(4)*A*C)
                        X=int((-B+sqrt(DELTA))/(dble(2)*A))
                        IF(X.GT.NCB-ACC) X=NCB-ACC
                        BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                     ENDIF
                  ENDIF
                  MAX_MEM_ALLOW=BANDE_K821
                  IF(BDC_MD)THEN
                     MAX_MEM_ALLOW=min(                                 &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                    BANDE_K821)
                     MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                  ENDIF
                  IF(K50.EQ.0)THEN
                     KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                     X=int((MAX_LOAD-TEMP(i))/                          &
     &                    (dble(NELIM)*dble(2*NFRONT-NELIM)))
                     IF(X.GE.KMAX)THEN
                        IF(KMAX.GE.KMIN)THEN
                           X=KMAX
                           NB_SAT=NB_SAT+1
                        ELSE
                           X=0
                        ENDIF
                     ELSE
                        IF(X.LT.KMIN)THEN
                           X=0
                        ENDIF
                     ENDIF
                     IF((ACC+X).GT.NCB) X=NCB-ACC
                  ENDIF
                  IF(K50.NE.0)THEN
                        A=dble(1)
                        B=dble(ACC+NELIM)
                        C=dble(-MAX_MEM_ALLOW)
                        DELTA=((B*B)-(dble(4)*A*C))
                        KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                     A=dble(NELIM)
                     B=dble(NELIM)*(dble(NELIM)+dble(2*ACC+1))
                     C=-(MAX_LOAD-TEMP(i))
                     DELTA=(B*B-(dble(4)*A*C))
                     X=int((-B+sqrt(DELTA))/(dble(2)*A))
                     IF(X.LT.0) THEN
                        WRITE(*,*)MYID,                                 &
     &    ': Internal error 1 in DMUMPS_518'
                        CALL AGMG_MUMPS_ABORT()
                     ENDIF
                     IF(X.GE.KMAX)THEN
                        IF(KMAX.GE.KMIN)THEN
                           X=KMAX
                           NB_SAT=NB_SAT+1
                        ELSE
                           X=0
                        ENDIF
                     ELSE
                        IF(X.LT.KMIN)THEN
                           X=0
                        ENDIF
                     ENDIF
                     IF((ACC+X).GT.NCB) X=NCB-ACC
                  ENDIF
                  NB_ROWS(i)=X
                  ACC=ACC+X
                  CHOSEN=CHOSEN+1
                  IF(SMP)THEN
                     IF(MIN_LOAD.GT.TEMP(i))THEN
                        MIN_LOAD=TEMP(i)
                        POS_MIN_LOAD=i
                     ENDIF
                  ENDIF
                  TMP_SUM=MAX_LOAD
                  IF(K50.EQ.0)THEN
                     MAX_LOAD=max(MAX_LOAD,                             &
     &                    (TEMP(i)+(dble(NELIM) *                       &
     &                    dble(NB_ROWS(i)))+                            &
     &                    (dble(NB_ROWS(i))*dble(NELIM)*                &
     &                    dble(2*NFRONT-NELIM-1))))
                  ELSE
                     MAX_LOAD=max(MAX_LOAD,                             &
     &               TEMP(i)+(dble(NELIM) * dble(NB_ROWS(i)))*          &
     &                    dble(2*(NELIM+ACC)-NB_ROWS(i)                 &
     &                    -NELIM+1))
                  ENDIF
                  IF(TMP_SUM.LT.MAX_LOAD)THEN
                  ENDIF
                  IF(NCB-ACC.LT.KMIN) GOTO 888
                  IF(NCB.EQ.ACC) GOTO 888
                  IF(ACC.GT.NCB) THEN
                    WRITE(*,*)MYID,                                     &
     &      ': Internal error 2 in DMUMPS_518'
                    CALL AGMG_MUMPS_ABORT()
                  ENDIF
               ENDDO
  888          CONTINUE
               SOMME=dble(0)
               X=NFRONT-NCB
               IF((ACC.GT.NCB))THEN
                  WRITE(*,*)MYID,                                       &
     &          ': Internal error 3 in DMUMPS_518'
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               IF((ACC.LT.NCB))THEN
                  IF(K50.NE.0)THEN
                     IF(SMALL_SET.LE.OTHERS)THEN
                       IF((NB_SAT.EQ.SMALL_SET).AND.(SMALL_SET.LT.      &
     &                      NSLAVES_REF))THEN
                          SMALL_SET=REF+1
                          REF=REF+1
                          NB_ROWS=0
                          GOTO 323
                       ENDIF
                       ADDITIONNAL_ROWS_SPECIAL=NCB-ACC
                       DO i=1,SMALL_SET
                          MAX_LOAD=TEMP_MAX_LOAD
                          ADDITIONNAL_ROWS=NCB-ACC
                          SOMME=dble(NELIM)*                            &
     &                         dble(ADDITIONNAL_ROWS)*                  &
     &                         dble(2*NFRONT-ADDITIONNAL_ROWS-NELIM     &
     &                         +1)
                          SOMME=SOMME/dble(SMALL_SET-NB_SAT)
                          NB_ROWS=0
                          NB_ZERO=0
                          ACC=0
                          CHOSEN=0
                          NB_SAT=0
                          IF(SMP)THEN
                             MIN_LOAD=TEMP(1)
                             POS_MIN_LOAD=1
                          ENDIF
                          DO J=1,SMALL_SET
                             A=dble(1)
                             B=dble(ACC+2)
                             C=-BUF_SIZE+dble(ACC+NELIM)
                             DELTA=(B*B)-(dble(4)*A*C)
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.GT.NCB-ACC) X=NCB-ACC
                             BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             IF(HAVE_TYPE1_SON)THEN
                                A=dble(1)
                                B=dble(ACC+2+NELIM)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             ENDIF
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                        min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)), &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             A=dble(1)
                             B=dble(ACC+NELIM)
                             C=dble(-MAX_MEM_ALLOW)
                             DELTA=((B*B)-(dble(4)*A*C))
                             KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                             A=dble(NELIM)
                             B=(dble(NELIM)*dble(NELIM+2*ACC+1))
                             C=-(MAX_LOAD-TEMP(J)+SOMME)
                             DELTA=(B*B-(dble(4)*A*C))
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             X=X+1
                             IF(X.LT.0) THEN
                                WRITE(*,*)MYID,                         &
     &    ': Internal error 4 in DMUMPS_518'
                                CALL AGMG_MUMPS_ABORT()
                             ENDIF
                             IF(X.GE.KMAX)THEN
                                IF(KMAX.GE.KMIN)THEN
                                   X=KMAX
                                   NB_SAT=NB_SAT+1
                                ELSE
                                   NB_ZERO=NB_ZERO+1
                                   X=0
                                ENDIF
                             ELSE
                                IF(X.LT.min(KMIN,KMAX))THEN
                                   NB_ZERO=NB_ZERO+1
                                   X=0
                                ENDIF
                             ENDIF
                             IF((ACC+X).GT.NCB) X=NCB-ACC
                             NB_ROWS(J)=X
                             IF(SMP)THEN
                                IF(MIN_LOAD.GT.TEMP(J))THEN
                                   MIN_LOAD=TEMP(J)
                                   POS_MIN_LOAD=i
                                ENDIF
                             ENDIF
                             CHOSEN=CHOSEN+1
                             ACC=ACC+X
                             TMP_SUM=MAX_LOAD
                             TEMP_MAX_LOAD=max(TEMP_MAX_LOAD,           &
     &                            TEMP(J)+(dble(NELIM) *                &
     &                            dble(NB_ROWS(J)))*                    &
     &                            dble(2*(NELIM+                        &
     &                            ACC)-NB_ROWS(J)                       &
     &                            -NELIM+1))
                             IF(REF.LE.NUMBER_OF_PROCS-1)THEN
                                IF(TEMP_MAX_LOAD.GT.TEMP(REF+1))THEN
                                   IF(SMALL_SET.LT.NSLAVES_REF)THEN
                                      SMALL_SET=REF+1
                                      REF=REF+1
                                      NB_ROWS=0
                                      GOTO 323
                                   ENDIF
                                ENDIF
                             ENDIF
                             IF(NCB.EQ.ACC) GOTO 666
                          ENDDO
                          IF(NB_SAT.EQ.SMALL_SET)THEN
                             IF(SMALL_SET.LT.NSLAVES_REF)THEN
                                SMALL_SET=REF+1
                                REF=REF+1
                                NB_ROWS=0
                                GOTO 323
                             ELSE
                                GOTO 434
                             ENDIF
                          ENDIF
                          IF(NB_ZERO.EQ.SMALL_SET)THEN
                             IF(SMALL_SET.LT.NSLAVES_REF)THEN
                                SMALL_SET=REF+1
                                REF=REF+1
                                NB_ROWS=0
                                GOTO 323
                             ELSE
                                GOTO 434
                             ENDIF
                          ENDIF
                          IF((NB_SAT+NB_ZERO).EQ.SMALL_SET)THEN
                             IF(SMALL_SET.LT.NSLAVES_REF)THEN
                                SMALL_SET=REF+1
                                REF=REF+1
                                NB_ROWS=0
                                GOTO 323
                             ELSE
                                GOTO 434
                             ENDIF
                          ENDIF
                       ENDDO
  434                  CONTINUE
                       ADDITIONNAL_ROWS=NCB-ACC
                       IF(ADDITIONNAL_ROWS.NE.0)THEN
                          IF(ADDITIONNAL_ROWS.LT.KMIN)THEN
                             i=CHOSEN
                             J=ACC
  436                        CONTINUE
                             IF(NB_ROWS(i).NE.0)THEN
                                J=J-NB_ROWS(i)
                                A=dble(1)
                                B=dble(J+2)
                                C=-BUF_SIZE+dble(J+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-J) X=NCB-J
                                BANDE_K821=dble(X)*dble(NELIM+J+X)
                                IF(HAVE_TYPE1_SON)THEN
                                   A=dble(1)
                                   B=dble(J+2+NELIM)
                                   C=-BUF_SIZE+dble(J+NELIM)
                                   DELTA=(B*B)-(dble(4)*A*C)
                                   X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                   IF(X.GT.NCB-J) X=NCB-J
                                   BANDE_K821=dble(X)*dble(NELIM+J+X)
                                ENDIF
                                MAX_MEM_ALLOW=BANDE_K821
                                IF(BDC_MD)THEN
                                   MAX_MEM_ALLOW=min(                   &
     &                         min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),&
     &                                  BANDE_K821)
                                   MAX_MEM_ALLOW=max(dble(0),           &
     &                                  MAX_MEM_ALLOW)
                                ENDIF
                                A=dble(1)
                                B=dble(J+NELIM)
                                C=dble(-MAX_MEM_ALLOW)
                                DELTA=((B*B)-(dble(4)*A*C))
                                KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(NB_ROWS(i).NE.KMAX)THEN
                                   IF(NCB-J.LE.KMAX)THEN
                                      NB_ROWS(i)=+NCB-J
                                      ADDITIONNAL_ROWS=0
                                   ENDIF
                                ENDIF
                                TEMP_MAX_LOAD=max(TEMP_MAX_LOAD,        &
     &                               TEMP(i)+                           &
     &                               (dble(NELIM) * dble(NB_ROWS(i)))*  &
     &                               dble(2*(NELIM+                     &
     &                               ACC)-NB_ROWS(i)                    &
     &                               -NELIM+1))
                                IF(REF.LE.NUMBER_OF_PROCS-1)THEN
                                   IF(TEMP_MAX_LOAD.GT.TEMP(REF+1))THEN
                                      IF(SMALL_SET.LT.NSLAVES_REF)THEN
                                         SMALL_SET=REF+1
                                         REF=REF+1
                                         NB_ROWS=0
                                         GOTO 323
                                      ENDIF
                                   ENDIF
                                ENDIF
                             ELSE
                                i=i-1
                                IF(i.NE.0)GOTO 436
                             ENDIF
                             IF(ADDITIONNAL_ROWS.NE.0)THEN
                                i=CHOSEN
                                IF(i.NE.SMALL_SET)THEN
                                   i=i+1
                                   IF(NB_ROWS(i).NE.0)THEN
                                      WRITE(*,*)MYID,                   &
     &    ': Internal error 5 in DMUMPS_518'
                                      CALL AGMG_MUMPS_ABORT()
                                   ENDIF
                                ENDIF
                                NB_ROWS(i)=NB_ROWS(i)+ADDITIONNAL_ROWS
                                ADDITIONNAL_ROWS=0
                             ENDIF
                             CHOSEN=i
                          ENDIF
                       ENDIF
                       i=CHOSEN+1
                       DO WHILE ((ADDITIONNAL_ROWS.NE.0)                &
     &                      .AND.(i.LE.NUMBER_OF_PROCS))
                          IF((TEMP(i).LE.MAX_LOAD))THEN
                             A=dble(1)
                             B=dble(ACC+2)
                             C=-BUF_SIZE+dble(ACC+NELIM)
                             DELTA=(B*B)-(dble(4)*A*C)
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.GT.NCB-ACC) X=NCB-ACC
                             BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             IF(HAVE_TYPE1_SON)THEN
                                A=dble(1)
                                B=dble(ACC+2+NELIM)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             ENDIF
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             A=dble(1)
                             B=dble(ACC+NELIM)
                             C=dble(-MAX_MEM_ALLOW)
                             DELTA=((B*B)-(dble(4)*A*C))
                             KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                             A=dble(NELIM)
                             B=dble(NELIM)*dble(NELIM+2*ACC+1)
                             C=-(MAX_LOAD-TEMP(i))
                             DELTA=(B*B-(dble(4)*A*C))
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.GE.KMAX)THEN
                                IF(KMAX.GE.KMIN)THEN
                                   X=KMAX
                                ELSE
                                   X=0
                                ENDIF
                             ELSE
                                IF(X.LT.KMIN)THEN
                                   X=0
                                ENDIF
                             ENDIF
                             IF((ACC+X).GT.NCB) X=NCB-ACC
                             NB_ROWS(i)=X
                             ACC=ACC+X
                             ADDITIONNAL_ROWS=NCB-ACC
                          ELSE IF((TEMP(i).GT.MAX_LOAD))THEN
                             MAX_LOAD=TEMP(i)
                             NB_SAT=0
                             ACC=0
                             NB_ROWS=0
                             DO J=1,i
                                A=dble(1)
                                B=dble(ACC+2)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                                IF(HAVE_TYPE1_SON)THEN
                                   A=dble(1)
                                   B=dble(ACC+2+NELIM)
                                   C=-BUF_SIZE+dble(ACC+NELIM)
                                   DELTA=(B*B)-(dble(4)*A*C)
                                   X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                   IF(X.GT.NCB-ACC) X=NCB-ACC
                                   BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                                ENDIF
                                MAX_MEM_ALLOW=BANDE_K821
                                IF(BDC_MD)THEN
                                   MAX_MEM_ALLOW=min(                   &
     &                    min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)),     &
     &                                  BANDE_K821)
                                   MAX_MEM_ALLOW=max(dble(0),           &
     &                                  MAX_MEM_ALLOW)
                                ENDIF
                                A=dble(1)
                                B=dble(ACC+NELIM)
                                C=dble(-MAX_MEM_ALLOW)
                                DELTA=((B*B)-(dble(4)*A*C))
                                KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                                A=dble(NELIM)
                                B=dble(NELIM)*dble(NELIM+2*ACC+1)
                                C=-(MAX_LOAD-TEMP(J))
                                DELTA=(B*B-(dble(4)*A*C))
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.LT.0) THEN
                        WRITE(*,*)MYID,                                 &
     &    ': Internal error 6 in DMUMPS_518'
                                   CALL AGMG_MUMPS_ABORT()
                                ENDIF
                                IF(X.GE.KMAX)THEN
                                   IF(KMAX.GE.KMIN)THEN
                                      X=KMAX
                                      NB_SAT=NB_SAT+1
                                   ELSE
                                      X=0
                                   ENDIF
                                ELSE
                                   IF(X.LT.min(KMIN,KMAX))THEN
                                      X=0
                                   ENDIF
                                ENDIF
                                IF((ACC+X).GT.NCB) X=NCB-ACC
                                NB_ROWS(J)=X
                                IF(SMP)THEN
                                   IF(MIN_LOAD.GT.TEMP(J))THEN
                                      MIN_LOAD=TEMP(J)
                                      POS_MIN_LOAD=i
                                   ENDIF
                                ENDIF
                                ACC=ACC+X
                                MAX_LOAD=max(MAX_LOAD,                  &
     &                               TEMP(J)+                           &
     &                               (dble(NELIM)*dble(NB_ROWS(J)))*    &
     &                               dble(2*(NELIM+                     &
     &                               ACC)-NB_ROWS(J)                    &
     &                               -NELIM+1))
                                IF(NCB.EQ.ACC) GOTO 741
                                IF(NCB-ACC.LT.KMIN) GOTO 210
                             ENDDO
  210                        CONTINUE
                          ENDIF
  741                     CONTINUE
                          i=i+1
                          ADDITIONNAL_ROWS=NCB-ACC
                       ENDDO
                       CHOSEN=i-1
                       IF(ADDITIONNAL_ROWS.NE.0)THEN
                          ADDITIONNAL_ROWS=NCB-ACC
                          SOMME=dble(NELIM)*dble(ADDITIONNAL_ROWS)*     &
     &                         dble(2*NFRONT-ADDITIONNAL_ROWS-          &
     &                         NELIM+1)
                          SOMME=SOMME/dble(NUMBER_OF_PROCS)
                          NB_ROWS=0
                          ACC=0
                          CHOSEN=0
                          IF(SMP)THEN
                             MIN_LOAD=TEMP(1)
                             POS_MIN_LOAD=1
                          ENDIF
                          DO i=1,OTHERS
                             A=dble(1)
                             B=dble(ACC+2)
                             C=-BUF_SIZE+dble(ACC+NELIM)
                             DELTA=(B*B)-(dble(4)*A*C)
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.GT.NCB-ACC) X=NCB-ACC
                             BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             IF(HAVE_TYPE1_SON)THEN
                                A=dble(1)
                                B=dble(ACC+2+NELIM)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             ENDIF
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             A=dble(1)
                             B=dble(ACC+NELIM)
                             C=dble(-MAX_MEM_ALLOW)
                             DELTA=((B*B)-(dble(4)*A*C))
                             KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                             A=dble(NELIM)
                             B=dble(NELIM)*dble(NELIM+2*ACC+1)
                             C=-(MAX_LOAD-TEMP(i)+SOMME)
                             DELTA=(B*B-(dble(4)*A*C))
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.LT.0) THEN
                                WRITE(*,*)MYID,                         &
     &    ': Internal error 7 in DMUMPS_518'
                                CALL AGMG_MUMPS_ABORT()
                             ENDIF
                             IF(X.GE.KMAX)THEN
                                IF(KMAX.GE.KMIN)THEN
                                   X=KMAX
                                ELSE
                                   X=0
                                ENDIF
                             ELSE
                                IF(X.LT.min(KMIN,KMAX))THEN
                                   X=min(KMAX,KMIN)
                                ENDIF
                             ENDIF
                             IF((ACC+X).GT.NCB) X=NCB-ACC
                             NB_ROWS(i)=X
                             IF(SMP)THEN
                                IF(MIN_LOAD.GT.TEMP(i))THEN
                                   MIN_LOAD=TEMP(i)
                                   POS_MIN_LOAD=i
                                ENDIF
                             ENDIF
                             CHOSEN=CHOSEN+1
                             ACC=ACC+X
                             IF(NCB.EQ.ACC) GOTO 666
                             IF(NCB-ACC.LT.KMIN) GOTO 488
                          ENDDO
  488                     CONTINUE
                          ADDITIONNAL_ROWS=NCB-ACC
                          SOMME=dble(NELIM)*                            &
     &                         dble(ADDITIONNAL_ROWS)*                  &
     &                         dble(2*NFRONT-ADDITIONNAL_ROWS-          &
     &                         NELIM+1)
                          SOMME=SOMME/dble(NUMBER_OF_PROCS)
                          NB_ROWS=0
                          ACC=0
                          CHOSEN=0
                          IF(SMP)THEN
                             MIN_LOAD=TEMP(1)
                             POS_MIN_LOAD=1
                          ENDIF
                          DO i=1,OTHERS
                             A=dble(1)
                             B=dble(ACC+2)
                             C=-BUF_SIZE+dble(ACC+NELIM)
                             DELTA=(B*B)-(dble(4)*A*C)
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.GT.NCB-ACC) X=NCB-ACC
                             BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             IF(HAVE_TYPE1_SON)THEN
                                A=dble(1)
                                B=dble(ACC+2+NELIM)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                             ENDIF
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(BANDE_K821,           &
     &                               MEM_SIZE_STRONG(i))
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             A=dble(1)
                             B=dble(ACC+NELIM)
                             C=dble(-MAX_MEM_ALLOW)
                             DELTA=((B*B)-(dble(4)*A*C))
                             KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                             A=dble(NELIM)
                             B=dble(NELIM)*dble(NELIM+2*ACC+1)
                             C=-(MAX_LOAD-TEMP(i)+SOMME)
                             DELTA=(B*B-(dble(4)*A*C))
                             X=int((-B+sqrt(DELTA))/(dble(2)*A))
                             IF(X.LT.0) THEN
                                WRITE(*,*)MYID,                         &
     &    ': Internal error 8 in DMUMPS_518'
                                CALL AGMG_MUMPS_ABORT()
                             ENDIF
                             IF(X.GE.KMAX)THEN
                                X=KMAX
                             ELSE
                                IF(X.LT.KMIN)THEN
                                   X=KMIN
                                ENDIF
                             ENDIF
                             IF((ACC+X).GT.NCB) X=NCB-ACC
                             NB_ROWS(i)=X
                             IF(SMP)THEN
                                IF(MIN_LOAD.GT.TEMP(i))THEN
                                   MIN_LOAD=TEMP(i)
                                   POS_MIN_LOAD=i
                                ENDIF
                             ENDIF
                             CHOSEN=CHOSEN+1
                             ACC=ACC+X
                             IF(NCB.EQ.ACC) GOTO 666
                             IF(NCB-ACC.LT.KMIN) GOTO 477
                          ENDDO
  477                     CONTINUE
                          IF(ACC.NE.NCB)THEN
                             NB_SAT=0
                             ACC=0
                             CHOSEN=0
                             IF(SMP)THEN
                                MIN_LOAD=TEMP(1)
                                POS_MIN_LOAD=1
                             ENDIF
                             DO i=1,OTHERS
                                A=dble(1)
                                B=dble(ACC+2)
                                C=-BUF_SIZE+dble(ACC+NELIM)
                                DELTA=(B*B)-(dble(4)*A*C)
                                X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                IF(X.GT.NCB-ACC) X=NCB-ACC
                                BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                                IF(HAVE_TYPE1_SON)THEN
                                   A=dble(1)
                                   B=dble(ACC+2+NELIM)
                                   C=-BUF_SIZE+dble(ACC+NELIM)
                                   DELTA=(B*B)-(dble(4)*A*C)
                                   X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                   IF(X.GT.NCB-ACC) X=NCB-ACC
                                   BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                                ENDIF
                                MAX_MEM_ALLOW=BANDE_K821
                                IF(BDC_MD)THEN
                                   MAX_MEM_ALLOW=min(BANDE_K821,        &
     &                                  MEM_SIZE_STRONG(i))
                                   MAX_MEM_ALLOW=max(dble(0),           &
     &                                  MAX_MEM_ALLOW)
                                ENDIF
                                A=dble(1)
                                B=dble(ACC+NELIM)
                                C=dble(-MAX_MEM_ALLOW)
                                DELTA=((B*B)-(dble(4)*A*C))
                                KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                                X=KMAX-NB_ROWS(i)
                                IF((ACC+NB_ROWS(i)+X).GT.NCB)           &
     &                               X=NCB-(ACC+NB_ROWS(i))
                                NB_ROWS(i)=NB_ROWS(i)+X
                                IF((dble(NB_ROWS(i))*                   &
     &                               dble(NB_ROWS(i)+ACC)).EQ.          &
     &                               BANDE_K821)THEN
                                   NB_SAT=NB_SAT+1
                                ENDIF
                                ACC=ACC+NB_ROWS(i)
                                IF(SMP)THEN
                                   IF(MIN_LOAD.GT.TEMP(i))THEN
                                      MIN_LOAD=TEMP(i)
                                      POS_MIN_LOAD=i
                                   ENDIF
                                ENDIF
                                CHOSEN=CHOSEN+1
                                IF(NCB.EQ.ACC) GOTO 666
                                IF(NCB-ACC.LT.KMIN) GOTO 834
                             ENDDO
  834                        CONTINUE
                          ENDIF
                          IF(ACC.NE.NCB)THEN
                            ADDITIONNAL_ROWS=NCB-ACC
                            SOMME=dble(NELIM)*                          &
     &                           dble(ADDITIONNAL_ROWS)*                &
     &                           dble(2*NFRONT-ADDITIONNAL_ROWS-        &
     &                           NELIM+1)
                            SOMME=SOMME/dble(NUMBER_OF_PROCS-NB_SAT)
                            ACC=0
                            DO i=1,CHOSEN
                               A=dble(1)
                               B=dble(ACC+2)
                               C=-BUF_SIZE+dble(ACC+NELIM)
                               DELTA=(B*B)-(dble(4)*A*C)
                               X=int((-B+sqrt(DELTA))/(dble(2)*A))
                               IF(X.GT.NCB-ACC) X=NCB-ACC
                               BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                               IF(HAVE_TYPE1_SON)THEN
                                  A=dble(1)
                                  B=dble(ACC+2+NELIM)
                                  C=-BUF_SIZE+dble(ACC+NELIM)
                                  DELTA=(B*B)-(dble(4)*A*C)
                                  X=int((-B+sqrt(DELTA))/(dble(2)*A))
                                  IF(X.GT.NCB-ACC) X=NCB-ACC
                                  BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                               ENDIF
                               IF((dble(NB_ROWS(i))*                    &
     &                              dble(NB_ROWS(i)+ACC)).EQ.           &
     &                              BANDE_K821)THEN
                                  GOTO 102
                               ENDIF
                               A=dble(NELIM)
                               B=dble(NELIM)*                           &
     &                              dble(NELIM+2*(ACC+NB_ROWS(i))+1)
                               C=-(SOMME)
                               DELTA=(B*B-(dble(4)*A*C))
                               X=int((-B+sqrt(DELTA))/(dble(2)*A))
                               A=dble(1)
                               B=dble(ACC+NELIM)
                               C=dble(-BANDE_K821)
                               DELTA=((B*B)-(dble(4)*A*C))
                               KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                               IF(X.LT.0) THEN
                                  WRITE(*,*)MYID,                       &
     &    ': Internal error 9 in DMUMPS_518'
                                  CALL AGMG_MUMPS_ABORT()
                               ENDIF
                               IF((ACC+X+NB_ROWS(i)).GT.NCB)THEN
                                  IF((NCB-ACC).GT.KMAX)THEN
                                     NB_ROWS(i)=KMAX
                                  ELSE
                                     NB_ROWS(i)=NCB-ACC
                                  ENDIF
                               ELSE
                                  IF((NB_ROWS(i)+X).GT.KMAX)THEN
                                     NB_ROWS(i)=KMAX
                                  ELSE
                                     NB_ROWS(i)=NB_ROWS(i)+X
                                  ENDIF
                               ENDIF
  102                          CONTINUE
                               ACC=ACC+NB_ROWS(i)
                               IF(NCB.EQ.ACC) THEN
                                  CHOSEN=i
                                  GOTO 666
                               ENDIF
                               IF(NCB-ACC.LT.KMIN) THEN
                                  CHOSEN=i
                                  GOTO 007
                               ENDIF
                            ENDDO
    7                       CONTINUE
                            DO i=1,CHOSEN
                               NB_ROWS(i)=NB_ROWS(i)+1
                               ACC=ACC+1
                               IF(ACC.EQ.NCB)GOTO 666
                            ENDDO
                            IF(ACC.LT.NCB)THEN
                               IF(SMP)THEN
                                  NB_ROWS(1)=NB_ROWS(1)+NCB-ACC
                               ELSE
                                  NB_ROWS(POS_MIN_LOAD)=                &
     &                                 NB_ROWS(POS_MIN_LOAD)+NCB-ACC
                               ENDIF
                            ENDIF
                         ENDIF
                         GOTO 666
                     ENDIF
                  ENDIF
                  GOTO 666
                 ENDIF
                 ADDITIONNAL_ROWS=NCB-ACC
                 i=CHOSEN+1
                 IF(NB_SAT.EQ.SMALL_SET) GOTO 777
                 DO i=1,SMALL_SET
                    IDWLOAD(i)=i
                    AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                    BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                    IF(HAVE_TYPE1_SON)THEN
                       AFFECTED=int((BUF_SIZE-dble(NFRONT))/            &
     &                      (dble(NFRONT+1)))
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                    ENDIF
                    MAX_MEM_ALLOW=BANDE_K821
                    IF(BDC_MD)THEN
                       MAX_MEM_ALLOW=min(                               &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                      BANDE_K821)
                       MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                    ENDIF
                    WLOAD(i)=MAX_MEM_ALLOW
                 ENDDO
                 CALL AGMG_MUMPS_558(SMALL_SET, WLOAD, IDWLOAD)
                 NB_ZERO=0
                 IF((NB_SAT.EQ.SMALL_SET).AND.                          &
     &                (SMALL_SET.LT.NSLAVES_REF))THEN
                    SMALL_SET=REF+1
                    REF=REF+1
                    NB_ROWS=0
                    GOTO 323
                 ENDIF
                 IF((NB_SAT.EQ.SMALL_SET).AND.                          &
     &                (SMALL_SET.LE.NUMBER_OF_PROCS))GOTO 777
                 AFFECTED=int(ADDITIONNAL_ROWS/(SMALL_SET-NB_SAT))
                 AFFECTED=max(AFFECTED,1)
                 DO i=1,SMALL_SET
                    KMAX=int(WLOAD(i)/dble(NFRONT))
                    IF(NB_ROWS(IDWLOAD(i)).EQ.KMAX)THEN
                       GOTO 912
                    ENDIF
                    IF((NB_ROWS(IDWLOAD(i))+min(AFFECTED,               &
     &                   ADDITIONNAL_ROWS)).GT.KMAX)THEN
                       IF(NB_ROWS(IDWLOAD(i)).GT.KMAX)THEN
                       ENDIF
                       ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-               &
     &                      (KMAX-NB_ROWS(IDWLOAD(i)))
                       NB_ROWS(IDWLOAD(i))=KMAX
                       NB_SAT=NB_SAT+1
                       IF(NB_SAT.EQ.SMALL_SET)THEN
                          IF(SMALL_SET.NE.NSLAVES_REF)THEN
                             SMALL_SET=REF+1
                             REF=REF+1
                             NB_ROWS=0
                             GOTO 323
                          ELSE
                             MAX_LOAD=max(MAX_LOAD,                     &
     &                            (TEMP(IDWLOAD(i))+(dble(NELIM) *      &
     &                            dble(NB_ROWS(IDWLOAD(i))))+           &
     &                            (dble(NB_ROWS(IDWLOAD(i)))*           &
     &                            dble(NELIM))*                         &
     &                            dble(2*NFRONT-NELIM-1)))
                             GOTO 777
                          ENDIF
                       ENDIF
                       AFFECTED=int(ADDITIONNAL_ROWS/(SMALL_SET-NB_SAT))
                       AFFECTED=max(AFFECTED,1)
                    ELSE
                       IF((NB_ROWS(IDWLOAD(i))+min(AFFECTED,            &
     &                      ADDITIONNAL_ROWS)).GE.KMIN)THEN
                          X=min(AFFECTED,ADDITIONNAL_ROWS)
                          NB_ROWS(IDWLOAD(i))=NB_ROWS(IDWLOAD(i))+      &
     &                         X
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                       ELSE
                          X=int((MAX_LOAD-TEMP(IDWLOAD(i)))/            &
     &                         (dble(NELIM)*dble(2*NFRONT-NELIM)))
                          IF(X+AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                             X=ADDITIONNAL_ROWS
                          ELSE
                             X=AFFECTED+X
                          ENDIF
                          IF(X.GE.KMIN)THEN
                             NB_ROWS(IDWLOAD(i))=NB_ROWS(IDWLOAD(i))+   &
     &                            X
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-         &
     &                            X
                          ELSE
                             NB_ZERO=NB_ZERO+1
                          ENDIF
                       ENDIF
                    ENDIF
  912               CONTINUE
                    MAX_LOAD=max(MAX_LOAD,                              &
     &                   (TEMP(IDWLOAD(i))+(dble(NELIM)*                &
     &                   dble(NB_ROWS(IDWLOAD(i))))+                    &
     &                   (dble(NB_ROWS(IDWLOAD(i)))*dble(NELIM))*       &
     &                   dble(2*NFRONT-NELIM-1)))
                    IF(SMALL_SET.LT.NUMBER_OF_PROCS)THEN
                       IF(MAX_LOAD.GT.TEMP(SMALL_SET+1))THEN
                          IF(SMALL_SET.LT.NSLAVES_REF)THEN
                             SMALL_SET=REF+1
                             REF=REF+1
                             NB_ROWS=0
                             GOTO 323
                          ENDIF
                       ENDIF
                    ENDIF
                    IF(SMALL_SET.EQ.NB_SAT)GOTO 777
                    IF(ADDITIONNAL_ROWS.EQ.0)THEN
                       CHOSEN=SMALL_SET
                       GOTO 049
                    ENDIF
                 ENDDO
  777            CONTINUE
                 IF((NB_ZERO.NE.0).AND.(ADDITIONNAL_ROWS.GE.KMIN))THEN
                    J=NB_ZERO
  732               CONTINUE
                    X=int(ADDITIONNAL_ROWS/(J))
                    IF(X.LT.KMIN)THEN
                       J=J-1
                       GOTO 732
                    ENDIF
                    IF(X*J.LT.ADDITIONNAL_ROWS)THEN
                       X=X+1
                    ENDIF
                    DO i=1,SMALL_SET
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(                            &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                         dble(BANDE_K821))
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       IF(NB_ROWS(i).EQ.0)THEN
                          IF(X.GT.ADDITIONNAL_ROWS)THEN
                             X=ADDITIONNAL_ROWS
                          ENDIF
                          IF(X.GT.KMAX)THEN
                             X=KMAX
                          ENDIF
                          IF(X.GT.KMIN)THEN
                             NB_ROWS(i)=X
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                             MAX_LOAD=max(MAX_LOAD,                     &
     &                            (TEMP(i)+(dble(NELIM) *               &
     &                            dble(NB_ROWS(i)))+                    &
     &                            (dble(NB_ROWS(i))*dble(NELIM))*       &
     &                            dble(2*NFRONT-NELIM-1)))
                          ENDIF
                       ENDIF
                    ENDDO
                 ENDIF
                 i=CHOSEN+1
                 DO WHILE ((ADDITIONNAL_ROWS.NE.0)                      &
     &                .AND.(i.LE.NUMBER_OF_PROCS))
                    IF((TEMP(i).LE.MAX_LOAD))THEN
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(                            &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                         BANDE_K821)
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       AFFECTED=int((MAX_LOAD-TEMP(i))/                 &
     &                      (dble(NELIM)*dble(2*NFRONT-NELIM)))
                       IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                          AFFECTED=ADDITIONNAL_ROWS
                       ENDIF
                       IF(NB_ROWS(i).LT.KMAX)THEN
                          IF((AFFECTED+NB_ROWS(i)).GT.KMAX)THEN
                             AFFECTED=KMAX-NB_ROWS(i)
                             NB_SAT=NB_SAT+1
                          ELSE
                             IF((AFFECTED+NB_ROWS(i)).LT.               &
     &                            KMIN)THEN
                                AFFECTED=0
                             ENDIF
                          ENDIF
                          NB_ROWS(i)=NB_ROWS(i)+AFFECTED
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-AFFECTED
                       ENDIF
                    ELSE IF((TEMP(i).GT.MAX_LOAD))THEN
                       IF(NB_SAT.EQ.i-1) GOTO 218
                       X=(ADDITIONNAL_ROWS/(i-1-NB_SAT))
                       ACC=1
                       DO J=1,i-1
                          TMP_SUM=((dble(NELIM) * dble(NB_ROWS(J)+X))   &
     &                         +(dble(NB_ROWS(J)+X)*dble(NELIM))*       &
     &                         dble(2*NFRONT-NELIM-1))
                          IF((TEMP(J)+TMP_SUM).GT.MAX_LOAD)THEN
                             ACC=0
                          ENDIF
                       ENDDO
                       IF(ACC.EQ.1)THEN
                          MAX_LOAD=TEMP(i)
                          J=1
                          DO WHILE ((ADDITIONNAL_ROWS.NE.0)             &
     &                         .AND.(J.LT.i))
                             AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                             BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                             IF(HAVE_TYPE1_SON)THEN
                                AFFECTED=int((BUF_SIZE-dble(NFRONT))/   &
     &                               dble(NFRONT+1))
                                BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                             ENDIF
                             AFFECTED=X
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                             IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                                AFFECTED=ADDITIONNAL_ROWS
                             ENDIF
                             IF(NB_ROWS(J).LT.KMAX)THEN
                                IF((AFFECTED+NB_ROWS(J)).GT.KMAX)THEN
                                   AFFECTED=KMAX-NB_ROWS(J)
                                   NB_SAT=NB_SAT+1
                                ELSE
                                   IF((AFFECTED+NB_ROWS(J)).LT.         &
     &                                  KMIN)THEN
                                      AFFECTED=0
                                   ENDIF
                                ENDIF
                                NB_ROWS(J)=NB_ROWS(J)+AFFECTED
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-      &
     &                               AFFECTED
                             ENDIF
                             J=J+1
                          ENDDO
                       ELSE
                          MAX_LOAD=TEMP(i)
                          J=1
                          DO WHILE ((ADDITIONNAL_ROWS.NE.0)             &
     &                         .AND.(J.LT.i))
                             AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                             BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                             IF(HAVE_TYPE1_SON)THEN
                                AFFECTED=int((BUF_SIZE-dble(NFRONT))/   &
     &                               dble(NFRONT+1))
                                BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                             ENDIF
                             TMP_SUM=((dble(NELIM)* dble(NB_ROWS(J)))   &
     &                            +(dble(NB_ROWS(J))*dble(NELIM))*      &
     &                            dble(2*NFRONT-NELIM-1))
                             X=int((MAX_LOAD-(TEMP(J)+TMP_SUM))/        &
     &                            (dble(NELIM)*dble(2*NFRONT-NELIM)))
                             IF(X.LT.0)THEN
                                WRITE(*,*)MYID,                         &
     &    ': Internal error 10 in DMUMPS_518'
                                CALL AGMG_MUMPS_ABORT()
                             ENDIF
                             AFFECTED=X
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                             IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                                AFFECTED=ADDITIONNAL_ROWS
                             ENDIF
                             IF(NB_ROWS(J).LT.KMAX)THEN
                                IF((AFFECTED+NB_ROWS(J)).GT.KMAX)THEN
                                   AFFECTED=KMAX-NB_ROWS(J)
                                   NB_SAT=NB_SAT+1
                                ELSE
                                   IF((AFFECTED+NB_ROWS(J)).LT.         &
     &                                  KMIN)THEN
                                      AFFECTED=0
                                   ENDIF
                                ENDIF
                                NB_ROWS(J)=NB_ROWS(J)+AFFECTED
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-      &
     &                               AFFECTED
                             ENDIF
                             J=J+1
                          ENDDO
                       ENDIF
                    ENDIF
  218               CONTINUE
                    i=i+1
                 ENDDO
                 CHOSEN=i-1
                 IF((CHOSEN.EQ.NUMBER_OF_PROCS-1).AND.                  &
     &                 (ADDITIONNAL_ROWS.NE.0))THEN
                    DO i=1,CHOSEN
                       IF(NB_ROWS(i)+1.GE.KMIN)THEN
                          NB_ROWS(i)=NB_ROWS(i)+1
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-1
                       ENDIF
                       MAX_LOAD=max(MAX_LOAD,                           &
     &                      (TEMP(i)+(dble(NELIM) *                     &
     &                      dble(NB_ROWS(i)))+                          &
     &                      (dble(NB_ROWS(i))*dble(NELIM))*             &
     &                      dble(2*NFRONT-NELIM-1)))
                       IF(ADDITIONNAL_ROWS.EQ.0) GOTO 048
                    ENDDO
   48               CONTINUE
                 ENDIF
                 IF((ADDITIONNAL_ROWS.NE.0))THEN
                    IF(CHOSEN.LT.NUMBER_OF_PROCS)THEN
                       i=CHOSEN+1
                    ELSE
                       IF(CHOSEN.NE.NUMBER_OF_PROCS)THEN
                          WRITE(*,*)MYID,                               &
     &    ': Internal error 11 in DMUMPS_518'
                          CALL AGMG_MUMPS_ABORT()
                       ENDIF
                       i=CHOSEN
                    ENDIF
                    DO WHILE ((ADDITIONNAL_ROWS.NE.0)                   &
     &                   .AND.(i.LE.NUMBER_OF_PROCS))
                       IF(TEMP(i).LE.MAX_LOAD)THEN
                          AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             AFFECTED=int((BUF_SIZE-dble(NFRONT))/      &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          ENDIF
                          MAX_MEM_ALLOW=BANDE_K821
                          IF(BDC_MD)THEN
                             MAX_MEM_ALLOW=min(                         &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                            BANDE_K821)
                             MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                          ENDIF
                          KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                          TMP_SUM=((dble(NELIM) * dble(NB_ROWS(i)))     &
     &                         +(dble(NB_ROWS(i))*dble(NELIM))*         &
     &                         dble(2*NFRONT-NELIM-1))
                          X=int((MAX_LOAD-(TEMP(i)+TMP_SUM))/           &
     &                         (dble(NELIM)*dble(2*NFRONT-NELIM)))
                          AFFECTED=X
                          IF(X.LT.0)THEN
                             WRITE(*,*)MYID,                            &
     &    ': Internal error 12 in DMUMPS_518'
                             CALL AGMG_MUMPS_ABORT()
                          ENDIF
                          IF(AFFECTED.GT.ADDITIONNAL_ROWS)THEN
                             AFFECTED=ADDITIONNAL_ROWS
                          ENDIF
                          IF(NB_ROWS(i).LT.KMAX)THEN
                             IF((AFFECTED+NB_ROWS(i)).GT.KMAX)THEN
                                AFFECTED=KMAX-NB_ROWS(i)
                             ELSE
                                IF((AFFECTED+NB_ROWS(i)).LT.            &
     &                               KMIN)THEN
                                   AFFECTED=0
                                ENDIF
                             ENDIF
                             NB_ROWS(i)=NB_ROWS(i)+AFFECTED
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-AFFECTED
                          ENDIF
                          IF(i.NE.NUMBER_OF_PROCS) GOTO 624
                       ELSE IF((TEMP(i).GT.MAX_LOAD))THEN
                          X=int(ADDITIONNAL_ROWS/i-1)
                          X=max(X,1)
                          IF((MAX_LOAD+((dble(NELIM)*                   &
     &                         dble(X))+(dble(                          &
     &                         X)*dble(NELIM))*dble(                    &
     &                         (2*NFRONT-NELIM-1)))).LE.TEMP(i))THEN
                             AFFECTED=X
                             POS=1
                          ELSE
                             POS=0
                          ENDIF
                          MAX_LOAD=TEMP(i)
                          J=1
                          DO WHILE ((ADDITIONNAL_ROWS.NE.0)             &
     &                         .AND.(J.LT.i))
                             X=int(BUF_SIZE/dble(NCB+1))-1
                             BANDE_K821=dble(X)*dble(NFRONT)
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(HAVE_TYPE1_SON)THEN
                                X=int((BUF_SIZE-dble(NFRONT))/          &
     &                               dble(NFRONT+1))
                                BANDE_K821=dble(X)*dble(NFRONT)
                             ENDIF
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                             IF(POS.EQ.0)THEN
                                TMP_SUM=((dble(NELIM) *                 &
     &                               dble(NB_ROWS(J)))                  &
     &                               +(dble(NB_ROWS(J))*dble(NELIM))*   &
     &                               dble(2*NFRONT-NELIM-1))
                                X=int((TEMP(i)-(TEMP(J)+TMP_SUM))/      &
     &                               (dble(NELIM)*dble(2*NFRONT-        &
     &                               NELIM)))
                             ELSE
                                X=int(TMP_SUM)
                             ENDIF
                             IF(X.GT.ADDITIONNAL_ROWS)THEN
                                X=ADDITIONNAL_ROWS
                             ENDIF
                             IF(NB_ROWS(J).LT.KMAX)THEN
                                IF((X+NB_ROWS(J)).GT.KMAX)THEN
                                   X=KMAX-NB_ROWS(J)
                                ELSE
                                   IF((NB_ROWS(J)+X).LT.                &
     &                                  KMIN)THEN
                                     X=0
                                  ENDIF
                               ENDIF
                               NB_ROWS(J)=NB_ROWS(J)+X
                               ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                            ENDIF
                            J=J+1
                         ENDDO
                       ENDIF
  624                  CONTINUE
                       i=i+1
                    ENDDO
                    CHOSEN=i-1
                    IF(ADDITIONNAL_ROWS.NE.0)THEN
                       ACC=0
                       DO i=1,CHOSEN
                          X=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(X)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             X=int((BUF_SIZE-dble(NFRONT))/             &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(X)*dble(NFRONT)
                          ENDIF
                          MAX_MEM_ALLOW=BANDE_K821
                          IF(BDC_MD)THEN
                             MAX_MEM_ALLOW=min(                         &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                            BANDE_K821)
                             MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                          ENDIF
                             KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                          TMP_SUM=((dble(NELIM) * dble(NB_ROWS(i)))     &
     &                    +(dble(NB_ROWS(i))*dble(NELIM))*              &
     &                    dble(2*NFRONT-NELIM-1))
                          X=int((MAX_LOAD-                              &
     &                         (TEMP(i)+TMP_SUM))/                      &
     &                         (dble(NELIM)*dble(2*NFRONT-NELIM)))
                          IF(X.LT.0)THEN
                             WRITE(*,*)MYID,                            &
     &    ': Internal error 13 in DMUMPS_518'
                             CALL AGMG_MUMPS_ABORT()
                          ENDIF
                          IF(X.GT.ADDITIONNAL_ROWS)THEN
                             X=ADDITIONNAL_ROWS
                          ENDIF
                          IF(NB_ROWS(i).LT.KMAX)THEN
                             IF((X+NB_ROWS(i)).GE.KMAX)THEN
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-      &
     &                               (KMAX-NB_ROWS(i))
                                NB_ROWS(i)=KMAX
                             ELSE
                                IF((X+NB_ROWS(i)).GE.                   &
     &                               KMIN)THEN
                                   NB_ROWS(i)=NB_ROWS(i)+X
                                   ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                                   ACC=ACC+1
                                ELSE
                                   ACC=ACC+1
                                ENDIF
                             ENDIF
                          ENDIF
                          IF(ADDITIONNAL_ROWS.EQ.0)GOTO 049
                       ENDDO
                       IF(CHOSEN.LT.NUMBER_OF_PROCS)THEN
                          CHOSEN=CHOSEN+1
                       ENDIF
                       IF(ACC.EQ.0)THEN
                          ACC=1
                       ENDIF
                       X=int(ADDITIONNAL_ROWS/ACC)
                       X=max(X,1)
                       ACC=0
                       DO i=1,CHOSEN
                          J=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(J)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             J=int((BUF_SIZE-dble(NFRONT))/             &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(J)*dble(NFRONT)
                          ENDIF
                          MAX_MEM_ALLOW=BANDE_K821
                          IF(BDC_MD)THEN
                             MAX_MEM_ALLOW=min(                         &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                            BANDE_K821)
                             MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                          ENDIF
                          KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                          TMP_SUM=((dble(NELIM) * dble(NB_ROWS(i)))     &
     &                         +(dble(NB_ROWS(i))*dble(NELIM))*         &
     &                         dble(2*NFRONT-NELIM-1))
                          J=int((MAX_LOAD-                              &
     &                         (TEMP(i)+TMP_SUM))/                      &
     &                         (dble(NELIM)*dble(2*NFRONT-NELIM)))
                          IF(NB_ROWS(i).LT.KMAX)THEN
                             IF((min(X,J)+NB_ROWS(i)).GE.KMAX)THEN
                                IF((KMAX-NB_ROWS(i)).GT.                &
     &                               ADDITIONNAL_ROWS)THEN
                                   NB_ROWS(i)=NB_ROWS(i)+               &
     &                                  ADDITIONNAL_ROWS
                                   ADDITIONNAL_ROWS=0
                                ELSE
                                   ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-   &
     &                                  (KMAX-NB_ROWS(i))
                                   NB_ROWS(i)=KMAX
                                ENDIF
                             ELSE
                                IF((min(X,J)+NB_ROWS(i)).GE.            &
     &                            KMIN)THEN
                                   NB_ROWS(i)=NB_ROWS(i)+min(X,J)
                                   ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-   &
     &                                  min(X,J)
                                   ACC=ACC+1
                                ENDIF
                             ENDIF
                          ENDIF
                          IF(ADDITIONNAL_ROWS.EQ.0)GOTO 049
                       ENDDO
                       IF(ACC.GT.0)THEN
                          DO i=1,CHOSEN
                             X=int(BUF_SIZE/dble(NCB+1))-1
                             BANDE_K821=dble(X)*dble(NFRONT)
                             IF(HAVE_TYPE1_SON)THEN
                                X=int((BUF_SIZE-dble(NFRONT))/          &
     &                               dble(NFRONT+1))
                                BANDE_K821=dble(X)*dble(NFRONT)
                             ENDIF
                             MAX_MEM_ALLOW=BANDE_K821
                             IF(BDC_MD)THEN
                                MAX_MEM_ALLOW=min(                      &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)),     &
     &                               BANDE_K821)
                                MAX_MEM_ALLOW=max(dble(0),              &
     &                               MAX_MEM_ALLOW)
                             ENDIF
                             KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                             IF(KMAX-NB_ROWS(i).LT.                     &
     &                            ADDITIONNAL_ROWS)THEN
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-      &
     &                               (KMAX-NB_ROWS(i))
                                NB_ROWS(i)=KMAX
                             ELSE
                                IF(NB_ROWS(i).EQ.0)THEN
                                   IF(min(KMIN,KMAX).LT.                &
     &                                  ADDITIONNAL_ROWS)THEN
                                      NB_ROWS(i)=min(KMIN,KMAX)
                                      ADDITIONNAL_ROWS=                 &
     &                                     ADDITIONNAL_ROWS-            &
     &                                     min(KMIN,KMAX)
                                   ENDIF
                                ELSE
                                   NB_ROWS(i)=NB_ROWS(i)+               &
     &                                  ADDITIONNAL_ROWS
                                   ADDITIONNAL_ROWS=0
                                ENDIF
                             ENDIF
                             IF(ADDITIONNAL_ROWS.EQ.0)GOTO 049
                          ENDDO
                       ENDIF
                       DO i=1,CHOSEN
                          IDWLOAD(i)=i
                          AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             AFFECTED=int((BUF_SIZE-dble(NFRONT))/      &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          ENDIF
                          WLOAD(i)=(BANDE_K821-dble(NB_ROWS(i)*NFRONT))
                       ENDDO
                       CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, WLOAD,           &
     &                      IDWLOAD)
                       NB_SAT=0
                       DO i=1,CHOSEN
                          X=int(ADDITIONNAL_ROWS/(CHOSEN-NB_SAT))
                          X=max(X,1)
                          AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             AFFECTED=int((BUF_SIZE-dble(NFRONT))/      &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                          ENDIF
                          IF(BDC_MD)THEN
                             MAX_MEM_ALLOW=min(BANDE_K821,              &
     &                            MEM_SIZE_STRONG(i))
                             MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                          ENDIF
                          KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                          IF(NB_ROWS(IDWLOAD(i)).LT.KMAX)THEN
                             IF((NB_ROWS(IDWLOAD(i))+X).LT.KMAX)THEN
                                NB_ROWS(IDWLOAD(i))=                    &
     &                               NB_ROWS(IDWLOAD(i))+X
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                             ELSE
                                ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-      &
     &                               (KMAX-NB_ROWS(IDWLOAD(i)))
                                NB_ROWS(IDWLOAD(i))=KMAX
                             ENDIF
                          ENDIF
                          IF(NB_ROWS(IDWLOAD(i)).EQ.KMAX)THEN
                             NB_SAT=NB_SAT+1
                          ENDIF
                          IF(ADDITIONNAL_ROWS.EQ.0) GOTO 049
                       ENDDO
                       DO i=1,CHOSEN
                          X=int(BUF_SIZE/dble(NCB+1))-1
                          BANDE_K821=dble(X)*dble(NFRONT)
                          IF(HAVE_TYPE1_SON)THEN
                             X=int((BUF_SIZE-dble(NFRONT))/             &
     &                            dble(NFRONT+1))
                             BANDE_K821=dble(X)*dble(NFRONT)
                          ENDIF
                          MAX_MEM_ALLOW=BANDE_K821
                          IF(BDC_MD)THEN
                             MAX_MEM_ALLOW=min(BANDE_K821,              &
     &                            MEM_SIZE_STRONG(i))
                             MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                          ENDIF
                          KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                          IF(KMAX-NB_ROWS(i).LT.ADDITIONNAL_ROWS)THEN
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-         &
     &                            (KMAX-NB_ROWS(i))
                             NB_ROWS(i)=KMAX
                          ELSE
                             NB_ROWS(i)=NB_ROWS(i)+ADDITIONNAL_ROWS
                             ADDITIONNAL_ROWS=0
                          ENDIF
                          IF(ADDITIONNAL_ROWS.EQ.0)GOTO 049
                       ENDDO
                       X=int(ADDITIONNAL_ROWS/CHOSEN)
                       X=max(X,1)
                       DO i=1,CHOSEN
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                          NB_ROWS(i)=NB_ROWS(i)+X
                          IF(ADDITIONNAL_ROWS.EQ.0)GOTO 049
                       ENDDO
                       NB_ROWS(1)=NB_ROWS(1)+ADDITIONNAL_ROWS
                    ENDIF
                 ENDIF
   49            CONTINUE
              ENDIF
  666         CONTINUE
              SOMME=dble(0)
              X=0
              POS=0
              DO i=1,CHOSEN
                 X=X+NB_ROWS(i)
                 SOMME=SOMME+ dble(NB_ROWS(i))
              ENDDO
              GOTO 890
           ELSE IF((KEEP(83).GE.NUMBER_OF_PROCS).AND.FORCE_CAND)THEN
              MAX_LOAD=dble(0)
              DO i=1,OTHERS
                 MAX_LOAD=max(MAX_LOAD,TEMP(i))
              ENDDO
              ACC=0
              CHOSEN=0
              X=1
              DO i=1,OTHERS
              ENDDO
              DO i=2,OTHERS
                 IF(TEMP(i).EQ.TEMP(1))THEN
                    X=X+1
                 ELSE
                    GOTO 329
                 ENDIF
              ENDDO
  329         CONTINUE
              TMP_SUM=TOTAL_COST/dble(X)
              TEMP_MAX_LOAD=dble(0)
              DO i=1,OTHERS
                 IF(K50.EQ.0)THEN
                    X=int(BUF_SIZE/dble(NCB+1))-1
                    BANDE_K821=dble(X)*dble(NFRONT)
                 ELSE
                    A=dble(1)
                    B=dble(ACC+2)
                    C=-BUF_SIZE+dble(ACC+NELIM)
                    DELTA=(B*B)-(dble(4)*A*C)
                    X=int((-B+sqrt(DELTA))/(dble(2)*A))
                    IF(X.GT.NCB-ACC) X=NCB-ACC
                    BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                 ENDIF
                 IF(HAVE_TYPE1_SON)THEN
                    IF(K50.EQ.0)THEN
                       X=int((BUF_SIZE-dble(NFRONT))/dble(NFRONT+1))
                       BANDE_K821=dble(X)*dble(NFRONT)
                    ELSE
                       A=dble(1)
                       B=dble(ACC+2+NELIM)
                       C=-BUF_SIZE+dble(ACC+NELIM)
                       DELTA=(B*B)-(dble(4)*A*C)
                       X=int((-B+sqrt(DELTA))/(dble(2)*A))
                       IF(X.GT.NCB-ACC) X=NCB-ACC
                       BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                    ENDIF
                 ENDIF
                 MAX_MEM_ALLOW=BANDE_K821
                 IF(BDC_MD)THEN
                    MAX_MEM_ALLOW=min(BANDE_K821,                       &
     &                    min(MEM_SIZE_WEAK(i),MEM_SIZE_STRONG(i)))
                    MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                 ENDIF
                 IF(K50.EQ.0)THEN
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                    IF(TMP_SUM+TEMP(i).GT.MAX_LOAD)THEN
                       SOMME=MAX_LOAD-TEMP(i)
                    ELSE
                       SOMME=TMP_SUM
                    ENDIF
                    X=int(SOMME/                                        &
     &                   (dble(NELIM)*dble(2*NFRONT-NELIM)))
                    IF(X.GT.KMAX)THEN
                       X=KMAX
                    ELSE
                       IF(X.LT.KMIN)THEN
                          X=min(KMIN,KMAX)
                       ENDIF
                    ENDIF
                    IF((ACC+X).GT.NCB) X=NCB-ACC
                 ENDIF
                 IF(K50.NE.0)THEN
                       A=dble(1)
                       B=dble(ACC+NELIM)
                       C=dble(-MAX_MEM_ALLOW)
                       DELTA=((B*B)-(dble(4)*A*C))
                       KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                    A=dble(NELIM)
                    B=dble(NELIM)*dble(NELIM+2*ACC+1)
                    IF(TMP_SUM+TEMP(i).GT.MAX_LOAD)THEN
                       C=-(MAX_LOAD-TEMP(i))
                    ELSE
                       C=-TMP_SUM
                    ENDIF
                    DELTA=(B*B-(dble(4)*A*C))
                    X=int((-B+sqrt(DELTA))/(dble(2)*A))
                    IF(X.LT.0) THEN
                       WRITE(*,*)MYID,                                  &
     &    ': Internal error 14 in DMUMPS_518'
                       CALL AGMG_MUMPS_ABORT()
                    ENDIF
                    IF(X.GE.KMAX)THEN
                       IF(KMAX.GT.KMIN)THEN
                          X=KMAX
                       ELSE
                          X=0
                       ENDIF
                    ELSE
                       IF(X.LE.min(KMIN,KMAX))THEN
                          IF(KMAX.LT.KMIN)THEN
                             X=0
                          ELSE
                             X=min(KMIN,KMAX)
                          ENDIF
                       ENDIF
                    ENDIF
                    IF((ACC+X).GT.NCB) X=NCB-ACC
                 ENDIF
                 TEMP_MAX_LOAD=max(TEMP_MAX_LOAD,TEMP(i))
                 NB_ROWS(i)=X
                 CHOSEN=CHOSEN+1
                 ACC=ACC+X
                 IF(ACC.EQ.NCB) GOTO 541
              ENDDO
  541         CONTINUE
              IF(ACC.LT.NCB)THEN
                 IF(K50.EQ.0)THEN
                    ADDITIONNAL_ROWS=NCB-ACC
                    DO J=1,CHOSEN
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(                            &
     &                    min(MEM_SIZE_WEAK(J),MEM_SIZE_STRONG(J)),     &
     &                         dble(BANDE_K821))
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       IF((NB_ROWS(J)).LT.KMAX)THEN
                          IF(ADDITIONNAL_ROWS.GT.(KMAX-NB_ROWS(J)))THEN
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-         &
     &                            (KMAX-NB_ROWS(J))
                             NB_ROWS(J)=KMAX
                          ELSE
                             NB_ROWS(J)=NB_ROWS(J)+ADDITIONNAL_ROWS
                             ADDITIONNAL_ROWS=0
                          ENDIF
                       ENDIF
                       IF(ADDITIONNAL_ROWS.EQ.0)GOTO 889
                    ENDDO
                    X=int(ADDITIONNAL_ROWS/CHOSEN)
                    X=max(X,1)
                    DO J=1,CHOSEN
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(BANDE_K821,                 &
     &                         MEM_SIZE_STRONG(J))
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       IF((NB_ROWS(J)+X).GT.KMAX)THEN
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-            &
     &                         (KMAX-NB_ROWS(J))
                          NB_ROWS(J)=KMAX
                       ELSE
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                          NB_ROWS(J)=NB_ROWS(J)+X
                       ENDIF
                       IF(ADDITIONNAL_ROWS.EQ.0)GOTO 889
                    ENDDO
                    DO i=1,CHOSEN
                       X=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(X)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          X=int((BUF_SIZE-dble(NFRONT))/                &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(X)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(BANDE_K821,                 &
     &                         MEM_SIZE_STRONG(i))
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       IF(KMAX-NB_ROWS(i).LT.ADDITIONNAL_ROWS)THEN
                          ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-            &
     &                         (KMAX-NB_ROWS(i))
                          NB_ROWS(i)=KMAX
                       ELSE
                          NB_ROWS(i)=NB_ROWS(i)+ADDITIONNAL_ROWS
                          ADDITIONNAL_ROWS=0
                       ENDIF
                       IF(ADDITIONNAL_ROWS.EQ.0)GOTO 889
                    ENDDO
                    DO i=1,NUMBER_OF_PROCS
                       IDWLOAD(i)=i
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       WLOAD(i)=(BANDE_K821-(dble(NB_ROWS(i))*          &
     &                      dble(NFRONT)))
                    ENDDO
                    CALL AGMG_MUMPS_558(NUMBER_OF_PROCS, WLOAD,              &
     &                   IDWLOAD)
                    NB_SAT=0
                    DO i=1,CHOSEN
                       X=int(ADDITIONNAL_ROWS/(CHOSEN-NB_SAT))
                       X=max(X,1)
                       AFFECTED=int(BUF_SIZE/dble(NCB+1))-1
                       BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       IF(HAVE_TYPE1_SON)THEN
                          AFFECTED=int((BUF_SIZE-dble(NFRONT))/         &
     &                         dble(NFRONT+1))
                          BANDE_K821=dble(AFFECTED)*dble(NFRONT)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       KMAX=int(MAX_MEM_ALLOW/dble(NFRONT))
                       IF(NB_ROWS(IDWLOAD(i)).LT.KMAX)THEN
                          IF((NB_ROWS(IDWLOAD(i))+X).LT.KMAX)THEN
                             NB_ROWS(IDWLOAD(i))=                       &
     &                            NB_ROWS(IDWLOAD(i))+X
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                          ELSE
                             ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-         &
     &                            (KMAX-NB_ROWS(IDWLOAD(i)))
                             NB_ROWS(IDWLOAD(i))=KMAX
                          ENDIF
                       ENDIF
                       IF(NB_ROWS(IDWLOAD(i)).EQ.KMAX)THEN
                          NB_SAT=NB_SAT+1
                       ENDIF
                       IF(ADDITIONNAL_ROWS.EQ.0) GOTO 889
                    ENDDO
                    GOTO 994
                 ELSE
                    ACC=0
                    CHOSEN=0
                    DO i=1,OTHERS
                       A=dble(1)
                       B=dble(ACC+2)
                       C=-BUF_SIZE+dble(ACC+NELIM)
                       DELTA=(B*B)-(dble(4)*A*C)
                       X=int((-B+sqrt(DELTA))/(dble(2)*A))
                       IF(X.GT.NCB-ACC) X=NCB-ACC
                       BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                       IF(HAVE_TYPE1_SON)THEN
                          A=dble(1)
                          B=dble(ACC+2+NELIM)
                          C=-BUF_SIZE+dble(ACC+NELIM)
                          DELTA=(B*B)-(dble(4)*A*C)
                          X=int((-B+sqrt(DELTA))/(dble(2)*A))
                          IF(X.GT.NCB-ACC) X=NCB-ACC
                          BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                       ENDIF
                       MAX_MEM_ALLOW=BANDE_K821
                       IF(BDC_MD)THEN
                          MAX_MEM_ALLOW=min(BANDE_K821,                 &
     &                         MEM_SIZE_STRONG(i))
                          MAX_MEM_ALLOW=max(dble(0),MAX_MEM_ALLOW)
                       ENDIF
                       A=dble(1)
                       B=dble(ACC+NELIM)
                       C=dble(-MAX_MEM_ALLOW)
                       DELTA=((B*B)-(dble(4)*A*C))
                       KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                       X=KMAX-NB_ROWS(i)
                       IF((ACC+NB_ROWS(i)+X).GT.NCB)                    &
     &                            X=NCB-(ACC+NB_ROWS(i))
                       NB_ROWS(i)=NB_ROWS(i)+X
                       ACC=ACC+NB_ROWS(i)
                       CHOSEN=CHOSEN+1
                       IF(NCB.EQ.ACC) GOTO 889
                    ENDDO
                    ADDITIONNAL_ROWS=NCB-ACC
                 ENDIF
  993            CONTINUE
                 ACC=0
                 CHOSEN=0
                 DO i=1,OTHERS
                    A=dble(1)
                    B=dble(ACC+2)
                    C=-BUF_SIZE+dble(ACC+NELIM)
                    DELTA=(B*B)-(dble(4)*A*C)
                    X=int((-B+sqrt(DELTA))/(dble(2)*A))
                    IF(X.GT.NCB-ACC) X=NCB-ACC
                    BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                    IF(HAVE_TYPE1_SON)THEN
                       A=dble(1)
                       B=dble(ACC+2+NELIM)
                       C=-BUF_SIZE+dble(ACC+NELIM)
                       DELTA=(B*B)-(dble(4)*A*C)
                       X=int((-B+sqrt(DELTA))/(dble(2)*A))
                       IF(X.GT.NCB-ACC) X=NCB-ACC
                       BANDE_K821=dble(X)*dble(NELIM+ACC+X)
                    ENDIF
                    MAX_MEM_ALLOW=BANDE_K821
                    A=dble(1)
                    B=dble(ACC+NELIM)
                    C=dble(-MAX_MEM_ALLOW)
                    DELTA=((B*B)-(dble(4)*A*C))
                    KMAX=int((-B+sqrt(DELTA))/(dble(2)*A))
                    X=KMAX-NB_ROWS(i)
                    IF((ACC+NB_ROWS(i)+X).GT.NCB)                       &
     &                   X=NCB-(ACC+NB_ROWS(i))
                    NB_ROWS(i)=NB_ROWS(i)+X
                    ACC=ACC+NB_ROWS(i)
                    CHOSEN=CHOSEN+1
                    IF(NCB.EQ.ACC) GOTO 889
                 ENDDO
                 ADDITIONNAL_ROWS=NCB-ACC
  994            CONTINUE
                 X=int(dble(ADDITIONNAL_ROWS)/dble(OTHERS))
                 IF((X*OTHERS).LT.ADDITIONNAL_ROWS)THEN
                    X=X+1
                 ENDIF
                 DO i=1,OTHERS
                    NB_ROWS(i)=NB_ROWS(i)+X
                    ADDITIONNAL_ROWS=ADDITIONNAL_ROWS-X
                    IF(ADDITIONNAL_ROWS.LT.X)X=ADDITIONNAL_ROWS
                 ENDDO
                 CHOSEN=OTHERS
              ENDIF
           ENDIF
  889      CONTINUE
           MAX_LOAD=TEMP_MAX_LOAD
  890      CONTINUE
           J=CHOSEN
           X=0
              DO i=J,1,-1
                 IF(NB_ROWS(i).EQ.0)THEN
                    CHOSEN=CHOSEN-1
                    ELSE
                       IF(NB_ROWS(i).GT.0)THEN
                          X=1
                       ELSE
                          WRITE(*,*)MYID,                               &
     &    ': Internal error 15 in DMUMPS_518'
                          CALL AGMG_MUMPS_ABORT()
                       ENDIF
                    ENDIF
                 ENDDO
           NSLAVES_NODE=CHOSEN
           TAB_POS(NSLAVES_NODE+1)= NCB+1
           TAB_POS(SLAVEF+2) = CHOSEN
           POS=1
           X=1
           DO i=1,J
              IF(NB_ROWS(i).NE.0)THEN
                 SLAVES_LIST(X)=TEMP_ID(i)
                 TAB_POS(X)=POS
                 POS=POS+NB_ROWS(i)
                 IF(NB_ROWS(i).LE.0)THEN
                    WRITE(*,*)MYID,                                     &
     &    ': Internal error 16 in DMUMPS_518'
                    CALL AGMG_MUMPS_ABORT()
                 ENDIF
                 X=X+1
               ENDIF
           ENDDO
           DO i=CHOSEN+1,NUMBER_OF_PROCS
              SLAVES_LIST(i)=TEMP_ID(i)
           ENDDO
           IF(POS.NE.(NCB+1))THEN
              WRITE(*,*)MYID,                                           &
     &    ': Internal error 17 in DMUMPS_518',                          &
     &             POS,NCB+1
             CALL AGMG_MUMPS_ABORT()
           ENDIF
      END SUBROUTINE DAGMG_MUMPS_518
      SUBROUTINE DAGMG_MUMPS_520                                             &
     &      (INODE,UPPER,SLAVEF,KEEP,KEEP8,                             &
     &       STEP,POOL,LPOOL,PROCNODE,N)
      IMPLICIT NONE
      INTEGER INODE, LPOOL, SLAVEF, N
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER STEP(KEEP(28)), POOL(LPOOL), PROCNODE(KEEP(28))
      LOGICAL UPPER
      INTEGER J
      DOUBLE PRECISION MEM_COST
      INTEGER NBINSUBTREE,i,NBTOP
      EXTERNAL AGMG_MUMPS_167, AGMG_MUMPS_283, DAGMG_MUMPS_508,                        &
     & AGMG_MUMPS_170
      LOGICAL AGMG_MUMPS_167, AGMG_MUMPS_283, DAGMG_MUMPS_508,                         &
     & AGMG_MUMPS_170
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      IF(KEEP(47).LT.2)THEN
         WRITE(*,*)'DMUMPS_520 must                                     &
     &        be called with K47>=2'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF((INODE.GT.0).AND.(INODE.LE.N))THEN
      MEM_COST=DAGMG_MUMPS_543(INODE)
         IF((DM_MEM(MYID)+dble(MEM_COST)+ PEAK_SBTR_CUR_LOCAL-          &
     &        SBTR_CUR_LOCAL)                                           &
     &        .GT.MAX_PEAK_STK)THEN
            DO i=NBTOP-1,1,-1
               INODE = POOL( LPOOL - 2 - i)
               MEM_COST=DAGMG_MUMPS_543(INODE)
               IF((INODE.LT.0).OR.(INODE.GT.N)) THEN
                  DO J=i+1,NBTOP,-1
                     POOL(J-1)=POOL(J)
                  ENDDO
                  UPPER=.TRUE.
                  RETURN
               ENDIF
               IF((DM_MEM(MYID)+dble(MEM_COST)+PEAK_SBTR_CUR_LOCAL-     &
     &              SBTR_CUR_LOCAL).LE.                                 &
     &              MAX_PEAK_STK) THEN
                  DO J=i+1,NBTOP,-1
                     POOL(J-1)=POOL(J)
                  ENDDO
                  UPPER=.TRUE.
                  RETURN
               ENDIF
            ENDDO
            IF(NBINSUBTREE.NE.0)THEN
               INODE = POOL( NBINSUBTREE )
               IF(.NOT.AGMG_MUMPS_170(STEP(INODE),                           &
     &              PROCNODE,SLAVEF))THEN
                  WRITE(*,*)                                            &
     &        'Internal error 1 in DMUMPS_520'
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
               UPPER=.FALSE.
               RETURN
            ENDIF
            INODE=POOL(LPOOL-2-NBTOP)
            UPPER=.TRUE.
            RETURN
         ENDIF
      ENDIF
      UPPER=.TRUE.
      END SUBROUTINE DAGMG_MUMPS_520
      SUBROUTINE DAGMG_MUMPS_513(WHAT)
      IMPLICIT NONE
      LOGICAL WHAT
      IF(.NOT.BDC_POOL_MNG)THEN
         WRITE(*,*)'DMUMPS_513                                          &
     &        should be called when K81>0 and K47>2'
      ENDIF
      IF(WHAT)THEN
         PEAK_SBTR_CUR_LOCAL=PEAK_SBTR_CUR_LOCAL+                       &
     &        dble(MEM_SUBTREE(INDICE_SBTR))
         IF(.NOT.BDC_SBTR) INDICE_SBTR=INDICE_SBTR+1
      ELSE
         PEAK_SBTR_CUR_LOCAL=dble(0)
         SBTR_CUR_LOCAL=dble(0)
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_513
      DOUBLE PRECISION FUNCTION DAGMG_MUMPS_543( INODE )
      IMPLICIT NONE
      INTEGER INODE,LEVEL,i,NELIM,NFR
      DOUBLE PRECISION COST
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      i = INODE
      NELIM = 0
   10 CONTINUE
      IF ( i > 0 ) THEN
        NELIM = NELIM + 1
        i = FILS_LOAD(i)
        GOTO 10
      ENDIF
      NFR = ND_LOAD( STEP_LOAD(INODE) )
      LEVEL = AGMG_MUMPS_330( STEP_LOAD(INODE), PROCNODE_LOAD, NPROCS )
      IF (LEVEL .EQ. 1) THEN
        COST =  dble(NFR) * dble(NFR)
      ELSE
        IF ( K50 == 0 ) THEN
           COST =  dble(NFR) * dble(NELIM)
        ELSE
           COST = dble(NELIM) * dble(NELIM)
        ENDIF
      ENDIF
      DAGMG_MUMPS_543=COST
      RETURN
      END FUNCTION DAGMG_MUMPS_543
      RECURSIVE SUBROUTINE DAGMG_MUMPS_515(FLAG,COST,COMM)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER COMM,WHAT,IERR
      LOGICAL FLAG
      DOUBLE PRECISION COST
      DOUBLE PRECISION TO_BE_SENT
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      IF(FLAG)THEN
         WHAT=17
         IF(BDC_M2_FLOPS)THEN
            TO_BE_SENT=DELTA_LOAD-COST
            DELTA_LOAD=dble(0)
         ELSE IF(BDC_M2_MEM)THEN
            IF(BDC_POOL.AND.(.NOT.BDC_MD))THEN
               TO_BE_SENT=max(TMP_M2,POOL_LAST_COST_SENT)
               POOL_LAST_COST_SENT=TO_BE_SENT
            ELSE IF(BDC_MD)THEN
               DELTA_MEM=DELTA_MEM+TMP_M2
               TO_BE_SENT=DELTA_MEM
            ELSE
               TO_BE_SENT=dble(0)
            ENDIF
         ENDIF
      ELSE
         WHAT=6
         TO_BE_SENT=dble(0)
      ENDIF
  111 CONTINUE
      CALL DAGMG_MUMPS_460( WHAT,                                            &
     &         COMM, NPROCS,                                            &
     &               FUTURE_NIV2,                                       &
     &         COST,                                                    &
     &         TO_BE_SENT,                                              &
     &         MYID, IERR  )
      IF ( IERR == -1 )THEN
         CALL DAGMG_MUMPS_467(COMM_LD, KEEP_LOAD)
         GOTO 111
      ELSE IF ( IERR .NE. 0 ) THEN
         WRITE(*,*) "Internal Error in DAGMG_MUMPS_500",                     &
     &   IERR
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_515
      SUBROUTINE DAGMG_MUMPS_512(INODE,STEP,NSTEPS,PROCNODE,FRERE,           &
     &     NE,COMM,SLAVEF,MYID,KEEP,KEEP8,N)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER INODE,NSTEPS,MYID,SLAVEF,COMM,N
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER FRERE(NSTEPS),NE(NSTEPS),STEP(N),PROCNODE(NSTEPS)
      EXTERNAL AGMG_MUMPS_170,AGMG_MUMPS_275
      LOGICAL AGMG_MUMPS_170
      INTEGER i,NCB,NELIM
      INTEGER AGMG_MUMPS_275
      INTEGER FATHER_NODE,FATHER,WHAT,IERR
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      DOUBLE PRECISION ID
      IF((.NOT.BDC_M2_MEM).AND.(.NOT.BDC_M2_FLOPS))THEN
         WRITE(*,*)MYID,': Problem in DMUMPS_512'
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF((INODE.LT.0).OR.(INODE.GT.N)) THEN
         RETURN
      ENDIF
      i=INODE
      NELIM = 0
   10 CONTINUE
      IF ( i > 0 ) THEN
         NELIM = NELIM + 1
         i = FILS_LOAD(i)
         GOTO 10
      ENDIF
      NCB=ND_LOAD(STEP_LOAD(INODE))-NELIM
      WHAT=5
      FATHER_NODE=DAD_LOAD(STEP_LOAD(INODE))
      IF (FATHER_NODE.EQ.0) THEN
         RETURN
      ENDIF
      IF((FRERE(STEP(FATHER_NODE)).EQ.0).AND.                           &
     &     ((FATHER_NODE.EQ.KEEP(38)).OR.                               &
     &     (FATHER_NODE.EQ.KEEP(20))))THEN
         RETURN
      ENDIF
      IF(AGMG_MUMPS_170(STEP(FATHER_NODE),                                   &
     &   PROCNODE,SLAVEF)) THEN
         RETURN
      ENDIF
      FATHER=AGMG_MUMPS_275(STEP(FATHER_NODE),PROCNODE,SLAVEF)
      IF(FATHER.EQ.MYID)THEN
        IF(BDC_M2_MEM)THEN
           CALL PROCESS_NIV2_MEM_MSG(FATHER_NODE)
        ELSEIF(BDC_M2_FLOPS)THEN
           CALL PROCESS_NIV2_FLOPS_MSG(FATHER_NODE)
        ENDIF
        IF((KEEP(81).EQ.2).OR.(KEEP(81).EQ.3))THEN
           IF(AGMG_MUMPS_330(STEP_LOAD(INODE),                               &
     &          PROCNODE_LOAD,NPROCS).EQ.1)THEN
              CB_COST_ID(POS_ID)=INODE
              CB_COST_ID(POS_ID+1)=1
              CB_COST_ID(POS_ID+2)=POS_MEM
              POS_ID=POS_ID+3
              CB_COST_MEM(POS_MEM)=int(MYID,8)
              POS_MEM=POS_MEM+1
              CB_COST_MEM(POS_MEM)=int(NCB,8)*int(NCB,8)
              POS_MEM=POS_MEM+1
           ENDIF
        ENDIF
        GOTO 666
      ENDIF
  111 CONTINUE
      CALL DAGMG_MUMPS_519(WHAT, COMM, NPROCS,                               &
     &     FATHER_NODE,INODE,NCB, KEEP(81),MYID,                        &
     &     FATHER, IERR)
      IF (IERR == -1 ) THEN
        CALL DAGMG_MUMPS_467(COMM, KEEP)
        GOTO 111
      ELSE IF ( IERR .NE. 0 ) THEN
        WRITE(*,*) "Internal Error in DAGMG_MUMPS_512",                      &
     &  IERR
        CALL AGMG_MUMPS_ABORT()
      ENDIF
  666 CONTINUE
      END SUBROUTINE DAGMG_MUMPS_512
      SUBROUTINE DAGMG_MUMPS_514(INODE,NUM_CALL)
      IMPLICIT NONE
      DOUBLE PRECISION MAXI
      INTEGER i,J,IND_MAXI
      INTEGER INODE,NUM_CALL
      DOUBLE PRECISION MAX_ALL_M2
      IF(BDC_M2_MEM)THEN
         IF(((NUM_CALL.EQ.1).AND.(BDC_MD)).OR.                          &
     &       ((NUM_CALL.EQ.2).AND.(.NOT.BDC_MD)))THEN
            RETURN
         ENDIF
      ENDIF
      IF((FRERE_LOAD(STEP_LOAD(INODE)).EQ.0).AND.                       &
     &     ((INODE.EQ.KEEP_LOAD(38)).OR.                                &
     &     (INODE.EQ.KEEP_LOAD(20)))) THEN
         RETURN
      ENDIF
      DO i=POOL_SIZE,1,-1
         IF(POOL_NIV2(i).EQ.INODE) GOTO 666
      ENDDO
         NB_SON(STEP_LOAD(INODE))=-1
      RETURN
  666 CONTINUE
      IF(BDC_M2_MEM)THEN
         IF(POOL_NIV2_COST(i).EQ.MAX_M2)THEN
            TMP_M2=MAX_M2
            MAXI=dble(0)
            IND_MAXI=-9999
            DO J=POOL_SIZE,1,-1
               IF(J.NE.i) THEN
                  IF(POOL_NIV2_COST(J).GT.MAXI)THEN
                     MAXI=POOL_NIV2_COST(J)
                     IND_MAXI=J
                  ENDIF
               ENDIF
            ENDDO
            MAX_M2=MAXI
            J=IND_MAXI
            REMOVE_NODE_FLAG_MEM=.TRUE.
            REMOVE_NODE_COST_MEM=TMP_M2
            CALL DAGMG_MUMPS_515(REMOVE_NODE_FLAG,MAX_M2,COMM_LD)
            NIV2(MYID+1)=MAX_M2
         ENDIF
      ELSEIF(BDC_M2_FLOPS)THEN
         REMOVE_NODE_COST=POOL_NIV2_COST(i)
         REMOVE_NODE_FLAG=.TRUE.
         CALL DAGMG_MUMPS_515(REMOVE_NODE_FLAG,                              &
     &        -POOL_NIV2_COST(i),COMM_LD)
         NIV2(MYID+1)=NIV2(MYID+1)-POOL_NIV2_COST(i)
      ENDIF
      DO J=i+1,POOL_SIZE
         POOL_NIV2(J-1)=POOL_NIV2(J)
         POOL_NIV2_COST(J-1)=POOL_NIV2_COST(J)
      ENDDO
      POOL_SIZE=POOL_SIZE-1
      END SUBROUTINE DAGMG_MUMPS_514
      RECURSIVE SUBROUTINE PROCESS_NIV2_MEM_MSG(INODE)
      IMPLICIT NONE
      INTEGER INODE
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      INTEGER NBTOP, i
      IF((INODE.EQ.KEEP_LOAD(20)).OR.                                   &
     &     (INODE.EQ.KEEP_LOAD(38)))THEN
         RETURN
      ENDIF
      IF(NB_SON(STEP_LOAD(INODE)).EQ.-1)THEN
         RETURN
      ELSE
         IF(NB_SON(STEP_LOAD(INODE)).LT.0)THEN
            WRITE(*,*)                                                  &
     &        'Internal error 1 in PROCESS_NIV2_MEM_MSG'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
      NB_SON(STEP_LOAD(INODE))=                                         &
     &     NB_SON(STEP_LOAD(INODE))-1
      IF(NB_SON(STEP_LOAD(INODE)).EQ.0)THEN
         POOL_NIV2(POOL_SIZE+1)=INODE
         POOL_NIV2_COST(POOL_SIZE+1)=                                   &
     &        DAGMG_MUMPS_543(INODE)
         POOL_SIZE=POOL_SIZE+1
         IF(POOL_NIV2_COST(POOL_SIZE).GT.MAX_M2)THEN
            MAX_M2=POOL_NIV2_COST(POOL_SIZE)
            ID_MAX_M2=POOL_NIV2(POOL_SIZE)
            CALL DAGMG_MUMPS_515(REMOVE_NODE_FLAG_MEM,MAX_M2,COMM_LD)
            NIV2(1+MYID)=MAX_M2
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE PROCESS_NIV2_MEM_MSG
      RECURSIVE SUBROUTINE PROCESS_NIV2_FLOPS_MSG(INODE)
      IMPLICIT NONE
      INTEGER INODE
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      IF((INODE.EQ.KEEP_LOAD(20)).OR.                                   &
     &     (INODE.EQ.KEEP_LOAD(38)))THEN
         RETURN
      ENDIF
      IF(NB_SON(STEP_LOAD(INODE)).EQ.-1)THEN
         RETURN
      ELSE
         IF(NB_SON(STEP_LOAD(INODE)).LT.0)THEN
            WRITE(*,*)                                                  &
     &        'Internal error 1 in PROCESS_NIV2_FLOPS_MSG'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
      NB_SON(STEP_LOAD(INODE))=                                         &
     &     NB_SON(STEP_LOAD(INODE))-1
      IF(NB_SON(STEP_LOAD(INODE)).EQ.0)THEN
         POOL_NIV2(POOL_SIZE+1)=INODE
         POOL_NIV2_COST(POOL_SIZE+1)=                                   &
     &        DAGMG_MUMPS_542(INODE)
         POOL_SIZE=POOL_SIZE+1
         MAX_M2=POOL_NIV2_COST(POOL_SIZE)
         ID_MAX_M2=POOL_NIV2(POOL_SIZE)
         CALL DAGMG_MUMPS_515(REMOVE_NODE_FLAG,                              &
     &           POOL_NIV2_COST(POOL_SIZE),                             &
     &        COMM_LD)
         NIV2(MYID+1)=POOL_NIV2_COST(POOL_SIZE)+NIV2(MYID+1)
      ENDIF
      RETURN
      END SUBROUTINE PROCESS_NIV2_FLOPS_MSG
      DOUBLE PRECISION FUNCTION DAGMG_MUMPS_542(INODE)
      INTEGER INODE
      INTEGER NFRONT,NELIM,i,LEVEL
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      DOUBLE PRECISION COST
      i = INODE
      NELIM = 0
   10 CONTINUE
      IF ( i > 0 ) THEN
        NELIM = NELIM + 1
        i = FILS_LOAD(i)
        GOTO 10
      ENDIF
      NFRONT = ND_LOAD( STEP_LOAD(INODE) )
      LEVEL = AGMG_MUMPS_330( STEP_LOAD(INODE), PROCNODE_LOAD, NPROCS )
      COST=dble(0)
      CALL AGMG_MUMPS_511(NFRONT,NELIM,NELIM,                                &
     &                          KEEP_LOAD(50),LEVEL,COST)
      DAGMG_MUMPS_542=COST
      RETURN
      END FUNCTION DAGMG_MUMPS_542
      INTEGER FUNCTION DAGMG_MUMPS_541( INODE )
      IMPLICIT NONE
      INTEGER INODE,NELIM,NFR,SON,IN,i
      INTEGER COST_CB
      EXTERNAL AGMG_MUMPS_330
      INTEGER AGMG_MUMPS_330
      COST_CB=0
      i = INODE
   10 CONTINUE
      IF ( i > 0 ) THEN
        i = FILS_LOAD(i)
        GOTO 10
      ENDIF
      SON=-i
      DO i=1, NE_LOAD(STEP_LOAD(INODE))
         NFR = ND_LOAD( STEP_LOAD(SON) )
         IN=SON
         NELIM = 0
   20    CONTINUE
         IF ( IN > 0 ) THEN
            NELIM = NELIM + 1
            IN = FILS_LOAD(IN)
            GOTO 20
         ENDIF
         COST_CB=COST_CB+((NFR-NELIM)*(NFR-NELIM))
         SON=FRERE_LOAD(STEP_LOAD(SON))
      ENDDO
      DAGMG_MUMPS_541=COST_CB
      RETURN
      END FUNCTION DAGMG_MUMPS_541
      SUBROUTINE DAGMG_MUMPS_533(SLAVEF,NMB_OF_CAND,                         &
     &     TAB_POS, NASS, KEEP,KEEP8, LIST_SLAVES,                      &
     &     NSLAVES,INODE)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: SLAVEF, NASS, NSLAVES
      INTEGER, INTENT (IN) :: TAB_POS(SLAVEF+2)
      INTEGER, intent(in) :: NMB_OF_CAND
      INTEGER, INTENT (IN) :: LIST_SLAVES( NMB_OF_CAND )
      INTEGER KEEP(500),INODE,NELIM
      INTEGER*8 KEEP8(150)
      INTEGER allocok
      DOUBLE PRECISION MEM_COST,FCT_COST
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE ::EMPTY_ARRAY,         &
     &     DELTA_MD,EMPTY_ARRAY2
      INTEGER, DIMENSION(:),ALLOCATABLE ::PROCS
      INTEGER NBROWS_SLAVE,i,WHAT,IERR,NFRONT,NPROCS_LOC
      LOGICAL FORCE_CAND
      MEM_COST=dble(0)
      FCT_COST=dble(0)
      IF ( KEEP(24) == 0 .OR. KEEP(24) == 1 ) THEN
        FORCE_CAND = .FALSE.
        NPROCS_LOC=SLAVEF-1
      ELSE
        FORCE_CAND = (mod(KEEP(24),2).eq.0)
        NPROCS_LOC=NMB_OF_CAND
      END IF
      IF(FORCE_CAND)THEN
         CALL DAGMG_MUMPS_540(INODE,FCT_COST,                                &
     &        MEM_COST,NPROCS_LOC,NASS)
      ELSE
         CALL DAGMG_MUMPS_540(INODE,FCT_COST,                                &
     &        MEM_COST,SLAVEF-1,NASS)
      ENDIF
      DO i=1,SLAVEF
         IDWLOAD(i)=i-1
      ENDDO
      ALLOCATE(EMPTY_ARRAY(NPROCS_LOC),DELTA_MD(NPROCS_LOC),            &
     &     EMPTY_ARRAY2(NPROCS_LOC),                                    &
     &    stat=allocok)
      DO i = 1, NSLAVES
         NBROWS_SLAVE = TAB_POS(i+1) - TAB_POS(i)
         DELTA_MD( i ) = FCT_COST - dble(NBROWS_SLAVE)*                 &
     &        dble(NASS)
      END DO
      IF(FORCE_CAND)THEN
         DO i=NSLAVES+1,NPROCS_LOC
            DELTA_MD( i ) = FCT_COST
         ENDDO
      ELSE
         DO i=NSLAVES+1,SLAVEF-1
            DELTA_MD( i ) = FCT_COST
         ENDDO
      ENDIF
      WHAT=7
  111 CONTINUE
      CALL DAGMG_MUMPS_524(.FALSE., COMM_LD, MYID, SLAVEF,                   &
     &     FUTURE_NIV2,                                                 &
     &     NPROCS_LOC, LIST_SLAVES,0,                                   &
     &     EMPTY_ARRAY,                                                 &
     &     DELTA_MD,EMPTY_ARRAY2,WHAT, IERR)
      IF ( IERR == -1 ) THEN
          CALL DAGMG_MUMPS_467(COMM_LD, KEEP)
          GOTO 111
      ELSE IF ( IERR .NE. 0 ) THEN
         WRITE(*,*) "Internal Error in DAGMG_MUMPS_533",                     &
     &   IERR
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (FUTURE_NIV2(MYID+1) .NE. 0) THEN
        DO i = 1, NSLAVES
           MD_MEM(LIST_SLAVES(i))=MD_MEM(LIST_SLAVES(i))+               &
     &          int(DELTA_MD( i ),8)
           IF(FUTURE_NIV2(LIST_SLAVES(i)+1).EQ.0)THEN
              MD_MEM(LIST_SLAVES(i))=999999999_8
           ENDIF
        ENDDO
      ENDIF
      DEALLOCATE(EMPTY_ARRAY)
      DEALLOCATE(DELTA_MD)
      END SUBROUTINE DAGMG_MUMPS_533
      SUBROUTINE DAGMG_MUMPS_540(INODE,FCT_COST,                             &
     &     MEM_COST,NSLAVES,NELIM)
      IMPLICIT NONE
      INTEGER INODE,NSLAVES,NFR,NELIM,IN
      DOUBLE PRECISION MEM_COST,FCT_COST
      NFR=ND_LOAD(STEP_LOAD(INODE))
      IN = INODE
      FCT_COST=dble(int(dble(NFR-NELIM)/dble(NSLAVES))+1)*              &
     &     dble(NELIM)
      MEM_COST=dble(int(dble(NFR-NELIM)/dble(NSLAVES))+1)*              &
     &     dble(NFR)
      END SUBROUTINE DAGMG_MUMPS_540
      SUBROUTINE CLEAN_POOL_MEM_INFO(INODE)
      IMPLICIT NONE
      INTEGER INODE
      INTEGER i,J,SON,NSLAVES_TEMP,POS_TEMP,K
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      IF((INODE.LT.0).OR.(INODE.GT.N_LOAD))THEN
         RETURN
      ENDIF
      IF(POS_ID.GT.1)THEN
         i=INODE
   10    CONTINUE
         IF ( i > 0 ) THEN
            i = FILS_LOAD(i)
            GOTO 10
         ENDIF
         SON=-i
         IF(POS_ID.LT.NE_LOAD(STEP_LOAD(INODE))*3)THEN
            i=1
         ENDIF
         DO i=1, NE_LOAD(STEP_LOAD(INODE))
            J=1
            DO WHILE (J.LT.POS_ID)
               IF(CB_COST_ID(J).EQ.SON)GOTO 295
               J=J+3
            ENDDO
  295       CONTINUE
            IF(J.GE.POS_ID)THEN
               IF(AGMG_MUMPS_275(                                            &
     &            STEP_LOAD(INODE),PROCNODE_LOAD,NPROCS).EQ.MYID)THEN
                  IF(INODE.EQ.KEEP_LOAD(38))THEN
                     GOTO 666
                  ELSE
                     IF(FUTURE_NIV2(MYID+1).NE.0)THEN
                        WRITE(*,*)MYID,': i did not find ',SON
                        CALL AGMG_MUMPS_ABORT()
                     ENDIF
                     GOTO 666
                  ENDIF
               ELSE
                  GOTO 666
               ENDIF
            ENDIF
            NSLAVES_TEMP=CB_COST_ID(J+1)
            POS_TEMP=CB_COST_ID(J+2)
            DO K=J,POS_ID-1
               CB_COST_ID(K)=CB_COST_ID(K+3)
            ENDDO
            K=POS_TEMP
            DO WHILE (K.LE.POS_MEM-1)
               CB_COST_MEM(K)=CB_COST_MEM(K+2*NSLAVES_TEMP)
               K=K+1
            ENDDO
            POS_MEM=POS_MEM-2*NSLAVES_TEMP
            POS_ID=POS_ID-3
            IF((POS_MEM.LT.1).OR.(POS_ID.LT.1))THEN
               WRITE(*,*)MYID,': negative pos_mem or pos_id'
               CALL AGMG_MUMPS_ABORT()
            ENDIF
  666       CONTINUE
            SON=FRERE_LOAD(STEP_LOAD(SON))
         ENDDO
      ENDIF
      END SUBROUTINE CLEAN_POOL_MEM_INFO
      SUBROUTINE CHECK_MEM_CONST_FOR_POOL(FLAG)
      IMPLICIT NONE
      LOGICAL FLAG
      INTEGER i
      DOUBLE PRECISION MEM
      FLAG=.FALSE.
      DO i=0,NPROCS-1
         MEM=DM_MEM(i)+LU_USAGE(i)
         IF(BDC_SBTR)THEN
            MEM=MEM+SBTR_MEM(i)-SBTR_CUR(i)
         ENDIF
         IF((MEM/dble(TAB_MAXS(i))).GT.0.8d0)THEN
            FLAG=.TRUE.
            GOTO 666
         ENDIF
      ENDDO
  666 CONTINUE
      END SUBROUTINE CHECK_MEM_CONST_FOR_POOL
      SUBROUTINE DAGMG_MUMPS_554(NBINSUBTREE,INSUBTREE,NBTOP,                &
     &           MIN_COST,SBTR)
      IMPLICIT NONE
      INTEGER NBINSUBTREE,INSUBTREE,NBTOP
      DOUBLE PRECISION MIN_COST
      LOGICAL SBTR
      INTEGER i
      DOUBLE PRECISION TMP_COST,TMP_MIN
      TMP_MIN=huge(TMP_MIN)
      DO i=0,NPROCS-1
         IF(i.NE.MYID)THEN
            IF(BDC_SBTR)THEN
               TMP_MIN=min(TMP_MIN,dble(TAB_MAXS(i))-(DM_MEM(i)+        &
     &              LU_USAGE(i))-(SBTR_MEM(i)-SBTR_CUR(i)))
            ELSE
               TMP_MIN=min(TMP_MIN,dble(TAB_MAXS(i))-                   &
     &              (DM_MEM(i)+LU_USAGE(i)))
            ENDIF
         ENDIF
      ENDDO
      IF(NBINSUBTREE.GT.0)THEN
         IF(INSUBTREE.EQ.1)THEN
            TMP_COST=dble(TAB_MAXS(MYID))-(DM_MEM(MYID)+                &
     &           LU_USAGE(MYID))                                        &
     &           -(SBTR_MEM(MYID)-SBTR_CUR(MYID))
         ELSE
            SBTR=.FALSE.
            GOTO 777
         ENDIF
      ENDIF
      TMP_MIN=min(TMP_COST,TMP_MIN)
      IF(TMP_MIN.GT.MIN_COST) SBTR=.TRUE.
  777 CONTINUE
      END SUBROUTINE DAGMG_MUMPS_554
      SUBROUTINE COMPUTE_MAX_MEM(INODE,MAX_MEM,PROC)
      IMPLICIT NONE
      INTEGER INODE,PROC
      INTEGER i,POS,NSLAVES,SLAVE,NCAND,J,NELIM,NCB,NFRONT,SON,K
      INTEGER allocok
      EXTERNAL AGMG_MUMPS_330
      INTEGER  AGMG_MUMPS_330
      DOUBLE PRECISION MAX_MEM,TMP
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: MEM_ON_PROCS,      &
     &     RECV_BUF
      LOGICAL, DIMENSION(:), ALLOCATABLE :: CONCERNED
      DOUBLE PRECISION MAX_SENT_MSG
      IF((FRERE_LOAD(STEP_LOAD(INODE)).EQ.0)                            &
     &           .AND.(INODE.EQ.KEEP_LOAD(38)))THEN
         RETURN
      ENDIF
      ALLOCATE( MEM_ON_PROCS(0:NPROCS-1), stat=allocok)
      IF ( allocok > 0 ) THEN
        WRITE(*,*) 'PB allocation in COMPUTE_MAX_MEM'
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      ALLOCATE( CONCERNED(0:NPROCS-1), stat=allocok)
      IF ( allocok > 0 ) THEN
        WRITE(*,*) 'PB allocation in COMPUTE_MAX_MEM'
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      ALLOCATE( RECV_BUF(0:NPROCS-1), stat=allocok)
      IF ( allocok > 0 ) THEN
        WRITE(*,*) 'PB allocation in COMPUTE_MAX_MEM'
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      RECV_BUF=dble(0)
      MAX_SENT_MSG=dble(0)
      i = INODE
      NELIM = 0
   10 CONTINUE
      IF ( i > 0 ) THEN
        NELIM = NELIM + 1
        i = FILS_LOAD(i)
        GOTO 10
      ENDIF
      SON=-i
      NFRONT=ND_LOAD(STEP_LOAD(INODE))
      NCB=NFRONT-NELIM
      IF(AGMG_MUMPS_330(STEP_LOAD(INODE)                                     &
     &     ,PROCNODE_LOAD,NPROCS).EQ.2)THEN
         NCAND=CAND_LOAD(NPROCS+1, STEP_TO_NIV2_LOAD(STEP_LOAD(INODE)))
      ENDIF
      DO i=0,NPROCS-1
         IF(i.EQ.MYID)THEN
            MEM_ON_PROCS(i)=dble(TAB_MAXS(i))-(DM_MEM(i)+               &
     &           LU_USAGE(i)+                                           &
     &           DAGMG_MUMPS_543(INODE))
            IF(BDC_SBTR)THEN
               MEM_ON_PROCS(i)=MEM_ON_PROCS(i)-(SBTR_MEM(i)-SBTR_CUR(i))
            ENDIF
            CONCERNED(i)=.TRUE.
         ELSE
            MEM_ON_PROCS(i)=dble(TAB_MAXS(i))-(DM_MEM(i)+LU_USAGE(i))
            IF(BDC_SBTR)THEN
               MEM_ON_PROCS(i)=MEM_ON_PROCS(i)-(SBTR_MEM(i)-SBTR_CUR(i))
            ENDIF
            IF(BDC_M2_MEM)THEN
               MEM_ON_PROCS(i)=MEM_ON_PROCS(i)-NIV2(i+1)
            ENDIF
         ENDIF
         IF(AGMG_MUMPS_330(STEP_LOAD(INODE)                                  &
     &        ,PROCNODE_LOAD,NPROCS).EQ.2)THEN
            IF(BDC_MD.AND.(KEEP_LOAD(48).EQ.5))THEN
               DO J=1,NCAND
                  IF(CAND_LOAD(J, STEP_TO_NIV2_LOAD(STEP_LOAD(INODE)))  &
     &                 .EQ.i)THEN
                     MEM_ON_PROCS(i)=MEM_ON_PROCS(i)-                   &
     &                 ((dble(NFRONT)*dble(NCB))/dble(NCAND))
                     CONCERNED(i)=.TRUE.
                     GOTO 666
                  ENDIF
               ENDDO
            ENDIF
         ENDIF
  666    CONTINUE
      ENDDO
      DO K=1, NE_LOAD(STEP_LOAD(INODE))
         i=1
         DO WHILE (i.LE.POS_ID)
            IF(CB_COST_ID(i).EQ.SON)GOTO 295
            i=i+3
         ENDDO
  295    CONTINUE
         IF(i.GE.POS_ID)THEN
            IF(FUTURE_NIV2(MYID+1).NE.0)THEN
               WRITE(*,*)MYID,': ',SON,'has not been found              &
     &              in COMPUTE_MAX_MEM'
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            GOTO 777
         ENDIF
         NSLAVES=CB_COST_ID(i+1)
         POS=CB_COST_ID(i+2)
         DO i=1,NSLAVES
            SLAVE=int(CB_COST_MEM(POS))
            IF(.NOT.CONCERNED(SLAVE))THEN
               MEM_ON_PROCS(SLAVE)=MEM_ON_PROCS(SLAVE)+                 &
     &              dble(CB_COST_MEM(POS+1))
            ENDIF
            DO J=0,NPROCS-1
               IF(CONCERNED(J))THEN
                  IF(SLAVE.NE.J)THEN
                     RECV_BUF(J)=max(RECV_BUF(J),                       &
     &                    dble(CB_COST_MEM(POS+1)))
                  ENDIF
               ENDIF
            ENDDO
            POS=POS+2
         ENDDO
  777    CONTINUE
         SON=FRERE_LOAD(STEP_LOAD(SON))
      ENDDO
      MAX_MEM=huge(MAX_MEM)
      WRITE(*,*)'NPROCS=',NPROCS,MAX_MEM
      DO i=0,NPROCS-1
         IF(MAX_MEM.GT.MEM_ON_PROCS(i))THEN
            PROC=i
         ENDIF
         MAX_MEM=min(MEM_ON_PROCS(i),MAX_MEM)
      ENDDO
      DEALLOCATE(MEM_ON_PROCS)
      DEALLOCATE(CONCERNED)
      DEALLOCATE(RECV_BUF)
      END SUBROUTINE COMPUTE_MAX_MEM
      SUBROUTINE DAGMG_MUMPS_553(MIN_PROC,POOL,                              &
     &                      LPOOL,INODE)
      IMPLICIT NONE
      INTEGER INODE,LPOOL,MIN_PROC
      INTEGER POOL(LPOOL)
      EXTERNAL AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_275
      INTEGER i,NBTOP,INSUBTREE,NBINSUBTREE,NODE,FATHER,SON,J
      INTEGER FIRST_LEAF,SBTR_NB_LEAF,POS,K,allocok,L
      INTEGER, ALLOCATABLE, DIMENSION (:) ::  TMP_SBTR
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      INSUBTREE   = POOL(LPOOL - 2)
      IF((KEEP_LOAD(47).EQ.4).AND.                                      &
     &     ((NBINSUBTREE.NE.0)))THEN
         DO J=INDICE_SBTR,NB_SUBTREES
            NODE=MY_ROOT_SBTR(J)
            FATHER=DAD_LOAD(STEP_LOAD(NODE))
            i=FATHER
  110       CONTINUE
            IF ( i > 0 ) THEN
               i = FILS_LOAD(i)
               GOTO 110
            ENDIF
            SON=-i
            i=SON
  120       CONTINUE
            IF ( i > 0 ) THEN
               IF(AGMG_MUMPS_275(STEP_LOAD(i),PROCNODE_LOAD,NPROCS).EQ.      &
     &              MIN_PROC)THEN
                  SBTR_NB_LEAF=MY_NB_LEAF(J)
                  POS=SBTR_FIRST_POS_IN_POOL(J)
                  IF(POOL(POS+SBTR_NB_LEAF).NE.MY_FIRST_LEAF(J))THEN
                     WRITE(*,*)MYID,': The first leaf is not ok'
                     CALL AGMG_MUMPS_ABORT()
                  ENDIF
                  ALLOCATE (TMP_SBTR(SBTR_NB_LEAF), stat=allocok)
                  IF (allocok > 0 ) THEN
                     WRITE(*,*)MYID,': Not enough space                 &
     &                    for allocation'
                     CALL AGMG_MUMPS_ABORT()
                  ENDIF
                  POS=SBTR_FIRST_POS_IN_POOL(J)
                  DO K=1,SBTR_NB_LEAF
                     TMP_SBTR(K)=POOL(POS+K-1)
                  ENDDO
                  DO K=POS+1,NBINSUBTREE-SBTR_NB_LEAF
                     POOL(K)=POOL(K+SBTR_NB_LEAF)
                  ENDDO
                  POS=1
                  DO K=NBINSUBTREE-SBTR_NB_LEAF+1,NBINSUBTREE
                     POOL(K)=TMP_SBTR(POS)
                     POS=POS+1
                  ENDDO
                  DO K=INDICE_SBTR,J
                     SBTR_FIRST_POS_IN_POOL(K)=SBTR_FIRST_POS_IN_POOL(K)&
     &                    -SBTR_FIRST_POS_IN_POOL(J)
                  ENDDO
                  SBTR_FIRST_POS_IN_POOL(J)=NBINSUBTREE-SBTR_NB_LEAF
                  POS=MY_FIRST_LEAF(J)
                  L=MY_NB_LEAF(J)
                  DO K=INDICE_SBTR,J
                     MY_FIRST_LEAF(J)=MY_FIRST_LEAF(J+1)
                     MY_NB_LEAF(J)=MY_NB_LEAF(J+1)
                  ENDDO
                  MY_FIRST_LEAF(INDICE_SBTR)=POS
                  MY_NB_LEAF(INDICE_SBTR)=L
                  INODE=POOL(NBINSUBTREE)
                  DEALLOCATE(TMP_SBTR)
                  RETURN
               ENDIF
               i = FRERE_LOAD(STEP_LOAD(i))
               GOTO 120
            ENDIF
         ENDDO
      ENDIF
      DO J=NBTOP,1,-1
         NODE=POOL(LPOOL-2-J)
         FATHER=DAD_LOAD(STEP_LOAD(NODE))
         i=FATHER
   11    CONTINUE
         IF ( i > 0 ) THEN
            i = FILS_LOAD(i)
            GOTO 11
         ENDIF
         SON=-i
         i=SON
   12    CONTINUE
         IF ( i > 0 ) THEN
            IF(AGMG_MUMPS_275(STEP_LOAD(i),PROCNODE_LOAD,NPROCS).EQ.         &
     &           MIN_PROC)THEN
               INODE=NODE
               RETURN
            ENDIF
            i = FRERE_LOAD(STEP_LOAD(i))
            GOTO 12
         ENDIF
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_553
      SUBROUTINE DAGMG_MUMPS_555(POOL, LPOOL,KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER LPOOL,POOL(LPOOL),KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER i,POS
      EXTERNAL AGMG_MUMPS_283
      LOGICAL AGMG_MUMPS_283
      IF(.NOT.BDC_SBTR) RETURN
      POS=0
      DO i=NB_SUBTREES,1,-1
         DO WHILE(AGMG_MUMPS_283(STEP_LOAD(POOL(POS+1)),                     &
     &        PROCNODE_LOAD,NPROCS))
            POS=POS+1
         ENDDO
         SBTR_FIRST_POS_IN_POOL(i)=POS+1
         POS=POS+MY_NB_LEAF(i)
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_555
      END MODULE DAGMG_MUMPS_LOAD
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS( id )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!       matrix in assembled format (ICNTL(5)=0, and ICNTL(18) $\neq$ 3),
      INTERFACE
      SUBROUTINE DAGMG_MUMPS_26( id )
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET :: id
      END SUBROUTINE DAGMG_MUMPS_26
      SUBROUTINE DAGMG_MUMPS_142( id )
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET :: id
      END SUBROUTINE DAGMG_MUMPS_142
      SUBROUTINE DAGMG_MUMPS_301( id )
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET :: id
      END SUBROUTINE DAGMG_MUMPS_301
      SUBROUTINE DAGMG_MUMPS_349(id, LP)
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET, INTENT(IN) :: id
      INTEGER  :: LP
      END SUBROUTINE DAGMG_MUMPS_349
      END INTERFACE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MASTER, ierr
      PARAMETER( MASTER = 0 )
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER JOBMIN, JOBMAX, OLDJOB, NRHS_TMP
      INTEGER I, J, MP, LP, MPG
      LOGICAL LANAL, LFACTO, LSOLVE, PROK, FLAG, PROKG
      LOGICAL NOERRORBEFOREPERM
      LOGICAL UNS_PERM_DONE
      INTEGER COMM_SAVE
      INTEGER JOB, N, NZ, NELT
      INTEGER ICNTL20, ICNTL21, ICNTL26
      INTEGER, DIMENSION(:), ALLOCATABLE :: UNS_PERM_INV
      NOERRORBEFOREPERM = .FALSE.
      UNS_PERM_DONE = .FALSE.
      JOB  = id%JOB
      N    = id%N
      NZ   = id%NZ
      NELT = id%NELT
      id%INFO(1) = 0
      id%INFO(2) = 0
      IF ( JOB .NE. -1 ) THEN
        LP      = id%ICNTL(1)
        MP      = id%ICNTL(2)
        MPG     = id%ICNTL(3)
        PROK    = ((MP.GT.0).AND.(id%ICNTL(4).GE.3))
        PROKG   = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
        IF ((id%MYID .eq. MASTER) .AND. PROK .AND. (id%ICNTL(5).EQ.0 ) )&
     &       WRITE(MP,'(A,I4,I12,I15)')                                 &
     &       'Entering driver (DMUMPS) WITH JOB, N, NZ =', JOB,N,NZ
        IF ((id%MYID .eq. MASTER).AND. PROK .AND. (id%ICNTL(5).EQ.1 ) ) &
     &       WRITE(MP,'(A,I4,I12,I15)')                                 &
     &      'Entering driver (DMUMPS) WITH JOB, N, NELT =', JOB,N,NELT
      ELSE
        MPG = 0
        PROK = .FALSE.
        PROKG = .FALSE.
        LP = 6
        MP = 6
      END IF
      CALL AGMG_MPF_INITIALIZED( FLAG, ierr )
      IF ( .NOT. FLAG ) THEN
        WRITE(LP,990)
  990 FORMAT(' Error in DMUMPS initialization: MPI is not running.')
        id%INFO(1) = -23
        id%INFO(2) =   0
        GOTO 500
      END IF
       COMM_SAVE = id%COMM
       CALL AGMG_SETIERR( ierr )
      CALL AGMG_COPY(JOB,JOBMIN,1,AGMG_MPF_INTEGER,ierr)
      CALL AGMG_COPY(JOB,JOBMAX,1,AGMG_MPF_INTEGER,ierr)
      IF ( JOBMIN .NE. JOBMAX ) THEN
        id%INFO(1) = -3
        id%INFO(2) = JOB
        GOTO 499
      END IF
      IF ( JOB .EQ. -1 ) THEN
        id%INFO(1)=0
        id%INFO(2)=0
        IF ( id%KEEP(40) .EQ. 1 - 456789 .OR.                           &
     &      id%KEEP(40) .EQ. 2 - 456789 .OR.                            &
     &      id%KEEP(40) .EQ. 3 -456789 ) THEN
        IF ( id%N > 0 ) THEN
          id%INFO(1)=-3
          id%INFO(2)=JOB
        ENDIF
        ENDIF
        CALL AGMG_SETIERR2( id%MYID, IERR)
        CALL AGMG_MUMPS_276( id%ICNTL,                                       &
     &                       id%INFO,                                   &
     &                       id%COMM, id%MYID )
        IF ( id%INFO(1) .LT. 0 ) THEN
           IF (id%KEEP(201).GT.0) THEN
             CALL DAGMG_MUMPS_587(id, ierr)
           ENDIF
           GOTO 499
        ENDIF
        CALL DAGMG_MUMPS_163( id )
        GOTO 500
      END IF
      IF ( JOB .EQ. -2 ) THEN
        id%KEEP(40)= -2 - 456789
        CALL DAGMG_MUMPS_136( id )
        GOTO 500
      END IF
      IF ((JOB.LT.1).OR.(JOB.GT.6)) THEN
        id%INFO(1) = -3
        id%INFO(2) = JOB
        GOTO 499
      END IF
      IF (id%MYID.EQ.MASTER) THEN
        IF ( id%ICNTL(18) .eq. 0 ) THEN
        IF ((N.LE.0).OR.((N+N+N)/3.NE.N)) THEN
          id%INFO(1) = -16
          id%INFO(2) = N
        END IF
        IF (id%ICNTL(5).EQ.0) THEN
          IF (NZ.LE.0) THEN
            id%INFO(1) = -2
            id%INFO(2) = NZ
          END IF
        ELSE
          IF (NELT.LE.0) THEN
            id%INFO(1) = -24
            id%INFO(2) = NELT
          END IF
        ENDIF
        END IF
        IF ( (id%KEEP(46).EQ.0).AND.(id%NPROCS.LE.1) )                  &
     &     THEN
          id%INFO(1) = -21
          id%INFO(2) = id%NPROCS
        ENDIF
      END IF
      CALL AGMG_MUMPS_276( id%ICNTL,                                         &
     &                    id%INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( id%INFO(1) .LT. 0 ) GOTO 499
      LANAL  = .FALSE.
      LFACTO = .FALSE.
      LSOLVE = .FALSE.
      IF ((JOB.EQ.1).OR.(JOB.EQ.4).OR.                                  &
     &    (JOB.EQ.6))               LANAL  = .TRUE.
      IF ((JOB.EQ.2).OR.(JOB.EQ.4).OR.                                  &
     &    (JOB.EQ.5).OR.(JOB.EQ.6)) LFACTO = .TRUE.
      IF ((JOB.EQ.3).OR.(JOB.EQ.5).OR.                                  &
     &    (JOB.EQ.6))               LSOLVE = .TRUE.
      IF (MP.GT.0) CALL DAGMG_MUMPS_349(id, MP)
      OLDJOB = id%KEEP( 40 ) + 456789
      IF ( LANAL ) THEN
        IF ( OLDJOB .EQ. 0 .OR. OLDJOB .GT. 3 .OR. OLDJOB .LT. -1 ) THEN
          id%INFO(1) = -3
          id%INFO(2) = JOB
          GOTO 499
        END IF
        IF ( OLDJOB .GE. 2 ) THEN
          IF (associated(id%IS)) THEN
            DEALLOCATE  (id%IS)
            NULLIFY     (id%IS)
          END IF
          IF (associated(id%S)) THEN
            DEALLOCATE  (id%S)
            NULLIFY     (id%S)
          END IF
        END IF
      END IF
      IF ( LFACTO ) THEN
         IF ( OLDJOB .LT. 1 .and. .NOT. LANAL ) THEN
            id%INFO(1) = -3
            id%INFO(2) = JOB
            GOTO 499
         END IF
      END IF
      IF ( LSOLVE ) THEN
         IF ( OLDJOB .LT. 2 .AND. .NOT. LFACTO ) THEN
            id%INFO(1) = -3
            id%INFO(2) = JOB
            GOTO 499
         END IF
      END IF
      NOERRORBEFOREPERM =.TRUE.
      UNS_PERM_DONE=.FALSE.
      IF (id%MYID .eq. MASTER .AND. id%KEEP(23) .NE. 0) THEN
        IF ( id%JOB .EQ. 2 .OR. id%JOB .EQ. 5 .OR.                      &
     &       (id%JOB .EQ. 3 .AND. (id%ICNTL(10) .NE.0 .OR.              &
     &        id%ICNTL(11).NE. 0))) THEN
          UNS_PERM_DONE = .TRUE.
          ALLOCATE(UNS_PERM_INV(id%N),stat=ierr)
          IF (ierr .GT. 0) THEN
              id%INFO(1)=-13
              id%INFO(2)=id%N
              IF (id%ICNTL(1) .GT.  0 .AND. id%ICNTL(4) .GE.1) THEN
                WRITE(id%ICNTL(2),99993)
              END IF
            GOTO 510
          ENDIF
          DO I = 1, id%N
            UNS_PERM_INV(id%UNS_PERM(I))=I
          END DO
          DO I = 1, id%NZ
            J = id%JCN(I)
            IF (J.LE.0.OR.J.GT.id%N) CYCLE
            id%JCN(I)=UNS_PERM_INV(J)
          END DO
          DEALLOCATE(UNS_PERM_INV)
        END IF
      END IF
        CALL AGMG_MUMPS_276( id%ICNTL,                                       &
     &                    id%INFO,                                      &
     &                    id%COMM, id%MYID )
        IF ( id%INFO( 1 ) .LT. 0 ) GO TO 499
      IF (LANAL) THEN
        id%KEEP(40)=-1 -456789
        IF (id%MYID.EQ.MASTER) THEN
          id%INFOG(7) = -9999
          id%INFOG(23) = 0
          id%INFOG(24) = 1
          IF (associated(id%IS1)) DEALLOCATE(id%IS1)
          IF ( id%ICNTL(5) .EQ. 0 ) THEN
             IF ( id%SYM .NE. 1                                         &
     &            .AND. (                                               &
     &            (id%ICNTL(6) .NE. 0 .AND. id%ICNTL(7) .NE.1)          &
     &            .OR.                                                  &
     &            id%ICNTL(12) .NE. 1) ) THEN
                id%MAXIS1 = 11 * N
             ELSE
              id%MAXIS1 = 10 * N
             END IF
          ELSE
            id%MAXIS1 = 6 * N + 2 * NELT + 2
          ENDIF
          ALLOCATE( id%IS1(id%MAXIS1), stat=ierr )
          IF (ierr.gt.0) THEN
            id%INFO(1) = -7
            id%INFO(2) = id%MAXIS1
            IF ( LP .GT.0 )                                             &
     &      WRITE(LP,*) 'Problem in allocating work array for analysis.'
            GO TO 100
          END IF
          IF ( associated( id%PROCNODE ) )                              &
     &          DEALLOCATE( id%PROCNODE )
          ALLOCATE( id%PROCNODE(id%N), stat=ierr )
          IF (ierr.gt.0) THEN
            id%INFO(1) = -7
            id%INFO(2) = id%N
            IF ( LP .GT. 0 ) THEN
              WRITE(LP,*) 'Problem in allocating work array PROCNODE'
            END IF
            GOTO 100
          END IF
          id%PROCNODE(1:id%N) = 0
          IF ( id%ICNTL(5) .NE. 0 ) THEN
            IF ( associated( id%ELTPROC ) )                             &
     &            DEALLOCATE( id%ELTPROC )
            ALLOCATE( id%ELTPROC(id%NELT), stat=ierr )
            IF (ierr.gt.0) THEN
              id%INFO(1) = -7
              id%INFO(2) = id%NELT
              IF ( LP .GT. 0 ) THEN
                WRITE(LP,*) 'Problem in allocating work array ELTPROC'
              END IF
              GOTO 100
            END IF
          END IF
          IF ( id%ICNTL(5) .EQ. 0 ) THEN
            id%NA_ELT=0
            IF ( id%ICNTL(18).EQ.0 ) THEN
             IF ( .not. associated( id%IRN ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 1
             ELSE IF ( size( id%IRN ) < id%NZ ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 1
             ELSE IF ( .not. associated( id%JCN ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 2
             ELSE IF ( size( id%JCN ) < id%NZ ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 2
             END IF
            END IF
            IF ( id%INFO( 1 ) .eq. -22 ) THEN
              IF (LP.GT.0) WRITE(LP,*)                                  &
     &           'Error in analysis: IRN/JCN badly allocated.'
            END IF
          ELSE
            IF ( .not. associated( id%ELTPTR ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 1
            ELSE IF ( size( id%ELTPTR ) < id%NELT+1 ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 1
            ELSE IF ( .not. associated( id%ELTVAR ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 2
            ELSE
              id%LELTVAR = id%ELTPTR( id%NELT+1 ) - 1
              IF ( size( id%ELTVAR ) < id%LELTVAR ) THEN
                id%INFO(1) = -22
                id%INFO(2) = 2
              ELSE
                id%NA_ELT = 0
                IF ( id%KEEP(50) .EQ. 0 ) THEN
                  DO I = 1,NELT
                    J = id%ELTPTR(I+1) - id%ELTPTR(I)
                    J = (J * J)
                    id%NA_ELT = id%NA_ELT + J
                  ENDDO
                ELSE
                  DO I = 1,NELT
                    J = id%ELTPTR(I+1) - id%ELTPTR(I)
                    J = (J * (J+1))/2
                    id%NA_ELT = id%NA_ELT + J
                  ENDDO
                ENDIF
              ENDIF
            END IF
            IF ( id%INFO( 1 ) .eq. -22 ) THEN
              IF (LP.GT.0) WRITE(LP,*)                                  &
     &           'Error in analysis: ELTPTR/ELTVAR badly allocated.'
            END IF
          ENDIF
  100   CONTINUE
        END IF
        CALL AGMG_MUMPS_276( id%ICNTL,                                       &
     &                    id%INFO,                                      &
     &                    id%COMM, id%MYID )
        IF ( id%INFO( 1 ) .LT. 0 ) GO TO 499
         id%KEEP(52) = id%ICNTL(8)
         IF ( id%KEEP(52) .GT. 8 .OR. id%KEEP(52).LT.-2)                &
     &        id%KEEP(52) = 77
         IF ((id%KEEP(52).EQ.77).AND.(id%SYM.EQ.1)) THEN
           id%KEEP(52) = 0
         ENDIF
         IF ( id%KEEP(52).EQ.77 .OR. id%KEEP(52).LE.-2) THEN
           IF (.not.associated(id%A)) id%KEEP(52) = 0
         ENDIF
         IF(id%KEEP(52) .EQ. -1) id%KEEP(52) = 0
         CALL DAGMG_MUMPS_26( id )
        IF (id%MYID .eq. MASTER) THEN
           IF (id%KEEP(52) .NE. 0) THEN
             id%INFOG(33)=id%KEEP(52)
           ELSE
             id%INFOG(33)=id%ICNTL(8)
           ENDIF
        ENDIF
        IF (id%MYID .eq. MASTER) id%INFOG(24)=id%KEEP(95)
        IF ( id%INFO( 1 ) .LT. 0 ) GO TO 499
        id%KEEP(40) = 1 -456789
      END IF
      IF (LFACTO) THEN
         id%KEEP(40) = 1 - 456789
        IF ( id%MYID .EQ. MASTER ) THEN
           IF (id%KEEP(60).EQ.1) THEN
             IF ( associated( id%SCHUR_CINTERFACE)) THEN
               id%SCHUR=>id%SCHUR_CINTERFACE                            &
     &          (1:id%SIZE_SCHUR*id%SIZE_SCHUR)
             ENDIF
             IF ( .NOT. associated (id%SCHUR)) THEN
              IF (LP.GT.0)                                              &
     &        write(LP,'(A)')                                           &
     &                      ' SCHUR not associated'
              id%INFO(1)=-22
              id%INFO(2)=9
             ELSE IF ( size(id%SCHUR) .LT.                              &
     &                id%SIZE_SCHUR * id%SIZE_SCHUR ) THEN
                IF (LP.GT.0)                                            &
     &          write(LP,'(A)')                                         &
     &                ' SCHUR allocated but too small'
                id%INFO(1)=-22
                id%INFO(2)=9
             END IF
          END IF
          IF ( id%KEEP(55) .EQ. 0 ) THEN
           IF ( id%KEEP(54).eq.0 ) THEN
            IF ( .not. associated( id%A ) ) THEN
              id%INFO( 1 ) = -22
              id%INFO( 2 ) = 4
            ELSE IF ( size( id%A ) < id%NZ ) THEN
              id%INFO( 1 ) = -22
              id%INFO( 2 ) = 4
            END IF
           END IF
          ELSE
            IF ( .not. associated( id%A_ELT ) ) THEN
              id%INFO( 1 ) = -22
              id%INFO( 2 ) = 4
            ELSE
              IF ( size( id%A_ELT ) < id%NA_ELT ) THEN
                id%INFO( 1 ) = -22
                id%INFO( 2 ) = 4
              ENDIF
            END IF
          ENDIF
          CALL AGMG_MUMPS_633(id%KEEP(12),id%ICNTL(14),                      &
     &         id%KEEP(50),id%KEEP(54),id%ICNTL(6),id%ICNTL(8))
          CALL DAGMG_MUMPS_635(N,id%KEEP,id%ICNTL,MPG)
          IF( id%KEEP(52) .EQ. -2 .AND. id%ICNTL(8) .NE. -2 .AND.       &
     &        id%ICNTL(8).NE. 77 ) THEN
             IF ( MPG .GT. 0 ) THEN
                WRITE(MPG,'(A)') ' ** WARNING : SCALING'
                WRITE(MPG,'(A)')                                        &
     &               ' ** scaling already computed during analysis'
                WRITE(MPG,'(A)')                                        &
     &               ' ** keeping the scaling from the analysis'
             ENDIF
          ENDIF
          IF (id%KEEP(52) .NE. -2) THEN
            id%KEEP(52)=id%ICNTL(8)
          ENDIF
          IF ( id%KEEP(52) .GT. 8 .OR. id%KEEP(52).LT.-2)               &
     &    id%KEEP(52) = 77
          IF (id%KEEP(52).EQ.77) THEN
            IF (id%SYM.EQ.1) THEN
              id%KEEP(52) = 0
            ELSE
              id%KEEP(52) = 7
            ENDIF
          ENDIF
          IF( id%KEEP(23) .NE. 0 .AND. id%ICNTL(8) .EQ. -1) THEN
             IF ( MPG .GT. 0 ) THEN
                WRITE(MPG,'(A)') ' ** WARNING : SCALING'
                WRITE(MPG,'(A)')                                        &
     &               ' ** column permutation applied:'
                WRITE(MPG,'(A)')                                        &
     &               ' ** column scaling has to be permuted'
             ENDIF
          ENDIF
          IF ( id%KEEP( 19 ) .ne. 0 .and. id%KEEP( 52 ).ne. 0 ) THEN
            IF ( MPG .GT. 0 ) THEN
              WRITE(MPG,'(A)') ' ** Warning: Scaling not applied.'
              WRITE(MPG,'(A)') ' ** (incompatibility with null space)'
            END IF
            id%KEEP(52) = 0
          END IF
          IF ( id%KEEP(60) .ne. 0 .and. id%KEEP(52) .ne. 0 ) THEN
            id%KEEP(52) = 0
            IF ( MPG .GT. 0 .AND. id%ICNTL(8) .NE. 0 ) THEN
              WRITE(MPG,'(A)') ' ** Warning: Scaling not applied.'
              WRITE(MPG,'(A)') ' ** (incompatibility with Schur)'
            END IF
          END IF
          IF (id%KEEP(54) .NE. 0 .AND.                                  &
     &        id%KEEP(52).NE.7 .AND. id%KEEP(52).NE.8 .AND.             &
     &        id%KEEP(52) .NE. 0 ) THEN
             id%KEEP(52) = 0
             IF ( MPG .GT. 0 .and. id%ICNTL(8) .ne. 0 ) THEN
               WRITE(MPG,'(A)')                                         &
     &         ' ** Warning: This scaling option not available'
               WRITE(MPG,'(A)') ' ** for distributed matrix entry'
             END IF
          END IF
          IF ( id%KEEP(50) .NE. 0 ) THEN
             IF ( id%KEEP(52).ne.  1 .and.                              &
     &            id%KEEP(52).ne. -1 .and.                              &
     &            id%KEEP(52).ne.  0 .and.                              &
     &            id%KEEP(52).ne.  7 .and.                              &
     &            id%KEEP(52).ne.  8 .and.                              &
     &            id%KEEP(52).ne. -2 .and.                              &
     &            id%KEEP(52).ne. 77) THEN
              IF ( MPG .GT. 0 ) THEN
                WRITE(MPG,'(A)')                                        &
     &  ' ** Warning: Scaling option n.a. for symmetric matrix'
              END IF
              id%KEEP(52) = 0
            END IF
          END IF
          IF (id%KEEP(55) .NE. 0 .AND.                                  &
     &        ( id%KEEP(52) .gt. 0 ) ) THEN
            id%KEEP(52) = 0
            IF ( MPG .GT. 0 ) THEN
              WRITE(MPG,'(A)') ' ** Warning: Scaling not applied.'
              WRITE(MPG,'(A)')                                          &
     &        ' ** (only user scaling av. for elt. entry)'
            END IF
          END IF
          IF ( id%KEEP(52) .eq. -1 ) THEN
            IF ( .not. associated( id%ROWSCA ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 5
            ELSE IF ( size( id%ROWSCA ) < id%N ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 5
            ELSE IF ( .not. associated( id%COLSCA ) ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 6
            ELSE IF ( size( id%COLSCA ) < id%N ) THEN
              id%INFO(1) = -22
              id%INFO(2) = 6
            END IF
          END IF
          IF (id%KEEP(52).GT.0 .AND.                                    &
     &        id%KEEP(52) .LE.8) THEN
            IF ( associated(id%COLSCA))                                 &
     &             DEALLOCATE( id%COLSCA )
            IF ( associated(id%ROWSCA))                                 &
     &             DEALLOCATE( id%ROWSCA )
            ALLOCATE( id%COLSCA(N), stat=ierr)
            IF (ierr .GT.0) id%INFO(1)=-13
            ALLOCATE( id%ROWSCA(N), stat=ierr)
            IF (ierr .GT.0) id%INFO(1)=-13
          END IF
          IF (.NOT. associated(id%COLSCA)) THEN
            ALLOCATE( id%COLSCA(1), stat=ierr)
          END IF
          IF (ierr .GT.0) id%INFO(1)=-13
          IF (.NOT. associated(id%ROWSCA))                              &
     &    ALLOCATE( id%ROWSCA(1), stat=ierr)
          IF (ierr .GT.0) id%INFO(1)=-13
          IF ( id%INFO(1) .eq. -13 ) THEN
            IF ( LP .GT. 0 )                                            &
     &      WRITE(LP,*) 'Problems in allocations before facto'
            GOTO 200
          END IF
  200     CONTINUE
        END IF
        IF (id%KEEP(60).EQ.2.OR.id%KEEP(60).EQ.3) THEN
          IF ( id%root%yes ) THEN
            IF ( associated( id%SCHUR_CINTERFACE )) THEN
              id%SCHUR=>id%SCHUR_CINTERFACE                             &
     &          (1:id%SCHUR_LLD*(id%root%SCHUR_NLOC-1)+                 &
     &          id%root%SCHUR_MLOC)
            ENDIF
            IF (id%SCHUR_LLD < id%root%SCHUR_MLOC) THEN
              IF (LP.GT.0) write(LP,*)                                  &
     &          ' SCHUR leading dimension SCHUR_LLD ',                  &
     &          id%SCHUR_LLD, 'too small with respect to',              &
     &          id%root%SCHUR_MLOC
              id%INFO(1)=-30
              id%INFO(2)=id%SCHUR_LLD
            ELSE IF ( .NOT. associated (id%SCHUR)) THEN
              IF (LP.GT.0) write(LP,'(A)')                              &
     &                      ' SCHUR not associated'
              id%INFO(1)=-22
              id%INFO(2)=9
            ELSE IF (size(id%SCHUR) <                                   &
     &          id%SCHUR_LLD*(id%root%SCHUR_NLOC-1)+                    &
     &          id%root%SCHUR_MLOC) THEN
              IF (LP.GT.0) THEN
                write(LP,'(A)')                                         &
     &                      ' SCHUR allocated but too small'
                write(LP,*) id%MYID, ' : Size Schur=',                  &
     &          size(id%SCHUR),                                         &
     &          ' SCHUR_LLD= ', id%SCHUR_LLD,                           &
     &          ' SCHUR_MLOC=', id%root%SCHUR_NLOC,                     &
     &          ' SCHUR_NLOC=', id%root%SCHUR_NLOC
              ENDIF
              id%INFO(1)=-22
              id%INFO(2)= 9
            ELSE
               id%root%SCHUR_LLD=id%SCHUR_LLD
               IF (id%root%SCHUR_NLOC==0) THEN
                 ALLOCATE(id%root%SCHUR_POINTER(1))
               ELSE
                id%root%SCHUR_POINTER=>id%SCHUR
               ENDIF
            ENDIF
          ENDIF
        ENDIF
        CALL AGMG_MUMPS_276( id%ICNTL,                                       &
     &                      id%INFO,                                    &
     &                      id%COMM, id%MYID )
        IF ( id%INFO(1) .LT. 0 ) GO TO 499
        CALL DAGMG_MUMPS_142(id)
        IF (id%MYID .eq. MASTER) id%INFOG(33)=id%KEEP(52)
        IF (id%KEEP(60).EQ.2.OR.id%KEEP(60).EQ.3) THEN
          IF (id%root%yes) THEN
            IF (id%root%SCHUR_NLOC==0) THEN
               DEALLOCATE(id%root%SCHUR_POINTER)
               NULLIFY(id%root%SCHUR_POINTER)
            ELSE
               NULLIFY(id%root%SCHUR_POINTER)
            ENDIF
          ENDIF
        ENDIF
        IF ( id%INFO(1) .LT. 0 ) GO TO 499
        id%KEEP(40) = 2 - 456789
      END IF
      IF (LSOLVE) THEN
        IF (id%MYID .EQ. MASTER) THEN
          ICNTL20 = id%ICNTL(20)
          ICNTL21 = id%ICNTL(21)
          ICNTL26 = id%ICNTL(26)
          IF (ICNTL20 .ne.0.and.ICNTL20.ne.1) ICNTL20=0
          IF (ICNTL21 .ne.0.and.ICNTL21.ne.1) ICNTL21=0
          IF (ICNTL26 .ne.0.and.ICNTL26.ne.1.and.ICNTL26.ne.2) ICNTL26=0
          id%KEEP(221)=ICNTL26
        ENDIF
        CALL AGMG_SETIERR( ierr )
        CALL AGMG_SETIERR( ierr )
        CALL AGMG_SETIERR(                            ierr )
        id%KEEP(40) = 2 -456789
        IF ( id%MYID .EQ. MASTER ) THEN
          IF (ICNTL20 == 0 .OR. ICNTL21==0) THEN
           IF ( .not. associated( id%RHS ) ) THEN
              id%INFO( 1 ) = -22
              id%INFO( 2 ) = 7
              GOTO 333
           ELSE IF (id%NRHS.EQ.1) THEN
               IF ( size( id%RHS ) < id%N ) THEN
                  id%INFO( 1 ) = -22
                  id%INFO( 2 ) = 7
                  GOTO 333
               ENDIF
           ELSE IF (id%LRHS < id%N)                                     &
     &            THEN
                  id%INFO( 1 ) = -26
                  id%INFO( 2 ) = id%LRHS
                  GOTO 333
           ELSE IF                                                      &
     &     (size(id%RHS)<(id%NRHS*id%LRHS-id%LRHS+id%N))                &
     &            THEN
                  id%INFO( 1 ) = -22
                  id%INFO( 2 ) = 7
                  GOTO 333
           END IF
          ENDIF
          IF (ICNTL20 == 1) THEN
            IF ( .not. associated(id%RHS_SPARSE) )THEN
              id%INFO(1)=-22
              id%INFO(2)=10
              GOTO 333
            ENDIF
            IF ( .not. associated(id%IRHS_SPARSE) )THEN
              id%INFO(1)=-22
              id%INFO(2)=11
              GOTO 333
            ENDIF
            IF ( .not. associated(id%IRHS_PTR) )THEN
              id%INFO(1)=-22
              id%INFO(2)=12
              GOTO 333
            ENDIF
            IF (size(id%IRHS_PTR) < id%NRHS + 1) THEN
              id%INFO(1)=-22
              id%INFO(2)=12
              GOTO 333
            END IF
            IF (id%IRHS_PTR(id%NRHS + 1).ne.id%NZ_RHS+1) THEN
              id%INFO(1)=-27
              id%INFO(2)=id%IRHS_PTR(id%NRHS+1)
              GOTO 333
            END IF
            IF (id%IRHS_PTR(1).ne.1) THEN
              id%INFO(1)=-28
              id%INFO(2)=id%IRHS_PTR(1)
              GOTO 333
            END IF
            IF (size(id%IRHS_SPARSE) < id%NZ_RHS) THEN
              id%INFO(1)=-22
              id%INFO(2)=11
              GOTO 333
            END IF
            IF (size(id%RHS_SPARSE) < id%NZ_RHS) THEN
              id%INFO(1)=-22
              id%INFO(2)=10
              GOTO 333
            END IF
          ENDIF
          IF ( ICNTL26 == 1 .or. ICNTL26 ==2 ) THEN
            IF ( id%KEEP(60).eq. 0 .or. id%SIZE_SCHUR.EQ.0 ) THEN
              id%INFO(1)=-33
              id%INFO(2)=ICNTL26
              GOTO 333
            ENDIF
            IF ( .NOT. associated( id%REDRHS)) THEN
              id%INFO(1)=-22
              id%INFO(2)=15
              GOTO 333
            ELSE IF (id%NRHS.EQ.1) THEN
              IF (size(id%REDRHS) < id%SIZE_SCHUR ) THEN
                id%INFO(1)=-22
                id%INFO(2)=15
                GOTO 333
              ENDIF
            ELSE IF (id%LREDRHS < id%SIZE_SCHUR) THEN
              id%INFO(1)=-34
              id%INFO(2)=id%LREDRHS
              GOTO 333
            ELSE IF                                                     &
     &      (size(id%REDRHS)<                                           &
     &         id%NRHS*id%LREDRHS-id%LREDRHS+id%SIZE_SCHUR)             &
     &      THEN
              id%INFO(1)=-22
              id%INFO(2)=15
              GOTO 333
            ENDIF
          ENDIF
        END IF
        IF (ICNTL21==1) THEN
          IF (id%MYID==MASTER) NRHS_TMP=id%NRHS
          CALL AGMG_SETIERR( ierr )
          IF ( id%MYID .ne. MASTER  .OR.                                &
     &       ( id%MYID .eq. MASTER .AND.                                &
     &               id%KEEP(46) .eq. 1 ) ) THEN
            IF ( id%LSOL_LOC < id%KEEP(89) ) THEN
              id%INFO(1)= -29
              id%INFO(2)= id%LSOL_LOC
            ENDIF
            IF ( .not. associated(id%ISOL_LOC) )THEN
              id%INFO(1)=-22
              id%INFO(2)=13
              GOTO 333
            ENDIF
            IF ( .not. associated(id%SOL_LOC) )THEN
              id%INFO(1)=-22
              id%INFO(2)=14
              GOTO 333
            ENDIF
            IF (id%LSOL_LOC < id%KEEP(89)) THEN
              id%INFO(1)=-29
              id%INFO(2)=id%LSOL_LOC
              GOTO 333
            ENDIF
            IF (size(id%ISOL_LOC) < id%KEEP(89) ) THEN
              id%INFO(1)=-22
              id%INFO(2)=13
              GOTO 333
            END IF
            IF (size(id%SOL_LOC) <                                      &
     &              (NRHS_TMP-1)*id%LSOL_LOC+id%KEEP(89)) THEN
              id%INFO(1)=-22
              id%INFO(2)=14
              GOTO 333
            END IF
          ENDIF
        ENDIF
        IF (id%MYID .NE. MASTER) THEN
          IF (ICNTL20 == 1) THEN
           IF ( associated( id%RHS ) ) THEN
             id%INFO( 1 ) = -22
             id%INFO( 2 ) = 7
             GOTO 333
           END IF
           IF ( associated( id%RHS_SPARSE ) ) THEN
             id%INFO( 1 ) = -22
             id%INFO( 2 ) = 10
             GOTO 333
           END IF
           IF ( associated( id%IRHS_SPARSE ) ) THEN
             id%INFO( 1 ) = -22
             id%INFO( 2 ) = 11
             GOTO 333
           END IF
           IF ( associated( id%IRHS_PTR ) ) THEN
             id%INFO( 1 ) = -22
             id%INFO( 2 ) = 12
             GOTO 333
           END IF
          END IF
        END IF
  333   CONTINUE
        CALL AGMG_MUMPS_276( id%ICNTL,                                       &
     &                      id%INFO,                                    &
     &                      id%COMM, id%MYID )
        IF ( id%INFO(1) .LT. 0 ) GO TO 499
        CALL DAGMG_MUMPS_301(id)
        IF (id%INFO(1).LT.0) GOTO 499
        id%KEEP(40) = 3 -456789
      ENDIF
      IF (MP.GT.0) CALL DAGMG_MUMPS_349(id, MP)
      GOTO 500
  499 PROK  = ((id%ICNTL(1).GT.0).AND.                                  &
     &         (id%ICNTL(4).GE.1))
      IF (PROK) WRITE (id%ICNTL(1),99995) id%INFO(1)
      IF (PROK) WRITE (id%ICNTL(1),99994) id%INFO(2)
  500 CONTINUE
      IF (id%MYID .eq. MASTER .AND. id%KEEP(23) .NE. 0                  &
     &    .AND. NOERRORBEFOREPERM) THEN
        IF (id%JOB .NE. 3 .OR. UNS_PERM_DONE) THEN
          DO I = 1, id%NZ
            J=id%JCN(I)
            IF (J.LE.0.OR.J.GT.id%N) CYCLE
            id%JCN(I)=id%UNS_PERM(J)
          END DO
        END IF
      END IF
  510 CONTINUE
      CALL DAGMG_MUMPS_300( id%INFO, id%INFOG, id%COMM, id%MYID )
      CALL AGMG_SETIERR( ierr )
      IF (id%MYID.EQ.MASTER.and.MPG.GT.0.and.                           &
     & id%INFOG(1).lt.0) THEN
        WRITE(MPG,'(A,I12)') ' On return from DMUMPS, INFOG(1)=',       &
     &      id%INFOG(1)
        WRITE(MPG,'(A,I12)') ' On return from DMUMPS, INFOG(2)=',       &
     &      id%INFOG(2)
      END IF
       CALL AGMG_SETIERR( ierr )
       id%COMM = COMM_SAVE
      RETURN
99995 FORMAT (' ** ERROR RETURN ** FROM DMUMPS INFO(1)=', I3)
99994 FORMAT (' ** INFO(2)=', I10)
99993 FORMAT (' ** Allocation error: could not permute JCN.')
      END SUBROUTINE DAGMG_MUMPS
      SUBROUTINE DAGMG_MUMPS_300( INFO, INFOG, COMM, MYID )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER INFO(40), INFOG(40), COMM, MYID
      INTEGER TMP1(2),TMP(2)
      INTEGER ROOT, ierr
      INTEGER MASTER
      PARAMETER (MASTER=0)
      IF ( INFO(1) .ge. 0  .and. INFO(2) .ge. 0 ) THEN
        INFOG(1) = INFO(1)
        INFOG(2) = INFO(2)
      ELSE
        INFOG(1) = INFO(1)
        TMP1(1) = INFO(1)
        TMP1(2) = MYID
        CALL AGMG_COPY(TMP1,TMP,1,AGMG_MPF_2INTEGER,ierr )
        INFOG(2) = INFO(2)
        ROOT = TMP(2)
        CALL AGMG_SETIERR( ierr )
        CALL AGMG_SETIERR( ierr )
      END IF
      CALL AGMG_SETIERR( ierr )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_300
      SUBROUTINE DAGMG_MUMPS_349(id, LP)
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET, INTENT(IN) :: id
      INTEGER  :: LP
      INTEGER, POINTER :: JOB
      INTEGER,DIMENSION(:),POINTER::ICNTL
      INTEGER MASTER
      PARAMETER( MASTER = 0 )
      IF (LP.LT.0) RETURN
      JOB=>id%JOB
      ICNTL=>id%ICNTL
      IF (id%MYID.EQ.MASTER) THEN
         SELECT CASE (JOB)
         CASE(1);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) ICNTL(5),ICNTL(6),ICNTL(7),ICNTL(12),         &
     &          ICNTL(13),ICNTL(18),ICNTL(19),ICNTL(22)
           IF ((ICNTL(6).EQ.5).OR.(ICNTL(6).EQ.6).OR.                   &
     &          (ICNTL(12).NE.1) )  THEN
              WRITE (LP,992) ICNTL(8)
           ENDIF
           IF (id%ICNTL(19).NE.0)                                       &
     &      WRITE(LP,998) id%SIZE_SCHUR
           WRITE (LP,993) ICNTL(14)
         CASE(2);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,992) ICNTL(8)
           WRITE (LP,993) ICNTL(14)
         CASE(3);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
         CASE(4);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,992) ICNTL(8)
           IF (id%ICNTL(19).NE.0)                                       &
     &      WRITE(LP,998) id%SIZE_SCHUR
           WRITE (LP,993) ICNTL(14)
         CASE(5);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) ICNTL(5),ICNTL(6),ICNTL(7),ICNTL(12),         &
     &          ICNTL(13),ICNTL(18),ICNTL(19),ICNTL(22)
           WRITE (LP,992) ICNTL(8)
           WRITE (LP,993) ICNTL(14)
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
         CASE(6);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) ICNTL(5),ICNTL(6),ICNTL(7),ICNTL(12),         &
     &          ICNTL(13),ICNTL(18),ICNTL(19),ICNTL(22)
           IF (id%ICNTL(19).NE.0)                                       &
     &      WRITE(LP,998) id%SIZE_SCHUR
           WRITE (LP,992) ICNTL(8)
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
           WRITE (LP,993) ICNTL(14)
        END SELECT
      ENDIF
  980 FORMAT (/'***********CONTROL PARAMETERS (ICNTL)**************'/)
  990 FORMAT (                                                          &
     &     'ICNTL(1)   Output stream for error messages        =',I10/  &
     &     'ICNTL(2)   Output stream for diagnostic messages   =',I10/  &
     &     'ICNTL(3)   Output stream for global information    =',I10/  &
     &     'ICNTL(4)   Level of printing                       =',I10)
  991 FORMAT (                                                          &
     &     'ICNTL(5)   Matrix format  ( keep(55) )             =',I10/  &
     &     'ICNTL(6)   Maximum transversal  ( keep(23) )       =',I10/  &
     &     'ICNTL(7)   Ordering                                =',I10/  &
     &     'ICNTL(12)  LDLT ordering strat ( keep(95) )        =',I10/  &
     &     'ICNTL(13)  Parallel root (0=on, 1=off)             =',I10/  &
     &     'ICNTL(18)  Distributed matrix  ( keep(54) )        =',I10/  &
     &     'ICNTL(19)  Schur option ( keep(60) 0=off,else=on ) =',I10/  &
     &     'ICNTL(22)  Out-off-core option (0=Off, >0=ON)      =',I10)
  992 FORMAT (                                                          &
     &     'ICNTL(8)   Scaling strategy                        =',I10)
  993 FORMAT (                                                          &
     &     'ICNTL(14)  Percent of memory increase              =',I10)
  995 FORMAT (                                                          &
     &     'ICNTL(9)   Solve A x=b (1) or A''x = b (else)       =',I10/ &
     &     'ICNTL(10)  Max steps iterative refinement          =',I10/  &
     &     'ICNTL(11)  Error analysis ( 0= off, else=on)       =',I10)
  998 FORMAT (                                                          &
     &     '      Size of SCHUR matrix (SIZE_SHUR)             =',I10)
      END SUBROUTINE DAGMG_MUMPS_349
      SUBROUTINE DAGMG_MUMPS_350(id, LP)
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET, INTENT(IN) :: id
      INTEGER ::LP
      INTEGER, POINTER :: JOB
      INTEGER,DIMENSION(:),POINTER::ICNTL, KEEP
      INTEGER MASTER
      PARAMETER( MASTER = 0 )
      IF (LP.LT.0) RETURN
      JOB=>id%JOB
      ICNTL=>id%ICNTL
      KEEP=>id%KEEP
      IF (id%MYID.EQ.MASTER) THEN
         SELECT CASE (JOB)
         CASE(1);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) KEEP(55),KEEP(23),ICNTL(7),KEEP(95),          &
     &          ICNTL(13),KEEP(54),KEEP(60),ICNTL(22)
           IF ((KEEP(23).EQ.5).OR.(KEEP(23).EQ.6))THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           WRITE (LP,993) KEEP(12)
         CASE(2);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           IF (KEEP(23).EQ.0)THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           WRITE (LP,993) KEEP(12)
         CASE(3);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
         CASE(4);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           IF (KEEP(23).NE.0)THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           WRITE (LP,991) KEEP(55),KEEP(23),ICNTL(7),KEEP(95),          &
     &          ICNTL(13),KEEP(54),KEEP(60),ICNTL(22)
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
           WRITE (LP,993) KEEP(12)
         CASE(5);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) KEEP(55),KEEP(23),ICNTL(7),KEEP(95),          &
     &          ICNTL(13),KEEP(54),KEEP(60),ICNTL(22)
           IF ((KEEP(23).EQ.5).OR.(KEEP(23).EQ.6)                       &
     &       .OR. (KEEP(23).EQ.7)) THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           IF (KEEP(23).EQ.0)THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           WRITE (LP,993) KEEP(12)
         CASE(6);
           WRITE (LP,980)
           WRITE (LP,990) ICNTL(1),ICNTL(2),ICNTL(3),ICNTL(4)
           WRITE (LP,991) KEEP(55),KEEP(23),ICNTL(7),KEEP(95),          &
     &          ICNTL(13),KEEP(54),KEEP(60),ICNTL(22)
           IF ((KEEP(23).EQ.5).OR.(KEEP(23).EQ.6)                       &
     &       .OR. (KEEP(23).EQ.7)) THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           IF (KEEP(23).EQ.0)THEN
              WRITE (LP,992) KEEP(52)
           ENDIF
           WRITE (LP,995)                                               &
     &     ICNTL(9),ICNTL(10),ICNTL(11),ICNTL(20),ICNTL(21)
           WRITE (LP,993) KEEP(12)
        END SELECT
      ENDIF
  980 FORMAT (/'******INTERNAL VALUE OF PARAMETERS (ICNTL/KEEP)****'/)
  990 FORMAT (                                                          &
     &     'ICNTL(1)   Output stream for error messages        =',I10/  &
     &     'ICNTL(2)   Output stream for diagnostic messages   =',I10/  &
     &     'ICNTL(3)   Output stream for global information    =',I10/  &
     &     'ICNTL(4)   Level of printing                       =',I10)
  991 FORMAT (                                                          &
     &     'ICNTL(5)   Matrix format  ( keep(55) )             =',I10/  &
     &     'ICNTL(6)   Maximum transversal  ( keep(23) )       =',I10/  &
     &     'ICNTL(7)   Ordering                                =',I10/  &
     &     'ICNTL(12)  LDLT ordering strat ( keep(95) )        =',I10/  &
     &     'ICNTL(13)  Parallel root (0=on, 1=off)             =',I10/  &
     &     'ICNTL(18)  Distributed matrix  ( keep(54) )        =',I10/  &
     &     'ICNTL(19)  Schur option ( keep(60) 0=off,else=on ) =',I10/  &
     &     'ICNTL(22)  Out-off-core option (0=Off, >0=ON)      =',I10)
  992 FORMAT (                                                          &
     &     'ICNTL(8)   Scaling strategy ( keep(52) )           =',I10)
  993 FORMAT (                                                          &
     &     'ICNTL(14)  Percent of memory increase ( keep(12) ) =',I10)
  995 FORMAT (                                                          &
     &     'ICNTL(9)   Solve A x=b (1) or A''x = b (else)      =',I10/  &
     &     'ICNTL(10)  Max steps iterative refinement          =',I10/  &
     &     'ICNTL(11)  Error analysis ( 0= off, else=on)       =',I10/  &
     &     'ICNTL(20)  Dense (0) or sparse (1) RHS             =',I10/  &
     &     'ICNTL(21)  Gathered (0) or distributed(1) solution =',I10)
      END SUBROUTINE DAGMG_MUMPS_350
      SUBROUTINE DAGMG_MUMPS_24( MYID, SLAVEF, N,                            &
     &           PROCNODE, STEP, PTRAIW, PTRARW, ISTEP_TO_INIV2,        &
     &           I_AM_CAND,                                             &
     &           KEEP, KEEP8, ICNTL, id )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER MYID, N, SLAVEF
      INTEGER KEEP( 500 ), ICNTL( 40 )
      INTEGER*8 KEEP8(150)
      INTEGER PROCNODE( KEEP(28) ), STEP( N ),                          &
     &        PTRAIW( N ), PTRARW( N )
      INTEGER ISTEP_TO_INIV2(KEEP(71))
      LOGICAL I_AM_CAND(max(1,KEEP(56)))
      LOGICAL I_AM_SLAVE
      LOGICAL I_AM_CAND_LOC
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      INTEGER ISTEP, I, IPTRI, IPTRR, NCOL, NROW, allocok
      INTEGER TYPE_PARALL, ITYPE, IRANK
      TYPE_PARALL = KEEP(46)
      I_AM_SLAVE = (KEEP(46).EQ.1 .OR. MYID.NE.0)
      KEEP(14) = 0
      KEEP(13) = 0
      DO I = 1, N
        ISTEP=abs(STEP(I))
        ITYPE = AGMG_MUMPS_330( ISTEP, PROCNODE, SLAVEF )
        IRANK = AGMG_MUMPS_275( ISTEP, PROCNODE, SLAVEF )
        I_AM_CAND_LOC = .FALSE.
        IF (ITYPE.EQ.2.AND.I_AM_SLAVE) THEN
          I_AM_CAND_LOC = I_AM_CAND(ISTEP_TO_INIV2(ISTEP))
        ENDIF
        IF ( TYPE_PARALL .eq. 0 ) THEN
          IRANK = IRANK + 1
        END IF
        IF ( (ITYPE .EQ. 1.OR.ITYPE.EQ.2) .AND.                         &
     &            IRANK .EQ. MYID ) THEN
          KEEP( 14 ) = KEEP( 14 ) + 3 + PTRAIW( I ) + PTRARW( I )
          KEEP( 13 ) = KEEP( 13 ) + 1 + PTRAIW( I ) + PTRARW( I )
        ELSE IF ( ITYPE .EQ. 3 ) THEN
        ELSE IF ( ITYPE .EQ. 2 .AND. I_AM_CAND_LOC ) THEN
           PTRARW( I ) = 0
           KEEP(14) = KEEP(14) + 3 + PTRAIW( I ) + PTRARW( I )
           KEEP(13) = KEEP(13) + 1 + PTRAIW( I ) + PTRARW( I )
        END IF
      END DO
      IF ( associated( id%INTARR ) ) THEN
        DEALLOCATE( id%INTARR )
        NULLIFY( id%INTARR )
      END IF
      IF ( KEEP(14) > 0 ) THEN
      ALLOCATE( id%INTARR( KEEP(14) ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        id%INFO(1) = -7
        id%INFO(2) = KEEP(14)
        RETURN
      END IF
      ELSE
      ALLOCATE( id%INTARR( 1 ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        id%INFO(1) = -7
        id%INFO(2) = 1
        RETURN
      END IF
      END IF
      IPTRI = 1
      IPTRR = 1
      DO I = 1, N
        ISTEP = abs(STEP(I))
        ITYPE = AGMG_MUMPS_330( ISTEP, PROCNODE, SLAVEF )
        IRANK = AGMG_MUMPS_275( ISTEP, PROCNODE, SLAVEF )
        IF ( TYPE_PARALL .eq. 0 ) THEN
          IRANK =IRANK + 1
        END IF
        IF (                                                            &
     &      ( ITYPE .eq. 2 .and.                                        &
     &        IRANK .eq. MYID )                                         &
     & .or.                                                             &
     &      ( ITYPE .eq. 1 .and.                                        &
     &        IRANK .eq. MYID )                                         &
     &     )  THEN
          NCOL = PTRAIW( I )
          NROW = PTRARW( I )
          id%INTARR( IPTRI     ) = NCOL
          id%INTARR( IPTRI + 1 ) = -NROW
          id%INTARR( IPTRI + 2 ) = I
          PTRAIW( I ) = IPTRI
          PTRARW( I ) = IPTRR
          IPTRI = IPTRI + NCOL + NROW + 3
          IPTRR = IPTRR + NCOL + NROW + 1
        ELSE IF ( ITYPE .eq. 2 ) THEN
          IF ( I_AM_CAND(ISTEP_TO_INIV2(ISTEP)))                        &
     &    THEN
           NCOL = PTRAIW( I )
           NROW = 0
           id%INTARR( IPTRI     ) = NCOL
           id%INTARR( IPTRI + 1 ) = -NROW
           id%INTARR( IPTRI + 2 ) = I
           PTRAIW( I ) = IPTRI
           PTRARW( I ) = IPTRR
           IPTRI = IPTRI + NCOL + NROW + 3
           IPTRR = IPTRR + NCOL + NROW + 1
          ELSE
           PTRAIW(I)=0
           PTRARW(I)=0
          ENDIF
        ELSE
          PTRAIW(I) = 0
          PTRARW(I) = 0
        END IF
      END DO
      IF ( IPTRI - 1 .NE. KEEP(14) ) THEN
        WRITE(*,*) 'Error 1 in anal_arrowheads'
        CALL AGMG_MUMPS_ABORT()
      END IF
      IF ( IPTRR - 1 .NE. KEEP(13) ) THEN
        WRITE(*,*) 'Error 2 in anal_arrowheads'
        CALL AGMG_MUMPS_ABORT()
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_24
      SUBROUTINE DAGMG_MUMPS_148(N, NZ, ASPK,                                &
     &   IRN, ICN, PERM,                                                &
     &   LSCAL,COLSCA,ROWSCA,                                           &
     &   MYID, SLAVEF, PROCNODE_STEPS, NBRECORDS,                       &
     &   LP, COMM, root, KEEP, KEEP8, FILS, RG2L,                       &
     &   INTARR, DBLARR, PTRAIW, PTRARW, FRERE_STEPS,                   &
     &   STEP, A, LA, ISTEP_TO_INIV2, I_AM_CAND, CANDIDATES )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER N,NZ, COMM, NBRECORDS
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION ASPK(NZ)
      DOUBLE PRECISION COLSCA(*), ROWSCA(*)
      INTEGER IRN(NZ), ICN(NZ)
      INTEGER PERM(N), PROCNODE_STEPS(KEEP(28))
      INTEGER RG2L( N ), FILS( N )
      INTEGER ISTEP_TO_INIV2(KEEP(71))
      LOGICAL I_AM_CAND(max(1,KEEP(56)))
      INTEGER LP, SLAVEF, MYID
      INTEGER CANDIDATES(SLAVEF+1, max(1,KEEP(56)))
      LOGICAL LSCAL
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER(8) :: LA
      INTEGER PTRAIW( N ), PTRARW( N ), FRERE_STEPS( KEEP(28) )
      INTEGER STEP(N)
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION A( LA ), DBLARR(max(1,KEEP(13)))
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: BUFI
      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: BUFR
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330, NUMROC_FOOL
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330, NUMROC_FOOL
      DOUBLE PRECISION VAL
      INTEGER IOLD,JOLD,INEW,JNEW,ISEND,JSEND,DEST,I,K,IARR
      INTEGER IPOSROOT, JPOSROOT
      INTEGER IROW_GRID, JCOL_GRID
      INTEGER INODE, ISTEP
      INTEGER NBUFS
      INTEGER ARROW_ROOT, TAILLE
      INTEGER LOCAL_M, LOCAL_N
      INTEGER(8) :: PTR_ROOT
      INTEGER TYPENODE_TMP, MASTER_NODE
      LOGICAL I_AM_CAND_LOC, I_AM_SLAVE
      INTEGER I1, IA, JARR, ILOCROOT, JLOCROOT
      INTEGER IS1, ISHIFT, IIW, IS, IAS, IPROC
      INTEGER allocok
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      INTEGER, POINTER, DIMENSION(:,:) :: IW4
      ARROW_ROOT = 0
      I_AM_SLAVE=(MYID.NE.0.OR.KEEP(46).EQ.1)
      IF ( KEEP(46) .eq. 0 ) THEN
        NBUFS = SLAVEF
      ELSE
        NBUFS = SLAVEF - 1
        ALLOCATE( IW4( N, 2 ), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          WRITE(*,*) 'Error allocating IW4'
          CALL AGMG_MUMPS_ABORT()
        END IF
        DO I = 1, N
          I1 = PTRAIW( I )
          IA = PTRARW( I )
          IF ( IA .GT. 0 ) THEN
            DBLARR( IA ) = dble(ZERO)
            IW4( I, 1 ) = INTARR( I1 )
            IW4( I, 2 ) = -INTARR( I1 + 1 )
            INTARR( I1 + 2 ) = I
          END IF
        END DO
        IF ( KEEP(38) .NE. 0 ) THEN
          IF (KEEP(60)==0) THEN
            LOCAL_M = NUMROC_FOOL( root%ROOT_SIZE, root%MBLOCK,              &
     &               root%MYROW, 0, root%NPROW )
            LOCAL_M = max( 1, LOCAL_M )
            LOCAL_N = NUMROC_FOOL( root%ROOT_SIZE, root%NBLOCK,              &
     &               root%MYCOL, 0, root%NPCOL )
            PTR_ROOT = LA - int(LOCAL_M,8) * int(LOCAL_N,8) + 1_8
            IF ( PTR_ROOT .LE. LA ) THEN
              A( PTR_ROOT:LA ) = dble(ZERO)
            END IF
          ELSE
            DO I = 1, root%SCHUR_NLOC
              root%SCHUR_POINTER(int(I-1,8)*int(root%SCHUR_LLD,8)+1_8:  &
     &        int(I-1,8)*int(root%SCHUR_LLD,8)+int(root%SCHUR_MLOC,8))= &
     &        dble(ZERO)
            ENDDO
          ENDIF
        END IF
      END IF
      IF (NBUFS.GT.0) THEN
       ALLOCATE( BUFI(NBRECORDS*2+1,NBUFS),stat=allocok )
       IF ( allocok .GT. 0 ) THEN
        WRITE(*,*) 'Error allocating BUFI'
        CALL AGMG_MUMPS_ABORT()
       END IF
       ALLOCATE( BUFR( NBRECORDS, NBUFS ), stat=allocok )
       IF ( allocok .GT. 0 ) THEN
         WRITE(*,*) 'Error allocating BUFR'
         CALL AGMG_MUMPS_ABORT()
       END IF
       DO I = 1, NBUFS
        BUFI( 1, I ) = 0
       ENDDO
      ENDIF
      INODE = KEEP(38)
      I     = 1
      DO WHILE ( INODE .GT. 0 )
        RG2L( INODE ) = I
        INODE = FILS( INODE )
        I = I + 1
      END DO
      DO 120 K=1,NZ
        IOLD = IRN(K)
        JOLD = ICN(K)
        IF ( (IOLD.GT.N).OR.(JOLD.GT.N).OR.(IOLD.LT.1)                  &
     &                 .OR.(JOLD.LT.1) ) THEN
           GOTO 120
        END IF
        IF (LSCAL) THEN
          VAL = ASPK(K)*ROWSCA(IOLD)*COLSCA(JOLD)
        ELSE
          VAL = ASPK(K)
        ENDIF
        IF (IOLD.EQ.JOLD) THEN
          ISEND = IOLD
          JSEND = JOLD
        ELSE
          INEW = PERM(IOLD)
          JNEW = PERM(JOLD)
          IF (INEW.LT.JNEW) THEN
            ISEND = IOLD
            IF ( KEEP(50) .NE. 0 ) ISEND = -IOLD
            JSEND = JOLD
          ELSE
            ISEND = -JOLD
            JSEND = IOLD
          ENDIF
        ENDIF
        IARR  = abs( ISEND )
        ISTEP = abs( STEP(IARR) )
        TYPENODE_TMP = AGMG_MUMPS_330( ISTEP,                                &
     &       PROCNODE_STEPS, SLAVEF )
        MASTER_NODE  = AGMG_MUMPS_275( ISTEP,                                &
     &             PROCNODE_STEPS, SLAVEF )
        I_AM_CAND_LOC = .FALSE.
        IF (TYPENODE_TMP .EQ. 2 .AND. I_AM_SLAVE) THEN
          I_AM_CAND_LOC = I_AM_CAND(ISTEP_TO_INIV2(ISTEP))
        END IF
        IF ( TYPENODE_TMP .EQ. 1 ) THEN
          IF ( KEEP(46) .eq. 0 ) THEN
            DEST = MASTER_NODE + 1
          ELSE
            DEST = MASTER_NODE
          END IF
        ELSE IF ( TYPENODE_TMP .EQ. 2 ) THEN
          IF ( ISEND .LT. 0  ) THEN
            DEST = -1
          ELSE
            IF ( KEEP( 46 ) .eq. 0 ) THEN
              DEST = MASTER_NODE + 1
            ELSE
              DEST = MASTER_NODE
            END IF
          END IF
        ELSE
          IF ( ISEND .LT. 0 ) THEN
            IPOSROOT = RG2L(JSEND)
            JPOSROOT = RG2L(IARR)
          ELSE
            IPOSROOT = RG2L( IARR )
            JPOSROOT = RG2L( JSEND )
          END IF
          IROW_GRID = mod( ( IPOSROOT - 1 )/root%MBLOCK, root%NPROW )
          JCOL_GRID = mod( ( JPOSROOT - 1 )/root%NBLOCK, root%NPCOL )
          IF ( KEEP( 46 ) .eq. 0 ) THEN
            DEST = IROW_GRID * root%NPCOL + JCOL_GRID + 1
          ELSE
            DEST = IROW_GRID * root%NPCOL + JCOL_GRID
          END IF
        END IF
        IF ( DEST .eq. 0 .or.                                           &
     &     ( DEST .eq. -1 .and. KEEP( 46 ) .eq. 1 .AND.                 &
     &       ( I_AM_CAND_LOC .OR. MASTER_NODE .EQ. 0 ) )) THEN
          IARR = ISEND
          JARR = JSEND
          IF ( TYPENODE_TMP .eq. 3 ) THEN
            ARROW_ROOT = ARROW_ROOT + 1
            IF ( IROW_GRID .EQ. root%MYROW .AND.                        &
     &         JCOL_GRID .EQ. root%MYCOL ) THEN
              ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /             &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
              JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /             &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
             IF (KEEP(60)==0) THEN
               A( PTR_ROOT                                              &
     &           + int(JLOCROOT - 1,8) * int(LOCAL_M,8)                 &
     &           + int(ILOCROOT - 1,8) )                                &
     &         =  A( PTR_ROOT                                           &
     &           + int(JLOCROOT - 1,8) * int(LOCAL_M,8)                 &
     &           + int(ILOCROOT - 1,8) )                                &
     &         + VAL
             ELSE
               root%SCHUR_POINTER( int(JLOCROOT - 1,8)                  &
     &                           * int(root%SCHUR_LLD,8)                &
     &                           + int(ILOCROOT,8) )                    &
     &          = root%SCHUR_POINTER( int(JLOCROOT - 1,8)               &
     &                           *    int(root%SCHUR_LLD,8)             &
     &                           +    int(ILOCROOT,8))                  &
     &          + VAL
             ENDIF
            ELSE
              WRITE(*,*) MYID,':INTERNAL Error: root arrowhead '
              WRITE(*,*) MYID,':is not belonging to me. IARR,JARR='     &
     &        ,IARR,JARR
              CALL AGMG_MUMPS_ABORT()
            END IF
          ELSE IF ( IARR .GE. 0 ) THEN
            IF ( IARR .eq. JARR ) THEN
              IA = PTRARW( IARR )
              DBLARR( IA ) = DBLARR( IA ) + VAL
            ELSE
              IS1 =  PTRAIW(IARR)
              ISHIFT      = INTARR(IS1) + IW4(IARR,2)
              IW4(IARR,2) = IW4(IARR,2) - 1
              IIW         = IS1 + ISHIFT + 2
              INTARR(IIW)     = JARR
              IS          = PTRARW(IARR)
              IAS         = IS + ISHIFT
              DBLARR(IAS) = VAL
            END IF
          ELSE
            IARR = -IARR
            ISHIFT      = PTRAIW(IARR)+IW4(IARR,1)+2
            INTARR(ISHIFT)  = JARR
            IAS         = PTRARW(IARR)+IW4(IARR,1)
            IW4(IARR,1) = IW4(IARR,1) - 1
            DBLARR(IAS)      = VAL
            IF ( (KEEP(50) .NE. 0 .OR. KEEP(234).NE.0 )                 &
     &           .AND.  IW4(IARR,1) .EQ. 0 .AND.                        &
     &           STEP( IARR) > 0 ) THEN
              IF (AGMG_MUMPS_275( abs(STEP(IARR)),                           &
     &              PROCNODE_STEPS,SLAVEF ) == MYID) THEN
                TAILLE = INTARR( PTRAIW(IARR) )
                CALL DAGMG_MUMPS_310( N, PERM,                               &
     &             INTARR( PTRAIW(IARR) + 3 ),                          &
     &             DBLARR( PTRARW(IARR) + 1 ),                          &
     &             TAILLE, 1, TAILLE )
              END IF
            END IF
          ENDIF
        END IF
        IF ( DEST.EQ. -1 ) THEN
         DO I=1, CANDIDATES(SLAVEF+1,ISTEP_TO_INIV2(ISTEP))
           DEST=CANDIDATES(I,ISTEP_TO_INIV2(ISTEP))
           IF (KEEP(46).EQ.0) DEST=DEST+1
           IF (DEST.NE.0)                                               &
     &     CALL DAGMG_MUMPS_34( ISEND, JSEND, VAL,                           &
     &     DEST, BUFI, BUFR, NBRECORDS, NBUFS,                          &
     &     LP, COMM, KEEP(46))
         ENDDO
         DEST = MASTER_NODE
         IF (KEEP(46).EQ.0) DEST=DEST+1
         IF ( DEST .NE. 0 ) THEN
           CALL DAGMG_MUMPS_34( ISEND, JSEND, VAL,                           &
     &     DEST, BUFI, BUFR, NBRECORDS, NBUFS,                          &
     &     LP, COMM, KEEP(46))
         ENDIF
        ELSE IF ( DEST .GT. 0 ) THEN
         CALL DAGMG_MUMPS_34( ISEND, JSEND, VAL,                             &
     &    DEST, BUFI, BUFR, NBRECORDS, NBUFS,                           &
     &    LP, COMM, KEEP(46))
        END IF
  120 END DO
      KEEP(49) = ARROW_ROOT
      IF (NBUFS.GT.0) THEN
       CALL DAGMG_MUMPS_18(                                                  &
     &   BUFI, BUFR, NBRECORDS, NBUFS,                                  &
     &   LP, COMM, KEEP( 46 ) )
      ENDIF
      IF ( KEEP( 46 ) .NE. 0 ) DEALLOCATE( IW4 )
      IF (NBUFS.GT.0) THEN
        DEALLOCATE( BUFI )
        DEALLOCATE( BUFR )
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_148
      SUBROUTINE DAGMG_MUMPS_34(ISEND, JSEND, VAL,                           &
     &   DEST, BUFI, BUFR, NBRECORDS, NBUFS, LP, COMM,                  &
     &   TYPE_PARALL )
      IMPLICIT NONE
      INTEGER ISEND, JSEND, DEST, NBUFS, NBRECORDS, TYPE_PARALL
      INTEGER BUFI( NBRECORDS * 2 + 1, NBUFS )
      DOUBLE PRECISION BUFR( NBRECORDS, NBUFS )
      INTEGER COMM
      INTEGER LP
      DOUBLE PRECISION VAL
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IBEG,IEND, IERR
      INTEGER TAILLE_SENDI, TAILLE_SENDR, IREQ
         IF (BUFI(1,DEST)+1.GT.NBRECORDS) THEN
          TAILLE_SENDI = BUFI(1,DEST) * 2 + 1
          TAILLE_SENDR = BUFI(1,DEST)
          CALL AGMG_NOCALL('MPI_SEND')
          CALL AGMG_NOCALL('MPI_SEND')
          BUFI(1,DEST) = 0
         ENDIF
         IREQ = BUFI(1,DEST) + 1
         BUFI(1,DEST) = IREQ
         BUFI( IREQ * 2, DEST )     = ISEND
         BUFI( IREQ * 2 + 1, DEST ) = JSEND
         BUFR( IREQ, DEST )         = VAL
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_34
      SUBROUTINE DAGMG_MUMPS_18(                                             &
     &   BUFI, BUFR, NBRECORDS, NBUFS, LP, COMM,                        &
     &   TYPE_PARALL )
      IMPLICIT NONE
      INTEGER NBUFS, NBRECORDS, TYPE_PARALL
      INTEGER BUFI( NBRECORDS * 2 + 1, NBUFS )
      DOUBLE PRECISION BUFR( NBRECORDS, NBUFS )
      INTEGER COMM
      INTEGER LP
      INTEGER ISLAVE, TAILLE_SENDI, TAILLE_SENDR, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
        DO ISLAVE = 1,NBUFS
          TAILLE_SENDI = BUFI(1,ISLAVE) * 2 + 1
          TAILLE_SENDR = BUFI(1,ISLAVE)
          BUFI(1,ISLAVE) = - BUFI(1,ISLAVE)
          CALL AGMG_NOCALL('MPI_SEND')
          IF ( TAILLE_SENDR .NE. 0 ) THEN
            CALL AGMG_NOCALL('MPI_SEND')
          END IF
        ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_18
      RECURSIVE SUBROUTINE DAGMG_MUMPS_310( N, PERM,                         &
     &            INTLIST, DBLLIST, TAILLE, LO, HI )
      IMPLICIT NONE
      INTEGER N, TAILLE
      INTEGER PERM( N )
      INTEGER INTLIST( TAILLE )
      DOUBLE PRECISION DBLLIST( TAILLE )
      INTEGER LO, HI
      INTEGER I,J
      INTEGER ISWAP, PIVOT
      DOUBLE PRECISION DSWAP
      I = LO
      J = HI
      PIVOT = PERM(INTLIST((I+J)/2))
   10 IF (PERM(INTLIST(I)) < PIVOT) THEN
        I=I+1
        GOTO 10
      ENDIF
   20 IF (PERM(INTLIST(J)) > PIVOT) THEN
        J=J-1
        GOTO 20
      ENDIF
      IF (I < J) THEN
        ISWAP = INTLIST(I)
        INTLIST(I) = INTLIST(J)
        INTLIST(J)=ISWAP
        DSWAP = DBLLIST(I)
        DBLLIST(I) = DBLLIST(J)
        DBLLIST(J) = DSWAP
      ENDIF
      IF ( I <= J) THEN
        I = I+1
        J = J-1
      ENDIF
      IF ( I <= J ) GOTO 10
      IF ( LO < J ) CALL DAGMG_MUMPS_310(N, PERM,                            &
     &              INTLIST, DBLLIST, TAILLE, LO, J)
      IF ( I < HI ) CALL DAGMG_MUMPS_310(N, PERM,                            &
     &              INTLIST, DBLLIST, TAILLE, I, HI)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_310
      SUBROUTINE DAGMG_MUMPS_145(  N,                                        &
     &    DBLARR, LDBLARR, INTARR, LINTARR, PTRAIW, PTRARW,             &
     &    KEEP, KEEP8, MYID,  COMM, NBRECORDS,                          &
     &    A, LA, root,                                                  &
     &    PROCNODE_STEPS,                                               &
     &    SLAVEF, PERM, FRERE_STEPS, STEP, INFO1, INFO2                 &
     &   )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER N, MYID, LDBLARR, LINTARR,                                &
     &        COMM
      INTEGER INTARR(LINTARR)
      INTEGER PTRAIW(N), PTRARW(N)
      INTEGER   KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8), intent(IN) :: LA
      INTEGER PROCNODE_STEPS( KEEP(28) ), PERM( N )
      INTEGER SLAVEF, NBRECORDS
      DOUBLE PRECISION A( LA )
      INTEGER INFO1, INFO2
      DOUBLE PRECISION DBLARR(LDBLARR)
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER, POINTER, DIMENSION(:) :: BUFI
      DOUBLE PRECISION, POINTER, DIMENSION(:) :: BUFR
      INTEGER, POINTER, DIMENSION(:,:) :: IW4
      LOGICAL FINI
      INTEGER IREC, NB_REC, IARR, JARR, IA, I1, I, allocok
      INTEGER IS, IS1, ISHIFT, IIW, IAS
      INTEGER LOCAL_M, LOCAL_N, ILOCROOT, JLOCROOT,                     &
     &        IPOSROOT, JPOSROOT, TAILLE,                               &
     &        IPROC
      INTEGER FRERE_STEPS( KEEP(28) ), STEP(N)
      INTEGER(8) :: PTR_ROOT
      INTEGER ARROW_ROOT, TYPE_PARALL
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      DOUBLE PRECISION VAL
      DOUBLE PRECISION  ZERO
      PARAMETER( ZERO = 0.0D0 )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER MASTER
      PARAMETER(MASTER=0)
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER IERR
      INTEGER NUMROC_FOOL
      EXTERNAL NUMROC_FOOL
      TYPE_PARALL = KEEP(46)
      ARROW_ROOT=0
      ALLOCATE( BUFI( NBRECORDS * 2 + 1 ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        INFO1 = -13
        INFO2 = NBRECORDS * 2 + 1
        WRITE(*,*) MYID,': Could not allocate BUFI: goto 500'
        GOTO 500
      END IF
      ALLOCATE( BUFR( NBRECORDS )        , stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        INFO1 = -13
        INFO2 = NBRECORDS
        WRITE(*,*) MYID,': Could not allocate BUFR: goto 500'
        GOTO 500
      END IF
      ALLOCATE( IW4(N,2), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        INFO1 = -13
        INFO2 = 2 * N
        WRITE(*,*) MYID,': Could not allocate IW4: goto 500'
        GOTO 500
      END IF
      IF ( KEEP(38).NE.0) THEN
        IF (KEEP(60)==0) THEN
         LOCAL_M = NUMROC_FOOL( root%ROOT_SIZE, root%MBLOCK,                 &
     &             root%MYROW, 0, root%NPROW )
         LOCAL_M = max( 1, LOCAL_M )
         LOCAL_N = NUMROC_FOOL( root%ROOT_SIZE, root%NBLOCK,                 &
     &             root%MYCOL, 0, root%NPCOL )
         PTR_ROOT = LA - int(LOCAL_M,8) * int(LOCAL_N,8) + 1_8
         IF ( PTR_ROOT .LE. LA ) THEN
           A( PTR_ROOT:LA ) = dble(ZERO)
         END IF
        ELSE
         DO I=1, root%SCHUR_NLOC
           root%SCHUR_POINTER((I-1)*root%SCHUR_LLD+1:                   &
     &     (I-1)*root%SCHUR_LLD+root%SCHUR_MLOC)=dble(ZERO)
         ENDDO
        ENDIF
      END IF
      FINI = .FALSE.
      DO I=1,N
       I1 = PTRAIW(I)
       IA = PTRARW(I)
       IF (IA.GT.0) THEN
        DBLARR(IA) = dble(ZERO)
        IW4(I,1) = INTARR(I1)
        IW4(I,2) = -INTARR(I1+1)
        INTARR(I1+2)=I
       ENDIF
      ENDDO
      DO WHILE (.NOT.FINI)
       CALL AGMG_NOCALL('MPI_RECV')
       NB_REC = BUFI(1)
       IF (NB_REC.LE.0) THEN
         FINI = .TRUE.
         NB_REC = -NB_REC
       ENDIF
       IF (NB_REC.EQ.0) EXIT
       CALL AGMG_NOCALL('MPI_RECV')
       DO IREC=1, NB_REC
        IARR = BUFI( IREC * 2 )
        JARR = BUFI( IREC * 2 + 1 )
        VAL  = BUFR( IREC )
        IF ( AGMG_MUMPS_330( abs(STEP(abs(IARR))),                           &
     &       PROCNODE_STEPS, SLAVEF ) .eq. 3 ) THEN
          ARROW_ROOT = ARROW_ROOT + 1
          IF ( IARR .GT. 0 ) THEN
            IPOSROOT = root%RG2L_ROW( IARR )
            JPOSROOT = root%RG2L_COL( JARR )
          ELSE
            IPOSROOT = root%RG2L_ROW( JARR )
            JPOSROOT = root%RG2L_COL( -IARR )
          END IF
            ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /               &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
            JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /               &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
           IF (KEEP(60)==0) THEN
             A( PTR_ROOT + int(JLOCROOT - 1,8) * int(LOCAL_M,8)         &
     &                   + int(ILOCROOT - 1,8) )                        &
     &       =  A( PTR_ROOT + int(JLOCROOT - 1,8)                       &
     &                      * int(LOCAL_M,8)                            &
     &                      + int(ILOCROOT - 1,8))                      &
     &        + VAL
           ELSE
             root%SCHUR_POINTER( int(JLOCROOT-1,8)                      &
     &                         * int(root%SCHUR_LLD,8)                  &
     &                         + int(ILOCROOT,8) )                      &
     &       = root%SCHUR_POINTER( int(JLOCROOT - 1,8)                  &
     &                         * int(root%SCHUR_LLD,8)                  &
     &                         + int(ILOCROOT,8))                       &
     &       + VAL
           ENDIF
        ELSE IF (IARR.GE.0) THEN
         IF (IARR.EQ.JARR) THEN
          IA = PTRARW(IARR)
          DBLARR(IA) = DBLARR(IA) + VAL
         ELSE
          IS1 =  PTRAIW(IARR)
          ISHIFT      = INTARR(IS1) + IW4(IARR,2)
          IW4(IARR,2) = IW4(IARR,2) - 1
          IIW         = IS1 + ISHIFT + 2
          INTARR(IIW)     = JARR
          IS          = PTRARW(IARR)
          IAS         = IS + ISHIFT
          DBLARR(IAS) = VAL
         ENDIF
        ELSE
           IARR = -IARR
           ISHIFT      = PTRAIW(IARR)+IW4(IARR,1)+2
           INTARR(ISHIFT)  = JARR
           IAS         = PTRARW(IARR)+IW4(IARR,1)
           IW4(IARR,1) = IW4(IARR,1) - 1
           DBLARR(IAS)      = VAL
           IF ( (KEEP(50) .NE. 0 .OR. KEEP(234).NE.0)                   &
     &          .AND.  IW4(IARR,1) .EQ. 0                               &
     &          .AND. STEP(IARR) > 0 ) THEN
              IPROC = AGMG_MUMPS_275( abs(STEP(IARR)),                       &
     &        PROCNODE_STEPS,SLAVEF )
              IF ( TYPE_PARALL .eq. 0 ) THEN
                IPROC = IPROC + 1
              END IF
              IF (IPROC .EQ. MYID) THEN
                TAILLE = INTARR( PTRAIW(IARR) )
                CALL DAGMG_MUMPS_310( N, PERM,                               &
     &            INTARR( PTRAIW(IARR) + 3 ),                           &
     &            DBLARR( PTRARW(IARR) + 1 ),                           &
     &            TAILLE, 1, TAILLE )
              END IF
           END IF
        ENDIF
       ENDDO
      END DO
      DEALLOCATE( BUFI )
      DEALLOCATE( BUFR )
      DEALLOCATE( IW4 )
  500 CONTINUE
      KEEP(49) = ARROW_ROOT
      RETURN
      END SUBROUTINE DAGMG_MUMPS_145
      SUBROUTINE DAGMG_MUMPS_266( MYID, BUFR, LBUFR,                         &
     &     LBUFR_BYTES,                                                 &
     &     IWPOS, IWPOSCB,                                              &
     &     IPTRLU, LRLU, LRLUS,                                         &
     &     TNBPROCFILS, N, IW, LIW, A, LA,                              &
     &     PTRIST, PTRAST, STEP, PIMASTER, PAMASTER, COMP,              &
     &     KEEP,KEEP8, ITLOC,                                           &
     &     IFLAG, IERROR )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER MYID
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: IPTRLU, LRLU, LRLUS, LA
      INTEGER IWPOS, IWPOSCB, N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER PTRIST(KEEP(28)), STEP(N),                                &
     & PIMASTER(KEEP(28)),                                              &
     & TNBPROCFILS( KEEP(28) ), ITLOC( N )
      INTEGER COMP, IFLAG, IERROR
      INTEGER INODE, NBPROCFILS, NCOL, NROW, NASS, NSLAVES
      INTEGER NSLAVES_RECU, NFRONT
      INTEGER LREQ
      INTEGER(8) :: LREQCB
      DOUBLE PRECISION FLOP1
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INODE = BUFR( 1 )
      NBPROCFILS = BUFR( 2 )
      NROW = BUFR( 3 )
      NCOL = BUFR( 4 )
      NASS = BUFR( 5 )
      NFRONT = BUFR( 6 )
      NSLAVES_RECU = BUFR( 7 )
      IF ( KEEP(50) .eq. 0 ) THEN
         FLOP1 = dble( NASS * NROW ) +                                  &
     &     dble(NROW*NASS)*dble(2*NCOL-NASS-1)
      ELSE
         FLOP1 = dble( NASS ) * dble( NROW )                            &
     &            * dble( 2 * NCOL - NROW - NASS + 1)
      END IF
      CALL DAGMG_MUMPS_190(1,.TRUE.,FLOP1, KEEP,KEEP8)
      IF ( KEEP(50) .eq. 0 ) THEN
        NSLAVES = NSLAVES_RECU + XTRA_SLAVES_UNSYM
      ELSE
        NSLAVES = NSLAVES_RECU + XTRA_SLAVES_SYM
      END IF
      LREQ   = NROW + NCOL + 6 + NSLAVES + KEEP(IXSZ)
      LREQCB = int(NCOL,8) * int(NROW,8)
      CALL DAGMG_MUMPS_22(.FALSE., 0_8, .FALSE.,.TRUE.,                      &
     &   MYID,N, KEEP,KEEP8, IW, LIW, A, LA,                            &
     &   LRLU, IPTRLU,IWPOS,IWPOSCB,                                    &
     &   PTRIST,PTRAST, STEP, PIMASTER,PAMASTER, ITLOC,                 &
     &   LREQ, LREQCB, INODE, S_ACTIVE, .TRUE.,                         &
     &   COMP, LRLUS, IFLAG, IERROR                                     &
     &     )
      IF ( IFLAG .LT. 0 ) RETURN
      PTRIST(STEP(INODE)) = IWPOSCB + 1
      PTRAST(STEP(INODE)) = IPTRLU  + 1_8
      IW( IWPOSCB + 1+KEEP(IXSZ) ) = NCOL
      IW( IWPOSCB + 2+KEEP(IXSZ) ) = - NASS
      IW( IWPOSCB + 3+KEEP(IXSZ) ) = NROW
      IW( IWPOSCB + 4+KEEP(IXSZ) ) = 0
      IW( IWPOSCB + 5+KEEP(IXSZ) ) = NASS
      IW( IWPOSCB + 6+KEEP(IXSZ) ) = NSLAVES
      IW( IWPOSCB + 7+KEEP(IXSZ)+NSLAVES :                              &
     &           IWPOSCB + 6+KEEP(IXSZ)+NSLAVES + NROW + NCOL )         &
     &= BUFR( 8 + NSLAVES_RECU : 7 + NSLAVES_RECU + NROW + NCOL )
      IF ( KEEP(50) .eq. 0 ) THEN
        IW( IWPOSCB + 7+KEEP(IXSZ) ) = 0
        IF (NSLAVES_RECU.GT.0)                                          &
     &  IW( IWPOSCB + 7+XTRA_SLAVES_UNSYM+KEEP(IXSZ):                   &
     &       IWPOSCB+6+KEEP(IXSZ)+NSLAVES_RECU ) =                      &
     &       BUFR( 8: 7 + NSLAVES_RECU )
      ELSE
        IW( IWPOSCB + 7+KEEP(IXSZ) ) = 0
        IW( IWPOSCB + 8+KEEP(IXSZ) ) = NFRONT
        IW( IWPOSCB + 9+KEEP(IXSZ) ) = 0
        IW( IWPOSCB + 7+XTRA_SLAVES_SYM+KEEP(IXSZ):                     &
     &      IWPOSCB + 6+XTRA_SLAVES_SYM+KEEP(IXSZ)+NSLAVES_RECU ) =     &
     &       BUFR( 8: 7 + NSLAVES_RECU )
      END IF
      TNBPROCFILS(STEP( INODE )) = NBPROCFILS
      RETURN
      END SUBROUTINE DAGMG_MUMPS_266
      SUBROUTINE DAGMG_MUMPS_163( id )
      USE DAGMG_MUMPS_STRUC_DEF
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE (DAGMG_MUMPS_STRUC) id
      INTEGER MASTER, IERR
      PARAMETER( MASTER = 0 )
      INTEGER color
      CALL AGMG_SETIERR12( id%NPROCS, IERR )
      IF ( id%PAR .eq. 0 ) THEN
        IF ( id%MYID .eq. MASTER ) THEN
          color = AGMG_MPF_UNDEFINED
        ELSE
          color = 0
        END IF
        CALL AGMG_SETIERR( IERR )
        id%NSLAVES = id%NPROCS - 1
      ELSE
        CALL AGMG_SETIERR( IERR )
        id%NSLAVES = id%NPROCS
      END IF
      IF (id%PAR .ne. 0 .or. id%MYID .NE. MASTER) THEN
        CALL AGMG_SETIERR( IERR )
      ENDIF
      CALL DAGMG_MUMPS_20( id%NSLAVES, id%LWK_USER,                          &
     &    id%CNTL, id%ICNTL,                                            &
     &    id%KEEP, id%KEEP8, id%INFO, id%INFOG,                         &
     &    id%RINFO, id%RINFOG,                                          &
     &    id%SYM, id%PAR, id%DKEEP )
      id%WRITE_PROBLEM="NAME_NOT_INITIALIZED"
      CALL AGMG_MUMPS_SET_VERSION( id%VERSION_NUMBER )
      id%OOC_TMPDIR="NAME_NOT_INITIALIZED"
      id%OOC_PREFIX="NAME_NOT_INITIALIZED"
      id%NRHS = 1
      id%LRHS = 1
      CALL DAGMG_MUMPS_61( id%KEEP( 34 ), id%KEEP(35) )
      NULLIFY(id%BUFR)
      id%NZ_loc = 0
      id%MAXIS1 = 0
      id%INST_Number = -1
      NULLIFY(id%IRN)
      NULLIFY(id%JCN)
      NULLIFY(id%A)
      NULLIFY(id%IRN_loc)
      NULLIFY(id%JCN_loc)
      NULLIFY(id%A_loc)
      NULLIFY(id%MAPPING)
      NULLIFY(id%RHS)
      NULLIFY(id%REDRHS)
      NULLIFY(id%RHS_SPARSE)
      NULLIFY(id%IRHS_SPARSE)
      NULLIFY(id%IRHS_PTR)
      NULLIFY(id%ISOL_LOC)
      NULLIFY(id%SOL_LOC)
      NULLIFY(id%COLSCA)
      NULLIFY(id%ROWSCA)
      NULLIFY(id%PERM_IN)
      NULLIFY(id%IS)
      NULLIFY(id%IS1)
      NULLIFY(id%STEP)
      NULLIFY(id%Step2node)
      NULLIFY(id%DAD_STEPS)
      NULLIFY(id%NE_STEPS)
      NULLIFY(id%ND_STEPS)
      NULLIFY(id%FRERE_STEPS)
      NULLIFY(id%SYM_PERM)
      NULLIFY(id%UNS_PERM)
      NULLIFY(id%PIVNUL_LIST)
      NULLIFY(id%FILS)
      NULLIFY(id%PTRAR)
      NULLIFY(id%FRTPTR)
      NULLIFY(id%FRTELT)
      NULLIFY(id%NA)
      id%LNA=0
      NULLIFY(id%PROCNODE_STEPS)
      NULLIFY(id%S)
      NULLIFY(id%PROCNODE)
      NULLIFY(id%POIDS)
      NULLIFY(id%PTLUST_S)
      NULLIFY(id%PTRFAC)
      NULLIFY(id%INTARR)
      NULLIFY(id%DBLARR)
      NULLIFY(id%NULL_SPACE)
      NULLIFY(id%DEPTH_FIRST)
      NULLIFY(id%MEM_SUBTREE)
      NULLIFY(id%MEM_SUBTREE)
      NULLIFY(id%MY_ROOT_SBTR)
      NULLIFY(id%MY_FIRST_LEAF)
      NULLIFY(id%MY_NB_LEAF)
      NULLIFY(id%COST_TRAV)
      NULLIFY(id%RHSCOMP)
      NULLIFY(id%POSINRHSCOMP)
      NULLIFY(id%OOC_INODE_SEQUENCE)
      NULLIFY(id%OOC_TOTAL_NB_NODES)
      NULLIFY(id%OOC_SIZE_OF_BLOCK)
      NULLIFY(id%OOC_FILE_NAME_LENGTH)
      NULLIFY(id%OOC_FILE_NAMES)
      NULLIFY(id%OOC_VADDR)
      NULLIFY(id%OOC_NB_FILES)
      NULLIFY(id%CB_SON_SIZE)
      NULLIFY(id%root%RG2L_ROW)
      NULLIFY(id%root%RG2L_COL)
      NULLIFY(id%root%IPIV)
      NULLIFY(id%root%SCHUR_POINTER)
      NULLIFY(id%SCHUR_CINTERFACE)
      NULLIFY(id%ELTPTR)
      NULLIFY(id%ELTVAR)
      NULLIFY(id%A_ELT)
      NULLIFY(id%ELTPROC)
      id%SIZE_SCHUR = 0
      NULLIFY( id%LISTVAR_SCHUR )
      NULLIFY( id%SCHUR )
      id%NPROW      = 0
      id%NPCOL      = 0
      id%MBLOCK     = 0
      id%NBLOCK     = 0
      id%SCHUR_MLOC = 0
      id%SCHUR_NLOC = 0
      id%SCHUR_LLD  = 0
      NULLIFY(id%ISTEP_TO_INIV2)
      NULLIFY(id%I_AM_CAND)
      NULLIFY(id%FUTURE_NIV2)
      NULLIFY(id%TAB_POS_IN_PERE)
      NULLIFY(id%CANDIDATES)
      CALL DAGMG_MUMPS_637(id)
      NULLIFY(id%MEM_DIST)
      NULLIFY(id%SUP_PROC)
      id%Deficiency = 0
      id%root%LPIV = -1
      id%root%yes  = .FALSE.
      id%root%gridinit_done  = .FALSE.
        IF ( id%KEEP( 46 ) .ne. 0  .OR.                                 &
     &     id%MYID .ne. MASTER ) THEN
          CALL AGMG_SETIERR2( id%MYID_NODES, IERR )
        ELSE
          id%MYID_NODES = -464646
        ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_163
      SUBROUTINE DAGMG_MUMPS_252( COMM_LOAD, ASS_IRECV,                      &
     &    N, INODE, IW, LIW, A, LA, IFLAG,                              &
     &    IERROR, ND,                                                   &
     &    FILS, FRERE, DAD, MAXFRW, root,                               &
     &    OPASSW, OPELIW, PTRIST, PTLUST_S, PTRFAC, PTRAST,             &
     &    STEP, PIMASTER, PAMASTER,PTRARW,                              &
     &    PTRAIW, ITLOC, NSTEPS, SON_LEVEL2,                            &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP,KEEP8,INTARR,DBLARR,                              &
     &    NSTK_S,NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM,MYID,         &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, JOBASS, ETATASS              &
     &    )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER IZERO
      PARAMETER (IZERO=0)
      INTEGER N,LIW,NSTEPS
      INTEGER(8) LA, LRLU, LRLUS, IPTRLU, POSFAC
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER IFLAG,IERROR,INODE,MAXFRW,                                &
     &        IWPOS, IWPOSCB, COMP, IERR_MPI
      INTEGER JOBASS,ETATASS
      LOGICAL SON_LEVEL2
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION  OPASSW, OPELIW
      INTEGER COMM, NBFIN, SLAVEF, MYID
      INTEGER LPOOL, LEAF
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER NBPROCFILS(KEEP(28))
      INTEGER NSTK_S(KEEP(28)),PROCNODE_STEPS(KEEP(28))
      INTEGER IPOOL( LPOOL )
      INTEGER BUFR( LBUFR )
      INTEGER IDUMMY(1)
      INTEGER IW(LIW), ITLOC(N),                                        &
     &        PTRARW(N), PTRAIW(N), ND(KEEP(28)), PERM(N),              &
     &        FILS(N), FRERE(KEEP(28)), DAD(KEEP(28)),                  &
     &        PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N), PIMASTER(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28)), PTRAST(KEEP(28)),                 &
     &              PAMASTER(KEEP(28))
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER      INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTEGER LP, HS, HF
      INTEGER NBPANELS_L, NBPANELS_U
      INTEGER IN,NUMSTK,NASS,ISON,IFSON,NASS1,IELL
      INTEGER NFS4FATHER
      INTEGER(8) NFRONT8, LAELL8, LAELL_REQ8
      INTEGER NFRONT,NFRONT_EFF,ISTCHK,LSTK,LREQ
      INTEGER LREQ_OOC
      INTEGER(8) :: SIZFR
      INTEGER SIZFI, NCB
      INTEGER J1,J2
      INTEGER NCOL, NROW, NCOLS, NROWS, LDA_SON
      INTEGER(8) :: JJ2, JJ3, ICT13
      INTEGER NELIM,JJ,JJ1,J3,                                          &
     &        IBROT,IORG
      INTEGER JPOS,ICT11
      INTEGER JK,IJROW,NBCOL,NUMORG,IOLDPS,J4
      INTEGER(8) IACHK, JJ8, POSELT, LAPOS2
      INTEGER(8) APOS, APOS2, APOS3, POSEL1, ICT12
      INTEGER AINPUT
      INTEGER NSLAVES, NSLSON, NPIVS,NPIV_ANA,NPIV
      INTEGER PTRCOL, ISLAVE, PDEST,LEVEL
      INTEGER ISON_IN_PLACE
      INTEGER ISON_TOP
      INTEGER(8) SIZE_ISON_TOP8
      LOGICAL RESET_TO_ZERO, RISK_OF_SAME_POS,                          &
     &        RISK_OF_SAME_POS_THIS_LINE
      LOGICAL LEVEL1, NIV1
      INTEGER TROW_SIZE
      INTEGER INDX, FIRST_INDEX, SHIFT_INDEX
      LOGICAL FLAG, BLOCKING, SET_IRECV, MESSAGE_RECEIVED
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER NCBSON
      LOGICAL FREE, SAME_PROC
      INTRINSIC real
      DOUBLE PRECISION ZERO
      DATA ZERO /0.0D0/
      INTEGER NELT, LPTRAR
      EXTERNAL AGMG_MUMPS_167
      LOGICAL AGMG_MUMPS_167
      LOGICAL SSARBR
      LOGICAL COMPRESSCB
      INTEGER(8) :: LCB
      DOUBLE PRECISION FLOP1,FLOP1_EFF
      EXTERNAL AGMG_MUMPS_170
      LOGICAL AGMG_MUMPS_170
      COMPRESSCB =.FALSE.
      NELT       = 1
      LPTRAR     = N
      NFS4FATHER = -1
      IN         = INODE
      NBPROCFILS(STEP(IN)) = 0
      LEVEL = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      IF (LEVEL.NE.1) THEN
       write(6,*) 'Error1 in mpi51f_niv1 '
       CALL AGMG_MUMPS_ABORT()
      ENDIF
      NSLAVES = 0
      HF =  6 + NSLAVES + KEEP(IXSZ)
      IF (JOBASS.EQ.0) THEN
        ETATASS= 0
      ELSE
        ETATASS= 2
        IOLDPS = PTLUST_S(STEP(INODE))
        NFRONT = IW(IOLDPS + KEEP(IXSZ))
        NASS1  = iabs(IW(IOLDPS + 2 + KEEP(IXSZ)))
        ICT11 = IOLDPS + HF - 1 + NFRONT
        SSARBR=AGMG_MUMPS_167(STEP(INODE),PROCNODE_STEPS,                    &
     &                        SLAVEF)
        NUMORG = 0
        DO WHILE (IN.GT.0)
          NUMORG = NUMORG + 1
          IN = FILS(IN)
        ENDDO
        NUMSTK = 0
        IFSON = -IN
        ISON = IFSON
        IF (ISON .NE. 0) THEN
         DO WHILE (ISON .GT. 0)
           NUMSTK = NUMSTK + 1
           ISON = FRERE(STEP(ISON))
         ENDDO
        ENDIF
        GOTO 123
      ENDIF
      NUMORG = 0
      DO WHILE (IN.GT.0)
        NUMORG = NUMORG + 1
        IN = FILS(IN)
      ENDDO
      NPIV_ANA=NUMORG
      NSTEPS = NSTEPS + 1
      NUMSTK = 0
      NASS = 0
      IFSON = -IN
      ISON = IFSON
      IF (ISON .NE. 0) THEN
        DO WHILE (ISON .GT. 0)
         NUMSTK = NUMSTK + 1
         NASS = NASS + IW(PIMASTER(STEP(ISON))+1+KEEP(IXSZ))
         ISON = FRERE(STEP(ISON))
         ENDDO
      ENDIF
      NFRONT = ND(STEP(INODE)) + NASS
      NASS1 = NASS + NUMORG
      LREQ_OOC = 0
      IF (KEEP(201).EQ.1) THEN
        CALL DAGMG_MUMPS_684( KEEP(50), NFRONT, NFRONT, NASS1,               &
     &                                NBPANELS_L, NBPANELS_U, LREQ_OOC)
      ENDIF
      LREQ = HF + 2 * NFRONT + LREQ_OOC
      IF ((IWPOS + LREQ -1) .GT. IWPOSCB) THEN
          CALL DAGMG_MUMPS_94(N, KEEP(28),                                   &
     &        IW, LIW, A, LA,                                           &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
          COMP = COMP+1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv1.F'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 270
          ENDIF
          IF ((IWPOS + LREQ -1) .GT. IWPOSCB) GOTO 270
      ENDIF
      IOLDPS = IWPOS
      IWPOS = IWPOS + LREQ
      ISON_TOP      = -9999
      ISON_IN_PLACE = -9999
      SIZE_ISON_TOP8 = 0_8
      IF (KEEP(234).NE.0) THEN
        IF ( IWPOSCB .NE. LIW ) THEN
        IF ( IWPOSCB+IW(IWPOSCB+1+XXI).NE.LIW) THEN
          ISON = IW( IWPOSCB + 1 + XXN )
          IF ( DAD( STEP( ISON ) ) .EQ. INODE .AND.                     &
     &    AGMG_MUMPS_330(STEP(ISON),PROCNODE_STEPS,SLAVEF)                   &
     &    .EQ. 1 )                                                      &
     &    THEN
            ISON_TOP = ISON
            CALL AGMG_MUMPS_729(SIZE_ISON_TOP8,IW(IWPOSCB + 1 + XXR))
            IF (LRLU .LT. int(NFRONT,8) * int(NFRONT,8)) THEN
              ISON_IN_PLACE = ISON
            ENDIF
          END IF
        END IF
        END IF
      END IF
      NIV1 = .TRUE.
      IF (KEEP(50).EQ.0 .AND. KEEP(234) .EQ. 0) THEN
        CALL  AGMG_MUMPS_81(MYID, INODE, N, IOLDPS, HF, NFRONT,              &
     &        NFRONT_EFF,                                               &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                   &
     &        INTARR, ITLOC, FILS, FRERE,                               &
     &        SON_LEVEL2, NIV1, NBPROCFILS, KEEP, KEEP8, IFLAG)
      ELSE
        CALL AGMG_MUMPS_86( MYID, INODE, N, IOLDPS, HF,                      &
     &        NFRONT, NFRONT_EFF, PERM,                                 &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                   &
     &        INTARR, ITLOC, FILS, FRERE,                               &
     &        SON_LEVEL2, NIV1, NBPROCFILS, KEEP, KEEP8, IFLAG,         &
     &        ISON_IN_PLACE)
        IF (IFLAG.LT.0) GOTO 300
      ENDIF
      IF (NFRONT_EFF.NE.NFRONT) THEN
        IF (NFRONT.GT.NFRONT_EFF) THEN
           IF(AGMG_MUMPS_170(STEP(INODE),PROCNODE_STEPS,                     &
     &          SLAVEF))THEN
              NPIV=NASS1-(NFRONT_EFF-ND(STEP(INODE)))
              CALL AGMG_MUMPS_511(ND(STEP(INODE)),NPIV,NPIV,                 &
     &                                 KEEP(50),1,FLOP1)
              NPIV=NPIV_ANA
              CALL AGMG_MUMPS_511(ND(STEP(INODE)),NPIV,NPIV,                 &
     &                                 KEEP(50),1,FLOP1_EFF)
              CALL DAGMG_MUMPS_190(0,.FALSE.,FLOP1-FLOP1_EFF,                &
     &             KEEP,KEEP8)
           ENDIF
           IWPOS = IWPOS - ((2*NFRONT)-(2*NFRONT_EFF))
           NFRONT = NFRONT_EFF
           LREQ = HF + 2 * NFRONT + LREQ_OOC
        ELSE
           Write(*,*) ' ERROR 1 during ass_niv1', NFRONT, NFRONT_EFF
           GOTO 270
        ENDIF
      ENDIF
      NFRONT8=int(NFRONT,8)
      IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_691(KEEP(50),                                       &
     &       NBPANELS_L, NBPANELS_U, NASS1,                             &
     &       IOLDPS + HF + 2 * NFRONT, IW, LIW)
      ENDIF
      NCB   = NFRONT - NASS1
      MAXFRW = max0(MAXFRW, NFRONT)
      ICT11 = IOLDPS + HF - 1 + NFRONT
      LAELL8 = NFRONT8 * NFRONT8
      LAELL_REQ8 = LAELL8
      IF ( ISON_IN_PLACE > 0 ) THEN
        LAELL_REQ8 = LAELL8 - SIZE_ISON_TOP8
      ENDIF
      IF (LRLU .LT. LAELL_REQ8) THEN
        IF (LRLUS .LT. LAELL_REQ8) THEN
          GOTO 280
        ELSE
          CALL DAGMG_MUMPS_94                                                &
     &        (N, KEEP(28), IW, LIW, A, LA, LRLU, IPTRLU,               &
     &         IWPOS, IWPOSCB, PTRIST, PTRAST, STEP, PIMASTER,          &
     &         PAMASTER,ITLOC,KEEP(216),LRLUS,KEEP(IXSZ))
          COMP = COMP + 1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv1.F'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 280
          ENDIF
        ENDIF
      ENDIF
      LRLU = LRLU - LAELL8
      LRLUS = LRLUS - LAELL8 + SIZE_ISON_TOP8
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSELT = POSFAC
      POSFAC = POSFAC + LAELL8
      SSARBR=AGMG_MUMPS_167(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      CALL DAGMG_MUMPS_471(SSARBR,.FALSE.,                                   &
     &     LA-LRLUS,                                                    &
     &     0_8,                                                         &
     &     LAELL8-SIZE_ISON_TOP8,                                       &
     &     KEEP,KEEP8,                                                  &
     &     LRLU)
      LAPOS2 = min(POSELT + LAELL8 - 1_8, IPTRLU)
      A(POSELT:LAPOS2) = dble(ZERO)
      PTRAST(STEP(INODE)) = POSELT
      PTRFAC(STEP(INODE)) = POSELT
      PTLUST_S(STEP(INODE)) = IOLDPS
      IW(IOLDPS+XXI)   = LREQ
      CALL AGMG_MUMPS_730(LAELL8,IW(IOLDPS+XXR))
      IW(IOLDPS+XXS) =-9999
      IW(IOLDPS+XXS+1:IOLDPS+KEEP(IXSZ)-1)=-99999
      IW(IOLDPS + KEEP(IXSZ))   = NFRONT
      IW(IOLDPS + KEEP(IXSZ) + 1) = 0
      IW(IOLDPS + KEEP(IXSZ) + 2) = -NASS1
      IW(IOLDPS + KEEP(IXSZ) + 3) = -NASS1
      IW(IOLDPS + KEEP(IXSZ) + 4) = STEP(INODE)
      IW(IOLDPS + KEEP(IXSZ) + 5)   = NSLAVES
  123 CONTINUE
      IF (NUMSTK.NE.0) THEN
        IF (ISON_TOP > 0) THEN
          ISON = ISON_TOP
        ELSE
          ISON = IFSON
        ENDIF
        DO 220 IELL = 1, NUMSTK
          ISTCHK    = PIMASTER(STEP(ISON))
          LSTK      = IW(ISTCHK + KEEP(IXSZ))
          NELIM     = IW(ISTCHK + KEEP(IXSZ) + 1)
          NPIVS     = IW(ISTCHK + KEEP(IXSZ) + 3)
          IF ( NPIVS .LT. 0 ) NPIVS = 0
          NSLSON    = IW(ISTCHK + KEEP(IXSZ) + 5)
          HS        = 6 + KEEP(IXSZ) + NSLSON
          NCOLS     = NPIVS + LSTK
          SAME_PROC     = (ISTCHK.LE.IWPOS)
          IF ( SAME_PROC ) THEN
            COMPRESSCB=( IW(PTRIST(STEP(ISON))+XXS) .EQ. S_CB1COMP )
          ELSE
            COMPRESSCB=( IW(ISTCHK + XXS) .EQ. S_CB1COMP )
          ENDIF
          LEVEL1    = NSLSON.EQ.0
          IF (.NOT.SAME_PROC) THEN
           NROWS = IW( ISTCHK + KEEP(IXSZ) + 2)
          ELSE
           NROWS = NCOLS
          ENDIF
          SIZFI   = HS + NROWS + NCOLS
          J1 = ISTCHK + HS + NROWS + NPIVS
          IF ( .NOT. LEVEL1 .AND. NELIM.EQ.0 ) GOTO 205
          IF (LEVEL1) THEN
           J2 = J1 + LSTK - 1
           SIZFR  = int(LSTK,8)*int(LSTK,8)
           IF (COMPRESSCB) SIZFR = (int(LSTK,8)*int(LSTK+1,8))/2_8
          ELSE
           IF ( KEEP(50).eq.0 ) THEN
             SIZFR = int(NELIM,8) * int(LSTK,8)
           ELSE
             SIZFR = int(NELIM,8) * int(NELIM,8)
           END IF
           J2 = J1 + NELIM - 1
          ENDIF
          IF (JOBASS.EQ.0) OPASSW = OPASSW + dble(SIZFR)
          IACHK = PAMASTER(STEP(ISON))
          IF ( KEEP(50) .eq. 0 ) THEN
            POSEL1 = PTRAST(STEP(INODE)) - NFRONT8
            IF (NFRONT .EQ. LSTK.AND. ISON.EQ.ISON_IN_PLACE             &
     &          .AND.IACHK + SIZFR - 1_8 .EQ. POSFAC - 1_8 ) THEN
               GOTO 205
            ENDIF
            IF (J2.GE.J1) THEN
              RESET_TO_ZERO = (IACHK .LT. POSFAC)
              RISK_OF_SAME_POS = IACHK + SIZFR - 1_8 .EQ. POSFAC - 1_8
              RISK_OF_SAME_POS_THIS_LINE = .FALSE.
              DO 170 JJ = J1, J2
                APOS = POSEL1 + int(IW(JJ),8) * int(NFRONT,8)
                IF (RISK_OF_SAME_POS) THEN
                  IF (JJ.EQ.J2) THEN
                    RISK_OF_SAME_POS_THIS_LINE =                        &
     &                  (ISON .EQ. ISON_IN_PLACE)                       &
     &                  .AND. ( APOS + int(IW(J1+LSTK-1)-1,8).EQ.       &
     &                          IACHK+int(LSTK-1,8) )
                  ENDIF
                ENDIF
                IF (RESET_TO_ZERO) THEN
                  IF (RISK_OF_SAME_POS_THIS_LINE) THEN
                    DO JJ1 = 1, LSTK
                      JJ2 = APOS + int(IW(J1 + JJ1 - 1) - 1,8)
                      IF ( IACHK+int(JJ1-1,8) .NE. JJ2 ) THEN
                        A(JJ2) = A(IACHK + int(JJ1 - 1,8))
                        A(IACHK + int(JJ1 -1,8)) = dble(ZERO)
                      ENDIF
                    ENDDO
                  ELSE
                    DO JJ1 = 1, LSTK
                      JJ2 = APOS + int(IW(J1+JJ1-1),8) - 1_8
                      A(JJ2) = A(IACHK + int(JJ1 - 1,8))
                      A(IACHK + int(JJ1 -1,8)) = dble(ZERO)
                    ENDDO
                  ENDIF
                ELSE
                  DO JJ1 = 1, LSTK
                    JJ2 = APOS + int(IW(J1+JJ1-1),8) - 1_8
                    A(JJ2) = A(JJ2) + A(IACHK + int(JJ1 - 1,8))
                  ENDDO
                ENDIF
                IACHK = IACHK + int(LSTK,8)
                IF (IACHK .GE. POSFAC) RESET_TO_ZERO =.FALSE.
  170         CONTINUE
            END IF
          ELSE
            IF (LEVEL1) THEN
             LDA_SON = LSTK
            ELSE
             LDA_SON = NELIM
            ENDIF
            IF (COMPRESSCB) THEN
              LCB = SIZFR
            ELSE
              LCB = int(LDA_SON,8)* int(J2-J1+1,8)
            ENDIF
            CALL DAGMG_MUMPS_178(A, LA,                                      &
     &           PTRAST(STEP( INODE )), NFRONT, NASS1,                  &
     &           IACHK, LDA_SON, LCB,                                   &
     &           IW( J1 ), J2 - J1 + 1, NELIM, ETATASS,                 &
     &           COMPRESSCB, (ISON.EQ.ISON_IN_PLACE)                    &
     &          )
          ENDIF
  205     IF (LEVEL1) THEN
           IF (SAME_PROC) ISTCHK = PTRIST(STEP(ISON))
           IF ((SAME_PROC).AND.ETATASS.NE.1) THEN
             IF (KEEP(50).NE.0) THEN
              J2 = J1 + LSTK - 1
              DO JJ = J1, J2
               IW(JJ) = IW(JJ - NROWS)
              ENDDO
             ELSE
              J2 = J1 + LSTK - 1
              J3 = J1 + NELIM
              DO JJ = J3, J2
               IW(JJ) = IW(JJ - NROWS)
              ENDDO
              IF (NELIM .NE. 0) THEN
                J3 = J3 - 1
                DO JJ = J1, J3
                 JPOS = IW(JJ) + ICT11
                 IW(JJ) = IW(JPOS)
                ENDDO
              ENDIF
             ENDIF
           ENDIF
           IF (ETATASS.NE.1) THEN
             IF ( SAME_PROC ) THEN
               PTRIST(STEP(ISON))   = -99999999
             ELSE
               PIMASTER(STEP( ISON )) = -99999999
             ENDIF
             CALL DAGMG_MUMPS_152(SSARBR, MYID, N, ISTCHK,                   &
     &          PAMASTER(STEP(ISON)),                                   &
     &          IW, LIW, LRLU, LRLUS, IPTRLU,                           &
     &          IWPOSCB, LA, KEEP,KEEP8,                                &
     &          (ISON .EQ. ISON_TOP)                                    &
     &          )
           ENDIF
          ELSE
           PDEST = ISTCHK + 6 + KEEP(IXSZ)
           NCBSON  = LSTK - NELIM
           PTRCOL   = ISTCHK +  HS + NROWS + NPIVS + NELIM
           DO ISLAVE = 0, NSLSON-1
             IF (IW(PDEST+ISLAVE).EQ.MYID) THEN
              CALL AGMG_MUMPS_49(                                            &
     &                KEEP, KEEP8, ISON, STEP, N, SLAVEF,               &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE+1, NCBSON,                                 &
     &                NSLSON,                                           &
     &                TROW_SIZE, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
              INDX = PTRCOL + SHIFT_INDEX
              CALL DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,                    &
     &             BUFR, LBUFR, LBUFR_BYTES,                            &
     &             INODE, ISON, NSLAVES, IDUMMY,                        &
     &             NFRONT, NASS1,NFS4FATHER,                            &
     &             TROW_SIZE, IW( INDX ),                               &
     &         PROCNODE_STEPS,                                          &
     &         SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,            &
     &         LRLUS, N, IW,                                            &
     &         LIW, A, LA,                                              &
     &         PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                  &
     &         PIMASTER, PAMASTER, NSTK_S, COMP,                        &
     &         IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL,     &
     &         LEAF, NBFIN, ICNTL, KEEP, KEEP8,  root,                  &
     &         OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,             &
     &         INTARR, DBLARR, ND, FRERE,                               &
     &         LPTRAR, NELT, IW, IW,                                    &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE )
              IF ( IFLAG .LT. 0 ) GOTO 500
              EXIT
             ENDIF
           ENDDO
           IF (PIMASTER(STEP(ISON)).GT.0) THEN
           IERR = -1
           DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON)) + HS + NROWS + NPIVS + NELIM
            PDEST  = PIMASTER(STEP(ISON)) + 6 + KEEP(IXSZ)
            CALL  DAGMG_MUMPS_71(                                            &
     &           INODE, NFRONT, NASS1, NFS4FATHER,                      &
     &           ISON, MYID,                                            &
     &       IZERO, IDUMMY, IW(PTRCOL), NCBSON,                         &
     &       COMM, IERR, IW(PDEST), NSLSON, SLAVEF,                     &
     &       KEEP, KEEP8, STEP, N,                                      &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE                            &
     &        )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329(                                           &
     &         COMM_LOAD, ASS_IRECV,                                    &
     &         BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                   &
     &         AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                             &
     &         STATUS,                                                  &
     &         BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,        &
     &         IWPOS, IWPOSCB, IPTRLU,                                  &
     &         LRLU, LRLUS, N, IW, LIW, A, LA,                          &
     &         PTRIST, PTLUST_S, PTRFAC,                                &
     &         PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,          &
     &         IFLAG, IERROR, COMM,                                     &
     &         NBPROCFILS,                                              &
     &         IPOOL, LPOOL, LEAF,                                      &
     &         NBFIN, MYID, SLAVEF,                                     &
     &         root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,       &
     &         INTARR, DBLARR, ICNTL, KEEP, KEEP8, ND, FRERE,           &
     &         LPTRAR, NELT, IW, IW,                                    &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
               IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
           ENDDO
           IF (IERR .EQ. -2) GOTO 290
           IF (IERR .EQ. -3) GOTO 295
           ENDIF
          ENDIF
  210   ISON = FRERE(STEP(ISON))
        IF (ISON .LE. 0) THEN
          ISON = IFSON
        ENDIF
  220 END DO
      END IF
      IF (ETATASS.EQ.2) GOTO 500
      POSELT = PTRAST(STEP(INODE))
      IBROT = INODE
      DO 260 IORG = 1, NUMORG
        JK = PTRAIW(IBROT)
        AINPUT = PTRARW(IBROT)
        IBROT = FILS(IBROT)
        JJ = JK + 1
        J1 = JJ + 1
        J2 = J1 + INTARR(JK)
        J3 = J2 + 1
        J4 = J2 - INTARR(JJ)
        IJROW = INTARR(J1)
        ICT12 = POSELT + int(IJROW - NFRONT - 1,8)
!duplicates --> CVD$ DEPCHK
        DO 240 JJ = J1, J2
           APOS2 = ICT12 + int(INTARR(JJ),8) * NFRONT8
           IF (APOS2 .LT.0_8) THEN
             WRITE(*,*) "APOS2=",APOS2
             WRITE(*,*) "INTARR(JJ)=",INTARR(JJ)
             WRITE(*,*) "ICT12=",ICT12
           ENDIF
           A(APOS2) = A(APOS2) + DBLARR(AINPUT)
          AINPUT = AINPUT + 1
  240   CONTINUE
        IF (J3 .LE. J4) THEN
          ICT13 = POSELT + int(IJROW - 1,8) * NFRONT8
          NBCOL = J4 - J3 + 1
!duplicates--> CVD$ DEPCHK
!duplicatesCVD$ NODEPCHK
          DO 250 JJ = 1, NBCOL
            APOS3 = ICT13 + int(INTARR(J3 + JJ - 1) - 1,8)
            A(APOS3) = A(APOS3) + DBLARR(AINPUT + JJ - 1)
  250     CONTINUE
        ENDIF
  260 END DO
      GOTO 500
  270 CONTINUE
      IFLAG = -8
      IERROR = LREQ
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE IN INTEGER ALLOCATION DURING DMUMPS_252'
      ENDIF
      GOTO 490
  280 CONTINUE
      IFLAG = -9
      IF (LAELL_REQ8 - LRLUS .GT. int(huge(IERROR),8)) THEN
        WRITE(*,*) "I8: OVERFLOW",LAELL_REQ8, LRLUS
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IERROR = int(LAELL_REQ8 - LRLUS, 4)
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, WORKSPACE TOO SMALL DURING DMUMPS_252'
      ENDIF
      GOTO 490
  290 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE, SEND BUFFER TOO SMALL DURING DMUMPS_252'
      ENDIF
      IFLAG = -17
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  295 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE, SEND BUFFER TOO SMALL DURING DMUMPS_252'
      ENDIF
      IFLAG = -17
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  300 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     & ' FAILURE IN INTEGER DYNAMIC ALLOCATION DURING DMUMPS_252'
      ENDIF
      IFLAG   = -13
      IERROR  = NUMSTK + 1
  490 CALL  DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_252
      SUBROUTINE DAGMG_MUMPS_253(COMM_LOAD, ASS_IRECV,                       &
     &    N, INODE, IW, LIW, A, LA, IFLAG,                              &
     &    IERROR, ND, FILS, FRERE,                                      &
     &    CAND,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    MAXFRW, root,                                                 &
     &    OPASSW, OPELIW, PTRIST, PTLUST_S,  PTRFAC,                    &
     &    PTRAST, STEP, PIMASTER, PAMASTER, PTRARW, NSTK_S,             &
     &    PTRAIW, ITLOC, NSTEPS,                                        &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP, KEEP8,INTARR,DBLARR,                             &
     &    NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM,MYID,                &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, LEAF, IPOOL, LPOOL,          &
     &    PERM , MEM_DISTRIB)
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE )
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N,LIW,NSTEPS, NBFIN
      INTEGER(8) :: LA
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER IFLAG,IERROR,INODE,MAXFRW,                                &
     &        LPOOL, LEAF, IWPOS, IWPOSCB, COMP
      INTEGER(8) :: LRLUS, LRLU, IPTRLU, POSFAC
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION  OPASSW, OPELIW
      INTEGER COMM, SLAVEF, MYID,  LBUFR, LBUFR_BYTES
      INTEGER, DIMENSION(0:SLAVEF - 1) :: MEM_DISTRIB
      INTEGER IPOOL(LPOOL)
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER IW(LIW), ITLOC(N),                                        &
     &        PTRARW(N), PTRAIW(N), ND(KEEP(28)),                       &
     &        FILS(N), FRERE(KEEP(28)),                                 &
     &        PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N),                                                  &
     & PIMASTER(KEEP(28)),                                              &
     &        NSTK_S(KEEP(28)), PERM(N)
      INTEGER   CAND(SLAVEF+1, max(1,KEEP(56)))
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER NBPROCFILS(KEEP(28)),                                     &
     &        PROCNODE_STEPS(KEEP(28)), BUFR(LBUFR)
      INTEGER      INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER LP, HS, HF, HF_OLD,NCBSON, NSLAVES_OLD
      INTEGER IN,NUMSTK,NASS,ISON,IFSON,NASS1,IELL
      INTEGER NFS4FATHER,I
      INTEGER NFRONT,NFRONT_EFF,ISTCHK,LSTK,LREQ
      INTEGER(8) :: NFRONT8, LAELL8
      INTEGER LREQ_OOC
      LOGICAL COMPRESSCB
      INTEGER(8) :: LCB
      INTEGER NCB, IERR_MPI
      INTEGER J1,J2,J3,MP
      INTEGER(8) :: JJ8, LAPOS2, JJ2, JJ3
      INTEGER NELIM,JJ,JJ1,NPIVS,NCOLS,NROWS,                           &
     &        IBROT,IORG
      INTEGER LDAFS, LDA_SON
      INTEGER JK,IJROW,NBCOL,NUMORG,IOLDPS,J4
      INTEGER(8) :: ICT13
      INTEGER(8) :: IACHK, APOS, APOS2, POSELT, ICT12, POSEL1
      INTEGER AINPUT
      INTEGER NSLAVES, NSLSON
      INTEGER NBLIG, PTRCOL, PTRROW, ISLAVE, PDEST
      INTEGER PDEST1(1)
      INTEGER NSLAVES_less, ITEMP, NMB_OF_CAND
      INTEGER ISON_IN_PLACE
      LOGICAL FLAG, SAME_PROC, NIV1, SON_LEVEL2
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER TROW_SIZE, INDX, FIRST_INDEX, SHIFT_INDEX
      INTEGER IZERO
      INTEGER IDUMMY(1)
      PARAMETER( IZERO = 0 )
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTRINSIC real
      DOUBLE PRECISION ZERO
      DATA ZERO /0.0D0/
      INTEGER NELT, LPTRAR, NCBSON_MAX
      logical :: force_cand
      INTEGER ETATASS
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER (8) :: APOSMAX
      DOUBLE PRECISION  MAXARR
      INTEGER INIV2, SIZE_TMP_SLAVES_LIST, allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: TMP_SLAVES_LIST
      INTEGER NBPANELS_L, NBPANELS_U
      MP         = ICNTL(2)
      COMPRESSCB = .FALSE.
      ETATASS    = 0
      IN         = INODE
      NBPROCFILS(STEP(IN)) = 0
      NSTEPS = NSTEPS + 1
      NUMORG = 0
      DO WHILE (IN.GT.0)
        NUMORG = NUMORG + 1
        IN = FILS(IN)
      ENDDO
      NUMSTK = 0
      NASS = 0
      IFSON = -IN
      ISON = IFSON
      NCBSON_MAX = 0
      NELT = 1
      LPTRAR = 1
      DO WHILE (ISON .GT. 0)
        NUMSTK = NUMSTK + 1
        IF ( KEEP(48)==5 .AND. AGMG_MUMPS_330(STEP(ISON),                    &
     &       PROCNODE_STEPS,SLAVEF) .EQ. 1) THEN
          NCBSON_MAX = max                                              &
     &      (                                                           &
     &       IW(PIMASTER(STEP(ISON))+KEEP(IXSZ)), NCBSON_MAX            &
     &       )
        ENDIF
        NASS = NASS + IW(PIMASTER(STEP(ISON)) + 1 + KEEP(IXSZ))
        ISON = FRERE(STEP(ISON))
      ENDDO
      NFRONT = ND(STEP(INODE)) + NASS
      NASS1 = NASS + NUMORG
      NCB   = NFRONT - NASS1
      if((KEEP(24).eq.0).or.(KEEP(24).eq.1)) then
         force_cand=.FALSE.
      else
         force_cand=(mod(KEEP(24),2).eq.0)
      end if
      IF (force_cand) THEN
         INIV2 = ISTEP_TO_INIV2( STEP( INODE ))
         SIZE_TMP_SLAVES_LIST = CAND( SLAVEF+1, INIV2 )
      ELSE
         INIV2 = 1
         SIZE_TMP_SLAVES_LIST = SLAVEF - 1
      ENDIF
      ALLOCATE(TMP_SLAVES_LIST(SIZE_TMP_SLAVES_LIST),stat=allocok)
      IF (allocok > 0 ) THEN
        GOTO 265
      ENDIF
      CALL DAGMG_MUMPS_472( NCBSON_MAX, SLAVEF, KEEP,KEEP8,                  &
     &     ICNTL, CAND(1,INIV2),                                        &
     &     MEM_DISTRIB(0), NCB, NFRONT, NSLAVES,                        &
     &     TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),              &
     &     TMP_SLAVES_LIST,                                             &
     &     SIZE_TMP_SLAVES_LIST,INODE )
      HF   = NSLAVES + 6 + KEEP(IXSZ)
      LREQ_OOC = 0
      IF (KEEP(201).EQ.1) THEN
        CALL DAGMG_MUMPS_684(KEEP(50), NASS1, NFRONT, NASS1,                 &
     &                               NBPANELS_L, NBPANELS_U, LREQ_OOC)
      ENDIF
      LREQ = HF + 2 * NFRONT + LREQ_OOC
      IF ((IWPOS + LREQ -1) .GT. IWPOSCB) THEN
          CALL DAGMG_MUMPS_94(N, KEEP(28),                                   &
     &        IW, LIW, A, LA,                                           &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,                          &
     &        KEEP(216),LRLUS,KEEP(IXSZ))
          COMP = COMP+1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv2'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 270
          ENDIF
          IF ((IWPOS + LREQ -1) .GT. IWPOSCB) GOTO 270
      ENDIF
      IOLDPS = IWPOS
      IWPOS = IWPOS + LREQ
      NIV1 = .FALSE.
      IF (KEEP(50).EQ.0 .AND. KEEP(234).EQ.0) THEN
        CALL  AGMG_MUMPS_81(MYID, INODE, N, IOLDPS, HF, NFRONT,              &
     &        NFRONT_EFF,                                               &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                   &
     &        INTARR, ITLOC, FILS, FRERE,                               &
     &        SON_LEVEL2, NIV1, NBPROCFILS, KEEP,KEEP8, IFLAG)
      ELSE
        ISON_IN_PLACE = -9999
        CALL AGMG_MUMPS_86( MYID, INODE, N, IOLDPS, HF,                      &
     &        NFRONT, NFRONT_EFF, PERM,                                 &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                   &
     &        INTARR, ITLOC, FILS, FRERE,                               &
     &        SON_LEVEL2, NIV1, NBPROCFILS, KEEP,KEEP8, IFLAG,          &
     &        ISON_IN_PLACE)
        IF (IFLAG.LT.0) GOTO 250
      ENDIF
      IF ( NFRONT .NE. NFRONT_EFF ) THEN
        IF (NFRONT.GT.NFRONT_EFF) THEN
            NCB    = NFRONT_EFF - NASS1
            NSLAVES_OLD = NSLAVES
            HF_OLD      = HF
            CALL DAGMG_MUMPS_472( NCBSON_MAX,                                &
     &      SLAVEF, KEEP,KEEP8, ICNTL,                                  &
     &      CAND(1,INIV2),                                              &
     &      MEM_DISTRIB(0), NCB, NFRONT_EFF, NSLAVES,                   &
     &      TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),             &
     &      TMP_SLAVES_LIST, SIZE_TMP_SLAVES_LIST,INODE )
            HF = NSLAVES + 6 + KEEP(IXSZ)
            IWPOS = IWPOS - ((2*NFRONT)-(2*NFRONT_EFF)) -               &
     &                   (NSLAVES_OLD - NSLAVES)
            IF (NSLAVES_OLD .NE. NSLAVES) THEN
              IF (NSLAVES_OLD > NSLAVES) THEN
               IW(IOLDPS+HF: IOLDPS+HF+2*NFRONT_EFF-1) =                &
     &         IW(IOLDPS+HF_OLD: IOLDPS+HF_OLD+2*NFRONT_EFF-1)
              ELSE
               IF (IWPOS - 1 > IWPOSCB ) GOTO 270
               DO JJ=2*NFRONT_EFF-1, 0, -1
                 IW(IOLDPS+HF+JJ) = IW(IOLDPS+HF_OLD+JJ)
               ENDDO
              END IF
            END IF
            NFRONT = NFRONT_EFF
            LREQ = HF + 2 * NFRONT + LREQ_OOC
        ELSE
          Write(*,*) ' ERROR 2 during ass_niv2'
          GOTO 270
        ENDIF
      ENDIF
      IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_691(KEEP(50),                                       &
     &       NBPANELS_L, NBPANELS_U, NASS1,                             &
     &       IOLDPS + HF + 2 * NFRONT, IW, LIW)
      ENDIF
      MAXFRW = max0(MAXFRW, NFRONT)
      PTLUST_S(STEP(INODE)) = IOLDPS
      IW(IOLDPS + 1+KEEP(IXSZ)) = 0
      IW(IOLDPS + 2+KEEP(IXSZ)) = -NASS1
      IW(IOLDPS + 3+KEEP(IXSZ)) = -NASS1
      IW(IOLDPS + 4+KEEP(IXSZ)) = STEP(INODE)
      IW(IOLDPS+KEEP(IXSZ))   = NFRONT
      IW(IOLDPS+5+KEEP(IXSZ)) = NSLAVES
      IW(IOLDPS+6+KEEP(IXSZ):IOLDPS+5+KEEP(IXSZ)+NSLAVES)=              &
     &             TMP_SLAVES_LIST(1:NSLAVES)
      CALL DAGMG_MUMPS_461(MYID, SLAVEF, COMM_LOAD,                          &
     &     TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),              &
     &     NASS1, KEEP,KEEP8, IW(IOLDPS+6+KEEP(IXSZ)), NSLAVES,INODE)
      IF(KEEP(86).EQ.1)THEN
         IF(mod(KEEP(24),2).eq.0)THEN
            CALL DAGMG_MUMPS_533(SLAVEF,CAND(SLAVEF+1,INIV2),                &
     &           TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),        &
     &           NASS1, KEEP,KEEP8, TMP_SLAVES_LIST, NSLAVES,INODE)
         ELSEIF((KEEP(24).EQ.0).OR.(KEEP(24).EQ.1))THEN
            CALL DAGMG_MUMPS_533(SLAVEF,SLAVEF-1,                            &
     &           TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),        &
     &           NASS1, KEEP,KEEP8, TMP_SLAVES_LIST, NSLAVES,INODE)
         ENDIF
      ENDIF
      DEALLOCATE(TMP_SLAVES_LIST)
      IF (KEEP(50).EQ.0) THEN
        LAELL8 = int(NASS1,8) * int(NFRONT,8)
        LDAFS = NFRONT
      ELSE
        LAELL8 = int(NASS1,8)*int(NASS1,8)
        IF(KEEP(219).NE.0.AND.KEEP(50) .EQ. 2)                          &
     &     LAELL8 = LAELL8+int(NASS1,8)
        LDAFS = NASS1
      ENDIF
      IF (LRLU .LT. LAELL8) THEN
        IF (LRLUS .LT. LAELL8) THEN
          GOTO 280
        ELSE
         CALL DAGMG_MUMPS_94(N, KEEP(28),                                    &
     &      IW, LIW, A, LA,                                             &
     &      LRLU, IPTRLU,                                               &
     &      IWPOS, IWPOSCB, PTRIST, PTRAST,                             &
     &      STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,            &
     &      KEEP(IXSZ))
         IF (LRLU .NE. LRLUS) THEN
          WRITE( *, * ) 'PB compress ass..mpi51f_niv2'
          WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
          GOTO 280
         ENDIF
        ENDIF
      ENDIF
      LRLU = LRLU - LAELL8
      LRLUS = LRLUS - LAELL8
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSELT = POSFAC
      PTRAST(STEP(INODE)) = POSELT
      PTRFAC(STEP(INODE)) = POSELT
      POSFAC = POSFAC + LAELL8
      IW(IOLDPS+XXI)   = LREQ
      CALL AGMG_MUMPS_730(LAELL8,IW(IOLDPS+XXR))
      IW(IOLDPS+XXS) =-9999
      IW(IOLDPS+XXS+1:IOLDPS+KEEP(IXSZ)-1)=-99999
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,LA-LRLUS,0_8,LAELL8,              &
     &     KEEP,KEEP8,LRLU)
      POSEL1 = POSELT - int(LDAFS,8)
      LAPOS2 = POSELT + LAELL8 - 1_8
      A(POSELT:LAPOS2) = dble(ZERO)
      IF ((NUMSTK.NE.0).AND.(NASS.NE.0)) THEN
        ISON = IFSON
        DO 220 IELL = 1, NUMSTK
          ISTCHK = PIMASTER(STEP(ISON))
          NELIM = IW(ISTCHK + 1+KEEP(IXSZ))
          IF (NELIM.EQ.0) GOTO 210
          LSTK    = IW(ISTCHK+KEEP(IXSZ))
          NPIVS   = IW(ISTCHK + 3+KEEP(IXSZ))
          IF (NPIVS.LT.0) NPIVS=0
          NSLSON  = IW(ISTCHK + 5+KEEP(IXSZ))
          HS      = 6 + NSLSON  + KEEP(IXSZ)
          NCOLS     = NPIVS + LSTK
          SAME_PROC     = (ISTCHK.LE.IWPOS)
          IF ( SAME_PROC ) THEN
           COMPRESSCB=( IW(PTRIST(STEP(ISON))+XXS) .EQ. S_CB1COMP )
          ELSE
           COMPRESSCB=( IW(ISTCHK + XXS) .EQ. S_CB1COMP )
          ENDIF
          IF (.NOT.SAME_PROC) THEN
           NROWS = IW(ISTCHK + 2+KEEP(IXSZ))
          ELSE
           NROWS = NCOLS
          ENDIF
          OPASSW = OPASSW + dble(NELIM*LSTK)
          J1 = ISTCHK + HS + NROWS + NPIVS
          J2 = J1 + NELIM - 1
          IACHK = PAMASTER(STEP(ISON))
          IF (KEEP(50).eq.0) THEN
           DO 170 JJ = J1, J2
            APOS = POSEL1 + int(IW(JJ),8) * int(LDAFS,8)
            DO 160 JJ1 = 1, LSTK
              JJ2 = APOS + int(IW(J1 + JJ1 - 1),8) - 1_8
              A(JJ2) = A(JJ2) + A(IACHK + int(JJ1 - 1,8))
  160       CONTINUE
            IACHK = IACHK + int(LSTK,8)
  170      CONTINUE
          ELSE
            IF (NSLSON.EQ.0) THEN
             LDA_SON = LSTK
            ELSE
             LDA_SON = NELIM
            ENDIF
            IF (COMPRESSCB) THEN
              LCB = (int(NELIM,8)*int(NELIM+1,8))/2_8
            ELSE
              LCB = int(LDA_SON,8)*int(NELIM,8)
            ENDIF
            CALL DAGMG_MUMPS_178( A, LA,                                     &
     &           POSELT, LDAFS, NASS1,                                  &
     &           IACHK, LDA_SON, LCB,                                   &
     &           IW( J1 ), NELIM, NELIM, ETATASS,                       &
     &           COMPRESSCB,                                            &
     &           .FALSE.                                                &
     &          )
          ENDIF
  210     ISON = FRERE(STEP(ISON))
  220   CONTINUE
      ENDIF
      IBROT = INODE
      APOSMAX = POSELT + int(NASS1,8)*int(NASS1,8)
      DO 260 IORG = 1, NUMORG
        JK = PTRAIW(IBROT)
        AINPUT = PTRARW(IBROT)
        IBROT = FILS(IBROT)
        JJ = JK + 1
        J1 = JJ + 1
        J2 = J1 + INTARR(JK)
        J3 = J2 + 1
        J4 = J2 - INTARR(JJ)
        IJROW = INTARR(J1)
        ICT12 = POSELT + int(IJROW - 1 - LDAFS, 8)
        MAXARR = ZERO
!duplicatesCVD$ NODEPCHK
        DO 240 JJ = J1, J2
          IF (KEEP(219).NE.0) THEN
            IF (INTARR(JJ).LE.NASS1) THEN
              APOS2 = ICT12 + int(INTARR(JJ),8) * int(LDAFS,8)
              A(APOS2) = A(APOS2) + DBLARR(AINPUT)
            ELSEIF (KEEP(50).EQ.2) THEN
              MAXARR = max(MAXARR,abs(DBLARR(AINPUT)))
            ENDIF
          ELSE
            IF (INTARR(JJ).LE.NASS1) THEN
              APOS2 = ICT12 + int(INTARR(JJ),8) * int(LDAFS,8)
              A(APOS2) = A(APOS2) + DBLARR(AINPUT)
            ENDIF
          ENDIF
          AINPUT = AINPUT + 1
  240   CONTINUE
        IF(KEEP(219).NE.0.AND.KEEP(50) .EQ. 2) THEN
           A(APOSMAX+int(IJROW-1,8)) = dble(MAXARR)
        ENDIF
        IF (J3 .GT. J4) GOTO 260
        ICT13 = POSELT + int(IJROW - 1,8) * int(LDAFS,8)
        NBCOL = J4 - J3 + 1
!duplicatesCVD$ NODEPCHK
!duplicatesCVD$ NODEPCHK
        DO JJ = 1, NBCOL
          JJ3 = ICT13 + int(INTARR(J3 + JJ - 1),8) - 1_8
          A(JJ3) = A(JJ3) + DBLARR(AINPUT + JJ - 1)
        ENDDO
  260 END DO
      PTRCOL = IOLDPS + HF + NFRONT
      PTRROW = IOLDPS + HF + NASS1
      PDEST  = IOLDPS + 6 + KEEP(IXSZ)
      DO ISLAVE = 1, NSLAVES
              CALL AGMG_MUMPS_49(                                            &
     &                KEEP,KEEP8, INODE, STEP, N, SLAVEF,               &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE, NCB,                                      &
     &                NSLAVES,                                          &
     &                NBLIG, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
        IERR = -1
        DO WHILE (IERR .EQ.-1)
         IF ( KEEP(50) .eq. 0 ) THEN
           NBCOL =  NFRONT
           CALL DAGMG_MUMPS_68( INODE,                                       &
     &      NBPROCFILS(STEP(INODE)),                                    &
     &      NBLIG, IW(PTRROW), NBCOL, IW(PTRCOL), NASS1,                &
     &      IZERO, IDUMMY,                                              &
     &      IW(PDEST), NFRONT, COMM, IERR)
         ELSE
           NBCOL = NASS1+SHIFT_INDEX+NBLIG
           CALL DAGMG_MUMPS_68( INODE,                                       &
     &      NBPROCFILS(STEP(INODE)),                                    &
     &      NBLIG, IW(PTRROW), NBCOL, IW(PTRCOL), NASS1,                &
     &      NSLAVES-ISLAVE,                                             &
     &      IW( PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)+ISLAVE),             &
     &      IW(PDEST), NFRONT, COMM, IERR)
         ENDIF
         IF (IERR.EQ.-1) THEN
          BLOCKING  = .FALSE.
          SET_IRECV = .TRUE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &     BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                       &
     &     AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                 &
     &     STATUS, BUFR, LBUFR,                                         &
     &     LBUFR_BYTES,                                                 &
     &     PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,              &
     &     LRLU, LRLUS, N, IW, LIW, A, LA,                              &
     &     PTRIST, PTLUST_S, PTRFAC,                                    &
     &     PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,       &
     &     IERROR, COMM,                                                &
     &     NBPROCFILS,                                                  &
     &     IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                     &
     &     root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,           &
     &     INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                &
     &     LPTRAR, NELT, IW, IW,                                        &
     &     ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF ( IFLAG .LT. 0 ) GOTO 500
          IF (MESSAGE_RECEIVED) THEN
           IOLDPS = PTLUST_S(STEP(INODE))
           PTRCOL = IOLDPS + HF + NFRONT
           PTRROW = IOLDPS + HF + NASS1 + SHIFT_INDEX
          ENDIF
         ENDIF
        ENDDO
        IF (IERR .EQ. -2) GOTO 300
        IF (IERR .EQ. -3) GOTO 305
        PTRROW = PTRROW + NBLIG
        PDEST  = PDEST + 1
      ENDDO
      IF (NUMSTK.EQ.0) GOTO 500
      ISON = IFSON
      DO IELL = 1, NUMSTK
        ISTCHK = PIMASTER(STEP(ISON))
        NELIM = IW(ISTCHK + 1+KEEP(IXSZ))
        LSTK    = IW(ISTCHK+KEEP(IXSZ))
        NPIVS   = IW(ISTCHK + 3+KEEP(IXSZ))
        IF ( NPIVS .LT. 0 ) NPIVS = 0
        NSLSON  = IW(ISTCHK + 5+KEEP(IXSZ))
        HS      = 6 + NSLSON + KEEP(IXSZ)
        NCOLS     = NPIVS + LSTK
        SAME_PROC     = (ISTCHK.LE.IWPOS)
        IF (.NOT.SAME_PROC) THEN
         NROWS = IW(ISTCHK + 2+KEEP(IXSZ))
        ELSE
         NROWS = NCOLS
        ENDIF
        PDEST   = ISTCHK + 6 + KEEP(IXSZ)
        NCBSON  = LSTK - NELIM
        PTRCOL   = ISTCHK +  HS + NROWS + NPIVS + NELIM
        IF (KEEP(219).NE.0) THEN
          IF(KEEP(50) .EQ. 2) THEN
           NFS4FATHER = NCBSON
           DO I=0,NCBSON-1
              IF(IW(PTRCOL+I) .GT. NASS1) THEN
                 NFS4FATHER = I
                 EXIT
              ENDIF
           ENDDO
           NFS4FATHER = NFS4FATHER+NELIM
          ELSE
           NFS4FATHER = 0
          ENDIF
        ELSE
          NFS4FATHER = 0
        ENDIF
        IF (NSLSON.EQ.0) THEN
          NSLSON = 1
          PDEST1(1)  = AGMG_MUMPS_275(STEP(ISON),                            &
     &                 PROCNODE_STEPS, SLAVEF)
          IF (PDEST1(1).EQ.MYID) THEN
            CALL DAGMG_MUMPS_211( COMM_LOAD, ASS_IRECV,                      &
     &      BUFR, LBUFR, LBUFR_BYTES,                                   &
     &      INODE, ISON, NSLAVES,                                       &
     &      IW( PTLUST_S(STEP(INODE)) + 6 +KEEP(IXSZ)),                 &
     &      NFRONT, NASS1, NFS4FATHER, NCBSON,                          &
     &           IW( PTRCOL ),                                          &
     &      PROCNODE_STEPS,                                             &
     &      SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,               &
     &      LRLUS, N, IW,                                               &
     &      LIW, A, LA,                                                 &
     &      PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                     &
     &      PIMASTER, PAMASTER, NSTK_S, COMP,                           &
     &      IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL, LEAF,  &
     &      NBFIN, ICNTL, KEEP,KEEP8, root,                             &
     &      OPASSW, OPELIW,                                             &
     &      ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,                &
     &      ND, FRERE, LPTRAR, NELT, IW, IW,                            &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &      )
           IF ( IFLAG .LT. 0 ) GOTO 500
          ELSE
           IERR = -1
           DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON))+HS+NROWS+NPIVS+NELIM
            CALL  DAGMG_MUMPS_71(                                            &
     &           INODE, NFRONT,NASS1,NFS4FATHER,                        &
     &           ISON, MYID,                                            &
     &      NSLAVES, IW( PTLUST_S(STEP(INODE))+6+KEEP(IXSZ) ),          &
     &      IW(PTRCOL), NCBSON,                                         &
     &      COMM, IERR, PDEST1, NSLSON, SLAVEF,                         &
     &      KEEP,KEEP8, STEP, N,                                        &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &      )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                     &
     &        BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                    &
     &        AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                              &
     &        STATUS, BUFR, LBUFR, LBUFR_BYTES,                         &
     &        PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,           &
     &        LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                   &
     &        PTLUST_S, PTRFAC,                                         &
     &        PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,    &
     &        IERROR, COMM,                                             &
     &        NBPROCFILS,                                               &
     &        IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                  &
     &        root,OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &        INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,     &
     &        NELT, IW, IW,                                             &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
              IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
           ENDDO
           IF (IERR .EQ. -2) GOTO 290
           IF (IERR .EQ. -3) GOTO 295
          ENDIF
        ELSE
          DO ISLAVE = 0, NSLSON-1
            IF (IW(PDEST+ISLAVE).EQ.MYID) THEN
            CALL AGMG_MUMPS_49(                                              &
     &                KEEP,KEEP8, ISON, STEP, N, SLAVEF,                &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE+1, NCBSON,                                 &
     &                NSLSON,                                           &
     &                TROW_SIZE, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
              INDX        = PTRCOL + SHIFT_INDEX
              CALL DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,                    &
     &        BUFR, LBUFR, LBUFR_BYTES,                                 &
     &        INODE, ISON, NSLAVES,                                     &
     &        IW( PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)),                  &
     &        NFRONT, NASS1,NFS4FATHER,                                 &
     &        TROW_SIZE, IW( INDX ),                                    &
     &        PROCNODE_STEPS,                                           &
     &        SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,             &
     &        LRLUS, N, IW,                                             &
     &        LIW, A, LA,                                               &
     &        PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                   &
     &        PIMASTER, PAMASTER, NSTK_S, COMP,                         &
     &        IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL, LEAF,&
     &        NBFIN, ICNTL, KEEP,KEEP8, root,                           &
     &        OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,              &
     &        INTARR, DBLARR, ND, FRERE, LPTRAR, NELT, IW,              &
     &        IW,                                                       &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE                           &
     &        )
              IF ( IFLAG .LT. 0 ) GOTO 500
              EXIT
            ENDIF
          ENDDO
          IF (PIMASTER(STEP(ISON)).GT.0) THEN
          IERR = -1
          DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON)) + HS + NROWS + NPIVS + NELIM
            PDEST  =  PIMASTER(STEP(ISON)) + 6 + KEEP(IXSZ)
            CALL  DAGMG_MUMPS_71(                                            &
     &           INODE, NFRONT,NASS1, NFS4FATHER,                       &
     &           ISON, MYID,                                            &
     &      NSLAVES, IW(PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)),            &
     &      IW(PTRCOL), NCBSON,                                         &
     &      COMM, IERR, IW(PDEST), NSLSON, SLAVEF,                      &
     &      KEEP,KEEP8, STEP, N,                                        &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &       )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                     &
     &        BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                    &
     &        AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                              &
     &        STATUS, BUFR, LBUFR,                                      &
     &        LBUFR_BYTES,                                              &
     &        PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,           &
     &        LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                   &
     &        PTLUST_S, PTRFAC,                                         &
     &        PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,    &
     &        IERROR, COMM,                                             &
     &        NBPROCFILS,                                               &
     &        IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                  &
     &        root,OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &        INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,             &
     &        LPTRAR, NELT, IW, IW,                                     &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
              IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
          ENDDO
          IF (IERR .EQ. -2) GOTO 290
          IF (IERR .EQ. -3) GOTO 295
          ENDIF
        ENDIF
       ISON = FRERE(STEP(ISON))
      ENDDO
      GOTO 500
  250 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE IN INTEGER DYNAMIC ALLOCATION DURING                    &
     & DAGMG_MUMPS_253'
      ENDIF
      IFLAG   = -13
      IERROR  = NUMSTK + 1
      GOTO 490
  265 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * ) ' FAILURE ALLOCATING TMP_SLAVES_LIST',           &
     &                 ' DURING DMUMPS_253'
      ENDIF
      IFLAG  = -13
      IERROR = SIZE_TMP_SLAVES_LIST
      GOTO 490
  270 CONTINUE
      IFLAG = -8
      IERROR = LREQ
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE IN INTEGER ALLOCATION DURING DMUMPS_253'
      ENDIF
      GOTO 490
  280 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, WORKSPACE TOO SMALL DURING DMUMPS_253'
      ENDIF
      IFLAG = -9
      CALL AGMG_MUMPS_731(LAELL8-LRLUS, IERROR)
      GOTO 490
  290 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, SEND BUFFER TOO SMALL (1) DURING DMUMPS_253'
      ENDIF
      IFLAG = -17
      LREQ = NCBSON + 6 + NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  295 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, RECV BUFFER TOO SMALL (1) DURING DMUMPS_253'
      ENDIF
      IFLAG = -20
      LREQ = NCBSON + 6 + NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  300 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, SEND BUFFER TOO SMALL (2) DURING DMUMPS_253'
      ENDIF
      IFLAG = -17
      LREQ = NBLIG + NBCOL + 4 + KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  305 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, RECV BUFFER TOO SMALL (2) DURING DMUMPS_253'
      ENDIF
      IFLAG = -17
      LREQ = NBLIG + NBCOL + 4 + KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
  490 CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_253
      SUBROUTINE DAGMG_MUMPS_39(N, INODE, IW, LIW, A, LA,                    &
     &    ISON, NBROWS, NBCOLS, ROWLIST,                                &
     &    VALSON, PTLUST_S, PTRAST, STEP, PIMASTER,                     &
     &    OPASSW, IWPOSCB, MYID, KEEP,KEEP8 )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA
      INTEGER N,LIW,MYID
      INTEGER INODE,ISON, IWPOSCB
      INTEGER NBROWS, NBCOLS
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER IW(LIW), STEP(N), PIMASTER(KEEP(28)),                     &
     &        PTLUST_S(KEEP(28)), ROWLIST(NBROWS)
      DOUBLE PRECISION A(LA), VALSON(NBCOLS,NBROWS)
      DOUBLE PRECISION OPASSW
      INTEGER(8) :: POSELT, POSEL1, APOS, JJ2
      INTEGER HF,HS, NSLAVES, NFRONT, NASS1,                            &
     &        IOLDPS, ISTCHK,                                           &
     &        LSTK, NSLSON,NELIM,NPIVS,NCOLS, J1,J2,J3, JJ,             &
     &        JJ1, JPOS, SIZFI, NCOL, NROW,                             &
     &        NROWS, LDAFS_PERE, IBEG
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL SAME_PROC, FREE
      INTRINSIC real
      IOLDPS = PTLUST_S(STEP(INODE))
      POSELT = PTRAST(STEP(INODE))
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      NASS1  = iabs(IW(IOLDPS + 2+KEEP(IXSZ)))
      NSLAVES= IW(IOLDPS+5+KEEP(IXSZ))
      IF (KEEP(50).EQ.0) THEN
        LDAFS_PERE = NFRONT
      ELSE
        IF ( NSLAVES .eq. 0 ) THEN
          LDAFS_PERE = NFRONT
        ELSE
          LDAFS_PERE = NASS1
        ENDIF
      ENDIF
      HF      = 6 + NSLAVES + KEEP(IXSZ)
      POSEL1 = POSELT - int(LDAFS_PERE,8)
      ISTCHK = PIMASTER(STEP(ISON))
      LSTK = IW(ISTCHK+KEEP(IXSZ))
      NSLSON  = IW(ISTCHK + 5+KEEP(IXSZ))
      HS      = 6 + NSLSON + KEEP(IXSZ)
      OPASSW = OPASSW + dble(NBROWS*NBCOLS)
      NELIM = IW(ISTCHK + 1+KEEP(IXSZ))
      NPIVS = IW(ISTCHK + 3+KEEP(IXSZ))
      IF (NPIVS.LT.0) NPIVS = 0
      NCOLS = NPIVS + LSTK
      SAME_PROC = (ISTCHK.LT.IWPOSCB)
      IF (SAME_PROC) THEN
       NROWS = NCOLS
      ELSE
       NROWS = IW(ISTCHK+2+KEEP(IXSZ))
      ENDIF
      J1 = ISTCHK + NROWS + HS + NPIVS
      IF (KEEP(50).EQ.0) THEN
       DO 170 JJ = 1, NBROWS
        APOS = POSEL1 + int(ROWLIST(JJ),8) * int(LDAFS_PERE,8)
        DO 160 JJ1 = 1, NBCOLS
          JJ2 = APOS + int(IW(J1 + JJ1 - 1) - 1,8)
          A(JJ2) = A(JJ2) + VALSON(JJ1,JJ)
  160   CONTINUE
  170  CONTINUE
      ELSE
       DO JJ = 1, NBROWS
        IF (ROWLIST(JJ).LE.NASS1) THEN
         APOS = POSEL1 + int(ROWLIST(JJ) - 1,8)
         DO JJ1 = 1, NELIM
          JJ2 = APOS + int(IW(J1+JJ1-1),8)*int(LDAFS_PERE,8)
           A(JJ2) = A(JJ2) + VALSON(JJ1,JJ)
         ENDDO
         IBEG = NELIM+1
        ELSE
         IBEG = 1
        ENDIF
        APOS = POSEL1 + int(ROWLIST(JJ),8) * int(LDAFS_PERE,8)
        DO JJ1 = IBEG, NBCOLS
          IF (ROWLIST(JJ).LT.IW(J1 + JJ1 - 1)) EXIT
          JJ2 = APOS + int(IW(J1 + JJ1 - 1) - 1,8)
          A(JJ2) = A(JJ2) + VALSON(JJ1,JJ)
        ENDDO
       ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_39
      SUBROUTINE DAGMG_MUMPS_539                                             &
     &    (N, INODE, IW, LIW, A, LA,                                    &
     &    NBROWS, NBCOLS,                                               &
     &    OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,                  &
     &    FILS, PTRARW, PTRAIW, INTARR, DBLARR,                         &
     &    ICNTL, KEEP,KEEP8, MYID)
      IMPLICIT NONE
      INTEGER N,LIW
      INTEGER(8) :: LA
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER INODE, MYID
      INTEGER NBROWS, NBCOLS
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER IW(LIW), ITLOC(N), STEP(N),                               &
     &        PTRIST(KEEP(28)), FILS(N), PTRARW(N), PTRAIW(N)
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION A(LA),                                           &
     &        DBLARR(max(1,KEEP(13)))
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER IOLDPS, NBCOLF, NBROWF, NSLAVES, HF,                      &
     &        K1,K2,K,I,J,JPOS,NASS,JJ,                                 &
     &        IN,AINPUT,JK,J1,J2,IJROW, ILOC
      INTEGER(8) :: POSELT, ICT12, APOS
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IOLDPS  = PTRIST(STEP(INODE))
      POSELT  = PTRAST(STEP(INODE))
      NBCOLF  = IW(IOLDPS+KEEP(IXSZ))
      NBROWF  = IW(IOLDPS+2+KEEP(IXSZ))
      NASS    = IW(IOLDPS+1+KEEP(IXSZ))
      NSLAVES = IW(IOLDPS+5+KEEP(IXSZ))
      HF      = 6 + NSLAVES + KEEP(IXSZ)
      IF (NASS.LT.0) THEN
          NASS         = -NASS
          IW(IOLDPS+1+KEEP(IXSZ)) = NASS
          A(POSELT:POSELT+int(NBROWF,8)*int(NBCOLF,8)-1_8) =            &
     &    dble(ZERO)
          K1 = IOLDPS + HF
          K2 = K1 + NBROWF - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = JPOS
           JPOS     = JPOS + 1
          ENDDO
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NASS - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = -JPOS
           JPOS     = JPOS + 1
          ENDDO
          IN = INODE
          DO WHILE (IN.GT.0)
           AINPUT = PTRARW(IN)
           JK     = PTRAIW(IN)
           JJ     = JK + 1
           J1     = JJ + 1
           J2 = J1 + INTARR(JK)
           IJROW = -ITLOC(INTARR(J1))
           ICT12 = POSELT +int(- NBCOLF + IJROW - 1,8)
           DO JJ= J1,J2
            ILOC = ITLOC(INTARR(JJ))
            IF (ILOC.GT.0) THEN
              APOS = ICT12 + int(ILOC,8)*int(NBCOLF,8)
              A(APOS) = A(APOS) + DBLARR(AINPUT)
            ENDIF
            AINPUT  = AINPUT + 1
           ENDDO
           IN = FILS(IN)
          ENDDO
          K1 = IOLDPS + HF
          K2 = K1 + NBROWF + NASS - 1
          DO K = K1, K2
           J = IW(K)
           ITLOC(J) = 0
          ENDDO
      ENDIF
      IF (NBROWS.GT.0) THEN
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NBCOLF - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = JPOS
           JPOS     = JPOS + 1
          ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_539
      SUBROUTINE DAGMG_MUMPS_531                                             &
     & (N, INODE, IW, LIW, NBROWS, STEP, PTRIST, ITLOC, KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER N, LIW
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER INODE, MYID
      INTEGER NBROWS
      INTEGER IW(LIW), ITLOC(N), STEP(N),                               &
     &        PTRIST(KEEP(28))
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER IOLDPS, NBCOLF, NBROWF, NSLAVES, HF,                      &
     &        K1,K2,K,J
      IOLDPS  = PTRIST(STEP(INODE))
      NBCOLF  = IW(IOLDPS+KEEP(IXSZ))
      NBROWF  = IW(IOLDPS+2+KEEP(IXSZ))
      NSLAVES = IW(IOLDPS+5+KEEP(IXSZ))
      HF      = 6 + NSLAVES+KEEP(IXSZ)
      IF (NBROWS.GT.0) THEN
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NBCOLF - 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = 0
          ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_531
      SUBROUTINE DAGMG_MUMPS_40(N, INODE, IW, LIW, A, LA,                    &
     &    NBROWS, NBCOLS, ROWLIST, COLLIST, VALSON,                     &
     &    OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,                  &
     &    FILS,                                                         &
     &    ICNTL, KEEP,KEEP8, MYID)
      IMPLICIT NONE
      INTEGER N,LIW
      INTEGER(8) :: LA
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER INODE, MYID
      INTEGER NBROWS, NBCOLS
      INTEGER ROWLIST(NBROWS), COLLIST(NBCOLS)
      INTEGER IW(LIW), ITLOC(N), STEP(N),                               &
     &        PTRIST(KEEP(28)), FILS(N)
      INTEGER(8) :: PTRAST(KEEP(28))
      DOUBLE PRECISION A(LA), VALSON(NBCOLS,NBROWS)
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER(8) :: POSEL1, POSELT, APOS, ICT12, K8
      INTEGER IOLDPS, NBCOLF, NBROWF, NSLAVES, HF,                      &
     &        I,J,JPOS,NASS,JJ,                                         &
     &        IN,AINPUT,JK,J1,J2,IJROW,ILOC
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTRINSIC real
      IOLDPS  = PTRIST(STEP(INODE))
      POSELT  = PTRAST(STEP(INODE))
      NBCOLF  = IW(IOLDPS+KEEP(IXSZ))
      NBROWF  = IW(IOLDPS+2+KEEP(IXSZ))
      NASS    = IW(IOLDPS+1+KEEP(IXSZ))
       IF ( NBROWS .GT. NBROWF ) THEN
          WRITE(*,*) ' ERR: ERROR : NBROWS > NBROWF'
          WRITE(*,*) ' ERR: INODE =', INODE
          WRITE(*,*) ' ERR: NBROW=',NBROWS,'NBROWF=',NBROWF
          WRITE(*,*) ' ERR: ROW_LIST=', ROWLIST
          CALL AGMG_MUMPS_ABORT()
       END IF
      NSLAVES = IW(IOLDPS+5+KEEP(IXSZ))
      HF      = 6 + NSLAVES+KEEP(IXSZ)
      IF (NBROWS.GT.0) THEN
          POSEL1 = POSELT - int(NBCOLF,8)
          IF (KEEP(50).EQ.0) THEN
           DO I=1,NBROWS
            APOS = POSEL1 + int(ROWLIST(I),8) * int(NBCOLF,8)
            DO J=1,NBCOLS
             K8 = APOS + int(ITLOC(COLLIST(J)),8) - 1_8
             A(K8) = A(K8) + VALSON(J,I)
            ENDDO
           ENDDO
          ELSE
           DO I=1,NBROWS
            APOS = POSEL1 + int(ROWLIST(I),8) * int(NBCOLF,8)
            DO J=1,NBCOLS
             IF (ITLOC(COLLIST(J)) .EQ. 0) EXIT
             K8 = APOS + int(ITLOC(COLLIST(J)),8) - 1_8
             A(K8) = A(K8) + VALSON(J,I)
            ENDDO
           ENDDO
          ENDIF
          OPASSW = OPASSW + dble(NBROWS*NBCOLS)
      ENDIF
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_40
      SUBROUTINE DAGMG_MUMPS_178( A, LA,                                     &
     &             IAFATH, NFRONT, NASS1,                               &
     &             IACB, NCOLS, LCB,                                    &
     &             IW, NROWS, NELIM, ETATASS,                           &
     &             CB_IS_COMPRESSED, IS_INPLACE                         &
     &             )
      IMPLICIT NONE
      INTEGER NFRONT, NASS1
      INTEGER(8) :: LA
      INTEGER NCOLS, NROWS, NELIM
      INTEGER(8) :: LCB
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: IAFATH, IACB
      INTEGER IW( NCOLS )
      INTEGER ETATASS
      DOUBLE PRECISION ZERO
      LOGICAL CB_IS_COMPRESSED, IS_INPLACE
      PARAMETER(ZERO=0.0D0)
      LOGICAL RESET_TO_ZERO, RISK_OF_SAME_POS,                          &
     &        RISK_OF_SAME_POS_THIS_LINE
      INTEGER I, J
      INTEGER(8) :: APOS, POSELT
      INTEGER(8) :: IPOSCB, IBEGCBROW, IENDFRONT
      IENDFRONT =  IAFATH+int(NFRONT,8)*int(NFRONT,8)-1_8
      IF ( IS_INPLACE ) THEN
        IPOSCB=1_8
        RESET_TO_ZERO    = IACB .LT. IENDFRONT + 1_8
        RISK_OF_SAME_POS = IACB + LCB .EQ. IENDFRONT + 1_8
        RISK_OF_SAME_POS_THIS_LINE = .FALSE.
        DO I=1, NROWS
          POSELT = int(IW(I)-1,8) * int(NFRONT,8)
          IF (.NOT. CB_IS_COMPRESSED ) THEN
            IPOSCB = 1_8 + int(I - 1,8) * int(NCOLS,8)
            IF (IACB+IPOSCB-1_8 .GE. IENDFRONT + 1_8) THEN
              RESET_TO_ZERO = .FALSE.
            ENDIF
          ENDIF
          IF ( RISK_OF_SAME_POS ) THEN
            IF (I.EQ.NROWS .OR. .NOT. CB_IS_COMPRESSED) THEN
              IF ( IAFATH + POSELT + int(IW(I)-1,8) .EQ.                &
     &             IACB+IPOSCB+int(I-1-1,8)) THEN
                 RISK_OF_SAME_POS_THIS_LINE = .TRUE.
              ENDIF
            ENDIF
          ENDIF
          IF (RESET_TO_ZERO) THEN
            IF ( RISK_OF_SAME_POS_THIS_LINE ) THEN
              DO J=1, I
                APOS = POSELT + int(IW( J ),8)
                IF (IAFATH + APOS - 1_8.NE. IACB+IPOSCB-1_8) THEN
                  A(IAFATH+ APOS -1_8) = A(IACB+IPOSCB-1_8)
                  A(IACB+IPOSCB-1_8) = dble(ZERO)
                ENDIF
                IPOSCB = IPOSCB + 1_8
              ENDDO
            ELSE
              DO J=1, I
                APOS = POSELT + int(IW( J ),8)
                A(IAFATH+ APOS -1_8) = A(IACB+IPOSCB-1_8)
                A(IACB+IPOSCB-1_8)=dble(ZERO)
                IPOSCB = IPOSCB + 1_8
              ENDDO
            ENDIF
          ELSE
            DO J=1, I
              APOS = POSELT + int(IW( J ),8)
              A(IAFATH+ APOS -1_8) = A(IACB+IPOSCB-1_8)
              IPOSCB = IPOSCB + 1_8
            ENDDO
          ENDIF
          IF (.NOT. CB_IS_COMPRESSED ) THEN
            IBEGCBROW = IACB+IPOSCB-1_8
            IF ( IBEGCBROW .LE. IENDFRONT ) THEN
              A(IBEGCBROW:IBEGCBROW+int(NCOLS-I,8)-1_8)=dble(ZERO)
            ENDIF
          ENDIF
          IF (IACB+IPOSCB-1_8 .GE. IENDFRONT + 1_8) THEN
            RESET_TO_ZERO = .FALSE.
          ENDIF
        ENDDO
        RETURN
      ENDIF
      IF ((ETATASS.EQ.0) .OR. (ETATASS.EQ.1)) THEN
        IPOSCB = 1_8
        DO I = 1, NELIM
          POSELT = int( IW( I ) - 1, 8 ) * int(NFRONT, 8)
          IF (.NOT. CB_IS_COMPRESSED) THEN
            IPOSCB = 1_8 + int( I - 1, 8 ) * int(NCOLS,8)
          ENDIF
          DO J = 1, I
            APOS = POSELT + int(IW( J ),8)
            A(IAFATH+ APOS -1_8) = A(IAFATH+ APOS -1_8)                 &
     &                           + A(IACB+IPOSCB-1_8)
            IPOSCB = IPOSCB + 1_8
          END DO
        END DO
      ENDIF
      IF ((ETATASS.EQ.0).OR.(ETATASS.EQ.1)) THEN
        DO I = NELIM + 1, NROWS
          IF (CB_IS_COMPRESSED) THEN
            IPOSCB = (int(I,8) * int(I-1,8)) / 2_8 + 1_8
          ELSE
            IPOSCB = int(I-1,8) * int(NCOLS,8) + 1_8
          ENDIF
          POSELT = int(IW( I ),8)
          IF (POSELT.LE. int(NASS1,8) .AND. .NOT. IS_INPLACE) THEN
            DO J = 1, NELIM
              APOS = POSELT + int( IW( J ) - 1, 8 ) * int(NFRONT,8)
              A(IAFATH+APOS-1_8) = A(IAFATH+APOS-1_8) +                 &
     &                             A(IACB+IPOSCB-1_8)
              IPOSCB = IPOSCB + 1_8
            END DO
          ELSE
            POSELT = int( IW( I ) - 1, 8 ) * int(NFRONT, 8)
            DO J = 1, NELIM
             APOS = POSELT + int(IW( J ), 8)
             A(IAFATH+APOS-1_8) = A(IAFATH+APOS-1_8)                    &
     &                          + A(IACB+IPOSCB-1_8)
             IPOSCB = IPOSCB + 1_8
            END DO
          ENDIF
          IF (ETATASS.EQ.1) THEN
            POSELT = int( IW( I ) - 1, 8 ) * int(NFRONT, 8)
            DO J = NELIM + 1, I
                 IF (IW(J).GT.NASS1) EXIT
                 APOS = POSELT + int(IW( J ), 8)
                 A(IAFATH+APOS-1_8) = A(IAFATH+APOS-1_8)                &
     &                              + A(IACB+IPOSCB-1_8)
                 IPOSCB = IPOSCB +1_8
            END DO
          ELSE
            POSELT = int( IW( I ) - 1, 8 ) * int(NFRONT, 8)
            DO J = NELIM + 1, I
             APOS = POSELT + int(IW( J ), 8)
             A(IAFATH+APOS-1_8) = A(IAFATH+APOS-1_8)                    &
     &                          + A(IACB+IPOSCB-1_8)
             IPOSCB = IPOSCB + 1_8
            END DO
          ENDIF
        END DO
      ELSE
        DO I= NROWS, NELIM+1, -1
          IF (CB_IS_COMPRESSED) THEN
            IPOSCB = (int(I,8)*int(I+1,8))/2_8
          ELSE
            IPOSCB = int(I-1,8) * int(NCOLS,8) + int(I,8)
          ENDIF
          POSELT = int(IW( I ),8)
          IF (POSELT.LE.int(NASS1,8)) EXIT
          POSELT = int( IW( I ) - 1, 8 ) * int(NFRONT, 8)
          DO J=I,NELIM+1, -1
            IF (IW(J).LE.NASS1) EXIT
            APOS = POSELT + int(IW( J ), 8)
            A(IAFATH+APOS-1_8) = A(IAFATH+APOS-1_8)                     &
     &                         + A(IACB+IPOSCB-1_8)
            IPOSCB = IPOSCB - 1_8
          ENDDO
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_178
      SUBROUTINE DAGMG_MUMPS_530(N, ISON, INODE, IWPOSCB,                    &
     &           PIMASTER, PTLUST_S, IW, LIW, STEP, KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER N, ISON, INODE, IWPOSCB
      INTEGER KEEP(500), STEP(N)
      INTEGER*8 KEEP8(150)
      INTEGER PIMASTER(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER LIW
      INTEGER IW(LIW)
      INTEGER ISTCHK, LSTK, NSLSON, HS, NROWS, NCOLS, NPIVS, NELIM
      INTEGER IOLDPS, NFRONT, NSLAVES, ICT11, HF
      INTEGER J1, J2, J3, JJ, JPOS
      LOGICAL SAME_PROC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      ISTCHK = PIMASTER(STEP(ISON))
      LSTK   = IW(ISTCHK+KEEP(IXSZ))
      NSLSON = IW(ISTCHK+5+KEEP(IXSZ))
      HS     = 6 + NSLSON + KEEP(IXSZ)
      NELIM  = IW(ISTCHK + 1+KEEP(IXSZ))
      NPIVS  = IW(ISTCHK + 3+KEEP(IXSZ))
      NCOLS  = NPIVS + LSTK
      IF ( NPIVS < 0 ) NPIVS = 0
      SAME_PROC = ISTCHK < IWPOSCB
      IF (SAME_PROC) THEN
       NROWS = NCOLS
      ELSE
       NROWS = IW(ISTCHK+2+KEEP(IXSZ))
      ENDIF
      J1 = ISTCHK + NROWS + HS + NPIVS
      IF (KEEP(50).NE.0) THEN
          J2 = J1 +  LSTK - 1
          DO JJ = J1, J2
            IW(JJ) = IW(JJ - NROWS)
          ENDDO
      ELSE
            J2 = J1 + LSTK - 1
            J3 = J1 + NELIM
            DO JJ = J3, J2
             IW(JJ) = IW(JJ - NROWS)
            ENDDO
            IF (NELIM .NE. 0) THEN
              IOLDPS = PTLUST_S(STEP(INODE))
              NFRONT = IW(IOLDPS+KEEP(IXSZ))
              NSLAVES= IW(IOLDPS+5+KEEP(IXSZ))
              HF     = 6 + NSLAVES+KEEP(IXSZ)
              ICT11 = IOLDPS + HF - 1 + NFRONT
              J3 = J3 - 1
              DO 190 JJ = J1, J3
               JPOS = IW(JJ) + ICT11
               IW(JJ) = IW(JPOS)
  190         CONTINUE
            ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_530
      SUBROUTINE DAGMG_MUMPS_619(                                            &
     &     N, INODE, IW, LIW, A, LA,                                    &
     &     ISON, NBCOLS,                                                &
     &     VALSON, PTLUST_S, PTRAST, STEP, PIMASTER,                    &
     &     OPASSW, IWPOSCB,MYID, KEEP,KEEP8 )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA
      INTEGER N,LIW,MYID
      INTEGER INODE,ISON,IWPOSCB
      INTEGER NBCOLS
      INTEGER IW(LIW), STEP(N),                                         &
     &     PIMASTER(KEEP(28)),                                          &
     &     PTLUST_S(KEEP(28))
      INTEGER(8) PTRAST(KEEP(28))
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION VALSON(NBCOLS)
      DOUBLE PRECISION OPASSW
      INTEGER HF,HS, NSLAVES, NASS1,                                    &
     &     IOLDPS, ISTCHK,                                              &
     &     LSTK, NSLSON,NELIM,NPIVS,NCOLS, J1,                          &
     &     JJ1,JPOS, NROWS
      INTEGER(8) POSELT, APOS, JJ2
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL SAME_PROC, FREE
      INTRINSIC real
      IOLDPS = PTLUST_S(STEP(INODE))
      POSELT = PTRAST(STEP(INODE))
      NASS1  = iabs(IW(IOLDPS + 2 + KEEP(IXSZ)))
      NSLAVES= IW(IOLDPS+5 + KEEP(IXSZ))
      HF      = 6 + NSLAVES + KEEP(IXSZ)
      ISTCHK = PIMASTER(STEP(ISON))
      LSTK = IW(ISTCHK + KEEP(IXSZ))
      NSLSON  = IW(ISTCHK + 5 + KEEP(IXSZ))
      HS      = 6 + NSLSON + KEEP(IXSZ)
      NELIM = IW(ISTCHK + 1 + KEEP(IXSZ))
      NPIVS = IW(ISTCHK + 3 + KEEP(IXSZ))
      IF (NPIVS.LT.0) NPIVS = 0
      NCOLS = NPIVS + LSTK
      SAME_PROC = (ISTCHK.LT.IWPOSCB)
      IF (SAME_PROC) THEN
       NROWS = NCOLS
      ELSE
       NROWS = IW(ISTCHK+2 + KEEP(IXSZ))
      ENDIF
      J1 = ISTCHK + NROWS + HS + NPIVS
      APOS = POSELT + int(NASS1,8)*int(NASS1,8) - 1_8
      DO JJ1 = 1, NBCOLS
         JJ2 = APOS+int(IW(J1 + JJ1 - 1),8)
         IF(abs(A(JJ2)) .LT. VALSON(JJ1))                               &
     &         A(JJ2) = dble(VALSON(JJ1))
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_619
      RECURSIVE SUBROUTINE DAGMG_MUMPS_264(                                  &
     &   COMM_LOAD, ASS_IRECV,                                          &
     &   BUFR, LBUFR,                                                   &
     &   LBUFR_BYTES, PROCNODE_STEPS, MSGSOU,                           &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM, IFLAG, IERROR, NBFIN,                              &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE_STEPS,       &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER ICNTL( 40 ), KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER BUFR( LBUFR )
      INTEGER N, SLAVEF, IWPOS, IWPOSCB, LIW
      INTEGER(8) :: IPTRLU, LRLU, LRLUS, LA
      INTEGER(8) :: POSFAC
      INTEGER COMP
      INTEGER IFLAG, IERROR, NBFIN, MSGSOU
      INTEGER PROCNODE_STEPS(KEEP(28)), PTRIST(KEEP(28)),               &
     &        NSTK_S(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER NBPROCFILS( KEEP(28) ), STEP(N),                          &
     & PIMASTER(KEEP(28))
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER COMM, MYID
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER PTLUST_S(KEEP(28)),                                       &
     &        ITLOC(N), FILS(N), ND(KEEP(28))
      INTEGER PTRAIW( LPTRAR ), PTRARW( LPTRAR )
      INTEGER FRERE_STEPS(KEEP(28))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION FLOP1
      DOUBLE PRECISION  DBLARR(max(1,KEEP(13)))
      INTEGER LEAF, LPOOL
      INTEGER IPOOL( LPOOL )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER INODE, POSITION, NPIV, IERR, LP
      INTEGER NCOL, NROW
      INTEGER(8) :: POSBLOCFACTO
      INTEGER(8) :: LAELL
      INTEGER(8) :: MEM_GAIN
      INTEGER(8) :: POSELT
      INTEGER IOLDPS, LCONT1, NASS1, NROW1, NCOL1, NPIV1
      INTEGER NSLAV1, HS, ISW
      INTEGER (8) :: LPOS, LPOS1, LPOS2, IPOS, KPOS
      INTEGER ICT11
      INTEGER I, IPIV, FPERE
      INTEGER LCONT,NELIM,NASS, LDA, NCOL_TO_SEND,                      &
     &        SHIFT_LIST_ROW_SON, SHIFT_LIST_COL_SON
      INTEGER(8) :: SHIFT_VAL_SON
      INTEGER ITYPE2
      PARAMETER(ITYPE2=2)
      LOGICAL LASTBL
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      DOUBLE PRECISION ONE,ALPHA
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, NextPivDummy
      TYPE(IO_BLOCK) :: MonBloc
      LOGICAL LAST_CALL
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      FPERE    = -1
      POSITION = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      LASTBL = (NPIV.LE.0)
      IF (LASTBL) THEN
         NPIV = -NPIV
         CALL AGMG_NOCALL('MPI_UNPACK')
      ENDIF
      CALL AGMG_NOCALL('MPI_UNPACK')
      LAELL = int(NPIV,8) * int(NCOL,8)
      IF ( LRLU .LT. LAELL .OR. IWPOS + NPIV - 1 .GT. IWPOSCB ) THEN
        IF ( LRLUS .LT. LAELL ) THEN
          IF (LAELL - LRLUS .GT. int(huge(IERROR),8)) THEN
            write(*,*) "I8 OVERFLOW, LAELL-LRLUS=",LAELL-LRLUS
            CALL AGMG_MUMPS_ABORT()
          ENDIF
          IFLAG = -9
          IERROR = int(LAELL - LRLUS,kind(IERROR))
          IF (ICNTL(1).GT.0 .AND. ICNTL(4).GE.1) THEN
            LP=ICNTL(1)
            WRITE(LP,*)                                                 &
     &" FAILURE, WORKSPACE TOO SMALL DURING DAGMG_MUMPS_264"
          ENDIF
          GOTO 700
        END IF
        CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                     &
     &      LRLU, IPTRLU,                                               &
     &      IWPOS, IWPOSCB, PTRIST, PTRAST,                             &
     &      STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,            &
     &      KEEP(IXSZ))
        COMP = COMP+1
        IF ( LRLU .NE. LRLUS ) THEN
             WRITE(*,*) 'PB compress ass..blocfacto: LRLU,LRLUS='       &
     &       ,LRLU,LRLUS
             IFLAG = -9
             CALL AGMG_MUMPS_731( LAELL-LRLUS, IERROR )
             IF (LAELL - LRLUS .GT. int(huge(IERROR),8)) THEN
               write(*,*) "I8 OVERFLOW, LAELL-LRLUS=",LAELL-LRLUS
               CALL AGMG_MUMPS_ABORT()
             ENDIF
             IERROR = int(LAELL - LRLUS,kind(IERROR))
             GOTO 700
        END IF
        IF ( IWPOS + NPIV - 1 .GT. IWPOSCB ) THEN
          IF (ICNTL(1).GT.0 .AND. ICNTL(4).GE.1) THEN
            LP=ICNTL(1)
            WRITE(LP,*)                                                 &
     &" FAILURE IN INTEGER ALLOCATION DURING DAGMG_MUMPS_264"
          ENDIF
          IFLAG = -8
          IERROR = IWPOS + NPIV - 1 - IWPOSCB
          GOTO 700
        END IF
      END IF
      LRLU  = LRLU - LAELL
      LRLUS = LRLUS - LAELL
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSBLOCFACTO = POSFAC
      POSFAC = POSFAC + LAELL
      CALL DAGMG_MUMPS_471(.FALSE., .FALSE.,                                 &
     &               LA-LRLUS,0_8,LAELL,KEEP,KEEP8,LRLU)
      IPIV = IWPOS
      IWPOS = IWPOS + NPIV
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      IF (PTRIST(STEP( INODE )) .EQ. 0) THEN
         DO WHILE ( PTRIST(STEP(INODE)) .EQ. 0 )
          BLOCKING = .TRUE.
          SET_IRECV= .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD,                                   &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    MSGSOU, MAITRE_DESC_BANDE,                                    &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.                       &
     &    )
          IF ( IFLAG .LT. 0 ) GOTO 600
        END DO
      ENDIF
      DO WHILE ( NBPROCFILS( STEP(INODE)) .NE. 0 )
        BLOCKING = .TRUE.
        SET_IRECV = .FALSE.
        MESSAGE_RECEIVED = .FALSE.
        CALL DAGMG_MUMPS_329( COMM_LOAD,                                     &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    AGMG_MPF_ANY_SOURCE, CONTRIB_TYPE2,                                &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
        IF ( IFLAG .LT. 0 ) GOTO 600
      END  DO
        SET_IRECV = .TRUE.
        BLOCKING  = .FALSE.
        MESSAGE_RECEIVED = .TRUE.
        CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                          &
     &    BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                        &
     &    AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                  &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.  )
      IOLDPS = PTRIST(STEP(INODE))
      POSELT = PTRAST(STEP(INODE))
      LCONT1 = IW( IOLDPS +KEEP(IXSZ))
      NASS1  = IW( IOLDPS + 1 +KEEP(IXSZ))
      NROW1  = IW( IOLDPS + 2 +KEEP(IXSZ))
      NPIV1  = IW( IOLDPS + 3 +KEEP(IXSZ))
      NSLAV1 = IW( IOLDPS + 5 +KEEP(IXSZ))
      HS     = 6 + NSLAV1 + KEEP(IXSZ)
      NCOL1  = LCONT1 + NPIV1
      IF (NPIV.GT.0) THEN
        ICT11 = IOLDPS+HS+NROW1+NPIV1 - 1
        DO I = 1, NPIV
          IF (IW(IPIV+I-1).EQ.I) CYCLE
          ISW = IW(ICT11+I)
          IW(ICT11+I) = IW(ICT11+IW(IPIV+I-1))
          IW(ICT11+IW(IPIV+I-1)) = ISW
          IPOS = POSELT + int(NPIV1 + I - 1,8)
          KPOS = POSELT + int(NPIV1 + IW(IPIV+I-1) - 1,8)
          CALL DSWAP(NROW1, A(IPOS), NCOL1, A(KPOS), NCOL1)
        ENDDO
        LPOS2 = POSELT + int(NPIV1,8)
        CALL DTRSM('L','L','N','N',NPIV, NROW1, ONE,                    &
     &           A(POSBLOCFACTO), NCOL, A(LPOS2), NCOL1)
        LPOS1 = POSBLOCFACTO+int(NPIV,8)
        LPOS  = LPOS2 + int(NPIV,8)
      ENDIF
      IF (KEEP(201).eq.1) THEN
        MonBloc%INODE = INODE
        MonBloc%MASTER = .FALSE.
        MonBloc%TypeNode = 2
        MonBloc%NROW = NROW1
        MonBloc%NCOL = NCOL1
        MonBloc%NFS  = NASS1
        MonBloc%LastPiv = NPIV1 + NPIV
        NULLIFY(MonBloc%INDICES)
        MonBloc%LAST = LASTBL
        STRAT = STRAT_TRY_WRITE
        NextPivDummy      = -8888
        LIWFAC = IW(IOLDPS+XXI)
        CALL AGMG_MUMPS_729(LAFAC, IW(IOLDPS+XXR))
        LAST_CALL = .FALSE.
        CALL DAGMG_MUMPS_688( STRAT, TYPEF_L, A(POSELT),                     &
     &       LAFAC, MonBloc, NextPivDummy, NextPivDummy,                &
     &       IW(IOLDPS), LIWFAC, MYID, KEEP8(31), IFLAG,LAST_CALL)
      ENDIF
      IF ( NPIV .GT. 0 ) THEN
        CALL DGEMM('N','N', NCOL-NPIV,NROW1,NPIV,                       &
     &             ALPHA,A(LPOS1),NCOL,                                 &
     &             A(LPOS2),NCOL1,ONE, A(LPOS),NCOL1)
      ENDIF
  200 CONTINUE
      IW(IOLDPS+KEEP(IXSZ) ) = IW(IOLDPS+KEEP(IXSZ) ) - NPIV
      IW(IOLDPS + 3+KEEP(IXSZ) ) = IW(IOLDPS+3+KEEP(IXSZ) ) + NPIV
      IF (LASTBL) IW(IOLDPS+1+KEEP(IXSZ) ) = IW(IOLDPS + 3+KEEP(IXSZ) )
      IF ( .not. LASTBL .AND.                                           &
     &  (IW(IOLDPS+1+KEEP(IXSZ)) .EQ. IW(IOLDPS + 3+KEEP(IXSZ))) ) THEN
        write(*,*) ' ERROR 1 **** IN BLACFACTO '
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      LRLU  = LRLU + LAELL
      LRLUS = LRLUS + LAELL
      POSFAC = POSFAC - LAELL
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &             LA-LRLUS,0_8,-LAELL,KEEP,KEEP8,LRLU)
      IWPOS = IWPOS - NPIV
      FLOP1 = dble( NPIV1*NROW1 ) +                                     &
     &        dble(NROW1*NPIV1)*dble(2*NCOL1-NPIV1-1)                   &
     &   -                                                              &
     &        dble((NPIV1+NPIV)*NROW1 ) -                               &
     &        dble(NROW1*(NPIV1+NPIV))*dble(2*NCOL1-NPIV1-NPIV-1)
      CALL DAGMG_MUMPS_190( 1, .FALSE., FLOP1, KEEP,KEEP8 )
      IF (LASTBL) THEN
        IW(IOLDPS+XXS)=S_ALL
        IF (KEEP(214).EQ.1) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2         &
     &     )
          IF (KEEP(38).NE.FPERE) THEN
            IW(PTRIST(STEP(INODE))+XXS)=S_NOLCBNOCONTIG
            IF (KEEP(216).NE.3) THEN
              MEM_GAIN=int(IW(PTRIST(STEP(INODE))+2+KEEP(IXSZ)),8)*     &
     &                 int(IW(PTRIST(STEP(INODE))+3+KEEP(IXSZ)),8)
              LRLUS = LRLUS+MEM_GAIN
              CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                          &
     &                LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            ENDIF
          ENDIF
          IF (KEEP(216).EQ.2) THEN
           IF (KEEP(38).NE.FPERE) THEN
           CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                    &
     &         IW( PTRIST(STEP( INODE )) + 2 + KEEP(IXSZ) ),            &
     &         IW( PTRIST(STEP( INODE )) + KEEP(IXSZ) ),                &
     &         IW( PTRIST(STEP( INODE )) + 3 + KEEP(IXSZ) )+            &
     &         IW( PTRIST(STEP( INODE )) + KEEP(IXSZ) ),0,              &
     &         IW( PTRIST(STEP( INODE )) + XXS ),0_8)
           IW(PTRIST(STEP(INODE))+XXS)=S_NOLCBCONTIG
           ENDIF
          ENDIF
         ENDIF
      ENDIF
      IOLDPS = PTRIST(STEP(INODE))
      IF ( LASTBL  .AND. (KEEP(38).EQ.FPERE) ) THEN
       LCONT  = IW(IOLDPS+KEEP(IXSZ))
       NROW   = IW(IOLDPS+2+KEEP(IXSZ))
       NPIV   = IW(IOLDPS+3+KEEP(IXSZ))
       NASS   = IW(IOLDPS+4+KEEP(IXSZ))
       NELIM  = NASS-NPIV
       NCOL_TO_SEND =  LCONT-NELIM
       SHIFT_LIST_ROW_SON = 6 + IW(IOLDPS+5+KEEP(IXSZ)) + KEEP(IXSZ)
       SHIFT_LIST_COL_SON = SHIFT_LIST_ROW_SON + NROW + NASS
       SHIFT_VAL_SON      = int(NASS,8)
       LDA                = LCONT + NPIV
      IF (IW(IOLDPS+6+KEEP(IXSZ)).EQ.S_ROOTBAND_INIT) THEN
        IW(IOLDPS+6+KEEP(IXSZ)) = S_REC_CONTSTATIC
      ELSE
      ENDIF
       CALL DAGMG_MUMPS_80(                                                  &
     &    COMM_LOAD, ASS_IRECV,                                         &
     &    N, INODE, FPERE,                                              &
     &    PTRIST, PTRAST,                                               &
     &    root, NROW, NCOL_TO_SEND, SHIFT_LIST_ROW_SON,                 &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, LDA,                      &
     &    ROOT_CONT_STATIC, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8,                            &
     &    .FALSE., ND, FRERE_STEPS,                                     &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
       IF ( IFLAG < 0 ) GOTO 600
       IF (NELIM.EQ.0) THEN
        IF (KEEP(214).EQ.2) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &         PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,        &
     &         LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,               &
     &         IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,         &
     &         IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2    &
     &         )
        ENDIF
         CALL DAGMG_MUMPS_626( N, INODE,                                     &
     &         PTRIST, PTRAST, IW, LIW, A, LA,                          &
     &         LRLU, LRLUS, IWPOSCB,                                    &
     &         IPTRLU, STEP,                                            &
     &         MYID, KEEP                                               &
     &         )
       ELSE
        IOLDPS = PTRIST(STEP(INODE))
        IF  (IW(IOLDPS+6+KEEP(IXSZ)).EQ.S_ROOT2SON_CALLED) THEN
           CALL DAGMG_MUMPS_626( N, INODE, PTRIST, PTRAST, IW, LIW,          &
     &        A, LA, LRLU, LRLUS, IWPOSCB, IPTRLU, STEP,                &
     &        MYID, KEEP                                                &
     &         )
        ELSE
          IW(IOLDPS+6+KEEP(IXSZ)) = S_ROOTBAND_INIT
         IF (KEEP(214).EQ.1.AND.KEEP(216).NE.3) THEN
           IW(PTRIST(STEP(INODE))+XXS)=S_NOLCBNOCONTIG38
           CALL DAGMG_MUMPS_628( IW(PTRIST(STEP(INODE))),                    &
     &                     LIW-PTRIST(STEP(INODE))+1,                   &
     &                     MEM_GAIN, KEEP(IXSZ) )
           LRLUS = LRLUS + MEM_GAIN
              CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                          &
     &                LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            IF (KEEP(216).EQ.2) THEN
              CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                 &
     &         IW( PTRIST(STEP( INODE )) + 2 + KEEP(IXSZ) ),            &
     &         IW( PTRIST(STEP( INODE )) + KEEP(IXSZ) ),                &
     &         IW( PTRIST(STEP( INODE )) + 3 + KEEP(IXSZ) )+            &
     &         IW( PTRIST(STEP( INODE )) + KEEP(IXSZ) ),                &
     &         IW( PTRIST(STEP( INODE )) + 4 + KEEP(IXSZ) ) -           &
     &         IW( PTRIST(STEP( INODE )) + 3 + KEEP(IXSZ) ),            &
     &         IW( PTRIST(STEP( INODE )) + XXS ),0_8)
              IW(PTRIST(STEP(INODE))+XXS)=S_NOLCBCONTIG38
            ENDIF
         ENDIF
        ENDIF
       ENDIF
      ENDIF
  600 CONTINUE
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_264
      SUBROUTINE DAGMG_MUMPS_699( COMM_LOAD, ASS_IRECV,                      &
     &   MSGLEN, BUFR, LBUFR,                                           &
     &   LBUFR_BYTES, PROCNODE_STEPS,                                   &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, POSFAC,           &
     &   N, IW, LIW, A, LA, PTRIST, PTLUST_S, PTRFAC, PTRAST,           &
     &   STEP, PIMASTER, PAMASTER, NBPROCFILS,                          &
     &   COMP, root, OPASSW, OPELIW, ITLOC, NSTK_S,                     &
     &   FILS, PTRARW, PTRAIW, INTARR, DBLARR, NBFIN,                   &
     &   MYID, COMM, ICNTL, KEEP,KEEP8, IFLAG, IERROR,                  &
     &   IPOOL, LPOOL, LEAF, ND, FRERE_STEPS, LPTRAR, NELT,             &
     &   FRTPTR, FRTELT,                                                &
     &   ISTEP_TO_INIV2, TAB_POS_IN_PERE )
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER ICNTL( 40 ), KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER COMM_LOAD, ASS_IRECV, MSGLEN
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: LRLU, IPTRLU, LRLUS, LA, POSFAC
      INTEGER N, SLAVEF, IWPOS, IWPOSCB, LIW
      INTEGER NBFIN
      INTEGER COMP
      INTEGER NELT, LPTRAR
      INTEGER PROCNODE_STEPS( KEEP(28) ), PTRIST(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28)), PAMASTER(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER PTLUST_S( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER ITLOC( N ), NSTK_S( KEEP(28) ), FILS( N )
      INTEGER ND(KEEP(28)), FRERE_STEPS( KEEP(28) )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max( 1,KEEP(13)) )
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER COMM, MYID, IFLAG, IERROR
      INTEGER LEAF, LPOOL
      INTEGER IPOOL( LPOOL )
      INTEGER FRTPTR(N+1), FRTELT( NELT )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER NFS4FATHER
      LOGICAL COMPUTE_MAX
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      INTEGER IERR
      INTEGER NBROWS_ALREADY_SENT, NBROWS_PACKET
      INTEGER I, INODE, ISON, POSITION, NBROW, LROW, IROW, INDCOL
      INTEGER LREQI
      INTEGER(8) :: LREQA, POSCONTRIB
      INTEGER ROW_LENGTH
      INTEGER MASTER
      INTEGER ISTCHK
      LOGICAL SAME_PROC
      LOGICAL SLAVE_NODE
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER ISHIFT_BUFR, LBUFR_LOC, LBUFR_BYTES_LOC
      POSITION = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      MASTER     = AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      SLAVE_NODE = MASTER .NE. MYID
      IF (SLAVE_NODE .AND. PTRIST(STEP(INODE)) ==0) THEN
        ISHIFT_BUFR     = ( MSGLEN + KEEP(34) ) / KEEP(34)
        LBUFR_LOC       = LBUFR - ISHIFT_BUFR + 1
        LBUFR_BYTES_LOC = LBUFR_LOC * KEEP(34)
        DO WHILE ( PTRIST( STEP(INODE) ) .EQ. 0 )
          MASTER = AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,SLAVEF)
          BLOCKING = .TRUE.
          SET_IRECV = .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &     BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                       &
     &     MASTER, MAITRE_DESC_BANDE,                                   &
     &     STATUS,                                                      &
     &     BUFR(ISHIFT_BUFR), LBUFR_LOC, LBUFR_BYTES_LOC,               &
     &     PROCNODE_STEPS, POSFAC,                                      &
     &     IWPOS, IWPOSCB, IPTRLU,                                      &
     &     LRLU, LRLUS, N, IW, LIW, A, LA,                              &
     &     PTRIST, PTLUST_S, PTRFAC,                                    &
     &     PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,              &
     &     IFLAG, IERROR, COMM,                                         &
     &     NBPROCFILS, IPOOL, LPOOL, LEAF,                              &
     &     NBFIN, MYID, SLAVEF,                                         &
     &     root, OPASSW, OPELIW, ITLOC, FILS,                           &
     &     PTRARW, PTRAIW,                                              &
     &     INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,          &
     &     LPTRAR, NELT, FRTPTR, FRTELT,                                &
     &     ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF (IFLAG.LT.0) RETURN
        END DO
      ENDIF
      IF ( SLAVE_NODE ) THEN
         LREQI = LROW + NBROWS_PACKET
      ELSE
         LREQI = NBROWS_PACKET
      END IF
         LREQA = int(LROW,8)
         IF ( LRLU .LT. LREQA .OR. IWPOS + LREQI                        &
     &        - 1 .GT. IWPOSCB ) THEN
            IF ( LRLUS .LT. LREQA ) THEN
               IFLAG = -9
               CALL AGMG_MUMPS_731( LREQA - LRLUS, IERROR )
               CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
               RETURN
            END IF
            CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                 &
     &           LRLU, IPTRLU,                                          &
     &           IWPOS, IWPOSCB, PTRIST, PTRAST,                        &
     &           STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,       &
     &           KEEP(IXSZ))
            COMP = COMP+1
            IF ( LRLU .NE. LRLUS ) THEN
               WRITE(*,*) 'PB compress ass..process_contrib'
               WRITE(*,*) 'LRLU,LRLUS=',LRLU,LRLUS
               IFLAG = -9
               CALL AGMG_MUMPS_731( LREQA - LRLUS, IERROR )
               CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
               RETURN
            END IF
            IF ( IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
               IFLAG  = -8
               IERROR = IWPOS + LREQI - 1 - IWPOSCB
               CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
               RETURN
            END IF
         END IF
         LRLU  = LRLU - LREQA
         LRLUS = LRLUS - LREQA
         POSCONTRIB = POSFAC
         POSFAC = POSFAC + LREQA
         KEEP8(67) = min(LRLUS, KEEP8(67))
         CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                               &
     &        LA-LRLUS,0_8,LREQA,KEEP,KEEP8,LRLU)
         IF  ( SLAVE_NODE ) THEN
            IROW   = IWPOS
            INDCOL = IWPOS + NBROWS_PACKET
         ELSE
            IROW   = IWPOS
            INDCOL = -1
         END IF
         IWPOS = IWPOS + LREQI
         IF ( SLAVE_NODE ) THEN
            CALL AGMG_NOCALL('MPI_UNPACK')
         END IF
         DO I = 1, NBROWS_PACKET
            CALL AGMG_NOCALL('MPI_UNPACK')
         END DO
         IF ( SLAVE_NODE ) THEN
            IF ( NBROWS_ALREADY_SENT + NBROWS_PACKET == NBROW ) THEN
              NBPROCFILS(STEP(INODE))=NBPROCFILS(STEP(INODE))-1
            ENDIF
            IF ( KEEP(55) .eq. 0 ) THEN
               CALL DAGMG_MUMPS_539                                          &
     &              (N, INODE, IW, LIW, A, LA,                          &
     &              NBROW, LROW,                                        &
     &              OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,        &
     &              FILS, PTRARW, PTRAIW, INTARR, DBLARR, ICNTL,        &
     &              KEEP,KEEP8, MYID )
            ELSE
               CALL DAGMG_MUMPS_123(                                         &
     &              NELT, FRTPTR, FRTELT,                               &
     &              N, INODE, IW, LIW, A, LA,                           &
     &              NBROW, LROW,                                        &
     &              OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,        &
     &              FILS, PTRARW, PTRAIW, INTARR, DBLARR, ICNTL,        &
     &              KEEP,KEEP8, MYID )
            ENDIF
            DO I=1,NBROWS_PACKET
               IF(KEEP(50).NE.0)THEN
                  CALL AGMG_NOCALL('MPI_UNPACK')
               ELSE
                 ROW_LENGTH=LROW
               ENDIF
               CALL AGMG_NOCALL('MPI_UNPACK')
               CALL DAGMG_MUMPS_40(N, INODE, IW, LIW, A, LA,                 &
     &              1, ROW_LENGTH, IW( IROW+I-1 ),IW(INDCOL),           &
     &              A(POSCONTRIB),                                      &
     &              OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,        &
     &              FILS, ICNTL, KEEP,KEEP8, MYID )
            ENDDO
            CALL DAGMG_MUMPS_531                                             &
     &           (N, INODE, IW, LIW,                                    &
     &           NBROWS_PACKET, STEP, PTRIST, ITLOC, KEEP,KEEP8)
         ELSE
            DO I=1,NBROWS_PACKET
               IF(KEEP(50).NE.0)THEN
                  CALL AGMG_NOCALL('MPI_UNPACK')
               ELSE
                 ROW_LENGTH=LROW
               ENDIF
               CALL AGMG_NOCALL('MPI_UNPACK')
               CALL DAGMG_MUMPS_39(N, INODE, IW, LIW, A, LA,                 &
     &              ISON, 1, ROW_LENGTH, IW( IROW +I-1 ),               &
     &              A(POSCONTRIB), PTLUST_S, PTRAST,                    &
     &              STEP, PIMASTER, OPASSW,                             &
     &              IWPOSCB, MYID, KEEP,KEEP8)
            ENDDO
          IF (NBROWS_ALREADY_SENT .EQ. 0) THEN
          IF (KEEP(219).NE.0) THEN
            IF(KEEP(50) .EQ. 2) THEN
               CALL AGMG_NOCALL('MPI_UNPACK')
               IF(NFS4FATHER .GT. 0) THEN
                  CALL DAGMG_MUMPS_617(NFS4FATHER,IERR)
                  IF (IERR .NE. 0) THEN
                        IERROR         = BUF_LMAX_ARRAY
                        IFLAG          = -13
                        CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
                        RETURN
                  ENDIF
                  CALL AGMG_NOCALL('MPI_UNPACK')
                  CALL DAGMG_MUMPS_619(N, INODE, IW, LIW, A, LA,             &
     &                 ISON, NFS4FATHER,                                &
     &                 BUF_MAX_ARRAY, PTLUST_S, PTRAST,                 &
     &                 STEP, PIMASTER, OPASSW,                          &
     &                 IWPOSCB, MYID, KEEP,KEEP8)
               ENDIF
            ENDIF
          ENDIF
          ENDIF
          IF (NBROWS_ALREADY_SENT + NBROWS_PACKET == NBROW ) THEN
            NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE)) - 1
            NBPROCFILS(STEP(ISON))  = NBPROCFILS(STEP(ISON)) - 1
            IF ( NBPROCFILS(STEP(ISON)) .EQ. 0) THEN
               ISTCHK = PIMASTER(STEP(ISON))
               SAME_PROC= ISTCHK .LT. IWPOSCB
               IF (SAME_PROC) THEN
                  CALL DAGMG_MUMPS_530(N, ISON, INODE, IWPOSCB,              &
     &                 PIMASTER, PTLUST_S, IW, LIW, STEP, KEEP,KEEP8)
               ENDIF
               IF (SAME_PROC) THEN
                  ISTCHK = PTRIST(STEP(ISON))
                  PTRIST(STEP( ISON) ) = -99999999
               ELSE
                  PIMASTER(STEP( ISON )) = -99999999
               ENDIF
               CALL DAGMG_MUMPS_152(.FALSE., MYID, N, ISTCHK,                &
     &              PAMASTER(STEP(ISON)),                               &
     &              IW, LIW, LRLU, LRLUS, IPTRLU, IWPOSCB,              &
     &              LA, KEEP,KEEP8, .FALSE.                             &
     &              )
            ENDIF
            IF ( NBPROCFILS(STEP(INODE)) .EQ. 0 ) THEN
               CALL DAGMG_MUMPS_507( N, IPOOL, LPOOL,                        &
     &              PROCNODE_STEPS,                                     &
     &              SLAVEF, KEEP(28), KEEP(76), KEEP(80),               &
     &              KEEP(47), STEP, INODE+N )
               IF (KEEP(47) .GE. 3) THEN
                  CALL DAGMG_MUMPS_500(                                      &
     &          IPOOL, LPOOL,                                           &
     &                 PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,   &
     &                 MYID, STEP, N, ND, FILS )
               ENDIF
            ENDIF
          ENDIF
      END IF
         IWPOS = IWPOS - LREQI
         LRLU = LRLU + LREQA
         LRLUS = LRLUS + LREQA
         POSFAC = POSFAC - LREQA
         CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                               &
     &        LA-LRLUS,0_8,-LREQA,KEEP,KEEP8,LRLU)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_699
      SUBROUTINE DAGMG_MUMPS_143( N, INODE, IW, LIW, A, LA,                  &
     &                           IOLDPS, POSELT, IFLAG, UU, NOFFW,      &
     &                           NPVW,                                  &
     &                           KEEP,KEEP8, STEP,                      &
     &                           PROCNODE_STEPS, MYID, SLAVEF, SEUIL,   &
     &                           AVOID_DELAYED, ETATASS,                &
     &     DKEEP,PIVNUL_LIST,LPN_LIST,                                  &
     &     IWPOS )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER(8) :: LA, POSELT
      INTEGER N, INODE, LIW, IFLAG, NOFFW, NPVW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER MYID, SLAVEF, IOLDPS
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER PROCNODE_STEPS( KEEP(28) ), STEP(N)
      DOUBLE PRECISION UU, SEUIL
      LOGICAL AVOID_DELAYED
      INTEGER ETATASS, IWPOS
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER INOPV, IFINB, NFRONT, NPIV, IBEG_BLOCK
      INTEGER NASS, NEL1, NPIVB, NPIVE, NBOLKJ, NBTLKJ
      DOUBLE PRECISION UUTEMP
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, TYPEFile, LNextPiv2beWritten,              &
     &        UNextPiv2beWritten, IFLAG_OOC,                            &
     &        PP_FIRST2SWAP_L, PP_FIRST2SWAP_U,                         &
     &        PP_LastPIVRPTRFilled_L,                                   &
     &        PP_LastPIVRPTRFilled_U
      TYPE(IO_BLOCK) :: MonBloc
      LOGICAL LAST_CALL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      EXTERNAL AGMG_MUMPS_330, DAGMG_MUMPS_221, DAGMG_MUMPS_233,                       &
     &         DAGMG_MUMPS_229,                                              &
     &         DAGMG_MUMPS_225, DAGMG_MUMPS_232, DAGMG_MUMPS_231,                      &
     &         DAGMG_MUMPS_220,                                              &
     &         DAGMG_MUMPS_228, DAGMG_MUMPS_236
      INTEGER  AGMG_MUMPS_330
      LOGICAL STATICMODE
      DOUBLE PRECISION SEUIL_LOC
      INOPV = 0
      SEUIL_LOC = SEUIL
      IF(KEEP(97) .EQ. 0) THEN
         STATICMODE = .FALSE.
      ELSE
         STATICMODE = .TRUE.
      ENDIF
      IF (AVOID_DELAYED) THEN
         STATICMODE = .TRUE.
         UUTEMP=UU
         SEUIL_LOC = max(SEUIL,epsilon(SEUIL))
      ELSE
         UUTEMP=UU
      ENDIF
      IBEG_BLOCK=1
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      NASS   = iabs(IW(IOLDPS+2+KEEP(IXSZ)))
      IF (NASS .GT. KEEP(3)) THEN
        NBOLKJ = min( KEEP(6), NASS )
      ELSE
        NBOLKJ = min( KEEP(5), NASS )
      ENDIF
      NBTLKJ = NBOLKJ
        IF (KEEP(201).EQ.1) THEN
          CALL AGMG_MUMPS_729(LAFAC,IW(IOLDPS+XXR))
          LIWFAC    = IW(IOLDPS+XXI)
          TYPEFile     = TYPEF_BOTH_LU
          LNextPiv2beWritten = 1
          UNextPiv2beWritten = 1
          PP_FIRST2SWAP_L = LNextPiv2beWritten
          PP_FIRST2SWAP_U = UNextPiv2beWritten
          MonBloc%LastPanelWritten_L = 0
          MonBloc%LastPanelWritten_U = 0
          PP_LastPIVRPTRFilled_L = 0
          PP_LastPIVRPTRFilled_U = 0
          MonBloc%INODE    = INODE
          MonBloc%MASTER   = .TRUE.
          MonBloc%Typenode = 1
          MonBloc%NROW     = NFRONT
          MonBloc%NCOL     = NFRONT
          MonBloc%NFS      = NASS
          MonBloc%Last     = .FALSE.
          MonBloc%LastPiv  = -88877
          NULLIFY(MonBloc%INDICES)
        ENDIF
   50 CONTINUE
      CALL DAGMG_MUMPS_221(NFRONT,NASS,N,INODE,IW,LIW,A,LA,INOPV,NOFFW,      &
     &     IFLAG,IOLDPS,POSELT,UU,SEUIL_LOC,KEEP,KEEP8,                 &
     &     DKEEP(1),PIVNUL_LIST(1),LPN_LIST,                            &
     &     PP_FIRST2SWAP_L,  MonBloc%LastPanelWritten_L,                &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U,  MonBloc%LastPanelWritten_U,                &
     &     PP_LastPIVRPTRFilled_U)
      IF (IFLAG.LT.0) GOTO 500
      IF (INOPV.EQ.1) THEN
         IF(STATICMODE) THEN
            INOPV = -1
            GOTO 50
         ENDIF
         GOTO 80
      ENDIF
      IF (INOPV.EQ.2) THEN
         CALL DAGMG_MUMPS_233(IBEG_BLOCK,                                    &
     &            NFRONT,NASS,N,INODE,IW,LIW,A,LA,                      &
     &            IOLDPS,POSELT,NBOLKJ, NBTLKJ,KEEP(4),KEEP(IXSZ))
         GOTO 50
      ENDIF
      NPVW = NPVW + 1
      IF (NASS.LE.1) THEN
       CALL DAGMG_MUMPS_229(NFRONT,N,INODE,IW,LIW,A,LA,                      &
     &                 IOLDPS,POSELT,KEEP(IXSZ))
       IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + 1
       GO TO 500
      ENDIF
       CALL DAGMG_MUMPS_225(IBEG_BLOCK,NFRONT, NASS, N,INODE,IW,LIW,A,LA,    &
     &             IOLDPS,POSELT,IFINB,                                 &
     &             NBTLKJ,KEEP(4),KEEP(IXSZ))
       IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + 1
       IF (IFINB.EQ.0) GOTO 50
       IF (KEEP(201).EQ.1) THEN
           MonBloc%LastPiv= IW(IOLDPS+1+KEEP(IXSZ))
           STRAT          = STRAT_TRY_WRITE
           TYPEFile       = TYPEF_U
           LAST_CALL      = .FALSE.
           CALL DAGMG_MUMPS_688                                              &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           LNextPiv2beWritten, UNextPiv2beWritten,                &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
        ENDIF
       IF (IFINB.EQ.(-1)) GOTO 80
       NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
       NEL1   = NASS - NPIV
      CALL DAGMG_MUMPS_232(A,LA,                                             &
     &           NFRONT,NPIV,NASS,POSELT,NBTLKJ)
      GO TO 50
   80 CONTINUE
      NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
      IF (NPIV.LE.0) GO TO 110
      NEL1   = NFRONT - NASS
      IF (NEL1.LE.0) GO TO 110
        IF (KEEP(201).EQ.1) THEN
         STRAT          = STRAT_TRY_WRITE
         TYPEFile     = TYPEF_BOTH_LU
         MonBloc%LastPiv= NPIV
         CALL DAGMG_MUMPS_642(A(POSELT), LAFAC, NFRONT,                      &
     &      NPIV, NASS, IW(IOLDPS), LIWFAC,                             &
     &      MonBloc, TYPEFile, MYID, KEEP8,                             &
     &      STRAT, IFLAG_OOC,                                           &
     &      LNextPiv2beWritten, UNextPiv2beWritten)
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
        ELSE
          CALL DAGMG_MUMPS_231(A,LA,NFRONT, NPIV,NASS,POSELT)
        ENDIF
  110 CONTINUE
      IF (AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)                  &
     &                   .EQ.1) THEN
        NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
        IBEG_BLOCK = NPIV
        IF (NASS.EQ.NPIV) GOTO 500
  120   CALL DAGMG_MUMPS_220(NFRONT,NASS,N,INODE,IW,LIW,A,LA,                &
     &     INOPV,NOFFW,IOLDPS,POSELT,UU,SEUIL,                          &
     &     KEEP,                                                        &
     &     PP_FIRST2SWAP_L,  MonBloc%LastPanelWritten_L,                &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U,  MonBloc%LastPanelWritten_U,                &
     &     PP_LastPIVRPTRFilled_U)
        IF (INOPV.NE.1) THEN
         NPVW = NPVW + 1
         CALL DAGMG_MUMPS_228(NFRONT,NASS,N,INODE,IW,LIW,A,LA,               &
     &                 IOLDPS,POSELT,IFINB,KEEP(IXSZ))
         IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + 1
       IF (IFINB.EQ.0) GOTO 120
        ENDIF
        NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
        NPIVB  = IBEG_BLOCK
        NPIVE  = NPIV - NPIVB
        NEL1   = NFRONT - NASS
        IF ((NPIVE.LE.0).OR.(NEL1.EQ.0)) GO TO 500
        CALL DAGMG_MUMPS_236(A,LA,NPIVB,                                     &
     &                NFRONT,NPIV,NASS,POSELT)
      ENDIF
  500 CONTINUE
       IF (KEEP(201).EQ.1) THEN
          STRAT            = STRAT_WRITE_MAX
          MonBloc%Last     = .TRUE.
          MonBloc%LastPiv  = IW(IOLDPS+1+KEEP(IXSZ))
          TYPEFile     = TYPEF_BOTH_LU
          LAST_CALL    = .TRUE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           LNextPiv2beWritten, UNextPiv2beWritten,                &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC, LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
          CALL DAGMG_MUMPS_644(IWPOS,                                        &
     &      IOLDPS, IW, LIW, MonBloc , NFRONT, KEEP)
       ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_143
      RECURSIVE SUBROUTINE DAGMG_MUMPS_322(                                  &
     &    COMM_LOAD, ASS_IRECV,                                         &
     &    MSGSOU, MSGTAG, MSGLEN,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                 &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER MSGSOU, MSGTAG, MSGLEN
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER KEEP(500), ICNTL( 40 )
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS, LA
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S(KEEP(28)), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER MYID, SLAVEF, NBFIN
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1), FRTELT( NELT )
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      INTEGER INIV2, ISHIFT, IBEG
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      LOGICAL FLAG
      INTEGER MP, LP
      INTEGER TMP( 2 )
      INTEGER NBRECU, POSITION, INODE, ISON, IROOT
      INTEGER NSLAVES_PERE, NFRONT_PERE, NASS_PERE,                     &
     &     LASTBL_PERE, LMAP, FPERE, NELIM,                             &
     &     HDMAPLIG,NFS4FATHER,                                         &
     &     TOT_ROOT_SIZE, TOT_CONT_TO_RECV
      DOUBLE PRECISION FLOP1
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE )
      CHARACTER(LEN=35)::SUBNAME
      MP = ICNTL(2)
      LP = ICNTL(1)
      SUBNAME="??????"
      CALL DAGMG_MUMPS_467(COMM_LOAD, KEEP)
      IF ( MSGTAG .EQ. RACINE ) THEN
          POSITION = 0
          CALL AGMG_NOCALL('MPI_UNPACK')
          NBRECU = BUFR( 1 )
          NBFIN =  NBFIN - NBRECU
      ELSEIF ( MSGTAG .EQ. NOEUD ) THEN
          CALL DAGMG_MUMPS_269( MYID,KEEP,KEEP8,                             &
     &    BUFR, LBUFR, LBUFR_BYTES,                                     &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST, PTRAST,               &
     &    STEP, PIMASTER, PAMASTER,                                     &
     &    NSTK_S, COMP, FPERE, FLAG, IFLAG, IERROR, COMM, ITLOC )
          SUBNAME="DAGMG_MUMPS_269"
          IF ( IFLAG .LT. 0 ) GO TO 500
          IF ( FLAG ) THEN
            CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL,                            &
     &           PROCNODE_STEPS, SLAVEF, KEEP(28), KEEP(76),            &
     &           KEEP(80), KEEP(47), STEP, FPERE )
            IF (KEEP(47) .GE. 3) THEN
               CALL DAGMG_MUMPS_500(                                         &
     &              IPOOL, LPOOL,                                       &
     &              PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,      &
     &              MYID, STEP, N, ND, FILS )
            ENDIF
            CALL AGMG_MUMPS_137( FPERE, N,                                   &
     &           PROCNODE_STEPS,SLAVEF,                                 &
     &           ND, FILS, FRERE, STEP, PIMASTER,                       &
     &           KEEP(28), KEEP(50), FLOP1,                             &
     &           IW, LIW, KEEP(IXSZ) )
            IF (FPERE.NE.KEEP(20))                                      &
     &        CALL DAGMG_MUMPS_190(1,.FALSE.,FLOP1,KEEP,KEEP8)
          ENDIF
      ELSEIF ( MSGTAG .EQ. END_NIV2_LDLT ) THEN
          INODE = BUFR( 1 )
          CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL,                              &
     &         PROCNODE_STEPS, SLAVEF, KEEP(28), KEEP(76),              &
     &         KEEP(80), KEEP(47),                                      &
     &         STEP, -INODE )
          IF (KEEP(47) .GE. 3) THEN
             CALL DAGMG_MUMPS_500(                                           &
     &            IPOOL, LPOOL,                                         &
     &            PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,        &
     &            MYID, STEP, N, ND, FILS )
          ENDIF
      ELSEIF ( MSGTAG .EQ. TERREUR ) THEN
          IFLAG  = -001
          IERROR = MSGSOU
          GOTO 100
      ELSEIF ( MSGTAG .EQ. MAITRE_DESC_BANDE ) THEN
        CALL DAGMG_MUMPS_266( MYID,BUFR, LBUFR,                              &
     &    LBUFR_BYTES, IWPOS,                                           &
     &    IWPOSCB,                                                      &
     &    IPTRLU, LRLU, LRLUS, NBPROCFILS,                              &
     &    N, IW, LIW, A, LA,                                            &
     &    PTRIST, PTRAST, STEP, PIMASTER, PAMASTER, COMP,               &
     &    KEEP,KEEP8, ITLOC,                                            &
     &    IFLAG, IERROR )
          SUBNAME="DAGMG_MUMPS_266"
        IF ( IFLAG .LT. 0 ) GO to 500
      ELSEIF ( MSGTAG .EQ. MAITRE2           ) THEN
        CALL DAGMG_MUMPS_268(MYID,BUFR, LBUFR, LBUFR_BYTES,                  &
     &    PROCNODE_STEPS, SLAVEF, IWPOS, IWPOSCB,                       &
     &    IPTRLU, LRLU, LRLUS, N, IW, LIW, A, LA,                       &
     &    PTRIST, PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,       &
     &    IFLAG, IERROR, COMM, COMM_LOAD, NBPROCFILS,                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    KEEP,KEEP8, ND, FILS, FRERE, ITLOC,                           &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          SUBNAME="DAGMG_MUMPS_268"
        IF ( IFLAG .LT. 0 ) GO to 500
      ELSEIF ( MSGTAG .EQ. BLOC_FACTO        ) THEN
        CALL DAGMG_MUMPS_264( COMM_LOAD, ASS_IRECV,                          &
     &   BUFR,  LBUFR, LBUFR_BYTES,                                     &
     &   PROCNODE_STEPS, MSGSOU,                                        &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM , IFLAG, IERROR, NBFIN,                             &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE,             &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      ELSEIF ( MSGTAG .EQ. BLOC_FACTO_SYM_SLAVE    ) THEN
        CALL DAGMG_MUMPS_263( COMM_LOAD, ASS_IRECV,                          &
     &   BUFR, LBUFR,                                                   &
     &   LBUFR_BYTES, PROCNODE_STEPS, MSGSOU,                           &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM, IFLAG, IERROR, NBFIN,                              &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE,             &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      ELSEIF ( MSGTAG .EQ. BLOC_FACTO_SYM    ) THEN
        CALL DAGMG_MUMPS_274( COMM_LOAD, ASS_IRECV,                          &
     &   BUFR, LBUFR,                                                   &
     &   LBUFR_BYTES, PROCNODE_STEPS, MSGSOU,                           &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM, IFLAG, IERROR, NBFIN,                              &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE,             &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
      ELSEIF ( MSGTAG .EQ. CONTRIB_TYPE2    ) THEN
        CALL DAGMG_MUMPS_699( COMM_LOAD, ASS_IRECV,                          &
     &       MSGLEN, BUFR, LBUFR,                                       &
     &       LBUFR_BYTES, PROCNODE_STEPS,                               &
     &       SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, POSFAC,       &
     &       N, IW, LIW, A, LA, PTRIST,                                 &
     &       PTLUST_S, PTRFAC, PTRAST,                                  &
     &       STEP, PIMASTER, PAMASTER, NBPROCFILS, COMP, root,          &
     &       OPASSW, OPELIW, ITLOC, NSTK_S,                             &
     &       FILS, PTRARW, PTRAIW, INTARR, DBLARR, NBFIN, MYID, COMM,   &
     &       ICNTL, KEEP,KEEP8, IFLAG, IERROR, IPOOL, LPOOL, LEAF,      &
     &       ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,                   &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE )
        IF ( IFLAG .LT. 0 ) GO TO 100
      ELSEIF ( MSGTAG .EQ. MAPLIG            ) THEN
         HDMAPLIG = 7
         INODE        = BUFR( 1 )
         ISON         = BUFR( 2 )
         NSLAVES_PERE = BUFR( 3 )
         NFRONT_PERE  = BUFR( 4 )
         NASS_PERE    = BUFR( 5 )
         LMAP         = BUFR( 6 )
         NFS4FATHER = BUFR(7)
         IF ( (NSLAVES_PERE.NE.0).AND.(KEEP(48).NE.0) ) THEN
            INIV2 = ISTEP_TO_INIV2 ( STEP(INODE) )
            ISHIFT = NSLAVES_PERE+1
            TAB_POS_IN_PERE(1:NSLAVES_PERE+1, INIV2) =                  &
     &           BUFR(HDMAPLIG+1:HDMAPLIG+1+NSLAVES_PERE)
            TAB_POS_IN_PERE(SLAVEF+2, INIV2) = NSLAVES_PERE
         ELSE
            ISHIFT = 0
         ENDIF
         IBEG = HDMAPLIG+1+ISHIFT
         CALL DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,                         &
     &    BUFR, LBUFR, LBUFR_BYTES,                                     &
     &    INODE, ISON, NSLAVES_PERE,                                    &
     &    BUFR(IBEG),                                                   &
     &    NFRONT_PERE, NASS_PERE, NFS4FATHER,LMAP,                      &
     &    BUFR(IBEG+NSLAVES_PERE),                                      &
     &    PROCNODE_STEPS, SLAVEF, POSFAC, IWPOS, IWPOSCB,               &
     &    IPTRLU, LRLU, LRLUS, N, IW, LIW, A, LA,                       &
     &    PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP, PIMASTER, PAMASTER,   &
     &    NSTK_S, COMP,                                                 &
     &    IFLAG, IERROR, MYID, COMM, NBPROCFILS,                        &
     &    IPOOL, LPOOL, LEAF, NBFIN, ICNTL, KEEP,KEEP8, root,           &
     &    OPASSW, OPELIW,                                               &
     &    ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,                  &
     &    ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,                      &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
         IF ( IFLAG .LT. 0 ) GO TO 100
      ELSE IF ( MSGTAG .EQ. ROOT_CONT_STATIC ) THEN
        CALL DAGMG_MUMPS_700(                                                &
     &        BUFR, LBUFR, LBUFR_BYTES,                                 &
     &        root, N, IW, LIW, A, LA, NBPROCFILS,                      &
     &        LRLU, IPTRLU, IWPOS, IWPOSCB,                             &
     &        PTRIST, PTLUST_S, PTRFAC, PTRAST,                         &
     &        STEP, PIMASTER, PAMASTER,                                 &
     &        COMP, LRLUS, IPOOL, LPOOL, LEAF,                          &
     &        FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,               &
     &        KEEP,KEEP8, IFLAG, IERROR, COMM, COMM_LOAD, ITLOC,        &
     &        ND, PROCNODE_STEPS, SLAVEF)
        SUBNAME="DAGMG_MUMPS_700"
        IF ( IFLAG .LT. 0 ) GO TO 500
      ELSE IF ( MSGTAG .EQ. ROOT_NON_ELIM_CB ) THEN
        IROOT  = KEEP( 38 )
        MSGSOU = AGMG_MUMPS_275( STEP(IROOT), PROCNODE_STEPS,                &
     &           SLAVEF )
        IF ( PTLUST_S( STEP(IROOT)) .EQ. 0 ) THEN
          CALL AGMG_NOCALL('MPI_RECV')
          CALL DAGMG_MUMPS_270( TMP( 1 ), TMP( 2 ),                          &
     &    root,                                                         &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM, COMM_LOAD,                               &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND )
          SUBNAME="DAGMG_MUMPS_270"
          IF ( IFLAG .LT. 0 ) GOTO 500
        END IF
        CALL DAGMG_MUMPS_700(                                                &
     &       BUFR, LBUFR, LBUFR_BYTES,                                  &
     &       root, N, IW, LIW, A, LA, NBPROCFILS,                       &
     &       LRLU, IPTRLU, IWPOS, IWPOSCB,                              &
     &       PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP, PIMASTER, PAMASTER,&
     &       COMP, LRLUS, IPOOL, LPOOL, LEAF,                           &
     &       FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,                &
     &       KEEP,KEEP8, IFLAG, IERROR, COMM, COMM_LOAD, ITLOC,         &
     &       ND, PROCNODE_STEPS, SLAVEF )
          SUBNAME="DAGMG_MUMPS_700"
        IF ( IFLAG .LT. 0 ) GO TO 500
      ELSE IF ( MSGTAG .EQ. ROOT_2SON ) THEN
         ISON = BUFR( 1 )
         NELIM = BUFR( 2 )
         CALL DAGMG_MUMPS_271( COMM_LOAD, ASS_IRECV,                         &
     &    ISON, NELIM, root,                                            &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                 &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF ( IFLAG .LT. 0 ) GO TO 100
         IF (MYID.NE.AGMG_MUMPS_275(STEP(ISON),                              &
     &          PROCNODE_STEPS, SLAVEF)) THEN
          IF (KEEP(50).EQ.0) THEN
            IF (IW(PTRIST(STEP(ISON))+6+KEEP(IXSZ)).EQ.                 &
     &                                 S_REC_CONTSTATIC) THEN
             IW(PTRIST(STEP(ISON))+6+KEEP(IXSZ)) = S_ROOT2SON_CALLED
            ELSE
             CALL DAGMG_MUMPS_626( N, ISON, PTRIST, PTRAST,                  &
     &       IW, LIW, A, LA, LRLU, LRLUS, IWPOSCB,                      &
     &       IPTRLU, STEP, MYID, KEEP                                   &
     &    )
            ENDIF
          ELSE
           IF (IW(PTRIST(STEP(ISON))+8+KEEP(IXSZ)).EQ.                  &
     &                                 S_REC_CONTSTATIC) THEN
             IW(PTRIST(STEP(ISON))+8+KEEP(IXSZ)) = S_ROOT2SON_CALLED
           ELSE
             CALL DAGMG_MUMPS_626( N, ISON, PTRIST, PTRAST,                  &
     &       IW, LIW, A, LA, LRLU, LRLUS, IWPOSCB,                      &
     &       IPTRLU, STEP, MYID, KEEP                                   &
     &    )
           ENDIF
          ENDIF
         ENDIF
      ELSE IF ( MSGTAG .EQ. ROOT_2SLAVE ) THEN
          TOT_ROOT_SIZE    = BUFR( 1 )
          TOT_CONT_TO_RECV = BUFR( 2 )
          CALL DAGMG_MUMPS_270( TOT_ROOT_SIZE,                               &
     &    TOT_CONT_TO_RECV, root,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM, COMM_LOAD,                               &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND )
          IF ( IFLAG .LT. 0 ) GO TO 100
      ELSE IF ( MSGTAG .EQ. ROOT_NELIM_INDICES ) THEN
         ISON         = BUFR( 1 )
         NELIM        = BUFR( 2 )
         NSLAVES_PERE = BUFR( 3 )
         CALL DAGMG_MUMPS_273( root,                                         &
     &    ISON, NELIM, NSLAVES_PERE, BUFR(4), BUFR(4+BUFR(2)),          &
     &    BUFR(4+2*BUFR(2)),                                            &
     &    PROCNODE_STEPS,                                               &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, ITLOC, COMP,        &
     &    IFLAG, IERROR,                                                &
     &    IPOOL, LPOOL, LEAF, MYID, SLAVEF, KEEP,KEEP8,                 &
     &    COMM, COMM_LOAD, FILS, ND)
          SUBNAME="DAGMG_MUMPS_273"
         IF ( IFLAG .LT. 0 ) GO TO 500
      ELSE IF ( MSGTAG .EQ. UPDATE_LOAD ) THEN
         WRITE(*,*) "Internal error 3 in DAGMG_MUMPS_322"
         CALL AGMG_MUMPS_ABORT()
      ELSE IF ( MSGTAG .EQ. TAG_DUMMY   ) THEN
      ELSE
         IF ( LP > 0 )                                                  &
     &     WRITE(LP,*) MYID,                                            &
     &': Internal error, routine DMUMPS_322.',MSGTAG
         IFLAG = -100
         IERROR= MSGTAG
         GOTO 500
      ENDIF
  100 CONTINUE
      RETURN
  500 CONTINUE
      IF ( ICNTL(1) .GT. 0 .AND. ICNTL(4).GE.1 ) THEN
        LP=ICNTL(1)
        IF (IFLAG.EQ.-9) THEN
         WRITE(LP,*) 'FAILURE, WORKSPACE TOO SMALL DURING ',SUBNAME
        ENDIF
        IF (IFLAG.EQ.-8) THEN
         WRITE(LP,*) 'FAILURE IN INTEGER ALLOCATION DURING ',SUBNAME
        ENDIF
        IF (IFLAG.EQ.-13) THEN
         WRITE(LP,*) 'FAILURE IN DYNAMIC ALLOCATION DURING ',SUBNAME
        ENDIF
      ENDIF
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_322
      RECURSIVE SUBROUTINE DAGMG_MUMPS_280(                                  &
     &    COMM_LOAD, ASS_IRECV,                                         &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                 &
     &    LPTRAR, NELT, FRTPTR, FRTELT ,                                &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: POSFAC, LA, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST( KEEP(28) ),                                       &
     &        PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S(KEEP(28)), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER MYID, SLAVEF, NBFIN
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      INTEGER MSGSOU, MSGTAG, MSGLEN, IERR
      INTEGER allocok, OLDSIZE
      MSGSOU = STATUS( AGMG_MPF_SOURCE )
      MSGTAG = STATUS( AGMG_MPF_TAG )
      CALL AGMG_NOCALL('MPI_GET_COUNT')
      IF ( MSGLEN .GT. LBUFR_BYTES ) THEN
        IFLAG  = -20
        IERROR = MSGLEN
         WRITE(*,*) ' RECEPTION BUF TOO SMALL, Msgtag/len=',            &
     &                MSGTAG,MSGLEN
        CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
        RETURN
       ENDIF
       CALL AGMG_NOCALL('MPI_RECV')
       CALL DAGMG_MUMPS_322(                                                 &
     &      COMM_LOAD, ASS_IRECV,                                       &
     &      MSGSOU, MSGTAG, MSGLEN, BUFR, LBUFR,                        &
     &      LBUFR_BYTES,                                                &
     &      PROCNODE_STEPS, POSFAC,                                     &
     &      IWPOS, IWPOSCB, IPTRLU,                                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                     &
     &      PTLUST_S, PTRFAC,                                           &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,      &
     &      IERROR, COMM,                                               &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                    &
     &      root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,          &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,               &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &      )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_280
      RECURSIVE SUBROUTINE DAGMG_MUMPS_329(                                  &
     &    COMM_LOAD, ASS_IRECV, BLOCKING, SET_IRECV,                    &
     &    MESSAGE_RECEIVED, MSGSOU, MSGTAG,                             &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                 &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    STACK_RIGHT_AUTHORIZED                                        &
     &    )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      LOGICAL, INTENT (IN)  :: BLOCKING
      LOGICAL, INTENT (IN)  :: SET_IRECV
      LOGICAL, INTENT (INOUT) :: MESSAGE_RECEIVED
      INTEGER, INTENT (IN) :: MSGSOU, MSGTAG
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: LA, POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST( KEEP(28) ),                                       &
     &        PTLUST_S(KEEP(28))
      INTEGER STEP(N),                                                  &
     & PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S(KEEP(28)), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER MYID, SLAVEF, NBFIN
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      LOGICAL, intent(in) :: STACK_RIGHT_AUTHORIZED
       LOGICAL FLAG, RIGHT_MESS, FLAGbis
       INTEGER LP, MSGSOU_LOC, MSGTAG_LOC, MSGLEN_LOC
       INTEGER IERR
       INTEGER STATUS_BIS( AGMG_MPF_STATUS_SIZE )
       INTEGER, SAVE :: RECURS = 0
      CALL DAGMG_MUMPS_467(COMM_LOAD, KEEP)
      IF ( .NOT. STACK_RIGHT_AUTHORIZED ) THEN
          RETURN
      ENDIF
      RECURS = RECURS + 1
      LP = ICNTL(1)
      IF (ICNTL(4).LT.1) LP=-1
      IF ( MESSAGE_RECEIVED ) THEN
        MSGSOU_LOC = AGMG_MPF_ANY_SOURCE
        MSGTAG_LOC = AGMG_MPF_ANY_TAG
        GOTO 250
      ENDIF
      IF ( ASS_IRECV .NE. AGMG_MPF_REQUEST_NULL) THEN
      RIGHT_MESS = .TRUE.
       IF (BLOCKING) THEN
         CALL AGMG_NOCALL('MPI_WAIT')
         FLAG = .TRUE.
         IF ( ( (MSGSOU.NE.AGMG_MPF_ANY_SOURCE) .OR.                         &
     &      (MSGTAG.NE.AGMG_MPF_ANY_TAG) )  ) THEN
           IF ( MSGSOU.NE.AGMG_MPF_ANY_SOURCE) THEN
             RIGHT_MESS = MSGSOU.EQ.STATUS(AGMG_MPF_SOURCE)
           ENDIF
           IF ( MSGTAG.NE.AGMG_MPF_ANY_TAG) THEN
             RIGHT_MESS =                                               &
     &       ( (MSGTAG.EQ.STATUS(AGMG_MPF_TAG)).AND.RIGHT_MESS )
           ENDIF
           IF (.NOT.RIGHT_MESS) THEN
             CALL AGMG_NOCALL('MPI_PROBE')
           ENDIF
         ENDIF
       ELSE
        CALL AGMG_MPF_TEST(ASS_IRECV,                                        &
     &             FLAG, STATUS, IERR)
       ENDIF
       IF (IERR.LT.0) THEN
        IFLAG = -20
        IF (LP.GT.0)                                                    &
     &  write(LP,*) ' Error return from MPI_TEST ',                     &
     &     IFLAG, ' in DMUMPS_329'
        CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
        RETURN
       ENDIF
       IF ( FLAG ) THEN
         MESSAGE_RECEIVED = .TRUE.
         MSGSOU_LOC = STATUS( AGMG_MPF_SOURCE )
         MSGTAG_LOC = STATUS( AGMG_MPF_TAG )
         CALL AGMG_NOCALL('MPI_GET_COUNT')
           IF (.NOT.RIGHT_MESS) RECURS = RECURS + 10
         CALL DAGMG_MUMPS_322( COMM_LOAD, ASS_IRECV,                         &
     &      MSGSOU_LOC, MSGTAG_LOC, MSGLEN_LOC, BUFR, LBUFR,            &
     &      LBUFR_BYTES,                                                &
     &      PROCNODE_STEPS, POSFAC,                                     &
     &      IWPOS, IWPOSCB, IPTRLU,                                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA,                             &
     &      PTRIST, PTLUST_S, PTRFAC,                                   &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,      &
     &      IERROR, COMM,                                               &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                    &
     &      root, OPASSW, OPELIW, ITLOC, FILS,                          &
     &      PTRARW, PTRAIW,                                             &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,               &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
           IF (.NOT.RIGHT_MESS) RECURS = RECURS - 10
          IF ( IFLAG .LT. 0 ) RETURN
           IF (.NOT.RIGHT_MESS) THEN
              IF (ASS_IRECV .NE. AGMG_MPF_REQUEST_NULL) THEN
                CALL AGMG_MUMPS_ABORT()
              ENDIF
             CALL AGMG_MPF_IPROBE(MSGSOU,MSGTAG,                             &
     &           COMM, FLAGbis, STATUS, IERR)
             IF (FLAGbis) THEN
               MSGSOU_LOC = STATUS( AGMG_MPF_SOURCE )
               MSGTAG_LOC = STATUS( AGMG_MPF_TAG )
               CALL DAGMG_MUMPS_280( COMM_LOAD, ASS_IRECV,                   &
     &            STATUS, BUFR, LBUFR,                                  &
     &            LBUFR_BYTES,                                          &
     &            PROCNODE_STEPS, POSFAC,                               &
     &            IWPOS, IWPOSCB, IPTRLU,                               &
     &            LRLU, LRLUS, N, IW, LIW, A, LA,                       &
     &            PTRIST, PTLUST_S, PTRFAC,                             &
     &            PTRAST, STEP, PIMASTER, PAMASTER,                     &
     &            NSTK_S, COMP, IFLAG,                                  &
     &            IERROR, COMM,                                         &
     &            NBPROCFILS,                                           &
     &            IPOOL, LPOOL, LEAF,                                   &
     &            NBFIN, MYID, SLAVEF,                                  &
     &            root, OPASSW, OPELIW, ITLOC,                          &
     &            FILS, PTRARW, PTRAIW,                                 &
     &            INTARR, DBLARR, ICNTL,                                &
     &            KEEP,KEEP8, ND, FRERE,                                &
     &            LPTRAR, NELT, FRTPTR, FRTELT,                         &
     &            ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
                  IF ( IFLAG .LT. 0 ) RETURN
             ENDIF
           ENDIF
       ENDIF
      ELSE
         IF (BLOCKING) THEN
           CALL AGMG_NOCALL('MPI_PROBE')
           FLAG = .TRUE.
         ELSE
           CALL AGMG_MPF_IPROBE(AGMG_MPF_ANY_SOURCE,AGMG_MPF_ANY_TAG,                  &
     &           COMM, FLAG, STATUS, IERR)
         ENDIF
         IF (FLAG) THEN
          MSGSOU_LOC = STATUS( AGMG_MPF_SOURCE )
          MSGTAG_LOC = STATUS( AGMG_MPF_TAG )
          MESSAGE_RECEIVED = .TRUE.
          CALL DAGMG_MUMPS_280( COMM_LOAD, ASS_IRECV,                        &
     &      STATUS, BUFR, LBUFR,                                        &
     &      LBUFR_BYTES,                                                &
     &      PROCNODE_STEPS, POSFAC,                                     &
     &      IWPOS, IWPOSCB, IPTRLU,                                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA,                             &
     &      PTRIST, PTLUST_S, PTRFAC,                                   &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,      &
     &      IERROR, COMM,                                               &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                    &
     &      root, OPASSW, OPELIW, ITLOC,                                &
     &      FILS, PTRARW, PTRAIW,                                       &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,               &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
          IF ( IFLAG .LT. 0 ) RETURN
         ENDIF
      ENDIF
  250 CONTINUE
      RECURS  = RECURS - 1
      IF ( NBFIN .EQ. 0 ) RETURN
      IF ( RECURS .GT. 3 ) RETURN
      IF ( KEEP(36).EQ.1 .AND. SET_IRECV  .AND.                         &
     &      (ASS_IRECV.EQ.AGMG_MPF_REQUEST_NULL) .AND.                       &
     &    MESSAGE_RECEIVED ) THEN
       CALL AGMG_SETIERR( IERR )
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_329
      SUBROUTINE DAGMG_MUMPS_255( INFO1,                                     &
     &    ASS_IRECV,                                                    &
     &    BUFR, LBUFR, LBUFR_BYTES,                                     &
     &    COMM,                                                         &
     &    MYID, SLAVEF)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER ASS_IRECV
      INTEGER BUFR( LBUFR )
      INTEGER COMM
      INTEGER MYID, SLAVEF, INFO1, DEST
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      LOGICAL NO_ACTIVE_IRECV
      INTEGER LP, MSGSOU_LOC, MSGTAG_LOC
      INTEGER IERR, DUMMY
      INTRINSIC mod
      IF (SLAVEF .EQ. 1) RETURN
      IF (ASS_IRECV.EQ.AGMG_MPF_REQUEST_NULL) THEN
        NO_ACTIVE_IRECV=.TRUE.
      ELSE
        CALL AGMG_MPF_TEST(ASS_IRECV, NO_ACTIVE_IRECV,                       &
     &                STATUS, IERR)
      ENDIF
      CALL AGMG_SETIERR(IERR)
      DUMMY = 1
      DEST = mod(MYID+1, SLAVEF)
      CALL DAGMG_MUMPS_62                                                    &
     &    (DUMMY, DEST, TAG_DUMMY, COMM, IERR)
      IF (NO_ACTIVE_IRECV) THEN
        CALL AGMG_NOCALL('MPI_RECV')
      ELSE
        CALL AGMG_NOCALL('MPI_WAIT')
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_255
      SUBROUTINE DAGMG_MUMPS_180(                                            &
     &    INFO1, BUFR, LBUFR, LBUFR_BYTES,                              &
     &    COMM_NODES, COMM_LOAD, SLAVEF, MP )
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER COMM_NODES, COMM_LOAD, SLAVEF, INFO1, MP
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      LOGICAL FLAG, BUFFERS_EMPTY, BUFFERS_EMPTY_ON_ALL_PROCS
      INTEGER MSGSOU_LOC, MSGTAG_LOC, COMM_EFF
      INTEGER IERR, DUMMY
      INTEGER IBUF_EMPTY, IBUF_EMPTY_ON_ALL_PROCS
      IF (SLAVEF.EQ.1) RETURN
      BUFFERS_EMPTY_ON_ALL_PROCS = .FALSE.
   10 CONTINUE
      FLAG = .TRUE.
      DO WHILE ( FLAG )
        COMM_EFF = COMM_NODES
        CALL AGMG_MPF_IPROBE(AGMG_MPF_ANY_SOURCE,AGMG_MPF_ANY_TAG,                     &
     &       COMM_NODES, FLAG, STATUS, IERR)
        IF ( .NOT. FLAG ) THEN
          COMM_EFF = COMM_LOAD
          CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                 &
     &         COMM_LOAD, FLAG, STATUS, IERR)
        END IF
        IF (FLAG) THEN
            MSGSOU_LOC = STATUS( AGMG_MPF_SOURCE )
            MSGTAG_LOC = STATUS( AGMG_MPF_TAG )
               CALL AGMG_NOCALL('MPI_RECV')
           ENDIF
         END DO
        IF (BUFFERS_EMPTY_ON_ALL_PROCS) THEN
        RETURN
        ENDIF
        CALL DAGMG_MUMPS_469(BUFFERS_EMPTY)
        IF ( BUFFERS_EMPTY ) THEN
          IBUF_EMPTY = 0
        ELSE
          IBUF_EMPTY = 1
        ENDIF
        CALL AGMG_COPY(IBUF_EMPTY,                           IBUF_EMPTY_ON_ALL_PROCS,              1, AGMG_MPF_INTEGER, IERR)
        IF ( IBUF_EMPTY_ON_ALL_PROCS == 0) THEN
          BUFFERS_EMPTY_ON_ALL_PROCS = .TRUE.
        ELSE
          BUFFERS_EMPTY_ON_ALL_PROCS = .FALSE.
        ENDIF
        GOTO 10
      END SUBROUTINE DAGMG_MUMPS_180
      INTEGER FUNCTION DAGMG_MUMPS_748                                       &
     &     ( HBUF_SIZE, NNMAX, K227, K50 )
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: NNMAX, K227, K50
      INTEGER(8), INTENT(IN) :: HBUF_SIZE
      INTEGER K227_LOC
      INTEGER NBCOL_MAX
      INTEGER EFFECTIVE_SIZE
      NBCOL_MAX=int(HBUF_SIZE / int(NNMAX,8))
      K227_LOC = abs(K227)
      IF (K50.EQ.2) THEN
         K227_LOC=max(K227_LOC,2)
         EFFECTIVE_SIZE =  min(NBCOL_MAX-1, K227_LOC-1)
      ELSE
         EFFECTIVE_SIZE =  min(NBCOL_MAX, K227_LOC)
      ENDIF
      IF (EFFECTIVE_SIZE.LE.0) THEN
         write(6,*) 'Internal buffers too small to store ',             &
     &        ' ONE col/row of size', NNMAX
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      DAGMG_MUMPS_748 = EFFECTIVE_SIZE
      RETURN
      END FUNCTION DAGMG_MUMPS_748
      SUBROUTINE DAGMG_MUMPS_698( IPIV, LPIV, ISHIFT,                        &
     &     THE_PANEL, NBROW, NBCOL, KbeforePanel )
      IMPLICIT NONE
      INTEGER LPIV, ISHIFT, NBROW, NBCOL, KbeforePanel
      INTEGER IPIV(LPIV)
      DOUBLE PRECISION THE_PANEL(NBROW, NBCOL)
      INTEGER I, IPERM
      DO I = 1, LPIV
         IPERM=IPIV(I)
         IF ( I+ISHIFT.NE.IPERM) THEN
            CALL DSWAP(NBCOL,                                           &
     &           THE_PANEL(I+ISHIFT-KbeforePanel,1), NBROW,             &
     &           THE_PANEL(IPERM-KbeforePanel,1), NBROW)
         ENDIF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_698
      SUBROUTINE DAGMG_MUMPS_667(TYPEF,                                      &
     &     NBPANELS,                                                    &
     &     I_PIVPTR, I_PIV, IPOS, IW, LIW)
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER, intent(out) :: NBPANELS, I_PIVPTR, I_PIV
      INTEGER, intent(in) :: TYPEF
      INTEGER, intent(in) :: LIW, IPOS
      INTEGER IW(LIW)
      INTEGER I_NBPANELS, I_NASS
      I_NASS       = IPOS
      I_NBPANELS   = I_NASS + 1
      NBPANELS     = IW(I_NBPANELS)
      I_PIVPTR     = I_NBPANELS + 1
      I_PIV        = I_PIVPTR + NBPANELS
      IF (TYPEF==2) THEN
         I_NBPANELS   = I_PIV+IW(I_NASS)
         NBPANELS     = IW(I_NBPANELS)
         I_PIVPTR     = I_NBPANELS + 1
         I_PIV        = I_PIVPTR + NBPANELS
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_667
      SUBROUTINE DAGMG_MUMPS_691(K50,NBPANELS_L,NBPANELS_U,                  &
     &     NASS, IPOS, IW, LIW )
      IMPLICIT NONE
      INTEGER K50
      INTEGER IPOS, NASS, NBPANELS_L, NBPANELS_U, LIW
      INTEGER IW(LIW)
      INTEGER IPOS_U
      IF (K50.EQ.1) THEN
         WRITE(*,*) "Internal error: DAGMG_MUMPS_691 called"
      ENDIF
      IW(IPOS)=NASS
      IW(IPOS+1)=NBPANELS_L
      IW(IPOS+2:IPOS+1+NBPANELS_L)=NASS+1
      IF (K50 == 0) THEN
         IPOS_U=IPOS+2+NASS+NBPANELS_L
         IW(IPOS_U)=NBPANELS_U
         IW(IPOS_U+1:IPOS_U+NBPANELS_U)=NASS+1
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_691
      SUBROUTINE DAGMG_MUMPS_644(                                            &
     &     IWPOS, IOLDPS, IW, LIW, MonBloc, NFRONT, KEEP                &
     &     )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER, INTENT(IN)    :: IOLDPS, LIW, NFRONT,                    &
     &     KEEP(500)
      INTEGER, INTENT(INOUT) :: IWPOS, IW(LIW)
      TYPE(IO_BLOCK), INTENT(IN):: MonBloc
      INTEGER :: LREQ_OOC
      INTEGER :: NBPANELS_L,I_PIVRPTR_L, I_PIVR_L, NBPANELS_U,          &
     &     I_PIVRPTR_U, I_PIVR_U, XSIZE, IBEGOOC
      LOGICAL FREESPACE
      IF (KEEP(50).EQ.1) RETURN
      IF ((IOLDPS+IW(IOLDPS+XXI)).NE.IWPOS) RETURN
      XSIZE   = KEEP(IXSZ)
      IBEGOOC = IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE
      CALL DAGMG_MUMPS_667(TYPEF_L, NBPANELS_L,                              &
     &     I_PIVRPTR_L, I_PIVR_L,                                       &
     &     IBEGOOC, IW, LIW)
      FREESPACE =                                                       &
     &     (MonBloc%LastPiv.EQ.(IW(I_PIVRPTR_L)-1))
      IF (KEEP(50).EQ.0) THEN
         CALL DAGMG_MUMPS_667(TYPEF_U, NBPANELS_U,                           &
     &        I_PIVRPTR_U, I_PIVR_U,                                    &
     &        IBEGOOC, IW, LIW)
         FREESPACE =  FREESPACE .AND.                                   &
     &        (MonBloc%LastPiv.EQ.(IW(I_PIVRPTR_U)-1))
      ENDIF
      IF (FREESPACE) THEN
         IW(IBEGOOC) = -7777
         IW(IOLDPS+XXI) = IBEGOOC - IOLDPS + 1
         IWPOS = IBEGOOC+1
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_644
      SUBROUTINE DAGMG_MUMPS_684(K50, NBROW_L, NBCOL_U, NASS,                &
     &     NBPANELS_L, NBPANELS_U, LREQ)
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER, intent(IN)  :: K50, NBROW_L, NBCOL_U, NASS
      INTEGER, intent(OUT) :: NBPANELS_L, NBPANELS_U, LREQ
      NBPANELS_L=-99999
      NBPANELS_U=-99999
      IF (K50.EQ.1) THEN
         LREQ = 0
         RETURN
      ENDIF
      NBPANELS_L = (NASS / DAGMG_MUMPS_690(NBROW_L))+1
      LREQ =    1                                                       &
     &     + 1                                                          &
     &     + NASS                                                       &
     &     + NBPANELS_L
      IF (K50.eq.0) THEN
         NBPANELS_U = (NASS / DAGMG_MUMPS_690(NBCOL_U) ) +1
         LREQ = LREQ + 1                                                &
     &        + NASS                                                    &
     &        + NBPANELS_U
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_684
      SUBROUTINE DAGMG_MUMPS_755                                             &
     &           (IW_LOCATION, MUST_BE_PERMUTED)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: IW_LOCATION
      LOGICAL, INTENT(INOUT) :: MUST_BE_PERMUTED
      IF (IW_LOCATION .EQ. -7777) THEN
        MUST_BE_PERMUTED = .FALSE.
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_755
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_152(SSARBR, MYID, N, IPOSBLOCK,                 &
     &       RPOSBLOCK,                                                 &
     &       IW, LIW,                                                   &
     &       LRLU, LRLUS, IPTRLU,                                       &
     &       IWPOSCB, LA, KEEP, KEEP8, IN_PLACE_STATS                   &
     &     )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER(8) :: RPOSBLOCK
      INTEGER IPOSBLOCK,                                                &
     &         LIW, IWPOSCB, N
      INTEGER(8) :: LA, LRLU, LRLUS, IPTRLU
      LOGICAL IN_PLACE_STATS
      INTEGER IW( LIW ), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER MYID
      LOGICAL SSARBR
      INTEGER SIZFI_BLOCK, SIZFI
      INTEGER IPOSSHIFT
      INTEGER(8) :: SIZFR, SIZFR_BLOCK, SIZFR_BLOCK_EFF,                &
     &              SIZEHOLE, MEM_INC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IPOSSHIFT = IPOSBLOCK + KEEP(IXSZ)
      SIZFI_BLOCK=IW(IPOSBLOCK+XXI)
      CALL AGMG_MUMPS_729( SIZFR_BLOCK,IW(IPOSBLOCK+XXR) )
      IF (KEEP(216).eq.3) THEN
        SIZFR_BLOCK_EFF=SIZFR_BLOCK
      ELSE
        CALL DAGMG_MUMPS_628( IW(IPOSBLOCK),                                 &
     &                     LIW-IPOSBLOCK+1,                             &
     &                     SIZEHOLE, KEEP(IXSZ))
        SIZFR_BLOCK_EFF=SIZFR_BLOCK-SIZEHOLE
      ENDIF
      IF ( IPOSBLOCK .eq. IWPOSCB + 1 ) THEN
         IPTRLU  = IPTRLU  + SIZFR_BLOCK
         IWPOSCB = IWPOSCB + SIZFI_BLOCK
         LRLU    = LRLU  + SIZFR_BLOCK
         IF (.NOT. IN_PLACE_STATS) THEN
           LRLUS   = LRLUS + SIZFR_BLOCK_EFF
         ENDIF
      MEM_INC = -SIZFR_BLOCK_EFF
      IF (IN_PLACE_STATS) THEN
        MEM_INC= 0_8
      ENDIF
      CALL DAGMG_MUMPS_471(SSARBR,.FALSE.,                                   &
     &         LA-LRLUS,0_8,MEM_INC,KEEP,KEEP8,LRLU)
   90    IF ( IWPOSCB .eq. LIW ) GO TO 100
         IPOSSHIFT = IWPOSCB + KEEP(IXSZ)
         SIZFI = IW( IWPOSCB+1+XXI )
         CALL AGMG_MUMPS_729( SIZFR,IW(IWPOSCB+1+XXR) )
         IF ( IW( IWPOSCB+1+XXS ) .EQ. S_FREE ) THEN
              IPTRLU  = IPTRLU + SIZFR
              LRLU    = LRLU + SIZFR
              IWPOSCB = IWPOSCB + SIZFI
              GO TO 90
         ENDIF
  100    CONTINUE
         IW( IWPOSCB+1+XXP)=TOP_OF_STACK
      ELSE
         IW( IPOSBLOCK +XXS)=S_FREE
         IF (.NOT. IN_PLACE_STATS) LRLUS = LRLUS + SIZFR_BLOCK_EFF
      CALL DAGMG_MUMPS_471(SSARBR,.FALSE.,                                   &
     &            LA-LRLUS,0_8,-SIZFR_BLOCK_EFF,KEEP,KEEP8,LRLU)
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_152
      SUBROUTINE DAGMG_MUMPS_144( COMM_LOAD, ASS_IRECV,                      &
     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
     &           UU, NOFFW,                                             &
     &           NPVW,                                                  &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP, PIMASTER,    &
     &             PAMASTER,                                            &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
     &              DKEEP,PIVNUL_LIST,LPN_LIST)
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
      INTEGER(8) :: LA
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      DOUBLE PRECISION UU, SEUIL
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
      INTEGER LPTRAR, NELT
      INTEGER ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER NBFIN, SLAVEF,                                            &
     &        IFLAG, IERROR, LEAF, LPOOL
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB, COMP
      INTEGER FRTPTR( N + 1 ), FRTELT( NELT )
      INTEGER BUFR( LBUFR ), IPOOL(LPOOL),                              &
     &        ITLOC(N), FILS(N),                                        &
     &        PTRARW(LPTRAR), PTRAIW(LPTRAR),                           &
     &        ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER  INTARR(max(1,KEEP(14)))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N), PIMASTER(KEEP(28)),                              &
     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
     &        PROCNODE_STEPS(KEEP(28))
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      LOGICAL AVOID_DELAYED
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER INOPV, IFINB, NFRONT, NPIV, IBEGKJI, NBOLKJ,              &
     &        NBTLKJ, IBEG_BLOCK
      INTEGER(8) :: POSELT
      INTEGER NASS, NEL1, IEND, IOLDPS, dummy, allocok
      LOGICAL LASTBL
      DOUBLE PRECISION UUTEMP
      INTEGER , ALLOCATABLE, DIMENSION ( : ) :: IPIV
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, TYPEFile, LNextPiv2beWritten,              &
     &        UNextPiv2beWritten, IFLAG_OOC,                            &
     &        PP_FIRST2SWAP_L, PP_FIRST2SWAP_U,                         &
     &        PP_LastPIVRPTRFilled_L, PP_LastPIVRPTRFilled_U
      TYPE(IO_BLOCK) :: MonBloc
      LOGICAL LAST_CALL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      EXTERNAL DAGMG_MUMPS_224, DAGMG_MUMPS_233,                                  &
     &         DAGMG_MUMPS_225, DAGMG_MUMPS_232,                                  &
     &         DAGMG_MUMPS_294,                                              &
     &         DAGMG_MUMPS_44
      LOGICAL STATICMODE
      DOUBLE PRECISION SEUIL_LOC
      INOPV = 0
      SEUIL_LOC = SEUIL
      IF(KEEP(97) .EQ. 0) THEN
         STATICMODE = .FALSE.
      ELSE
         STATICMODE = .TRUE.
      ENDIF
      IF (AVOID_DELAYED) THEN
         STATICMODE = .TRUE.
         UUTEMP=UU
         SEUIL_LOC = max(SEUIL,epsilon(SEUIL))
      ELSE
         UUTEMP=UU
      ENDIF
      IBEG_BLOCK=1
      dummy  = 0
      IOLDPS = PTLUST_S(STEP( INODE ))
      POSELT = PTRAST(STEP( INODE ))
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      NASS   = iabs(IW(IOLDPS+2+KEEP(IXSZ)))
      IF (NASS .GT. KEEP(3)) THEN
        NBOLKJ = min( KEEP(6), NASS )
      ELSE
        NBOLKJ = min( KEEP(5),NASS )
      ENDIF
      NBTLKJ = NBOLKJ
      ALLOCATE( IPIV( NASS ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        WRITE(*,*) MYID,' : FACTO_NIV2 :failed to allocate ',NASS,      &
     & ' integers'
        IFLAG  = -13
        IERROR =NASS
        GO TO 490
      END IF
      IF (KEEP(201).EQ.1) THEN
          CALL AGMG_MUMPS_729(LAFAC,IW(IOLDPS+XXR))
          LIWFAC    = IW(IOLDPS+XXI)
          TYPEFile  = TYPEF_U
          LNextPiv2beWritten = 1
          UNextPiv2beWritten = 1
          PP_FIRST2SWAP_L = LNextPiv2beWritten
          PP_FIRST2SWAP_U = UNextPiv2beWritten
          MonBloc%LastPanelWritten_L = 0
          MonBloc%LastPanelWritten_U = 0
          MonBloc%INODE    = INODE
          MonBloc%MASTER   = .TRUE.
          MonBloc%Typenode = 2
          MonBloc%NROW     = NASS
          MonBloc%NCOL     = NFRONT
          MonBloc%NFS      = NASS
          MonBloc%Last     = .FALSE.
          MonBloc%LastPiv  = -68877
          NULLIFY(MonBloc%INDICES)
      ENDIF
   50 CONTINUE
      IBEGKJI = IBEG_BLOCK
      CALL DAGMG_MUMPS_224(NFRONT,NASS,IBEGKJI, NASS, IPIV,                  &
     &                N,INODE,IW,LIW,A,LA,INOPV,NOFFW,                  &
     &                IFLAG,IOLDPS,POSELT,UU,SEUIL_LOC,KEEP,KEEP8,      &
     &                 DKEEP(1),PIVNUL_LIST(1),LPN_LIST,                &
     &     PP_FIRST2SWAP_L,  MonBloc%LastPanelWritten_L,                &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U,  MonBloc%LastPanelWritten_U,                &
     &     PP_LastPIVRPTRFilled_U)
      IF (IFLAG.LT.0) GOTO 490
      IF (INOPV.EQ.1) THEN
         IF(STATICMODE) THEN
            INOPV = -1
            GOTO 50
         ENDIF
      ENDIF
      IF (INOPV.GE.1) THEN
          LASTBL = (INOPV.EQ.1)
          IEND = IW(IOLDPS+1+KEEP(IXSZ))
          CALL DAGMG_MUMPS_294( COMM_LOAD, ASS_IRECV,                        &
     &             N, INODE, FPERE, IW, LIW,                            &
     &             IOLDPS, POSELT, A, LA, NFRONT,                       &
     &             IBEGKJI, IEND, IPIV, NASS,LASTBL, dummy,             &
     &             COMM, MYID, BUFR, LBUFR, LBUFR_BYTES,NBFIN,LEAF,     &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
     &             PIMASTER, PAMASTER,                                  &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF ( IFLAG .LT. 0 ) GOTO 500
      ENDIF
      IF (INOPV.EQ.1) GO TO 500
      IF (INOPV.EQ.2) THEN
         CALL DAGMG_MUMPS_233(IBEG_BLOCK,NFRONT,NASS,N,INODE,IW,LIW,A,LA,    &
     &            IOLDPS,POSELT,NBOLKJ,NBTLKJ,KEEP(4),KEEP(IXSZ))
         GOTO 50
      ENDIF
      NPVW = NPVW + 1
      IF (NASS.LE.1) THEN
        IFINB = -1
      ELSE
         CALL DAGMG_MUMPS_225(IBEG_BLOCK,                                    &
     &             NFRONT, NASS, N,INODE,IW,LIW,A,LA,                   &
     &             IOLDPS,POSELT,IFINB,                                 &
     &             NBTLKJ,KEEP(4),KEEP(IXSZ))
      ENDIF
      IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + 1
       IF (IFINB.EQ.0) GOTO 50
       IF ((IFINB.EQ.1).OR.(IFINB.EQ.-1)) THEN
          LASTBL = (IFINB.EQ.-1)
          IEND = IW(IOLDPS+1+KEEP(IXSZ))
          CALL DAGMG_MUMPS_294(COMM_LOAD, ASS_IRECV,                         &
     &             N, INODE, FPERE, IW, LIW,                            &
     &             IOLDPS, POSELT, A, LA, NFRONT,                       &
     &             IBEGKJI, IEND, IPIV, NASS, LASTBL, dummy,            &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC,                    &
     &             STEP, PIMASTER, PAMASTER,                            &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF ( IFLAG .LT. 0 ) GOTO 500
       ENDIF
       IF (IFINB.EQ.(-1)) GOTO 500
       NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
       NEL1   = NASS - NPIV
      CALL DAGMG_MUMPS_232(A,LA,                                             &
     &           NFRONT,NPIV,NASS,POSELT,NBTLKJ)
      IF (KEEP(201).EQ.1) THEN
          STRAT            = STRAT_TRY_WRITE
          MonBloc%LastPiv  = NPIV
          TYPEFile         = TYPEF_BOTH_LU
          LAST_CALL= .FALSE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           LNextPiv2beWritten, UNextPiv2beWritten,                &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
          IF (IFLAG<0) RETURN
      ENDIF
      GO TO 50
  490 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      DEALLOCATE( IPIV )
      IF (KEEP(201).EQ.1) THEN
          STRAT        = STRAT_WRITE_MAX
          MonBloc%Last = .TRUE.
          MonBloc%LastPiv  = IW(IOLDPS+1+KEEP(IXSZ))
          TYPEFile     = TYPEF_BOTH_LU
          LAST_CALL = .TRUE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           LNextPiv2beWritten, UNextPiv2beWritten,                &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
          IF (IFLAG<0) RETURN
          CALL DAGMG_MUMPS_644(IWPOS,                                        &
     &      IOLDPS, IW, LIW, MonBloc , NFRONT, KEEP)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_144
      SUBROUTINE DAGMG_MUMPS_176( COMM_LOAD, ASS_IRECV,                      &
     &    root, FRERE, IROOT,                                           &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND,                        &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER IROOT
      INTEGER ICNTL( 40 ), KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: POSFAC,IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB
      INTEGER(8) :: LA
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S( KEEP(28) ), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM
      INTEGER LPTRAR, NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER MYID, SLAVEF, NBFIN
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND(KEEP(28)), FRERE(KEEP(28))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      INTEGER NELIM, NB_CONTRI_GLOBAL, NUMORG,                          &
     &        NFRONT, IROW, JCOL, PDEST, HF, IOLDPS,                    &
     &        IN, DEB_ROW, ILOC_ROW, IFSON, ILOC_COL,                   &
     &        IPOS_SON, NELIM_SON, NSLAVES_SON, HS,                     &
     &        IROW_SON, ICOL_SON, ISLAVE, IERR,                         &
     &        NELIM_SENT, IPOS_STATREC
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      NB_CONTRI_GLOBAL = KEEP(41)
      NUMORG    = root%ROOT_SIZE
      NELIM     = KEEP(42)
      NFRONT    = NUMORG + KEEP(42)
      DO IROW = 0, root%NPROW - 1
        DO JCOL = 0, root%NPCOL - 1
            PDEST = IROW * root%NPCOL + JCOL
          IF ( PDEST .NE. MYID ) THEN
           CALL DAGMG_MUMPS_73(NFRONT,                                       &
     &     NB_CONTRI_GLOBAL, PDEST, COMM, IERR)
              if (IERR.lt.0) then
                write(6,*) ' error detected by ',                       &
     &          'DMUMPS_73'
                CALL AGMG_MUMPS_ABORT()
               endif
           ENDIF
        END DO
      END DO
      CALL  DAGMG_MUMPS_270( NFRONT,                                         &
     &    NB_CONTRI_GLOBAL, root,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM, COMM_LOAD,                               &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND )
       IF (IFLAG < 0 ) RETURN
      HF = 6 + KEEP(IXSZ)
      IOLDPS = PTLUST_S(STEP(IROOT))
      IN = IROOT
      DEB_ROW = IOLDPS + HF
      ILOC_ROW    = DEB_ROW
      DO WHILE (IN.GT.0)
       IW(ILOC_ROW)           = IN
       IW(ILOC_ROW+NFRONT)    = IN
       ILOC_ROW = ILOC_ROW + 1
       IN = FILS(IN)
      END DO
      IFSON = -IN
      ILOC_ROW    = IOLDPS + HF + NUMORG
      ILOC_COL    = ILOC_ROW + NFRONT
      IF ( NELIM.GT.0 ) THEN
        IN = IFSON
        DO WHILE (IN.GT.0)
          IPOS_SON  = PIMASTER(STEP(IN))
          IF (IPOS_SON .EQ. 0) GOTO 100
          NELIM_SON   = IW(IPOS_SON+1+KEEP(IXSZ))
              if (NELIM_SON.eq.0) then
                write(6,*) ' error 1 in process_last_rtnelind'
                CALL AGMG_MUMPS_ABORT()
              endif
          NSLAVES_SON = IW(IPOS_SON+5+KEEP(IXSZ))
          HS          = 6 + NSLAVES_SON + KEEP(IXSZ)
          IROW_SON    = IPOS_SON + HS
          ICOL_SON    = IROW_SON + NELIM_SON
          IW(ILOC_ROW:ILOC_ROW+NELIM_SON-1) =                           &
     &            IW(IROW_SON:IROW_SON+NELIM_SON-1)
          IW(ILOC_COL:ILOC_COL+NELIM_SON-1) =                           &
     &            IW(ICOL_SON:ICOL_SON+NELIM_SON-1)
          NELIM_SENT = ILOC_ROW - IOLDPS - HF + 1
          DO ISLAVE = 0,NSLAVES_SON
            IF (ISLAVE.EQ.0) THEN
             PDEST= AGMG_MUMPS_275(STEP(IN),PROCNODE_STEPS,SLAVEF)
            ELSE
             PDEST = IW(IPOS_SON + 5 + ISLAVE+KEEP(IXSZ))
            ENDIF
            IF (PDEST.NE.MYID) THEN
             CALL DAGMG_MUMPS_74(IN, NELIM_SENT,                             &
     &        PDEST, COMM, IERR )
               if (IERR.lt.0) then
                write(6,*) ' error detected by ',                       &
     &          'DMUMPS_73'
                CALL AGMG_MUMPS_ABORT()
               endif
            ELSE
             CALL DAGMG_MUMPS_271( COMM_LOAD, ASS_IRECV,                     &
     &       IN, NELIM_SENT, root,                                      &
     &       BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,          &
     &       IWPOS, IWPOSCB, IPTRLU,                                    &
     &       LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                    &
     &       PTLUST_S, PTRFAC,                                          &
     &       PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,            &
     &       IFLAG, IERROR, COMM,                                       &
     &       NBPROCFILS,                                                &
     &       IPOOL, LPOOL, LEAF,                                        &
     &       NBFIN, MYID, SLAVEF,                                       &
     &       OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,               &
     &       INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,              &
     &       LPTRAR, NELT, FRTPTR, FRTELT,                              &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
             IF ( ISLAVE .NE. 0 ) THEN
               IF (KEEP(50) .EQ. 0) THEN
                IPOS_STATREC = PTRIST(STEP(IN))+6+KEEP(IXSZ)
               ELSE
                IPOS_STATREC = PTRIST(STEP(IN))+8+KEEP(IXSZ)
               ENDIF
               IF (IW(IPOS_STATREC).EQ. S_REC_CONTSTATIC) THEN
                  IW(IPOS_STATREC) = S_ROOT2SON_CALLED
               ELSE
                CALL DAGMG_MUMPS_626( N, IN, PTRIST, PTRAST,                 &
     &          IW, LIW, A, LA, LRLU, LRLUS, IWPOSCB,                   &
     &          IPTRLU, STEP, MYID, KEEP                                &
     &        )
               ENDIF
             ENDIF
             IPOS_SON  = PIMASTER(STEP(IN))
            ENDIF
          END DO
          CALL  DAGMG_MUMPS_152( .FALSE.,MYID,N, IPOS_SON,                   &
     &       PTRAST(STEP(IN)),                                          &
     &       IW, LIW,                                                   &
     &       LRLU, LRLUS, IPTRLU,                                       &
     &       IWPOSCB, LA, KEEP,KEEP8, .FALSE.                           &
     &         )
          ILOC_ROW = ILOC_ROW + NELIM_SON
          ILOC_COL = ILOC_COL + NELIM_SON
  100     CONTINUE
          IN = FRERE(STEP(IN))
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_176
      SUBROUTINE DAGMG_MUMPS_268(MYID,BUFR, LBUFR,                           &
     &     LBUFR_BYTES,                                                 &
     &     PROCNODE_STEPS, SLAVEF,                                      &
     &     IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS,                         &
     &     N, IW, LIW, A, LA,                                           &
     &     PTRIST, PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S,            &
     &     COMP,                                                        &
     &     IFLAG, IERROR, COMM, COMM_LOAD, NBPROCFILS,                  &
     &     IPOOL, LPOOL, LEAF, KEEP,KEEP8, ND, FILS, FRERE, ITLOC,      &
     &     ISTEP_TO_INIV2, TAB_POS_IN_PERE )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR
      INTEGER MYID
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER SLAVEF
      INTEGER(8) :: IPTRLU, LRLU, LRLUS, LA
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), STEP(N), PIMASTER(KEEP(28))
      INTEGER PROCNODE_STEPS( KEEP(28) ), ITLOC( N )
      INTEGER COMP
      INTEGER NSTK_S( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM, COMM_LOAD
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER ND(KEEP(28)), FILS( N ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER POSITION, IFATH, ISON, NROW, NCOL, NELIM,                 &
     &        NSLAVES
      INTEGER(8) :: NOREAL
      INTEGER NOINT, INIV2, NCOL_EFF
      DOUBLE PRECISION FLOP1
      INTEGER NBROWS_ALREADY_SENT, NBROWS_PACKET
      INTEGER NOREAL_PACKET
      LOGICAL PERETYPE2
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER  AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_330
      POSITION = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      IF ( NSLAVES .NE. 0 .and. KEEP(50).ne.0 ) THEN
        NCOL_EFF = NROW
      ELSE
        NCOL_EFF = NCOL
      ENDIF
      NOREAL_PACKET = NBROWS_PACKET * NCOL_EFF
      IF (NBROWS_ALREADY_SENT .EQ. 0) THEN
        NOINT = 6 + NROW + NCOL + NSLAVES + KEEP(IXSZ)
        NOREAL= int(NROW,8) * int(NCOL_EFF,8)
        CALL DAGMG_MUMPS_22(.FALSE.,0_8,.FALSE.,.FALSE.,                     &
     &   MYID,N,KEEP,KEEP8,IW,LIW,A,LA,                                 &
     &   LRLU, IPTRLU,IWPOS,IWPOSCB,                                    &
     &   PTRIST,PTRAST,STEP, PIMASTER, PAMASTER, ITLOC,                 &
     &   NOINT, NOREAL, ISON, S_NOTFREE, .TRUE.,                        &
     &   COMP, LRLUS, IFLAG, IERROR                                     &
     &     )
        IF ( IFLAG .LT. 0 ) THEN
          RETURN
        ENDIF
        PIMASTER(STEP( ISON )) = IWPOSCB + 1
        PAMASTER(STEP( ISON )) = IPTRLU  + 1_8
        IW( IWPOSCB + 1 + KEEP(IXSZ) ) = NCOL
        NELIM = NROW
        IW( IWPOSCB + 2 + KEEP(IXSZ) ) = NELIM
        IW( IWPOSCB + 3 + KEEP(IXSZ) ) = NROW
        IF ( NSLAVES .NE. 0 .and. KEEP(50).ne.0 ) THEN
          IW( IWPOSCB + 4 + KEEP(IXSZ) ) = NROW - NCOL
          IF ( NROW - NCOL .GE. 0 ) THEN
            WRITE(*,*) 'Error in PROCESS_MAITRE2:',NROW,NCOL
            CALL AGMG_MUMPS_ABORT()
          END IF
        ELSE
          IW( IWPOSCB + 4 + KEEP(IXSZ) ) = 0
        END IF
        IW( IWPOSCB + 5 + KEEP(IXSZ) ) = 1
        IW( IWPOSCB + 6 + KEEP(IXSZ) ) = NSLAVES
        IF (NSLAVES.GT.0) THEN
         CALL AGMG_NOCALL('MPI_UNPACK')
        ENDIF
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        IF ( ( KEEP(48).NE. 0 ).AND.(NSLAVES .GT. 0 )) THEN
          INIV2 = ISTEP_TO_INIV2 ( STEP(ISON) )
          CALL AGMG_NOCALL('MPI_UNPACK')
          TAB_POS_IN_PERE(SLAVEF+2,INIV2) = NSLAVES
        ENDIF
      ENDIF
      IF (NOREAL_PACKET.GT.0) THEN
        CALL AGMG_NOCALL('MPI_UNPACK')
      ENDIF
      IF ( NBROWS_ALREADY_SENT + NBROWS_PACKET .EQ. NROW ) THEN
        PERETYPE2 = ( AGMG_MUMPS_330(STEP(IFATH),PROCNODE_STEPS,             &
     &              SLAVEF) .EQ. 2 )
        NSTK_S( STEP(IFATH ))       = NSTK_S( STEP(IFATH) ) - 1
        IF ( NSTK_S( STEP(IFATH)) .EQ. 0 ) THEN
          CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL, PROCNODE_STEPS,              &
     &         SLAVEF, KEEP(28), KEEP(76), KEEP(80), KEEP(47),          &
     &         STEP, IFATH )
          IF (KEEP(47) .GE. 3) THEN
             CALL DAGMG_MUMPS_500(                                           &
     &            IPOOL, LPOOL,                                         &
     &            PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,        &
     &            MYID, STEP, N, ND, FILS )
          ENDIF
          CALL AGMG_MUMPS_137( IFATH, N, PROCNODE_STEPS,                     &
     &                            SLAVEF, ND,                           &
     &                            FILS,FRERE, STEP, PIMASTER,           &
     &                            KEEP(28), KEEP(50),                   &
     &                            FLOP1,IW, LIW, KEEP(IXSZ) )
          IF (IFATH.NE.KEEP(20))                                        &
     &    CALL DAGMG_MUMPS_190(1, .FALSE., FLOP1, KEEP,KEEP8)
        END IF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_268
      SUBROUTINE DAGMG_MUMPS_242(DATA, LDATA, MPITYPE, ROOT, COMMW, TAG,     &
     &SLAVEF)
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR
      INTEGER LDATA, ROOT, COMMW, TAG, MPITYPE, SLAVEF
      INTEGER DEST
      INTEGER DATA(LDATA)
      DO 10 DEST = 0, SLAVEF - 1
        IF (DEST .NE. ROOT) THEN
          IF ( LDATA .EQ. 1 .and. MPITYPE .EQ. AGMG_MPF_INTEGER ) THEN
            CALL DAGMG_MUMPS_62( DATA(1), DEST, TAG,                         &
     &                                COMMW, IERR )
          ELSE
            WRITE(*,*) 'Error : bad argument to DMUMPS_242'
            CALL AGMG_MUMPS_ABORT()
          END IF
        ENDIF
   10 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_242
      SUBROUTINE DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      INTEGER MYID, SLAVEF, COMM
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER DUMMY (1)
      CALL DAGMG_MUMPS_242( DUMMY, 1, AGMG_MPF_INTEGER, MYID,                     &
     &                 COMM, TERREUR, SLAVEF )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_44
      SUBROUTINE DAGMG_MUMPS_464( K34, K35, K16, K10 )
      IMPLICIT NONE
      INTEGER, INTENT(OUT) :: K34, K35, K10, K16
      INTEGER*4 SIZE_INT, SIZE_REAL_OR_DOUBLE
      INTEGER I(2)
      DOUBLE PRECISION R(2)
      !CALL AGMG_MUMPS_SIZE_C(I(1),I(2),SIZE_INT)
      !CALL AGMG_MUMPS_SIZE_C(R(1),R(2),SIZE_REAL_OR_DOUBLE)
          IF (HUGE(I(1)) > 1.0e10) THEN
             SIZE_INT=8
          ELSE
             SIZE_INT=4
          END IF
      K34 = SIZE_INT
      K10 = 8 / K34
      K16 = 8
      K35 = K16
      RETURN
      END SUBROUTINE DAGMG_MUMPS_464
      SUBROUTINE DAGMG_MUMPS_20( NPROCS, LWK_USER, CNTL, ICNTL,              &
     &                    KEEP,KEEP8,                                   &
     &                    INFO, INFOG, RINFO, RINFOG, SYM, PAR,         &
     &                    DKEEP)
      IMPLICIT NONE
      DOUBLE PRECISION    DKEEP(30)
      DOUBLE PRECISION    CNTL(15), RINFO(20), RINFOG(20)
      INTEGER ICNTL(40), KEEP(500), SYM, PAR, NPROCS
      INTEGER INFO(40), INFOG(40)
      INTEGER*8 KEEP8(150)
      INTEGER LWK_USER
!     Let $A_{preproc}$ be the preprocessed matrix to be factored (see
      LWK_USER = 0
      KEEP(1:500) = 0
      KEEP8(1:150)= 0_8
      INFO(1:40)  = 0
      INFOG(1:40) = 0
      ICNTL(1:40) = 0
      RINFO(1:20) = 0.0D0
      RINFOG(1:20)= 0.0D0
      CNTL(1:15)  = 0.0D0
      DKEEP(1:30) = 0.0D0
      KEEP( 50 ) = SYM
      IF ( KEEP(50).NE.1 .and. KEEP(50).NE.2 ) KEEP( 50 ) = 0
      IF ( KEEP(50) .NE. 1 ) THEN
        CNTL(1)   = 0.01D0
      ELSE
        CNTL(1)   = 0.0D0
      END IF
      CNTL(2) = sqrt(epsilon(0.0D0))
      CNTL(3) = 0.0D0
      CNTL(4) = -1.0D0
      CNTL(5) = 0.0D0
      CNTL(6) = -1.0D0
      KEEP(46) = PAR
      IF ( KEEP(46) .NE. 0 .AND.                                        &
     &     KEEP(46) .NE. 1 ) THEN
           KEEP(46) = 1
      END IF
      ICNTL(1)  = 6
      ICNTL(2)  = 0
      ICNTL(3)  = 6
      ICNTL(4)  = 2
      ICNTL(5)  = 0
      IF (SYM.NE.1) THEN
       ICNTL(6)  = 7
      ELSE
       ICNTL(6)  = 0
      ENDIF
      ICNTL(7) = 7
      ICNTL(8)  = 77
      ICNTL(9)  = 1
      ICNTL(10)  = 0
      ICNTL(11)  = 0
      IF(SYM .EQ. 2) THEN
         ICNTL(12)  = 0
      ELSE
         ICNTL(12)  = 1
      ENDIF
      ICNTL(13) = 0
      IF (SYM.eq.1.AND.NPROCS.EQ.1) THEN
        ICNTL(14) = 5
      ELSE IF (NPROCS .GT. 4) THEN
        ICNTL(14) = 30
      ELSE
        ICNTL(14) = 20
      END IF
      ICNTL(15) = 0
      ICNTL(16) = 0
      ICNTL(17) = 0
      ICNTL(18) = 0
      ICNTL(19) = 0
      ICNTL(20) = 0
      ICNTL(21) = 0
      ICNTL(22) = 0
      ICNTL(23) = 0
      ICNTL(24) = 0
      ICNTL(27) = -8
      ICNTL(28) = 1
      ICNTL(29) = 0
      ICNTL(39) = 1
      ICNTL(40)  = 0
      KEEP(12) = 0
      KEEP(11) = 2147483646
      KEEP(24) = 18
      KEEP(68) = 0
      KEEP(36) = 1
      KEEP(1) = 8
      KEEP(7)  = 150
      KEEP(8)  = 120
      KEEP(57) = 500
      KEEP(58) = 250
      IF ( SYM .eq. 0 ) THEN
        KEEP(4)  = 32
        KEEP(3)  = 96
        KEEP(5)  = 16
        KEEP(6)  = 32
        KEEP(9)  = 700
        KEEP(85) =  300
        KEEP(62) =  50
        IF (NPROCS.GE.128) KEEP(62)=200
        IF (NPROCS.GE.128) KEEP(9)=800
        IF (NPROCS.GE.256) KEEP(9)=900
      ELSE
        KEEP(4)  = 24
        KEEP(3)  = 96
        KEEP(5)  = 16
        KEEP(6)  = 48
        KEEP(9)  = 400
        KEEP(85) = 100
        KEEP(62) = 100
        IF (NPROCS.GE.128) KEEP(62)=150
        IF (NPROCS.GE.64) KEEP(9)=800
        IF (NPROCS.GE.128) KEEP(9)=900
      END IF
      KEEP(63) = 60
      KEEP(48) = 5
      KEEP(17) = 0
      CALL DAGMG_MUMPS_464( KEEP(34), KEEP(35),                              &
     &                            KEEP(16), KEEP(10) )
      KEEP(37) = max(800, 2*NPROCS)
      IF ( NPROCS > 256 ) THEN
        KEEP(39) = 10000
      ELSEIF ( NPROCS > 128 ) THEN
        KEEP(39) = 20000
      ELSEIF ( NPROCS > 64 ) THEN
        KEEP(39) = 40000
      ELSEIF ( NPROCS > 16 ) THEN
        KEEP(39) = 80000
      ELSE
        KEEP(39) = 160000
      END IF
      KEEP(40) = -1 - 456789
      KEEP(45) = 0
      KEEP(47) = 2
      KEEP( 51 )  = 48
      KEEP(64) = 10
      KEEP(69) = 4
      KEEP(75) = 1
      KEEP(76) = 2
      KEEP(77) = 30
      IF (NPROCS.GT.4) THEN
          KEEP(78)=max(                                                 &
     &       int(log(dble(NPROCS))/log(dble(2))) - 2                    &
     &       , 0         )
      ENDIF
      KEEP(210) = 2
      KEEP8(79) = -10_8
      KEEP(80) = 1
      KEEP(81) = 0
      KEEP(82) = 5
      KEEP(83) = min(8,NPROCS/4)
      KEEP(83) = max(min(4,NPROCS),max(KEEP(83),1))
      KEEP(86)=1
      KEEP(87)=0
      KEEP(88)=0
      KEEP(90)=1
      KEEP(91)=min(8, NPROCS)
      KEEP(91) = max(min(4,NPROCS),min(KEEP(83),KEEP(91)))
      IF(NPROCS.LT.48)THEN
         KEEP(102)=150
      ELSEIF(NPROCS.LT.128)THEN
         KEEP(102)=150
      ELSEIF(NPROCS.LT.256)THEN
         KEEP(102)=200
      ELSEIF(NPROCS.LT.512)THEN
         KEEP(102)=300
      ELSEIF(NPROCS.GE.512)THEN
         KEEP(102)=400
      ENDIF
      KEEP(99)=4
      KEEP(100)=0
      KEEP(204)=0
      KEEP(205)=0
      KEEP(209)=-1
      KEEP(104) = 16
      KEEP(107)=0
      KEEP(211)=2
      KEEP(213)=201
      KEEP(217)=0
      KEEP(215)=0
      KEEP(216)=1
      KEEP(218)=50
      KEEP(219)=1
      IF (KEEP(50).EQ.2) THEN
        KEEP(227)= max(2,32)
      ELSE
        KEEP(227)= max(1,32)
      ENDIF
      KEEP(231) = 1
      KEEP(232) = 3
      KEEP(233) = 0
      KEEP(239) = 1
      KEEP(240) = 10
      KEEP(241) = 0
      DKEEP(4) = -1.0D0
      DKEEP(5) = -1.0D0
      IF(NPROCS.LE.8)THEN
         KEEP(238)=12
      ELSE
         KEEP(238)=7
      ENDIF
      KEEP(234)= 1
      DKEEP(3)=-5.0D0
      KEEP(244) = ICNTL(28)
      KEEP(245) = ICNTL(29)
      KEEP(250) = 1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_20
      SUBROUTINE DAGMG_MUMPS_195(N, NZ, IRN, ICN, LIW, IKEEP, PTRAR,         &
     &     IORD, NFSIZ, FILS, FRERE, LISTVAR_SCHUR, SIZE_SCHUR,         &
     &     ICNTL, INFO, KEEP,KEEP8, NSLAVES, SYM, PIV, id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTEGER N,NZ,LIW,IORD,SIZE_SCHUR, NSLAVES, SYM
      INTEGER PTRAR(N,4), NFSIZ(N), FILS(N), FRERE(N)
      INTEGER IKEEP(N,3)
      INTEGER  LISTVAR_SCHUR(SIZE_SCHUR)
      INTEGER INFO(40), ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER IRN(NZ), ICN(NZ)
      INTEGER, DIMENSION(:), ALLOCATABLE :: IW
      INTEGER IERR
      INTEGER K,I,L1,L2,IWFR,NCMPA,LLIW, IN, IFSON
      INTEGER NEMIN, LP, MP, LDIAG, ITEMP, symmetry
      INTEGER MedDens, NBQD, AvgDens
      LOGICAL PROK, COMPRESS_SCHUR
      INTEGER NBBUCK
      INTEGER, DIMENSION(:), ALLOCATABLE :: HEAD
      INTEGER NUMFLAG
      INTEGER OPT_METIS_SIZE
      INTEGER, DIMENSION(:), ALLOCATABLE :: OPTIONS_METIS
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: COLSCA_TEMP
      INTEGER THRESH, IVersion
      LOGICAL AGG6
      INTEGER MINSYM
      PARAMETER (MINSYM=50)
      INTEGER(8) :: K79REF
      PARAMETER(K79REF=12000000_8)
      INTEGER PIV(N)
      INTEGER MTRANS, COMPRESS,NCMP,IERROR,J,JPERM,NCST
      INTEGER TOTEL
      LOGICAL IDENT,SPLITROOT
      EXTERNAL AGMG_MUMPS_197, DAGMG_MUMPS_198,                                   &
     &     DAGMG_MUMPS_199, DAGMG_MUMPS_351,                                      &
     &     DAGMG_MUMPS_557, DAGMG_MUMPS_201
      EXTERNAL DAGMG_MUMPS_623
      EXTERNAL DAGMG_MUMPS_547, DAGMG_MUMPS_550,                                  &
     &     DAGMG_MUMPS_556
      ALLOCATE( IW ( LIW ), stat = IERR )
      IF ( IERR .GT. 0 ) THEN
         INFO( 1 ) = -7
         INFO( 2 ) = LIW
         RETURN
      ENDIF
      LLIW = LIW - 2*N - 1
      L1 = LLIW + 1
      L2 = L1 + N
      LP    = ICNTL(1)
      MP    = ICNTL(3)
      PROK  = (MP.GT.0)
      LDIAG = ICNTL(4)
      COMPRESS_SCHUR = .FALSE.
      IF (KEEP(1).LT.0) KEEP(1) = 0
      NEMIN = KEEP(1)
      IF (LDIAG.GT.2 .AND. MP.GT.0) THEN
         WRITE (MP,99999) N, NZ, LIW, INFO(1)
         K = min0(10,NZ)
         IF (LDIAG.EQ.4) K = NZ
         IF (K.GT.0) WRITE (MP,99998) (IRN(I),ICN(I),I=1,K)
         K = min0(10,N)
         IF (LDIAG.EQ.4) K = N
         IF (IORD.EQ.1 .AND. K.GT.0) THEN
            WRITE (MP,99997) (IKEEP(I,1),I=1,K)
         ENDIF
      ENDIF
      NCMP    = N
      IF (KEEP(60).NE.0) THEN
         IF ((SIZE_SCHUR.LE.0 ).OR.                                     &
     &        (SIZE_SCHUR.GE.N) ) GOTO 90
      ENDIF
         CALL DAGMG_MUMPS_351(N,NZ,IRN, ICN, IW(1), LLIW,                    &
     &        IW(L2), PTRAR(1,2),                                       &
     &        PTRAR, IW(L1), IWFR, KEEP(113), KEEP(114),                &
     &        INFO(1), INFO(2), ICNTL, symmetry,                        &
     &        SYM, MedDens, NBQD, AvgDens)
      INFO(8) = symmetry
      IF(NBQD .GT. 0) THEN
         IF( KEEP(50) .EQ. 2 .AND. ICNTL(12) .LE. 1 ) THEN
            IF(KEEP(95) .NE. 1) THEN
               IF ( PROK )                                              &
     &              WRITE( MP,*)                                        &
     &              'Compressed/constrained ordering set OFF'
               KEEP(95) = 1
            ENDIF
         ENDIF
      ENDIF
      IF ( (KEEP(60).NE.0) .AND. (IORD.GT.1) .AND.                      &
     &     .NOT. COMPRESS_SCHUR ) THEN
         IORD = 0
      ENDIF
      CALL DAGMG_MUMPS_701( N, SYM, NSLAVES, IORD,                           &
     &     symmetry, MedDens, NBQD, AvgDens,                            &
     &     PROK, MP )
      IF(SYM .EQ. 2) THEN
         IF(KEEP(95) .EQ. 3 .AND. IORD .NE. 2) THEN
            IF (PROK) WRITE(MP,*)                                       &
     &           'WARNING: ANAL_F constrained ordering not available ', &
     &           'with selected ordering'
            KEEP(95) = 2
         ENDIF
         IF(KEEP(95) .EQ. 2 .AND. IORD .EQ. 0) THEN
            IF (PROK) WRITE(MP,*)                                       &
     &           'WARNING: ANAL_F AMD not available with ',             &
     &           'compressed ordering -> move to QAMD'
            IORD = 6
         ENDIF
      ELSE
         KEEP(95) = 1
      ENDIF
      MTRANS = KEEP(23)
      COMPRESS = KEEP(95) - 1
      IF(COMPRESS .GT. 0 .AND. KEEP(52) .EQ. -2) THEN
         IF(id%CNTL(4) .GE. 0.0D0) THEN
            IF (KEEP(1).LE.8) THEN
               NEMIN = 16
            ELSE
               NEMIN = 2*KEEP(1)
            ENDIF
            IF (PROK)                                                   &
     &           WRITE(MP,*) 'Setting static pivoting ON, COMPRESS =',  &
     &           COMPRESS
         ENDIF
      ENDIF
      IF(MTRANS .GT. 0 .AND. KEEP(50) .EQ. 2) THEN
         KEEP(23) = 0
      ENDIF
      IF(COMPRESS .EQ. 2) THEN
         IF (IORD.NE.2) THEN
            WRITE(*,*) "IORD not compatible with COMPRESS:",            &
     &           IORD, COMPRESS
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         CALL  DAGMG_MUMPS_556(                                              &
     &        N,PIV,FRERE,FILS,NFSIZ,IKEEP,                             &
     &        NCST,KEEP,KEEP8,id)
      ENDIF
      IF ( IORD .NE. 1 ) THEN
         IF(COMPRESS .GE. 1) THEN
            CALL DAGMG_MUMPS_547(                                            &
     &           N,NZ, IRN, ICN, PIV,                                   &
     &           NCMP, IW(1), LLIW, IW(L2),PTRAR(1,2),PTRAR,            &
     &           IW(L1), FILS, IWFR,                                    &
     &           IERROR, KEEP,KEEP8, ICNTL)
            symmetry = 100
         ENDIF
         IF ( (symmetry.LT.MINSYM).AND.(SYM.EQ.0) ) THEN
            IF(KEEP(23) .EQ. 7 ) THEN
               KEEP(23) = -5
               DEALLOCATE (IW)
               RETURN
            ELSE IF(KEEP(23) .EQ. -9876543) THEN
               IDENT = .TRUE.
               KEEP(23) = 5
               IF (PROK) WRITE(MP,'(A)')                                &
     &              ' ... Apply column permutation (already computed)'
               DO J=1,N
                  JPERM = PIV(J)
                  FILS(JPERM) = J
                  IF (JPERM.NE.J) IDENT = .FALSE.
               ENDDO
               IF (.NOT.IDENT) THEN
                  DO K=1,NZ
                     J = ICN(K)
                     IF ((J.LE.0).OR.(J.GT.N)) CYCLE
                     ICN(K) = FILS(J)
                  ENDDO
                  ALLOCATE(COLSCA_TEMP(N), stat=IERR)
                  IF ( IERR > 0 ) THEN
                     INFO( 1 ) = -7
                     INFO( 2 ) = LIW
                     RETURN
                  ENDIF
                  DO J = 1, N
                     COLSCA_TEMP(J)=id%COLSCA(J)
                  ENDDO
                  DO J=1, N
                     id%COLSCA(FILS(J))=COLSCA_TEMP(J)
                  ENDDO
                  DEALLOCATE(COLSCA_TEMP)
                  IF (MP.GT.0 .AND. ICNTL(4).GE.2)                      &
     &                 WRITE(MP,'(/A)')                                 &
     &                 ' WARNING input matrix data modified'
                  CALL DAGMG_MUMPS_351                                       &
     &                 (N,NZ,IRN, ICN, IW(1), LLIW, IW(L2), PTRAR(1,2), &
     &                 PTRAR, IW(L1), IWFR, KEEP(113), KEEP(114),       &
     &                 INFO(1), INFO(2), ICNTL, symmetry, SYM,          &
     &                 MedDens, NBQD, AvgDens)
                  INFO(8) = symmetry
                  NCMP = N
               ELSE
                  KEEP(23) = 0
               ENDIF
            ENDIF
         ELSE IF (KEEP(23) .EQ. 7 .OR. KEEP(23) .EQ. -9876543 ) THEN
            IF (PROK) WRITE(MP,'(A)')                                   &
     &           ' ... No column permutation'
            KEEP(23) = 0
         ENDIF
      ENDIF
      IF (IORD.NE.1 .AND. IORD.NE.5) THEN
         IF (PROK) THEN
            IF (IORD.EQ.2) THEN
               WRITE(MP,'(A)') ' Ordering based on AMF '
            ELSE IF (IORD.EQ.6) THEN
               WRITE(MP,'(A)') ' Ordering based on QAMD '
            ELSE
               WRITE(MP,'(A)') ' Ordering based on AMD '
            ENDIF
         ENDIF
         IF ( KEEP(60) .NE. 0 ) THEN
            CALL AGMG_MUMPS_162(N, LLIW, IW(L2), IWFR, PTRAR(1,2), IW(1),    &
     &           IW(L1), IKEEP,                                         &
     &           IKEEP(1,2), NCMPA, FILS, IKEEP(1,3), PTRAR, PTRAR(1,3),&
     &           LISTVAR_SCHUR, SIZE_SCHUR)
            IF (KEEP(60)==1) THEN
               KEEP(20) = LISTVAR_SCHUR(1)
            ELSE
               KEEP(38) = LISTVAR_SCHUR(1)
            ENDIF
         ELSE
            IF ( .FALSE. ) THEN
            ELSEIF (IORD .EQ. 2) THEN
               NBBUCK = 2*N
               ALLOCATE( HEAD ( 0: NBBUCK + 1), stat = IERR )
               IF ( IERR .GT. 0 ) THEN
                  INFO( 1 ) = -7
                  INFO( 2 ) = NBBUCK+2
                  RETURN
               ENDIF
               IF(COMPRESS .GE. 1) THEN
                  DO I=L1,L1-1+KEEP(93)/2
                     IW(I) = 2
                  ENDDO
                  DO I=L1+KEEP(93)/2,L1+NCMP-1
                     IW(I) = 1
                  ENDDO
               ELSE
                  IW(L1) = -1
               ENDIF
               IF(COMPRESS .LE. 1) THEN
                  CALL AGMG_MUMPS_337(NCMP, NBBUCK, LLIW, IW(L2),            &
     &                 IWFR, PTRAR(1,2),                                &
     &                 IW(1), IW(L1), IKEEP, IKEEP(1,2), NCMPA, FILS,   &
     &                 IKEEP(1,3), PTRAR, PTRAR(1,3), HEAD)
               ELSE
                  IF(PROK) WRITE(MP,'(A)')                              &
     &                 ' Constrained Ordering based on AMF'
                  CALL AGMG_MUMPS_560(NCMP, NBBUCK, LLIW, IW(L2),            &
     &                 IWFR, PTRAR(1,2),                                &
     &                 IW(1), IW(L1), IKEEP, IKEEP(1,2), NCMPA, FILS,   &
     &                 IKEEP(1,3), PTRAR, PTRAR(1,3), HEAD,             &
     &                 NFSIZ, FRERE)
               ENDIF
               DEALLOCATE(HEAD)
            ELSEIF (IORD .EQ. 6) THEN
               ALLOCATE( HEAD ( N ), stat = IERR )
               IF ( IERR .GT. 0 ) THEN
                  INFO( 1 ) = -7
                  INFO( 2 ) = N
                  RETURN
               ENDIF
               THRESH = 1
               IVersion = 2
               IF(COMPRESS .EQ. 1) THEN
                  DO I=L1,L1-1+KEEP(93)/2
                     IW(I) = 2
                  ENDDO
                  DO I=L1+KEEP(93)/2,L1+NCMP-1
                     IW(I) = 1
                  ENDDO
                  TOTEL = KEEP(93)+KEEP(94)
               ELSE
                  IW(L1) = -1
                  TOTEL = N
               ENDIF
               CALL AGMG_MUMPS_421(TOTEL,IVersion, THRESH, HEAD,             &
     &              NCMP, LLIW, IW(L2), IWFR, PTRAR(1,2), IW(1),        &
     &              IW(L1), IKEEP, IKEEP(1,2), NCMPA, FILS,             &
     &              IKEEP(1,3), PTRAR, PTRAR(1,3))
               DEALLOCATE(HEAD)
            ELSE
               CALL AGMG_MUMPS_197(NCMP, LLIW, IW(L2), IWFR, PTRAR(1,2),     &
     &              IW(1), IW(L1), IKEEP, IKEEP(1,2), NCMPA, FILS,      &
     &              IKEEP(1,3), PTRAR, PTRAR(1,3))
            ENDIF
         ENDIF
         IF(COMPRESS .GE. 1) THEN
            CALL DAGMG_MUMPS_550(N,NCMP,KEEP(94),KEEP(93),                   &
     &           PIV,IKEEP(1,1),IKEEP(1,2))
            COMPRESS = -1
         ENDIF
      ENDIF
      IF (PROK) THEN
         IF (IORD.EQ.1) THEN
            WRITE(MP,'(A)') ' Ordering given is used'
         ENDIF
      ENDIF
      IF ((IORD.EQ.1)                                                   &
     &     ) THEN
         DO K=1,N
            PTRAR(K,1) = 0
         ENDDO
         DO K=1,N
            IF ((IKEEP(K,1).LE.0).OR.(IKEEP(K,1).GT.N))                 &
     &           GO TO 40
            IF (PTRAR(IKEEP(K,1),1).EQ.1) THEN
               GOTO 40
            ELSE
               PTRAR(IKEEP(K,1),1) = 1
            ENDIF
         ENDDO
      ENDIF
      IF (IORD.EQ.1 .OR. IORD.EQ.5 .OR. COMPRESS.EQ.-1) THEN
         IF (KEEP(106)==1) THEN
            IF ( COMPRESS .EQ. -1 ) THEN
               CALL DAGMG_MUMPS_351(N,NZ,IRN, ICN, IW(1), LLIW,              &
     &              IW(L2), PTRAR(1,2),                                 &
     &              PTRAR, IW(L1), IWFR, KEEP(113), KEEP(114),          &
     &              INFO(1), INFO(2), ICNTL, symmetry, SYM,             &
     &              MedDens, NBQD, AvgDens)
               INFO(8) = symmetry
            ENDIF
            COMPRESS = 0
            ALLOCATE( HEAD ( 2*N ), stat = IERR )
            IF ( IERR .GT. 0 ) THEN
               INFO( 1 ) = -7
               INFO( 2 ) = 2*N
               RETURN
            ENDIF
            THRESH = -1
            IF (KEEP(60) == 0) THEN
               ITEMP = 0
            ELSE
               ITEMP = SIZE_SCHUR
               IF (KEEP(60)==1) THEN
                  KEEP(20) = LISTVAR_SCHUR(1)
               ELSE
                  KEEP(38) = LISTVAR_SCHUR(1)
               ENDIF
            ENDIF
            AGG6 = ( NSLAVES == 1 )
            CALL AGMG_MUMPS_422(THRESH, HEAD,                                &
     &           N, LLIW, IW(L2), IWFR, PTRAR(1,2), IW,                 &
     &           IW(L1), HEAD(N+1),                                     &
     &           IKEEP(1,2), NCMPA, FILS, IKEEP(1,3), PTRAR, PTRAR(1,3),&
     &           IKEEP(1,1), LISTVAR_SCHUR, ITEMP, AGG6)
            DEALLOCATE(HEAD)
         ELSE
            CALL DAGMG_MUMPS_198(N, NZ, IRN, ICN, IKEEP, IW(1),              &
     &           LLIW, IW(L2),                                          &
     &           PTRAR(1,2), IW(L1), IWFR,                              &
     &           INFO(1),INFO(2), KEEP(11), MP)
            IF (KEEP(60) .EQ. 0) THEN
               ITEMP = 0
               CALL DAGMG_MUMPS_199(N, IW(L2), IW, LLIW, IWFR, IKEEP,        &
     &              IKEEP(1,2), IW(L1),                                 &
     &              PTRAR, NCMPA, ITEMP)
            ELSE
               CALL DAGMG_MUMPS_199(N, IW(L2), IW, LLIW, IWFR, IKEEP,        &
     &              IKEEP(1,2), IW(L1),                                 &
     &              PTRAR, NCMPA, SIZE_SCHUR)
               IF (KEEP(60) .EQ. 1) THEN
                  KEEP(20) = LISTVAR_SCHUR(1)
               ELSE
                  KEEP(38) = LISTVAR_SCHUR(1)
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      CALL DAGMG_MUMPS_557                                                   &
     &     (N, IW(L2), IW(L1), IKEEP(1,1), IKEEP(1,2), IKEEP(1,3),      &
     &     NFSIZ, PTRAR, INFO(6), FILS, FRERE,                          &
     &     PTRAR(1,3), NEMIN, PTRAR(1,4), KEEP(60),                     &
     &     KEEP(20),KEEP(38),PTRAR(1,2),KEEP(104),IW(1),KEEP(50),       &
     &     ICNTL(13), KEEP(37), NSLAVES, KEEP(250).EQ.1)
      IF (KEEP(60).NE.0)  THEN
         IF (KEEP(60)==1) THEN
            IN = KEEP(20)
         ELSE
            IN = KEEP(38)
         ENDIF
         DO WHILE (IN.GT.0)
            IN = FILS (IN)
         END DO
         IFSON = -IN
         IF (KEEP(60)==1) THEN
            IN = KEEP(20)
         ELSE
            IN = KEEP(38)
         ENDIF
         DO I=2,SIZE_SCHUR
            FILS(IN) = LISTVAR_SCHUR (I)
            IN       = FILS(IN)
            FRERE (IN) = N+1
         ENDDO
         FILS(IN) = -IFSON
      ENDIF
      CALL DAGMG_MUMPS_201(IKEEP(1,2),                                       &
     &     PTRAR(1,3), INFO(6),                                         &
     &     INFO(5), KEEP(2), KEEP(50),                                  &
     &     KEEP(101),KEEP(108),KEEP(5),                                 &
     &     KEEP(6), KEEP(226))
      IF ( KEEP(53) .NE. 0 ) THEN
         CALL AGMG_MUMPS_209( N, FRERE, FILS, NFSIZ, KEEP(20) )
      END IF
      IF (  (KEEP(48) == 4 .AND. KEEP8(21).GT.0_8)                      &
     &     .OR.                                                         &
     &     (KEEP (48)==5 .AND. KEEP8(21) .GT. 0_8 )                     &
     &     .OR.                                                         &
     &     (KEEP(24).NE.0.AND.KEEP8(21).GT.0_8) ) THEN
         CALL DAGMG_MUMPS_510(KEEP8(21), KEEP(2),                            &
     &        KEEP(48), KEEP(50), NSLAVES)
      END IF
      IF (KEEP(210).LT.0.OR.KEEP(210).GT.2) KEEP(210)=0
      IF (KEEP(210).EQ.0.AND.KEEP(201).GT.0) KEEP(210)=1
      IF (KEEP(210).EQ.0.AND.KEEP(201).EQ.0) KEEP(210)=2
      IF (KEEP(210).EQ.2) KEEP8(79)=huge(KEEP8(79))
      IF (KEEP(210).EQ.1.AND.KEEP8(79).LE.0_8) THEN
         IF ( huge(KEEP8(79)) / K79REF + 1_8 .GE. int(NSLAVES,8) ) THEN
            KEEP8(79)=huge(KEEP8(79))
         ELSE
            KEEP8(79)=K79REF * int(NSLAVES,8)
         ENDIF
      ENDIF
      IF (KEEP(210).EQ.1) THEN
         SPLITROOT = .FALSE.
         IF ( KEEP(62).GE.1) THEN
            CALL DAGMG_MUMPS_97(N, FRERE, FILS, NFSIZ,INFO(6),               &
     &           NSLAVES, KEEP,KEEP8, SPLITROOT,                        &
     &           MP, LDIAG,INFO(1),INFO(2))
            IF (INFO(1).LT.0) RETURN
         ENDIF
      ENDIF
      SPLITROOT = ((ICNTL(13).GT.0 .AND. NSLAVES.GT.ICNTL(13)) .OR.     &
     &     ICNTL(13).EQ.-1 )                                            &
     &     .AND. (KEEP(60).EQ.0)
      IF (SPLITROOT) THEN
         CALL DAGMG_MUMPS_97(N, FRERE, FILS, NFSIZ,INFO(6),                  &
     &        NSLAVES, KEEP,KEEP8, SPLITROOT,                           &
     &        MP, LDIAG,INFO(1),INFO(2))
         IF (INFO(1).LT.0) RETURN
      ENDIF
!     $        IKEEP(1,3), IKEEP(1,2), IRN, ICN, PTRAR, KEEP)
      IF (LDIAG.GT.2 .AND. MP.GT.0) THEN
         K = min0(10,N)
         IF (LDIAG.EQ.4) K = N
         IF (K.GT.0) WRITE (MP,99997) (IKEEP(I,1),I=1,K)
         IF (K.GT.0) WRITE (MP,99991) (IKEEP(I,2),I=1,K)
         IF (K.GT.0) WRITE (MP,99990) (IKEEP(I,3),I=1,K)
         IF (K.GT.0) WRITE (MP,99986) (PTRAR(I,1),I=1,K)
         IF (K.GT.0) WRITE (MP,99985) (PTRAR(I,2),I=1,K)
         IF (K.GT.0) WRITE (MP,99984) (PTRAR(I,3),I=1,K)
         IF (K.GT.0) WRITE (MP,99987) (NFSIZ(I),I=1,K)
         IF (K.GT.0) WRITE (MP,99989) (FILS(I),I=1,K)
         IF (K.GT.0) WRITE (MP,99988) (FRERE(I),I=1,K)
      ENDIF
      GO TO 90
   40 INFO(1) = -4
      INFO(2) = K
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1)) WRITE (LP,99996) INFO(1)
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1)) WRITE (LP,99982) INFO(2)
      GOTO 90
   90 CONTINUE
      DEALLOCATE(IW)
      RETURN
99999 FORMAT (/'Entering analysis phase with ...'/                      &
     &     '                N         NZ         LIW       INFO(1)'/,   &
     &     9X, I8, I11, I12, I14)
99998 FORMAT ('Matrix entries:    IRN()   ICN()'/                       &
     &     (I12, I7, I12, I7, I12, I7))
99997 FORMAT ('IKEEP(.,1)=', 10I6/(12X, 10I6))
99996 FORMAT (/'** Error return ** from Analysis *  INFO(1)=', I3)
99991 FORMAT ('IKEEP(.,2)=', 10I6/(12X, 10I6))
99990 FORMAT ('IKEEP(.,3)=', 10I6/(12X, 10I6))
99989 FORMAT ('FILS (.)  =', 10I6/(12X, 10I6))
99988 FORMAT ('FRERE(.)  =', 10I6/(12X, 10I6))
99987 FORMAT ('NFSIZ(.)  =', 10I6/(12X, 10I6))
99986 FORMAT ('PTRAR(.,1)=', 10I6/(12X, 10I6))
99985 FORMAT ('PTRAR(.,2)=', 10I6/(12X, 10I6))
99984 FORMAT ('PTRAR(.,3)=', 10I6/(12X, 10I6))
99982 FORMAT ('Error in permutation array KEEP   INFO(2)=', I3)
      END SUBROUTINE DAGMG_MUMPS_195
      SUBROUTINE DAGMG_MUMPS_199(N,IPE,IW, LW, IWFR, IPS, IPV, NV, FLAG,     &
     &                  NCMPA, SIZE_SCHUR)
      INTEGER N,LW,IWFR,NCMPA,SIZE_SCHUR
      INTEGER FLAG(N)
      INTEGER IPS(N), IPV(N)
      INTEGER IW(LW), NV(N), IPE(N)
      INTEGER I,J,ML,MS,ME,IP,MINJS,IE,KDUMMY,JP
      INTEGER LN,JP1,JS,LWFR,JP2,JE
      DO 10 I=1,N
        FLAG(I) = 0
        NV(I) = 0
        J = IPS(I)
        IPV(J) = I
   10 END DO
      NCMPA = 0
      DO 100 ML=1,N-SIZE_SCHUR
        MS = IPV(ML)
        ME = MS
        FLAG(MS) = ME
        IP = IWFR
        MINJS = N
        IE = ME
        DO 70 KDUMMY=1,N
          JP = IPE(IE)
          LN = 0
          IF (JP.LE.0) GO TO 60
          LN = IW(JP)
          DO 50 JP1=1,LN
            JP = JP + 1
            JS = IW(JP)
            IF (FLAG(JS).EQ.ME) GO TO 50
            FLAG(JS) = ME
            IF (IWFR.LT.LW) GO TO 40
            IPE(IE) = JP
            IW(JP) = LN - JP1
            CALL DAGMG_MUMPS_194(N, IPE, IW, IP-1, LWFR,NCMPA)
            JP2 = IWFR - 1
            IWFR = LWFR
            IF (IP.GT.JP2) GO TO 30
            DO 20 JP=IP,JP2
              IW(IWFR) = IW(JP)
              IWFR = IWFR + 1
   20       CONTINUE
   30       IP = LWFR
            JP = IPE(IE)
   40       IW(IWFR) = JS
            MINJS = min0(MINJS,IPS(JS)+0)
            IWFR = IWFR + 1
   50     CONTINUE
   60     IPE(IE) = -ME
          JE = NV(IE)
          NV(IE) = LN + 1
          IE = JE
          IF (IE.EQ.0) GO TO 80
   70   CONTINUE
   80   IF (IWFR.GT.IP) GO TO 90
        IPE(ME) = 0
        NV(ME) = 1
        GO TO 100
   90   MINJS = IPV(MINJS)
        NV(ME) = NV(MINJS)
        NV(MINJS) = ME
        IW(IWFR) = IW(IP)
        IW(IP) = IWFR - IP
        IPE(ME) = IP
        IWFR = IWFR + 1
  100 END DO
      IF (SIZE_SCHUR == 0) RETURN
      DO ML = N-SIZE_SCHUR+1,N
        ME = IPV(ML)
        IE = ME
        DO KDUMMY=1,N
          JP = IPE(IE)
          LN = 0
          IF (JP.LE.0) GO TO 160
          LN = IW(JP)
  160     IPE(IE) = -IPV(N-SIZE_SCHUR+1)
          JE = NV(IE)
          NV(IE) = LN + 1
          IE = JE
          IF (IE.EQ.0) GO TO 190
        ENDDO
  190   NV(ME) = 0
        IPE(ME) = -IPV(N-SIZE_SCHUR+1)
      ENDDO
      ME = IPV(N-SIZE_SCHUR+1)
      IPE(ME) = 0
      NV(ME) = SIZE_SCHUR
      RETURN
      END SUBROUTINE DAGMG_MUMPS_199
      SUBROUTINE DAGMG_MUMPS_198(N, NZ, IRN, ICN, PERM,                      &
     & IW, LW, IPE, IQ, FLAG,                                           &
     & IWFR, IFLAG, IERROR, IOVFLO, MP)
      INTEGER N,NZ,LW,IWFR,IFLAG,IERROR
      INTEGER PERM(N)
      INTEGER IQ(N)
      INTEGER IRN(NZ), ICN(NZ)
      INTEGER IPE(N), IW(LW), FLAG(N)
      INTEGER MP
      INTEGER IOVFLO
      INTEGER I,J,K,LBIG,L,ID,IN,LEN,JDUMMY,K1,K2
      IERROR = 0
      DO 10 I=1,N
        IQ(I) = 0
   10 END DO
      DO 80 K=1,NZ
        I = IRN(K)
        J = ICN(K)
        IW(K) = -I
        IF (I.EQ.J) GOTO 40
        IF (I.GT.J) GOTO 30
        IF (I.GE.1 .AND. J.LE.N) GO TO 60
        GO TO 50
   30   IF (J.GE.1 .AND. I.LE.N) GO TO 60
        GO TO 50
   40   IW(K) = 0
        IF (I.GE.1 .AND. I.LE.N) GO TO 80
   50   IERROR = IERROR + 1
        IW(K) = 0
        IF (IERROR.LE.1 .AND. MP.GT.0) WRITE (MP,99999)
        IF (IERROR.LE.10 .AND. MP.GT.0) WRITE (MP,99998) K, I, J
        GO TO 80
   60   IF (PERM(J).GT.PERM(I)) GO TO 70
        IQ(J) = IQ(J) + 1
        GO TO 80
   70   IQ(I) = IQ(I) + 1
   80 END DO
      IF (IERROR.GE.1) THEN
        IF (mod(IFLAG,2) .EQ. 0) IFLAG = IFLAG+1
      ENDIF
      IWFR = 1
      LBIG = 0
      DO 100 I=1,N
        L = IQ(I)
        LBIG = MAX0(L,LBIG)
        IWFR = IWFR + L
        IPE(I) = IWFR - 1
  100 END DO
      DO 140 K=1,NZ
        I = -IW(K)
        IF (I.LE.0) GO TO 140
        L = K
        IW(K) = 0
        DO 130 ID=1,NZ
          J = ICN(L)
          IF (PERM(I).LT.PERM(J)) GO TO 110
          L = IPE(J)
          IPE(J) = L - 1
          IN = IW(L)
          IW(L) = I
          GO TO 120
  110     L = IPE(I)
          IPE(I) = L - 1
          IN = IW(L)
          IW(L) = J
  120     I = -IN
          IF (I.LE.0) GO TO 140
  130   CONTINUE
  140 END DO
      K = IWFR - 1
      L = K + N
      IWFR = L + 1
      DO 170 I=1,N
        FLAG(I) = 0
        J = N + 1 - I
        LEN = IQ(J)
        IF (LEN.LE.0) GO TO 160
        DO 150 JDUMMY=1,LEN
          IW(L) = IW(K)
          K = K - 1
          L = L - 1
  150   CONTINUE
  160   IPE(J) = L
        L = L - 1
  170 END DO
      IF (LBIG.GE.IOVFLO) GO TO 190
      DO 180 I=1,N
        K = IPE(I)
        IW(K) = IQ(I)
        IF (IQ(I).EQ.0) IPE(I) = 0
  180 END DO
      GO TO 230
  190 IWFR = 1
      DO 220 I=1,N
        K1 = IPE(I) + 1
        K2 = IPE(I) + IQ(I)
        IF (K1.LE.K2) GO TO 200
        IPE(I) = 0
        GO TO 220
  200   IPE(I) = IWFR
        IWFR = IWFR + 1
        DO 210 K=K1,K2
          J = IW(K)
          IF (FLAG(J).EQ.I) GO TO 210
          IW(IWFR) = J
          IWFR = IWFR + 1
          FLAG(J) = I
  210   CONTINUE
        K = IPE(I)
        IW(K) = IWFR - K - 1
  220 END DO
  230 RETURN
99999 FORMAT (' *** WARNING MESSAGE FROM DMUMPS_198 ***' )
99998 FORMAT (I6, ' NON-ZERO (IN ROW, I6, 11H AND COLUMN ', I6,         &
     & ') IGNORED')
      END SUBROUTINE DAGMG_MUMPS_198
      SUBROUTINE DAGMG_MUMPS_194(N, IPE, IW, LW, IWFR,NCMPA)
      INTEGER N,LW,IWFR,NCMPA
      INTEGER IPE(N)
      INTEGER   IW(LW)
      INTEGER I,K1,LWFR,IR,K,K2
      NCMPA = NCMPA + 1
      DO 10 I=1,N
        K1 = IPE(I)
        IF (K1.LE.0) GO TO 10
        IPE(I) = IW(K1)
        IW(K1) = -I
   10 END DO
      IWFR = 1
      LWFR = IWFR
      DO 60 IR=1,N
        IF (LWFR.GT.LW) GO TO 70
        DO 20 K=LWFR,LW
          IF (IW(K).LT.0) GO TO 30
   20   CONTINUE
        GO TO 70
   30   I = -IW(K)
        IW(IWFR) = IPE(I)
        IPE(I) = IWFR
        K1 = K + 1
        K2 = K + IW(IWFR)
        IWFR = IWFR + 1
        IF (K1.GT.K2) GO TO 50
        DO 40 K=K1,K2
          IW(IWFR) = IW(K)
          IWFR = IWFR + 1
   40   CONTINUE
   50   LWFR = K2 + 1
   60 END DO
   70 RETURN
      END SUBROUTINE DAGMG_MUMPS_194
      SUBROUTINE DAGMG_MUMPS_557(N, IPE, NV, IPS, NE, NA, NFSIZ,             &
     &               NODE, NSTEPS,                                      &
     &               FILS, FRERE, ND, NEMIN, SUBORD, KEEP60,            &
     &               KEEP20, KEEP38, NAMALG,NAMALGMAX,                  &
     &               CUMUL,KEEP50, ICNTL13, KEEP37, NSLAVES,            &
     &               ALLOW_AMALG_TINY_NODES)
      IMPLICIT NONE
      INTEGER N, NSTEPS, KEEP60, KEEP20, KEEP38, KEEP50
      INTEGER ND(N), NFSIZ(N)
      INTEGER IPE(N), FILS(N), FRERE(N), SUBORD(N)
      INTEGER NV(N), IPS(N), NE(N), NA(N), NODE(N)
      INTEGER NEMIN,AMALG_COUNT
      INTEGER NAMALG(N),NAMALGMAX, CUMUL(N)
      DOUBLE PRECISION ACCU, FLOPS_FATHER, FLOPS_SON,                   &
     &                  FLOPS_AVANT, FLOPS_APRES
      INTEGER ICNTL13, KEEP37, NSLAVES
      LOGICAL ALLOW_AMALG_TINY_NODES
      INTEGER I,IF,IS,NR,NR1,INS,INL,INB,INF,INFS,INSW
      INTEGER K,L,ISON,IN,IFSON,INO
      INTEGER INOS,IB,IL,INT
      INTEGER IPERM
      INTEGER DADI
      LOGICAL AMALG_TO_father_OK
      AMALG_COUNT = 0
      DO 10 I=1,N
        CUMUL(I)= 0
        IPS(I)  = 0
        NE(I)   = 0
        NODE(I) = 1
        SUBORD(I) = 0
        NAMALG(I) = 0
   10 END DO
      FRERE(1:N) = IPE(1:N)
      NR = N + 1
      DO 50 I=1,N
        IF = -FRERE(I)
        IF (NV(I).EQ.0) THEN
          IF (SUBORD(IF).NE.0) SUBORD(I) = SUBORD(IF)
          SUBORD(IF) = I
          NODE(IF) = NODE(IF)+1
        ELSE
          IF (IF.NE.0) THEN
            IS = -IPS(IF)
            IF (IS.GT.0) FRERE(I) = IS
            IPS(IF) = -I
          ELSE
            NR = NR - 1
            NE(NR) = I
          ENDIF
        ENDIF
   50 END DO
 1151 DO 51 I=1,N
       FILS(I) = IPS(I)
   51 END DO
      IS = 1
      I = 0
      IPERM = 1
      DO 160 K=1,N
        AMALG_TO_father_OK=.FALSE.
        IF (I.LE.0) THEN
         IF (NR.GT.N) EXIT
         I = NE(NR)
         NE(NR) = 0
         NR = NR + 1
         IL = N
         NA(N) = 0
        ENDIF
        DO 70 L=1,N
          IF (IPS(I).GE.0) EXIT
          ISON = -IPS(I)
          IPS(I) = 0
          I = ISON
          IL = IL - 1
          NA(IL) = 0
   70   CONTINUE
        DADI = -IPE(I)
        IF ( (DADI.NE.0) .AND.                                          &
     &      (                                                           &
     &       (KEEP60.EQ.0).OR.                                          &
     &       ( (KEEP20.NE.DADI).AND.(KEEP38.NE.DADI) )                  &
     &      )                                                           &
     &     ) THEN
           ACCU =                                                       &
     &     ( dble(20000)*                                               &
     &       dble(NODE(I))*dble(NV(DADI)-NV(I)+NODE(I))                 &
     &      )                                                           &
     &      /                                                           &
     &          ( dble(NV(DADI)+NODE(I))*                               &
     &              dble(NV(DADI)+NODE(I))  )
           ACCU = ACCU + dble(CUMUL(I) )
           AMALG_TO_father_OK = ( (NODE(I).LE.NEMIN).OR.                &
     &         (NODE(DADI).LE.NEMIN) )
           AMALG_TO_father_OK = ( AMALG_TO_father_OK .AND.              &
     &       (                                                          &
     &        ( dble(2*(NODE(I)))*                                      &
     &         dble((NV(DADI)-NV(I)+NODE(I)))                           &
     &        ) .LT.                                                    &
     &        (  dble(NV(DADI)+NODE(I))*                                &
     &         dble(NV(DADI)+NODE(I))*dble(NEMIN)/dble(100)             &
     &        )                                                         &
     &       ) )
           AMALG_TO_father_OK = ( AMALG_TO_father_OK .AND.              &
     &     ( ACCU .LE. dble(NEMIN)*dble(100) )                          &
     &                           )
           IF (AMALG_TO_father_OK) THEN
              CALL AGMG_MUMPS_511(NV(I),NODE(I),NODE(I),                     &
     &                                  KEEP50,1,FLOPS_SON)
              CALL AGMG_MUMPS_511(NV(DADI),NODE(DADI),                       &
     &                             NODE(DADI),                          &
     &                             KEEP50,1,FLOPS_FATHER)
              FLOPS_AVANT = FLOPS_FATHER+FLOPS_SON                      &
     &                      + max(dble(200.0) * dble(NV(I)-NODE(I))     &
     &                            * dble(NV(I)-NODE(I)),                &
     &                            dble(10000.0))
              CALL AGMG_MUMPS_511(NV(DADI)+NODE(I),                          &
     &                             NODE(DADI)+NODE(I),                  &
     &                             NODE(DADI)+NODE(I),                  &
     &                             KEEP50,1,FLOPS_APRES)
              IF(FLOPS_APRES .GT. FLOPS_AVANT) THEN
                 AMALG_TO_father_OK = .FALSE.
              ENDIF
           ENDIF
           IF ( (NV(I).GT. 50*NV(DADI)).AND. (NSLAVES.GT.1)             &
     &          .AND. (ICNTL13.LE.0)                                    &
     &          .AND. (NV(I).GT. KEEP37) )  THEN
             AMALG_TO_father_OK = .TRUE.
           ENDIF
           IF ( ALLOW_AMALG_TINY_NODES .AND.                            &
     &     NODE(I) * 900 .LE. NV(DADI) - NAMALG(DADI)) THEN
             IF ( NAMALG(DADI) < (NV(DADI)-NAMALG(DADI))/50 ) THEN
                AMALG_TO_father_OK = .TRUE.
                NAMALG(DADI) = NAMALG(DADI) + NODE(I)
           ENDIF
        ENDIF
      AMALG_TO_father_OK = (AMALG_TO_father_OK .OR.                     &
     &                       ( NV(I)-NODE(I).EQ.NV(DADI)) )
           IF (AMALG_TO_father_OK) THEN
             CUMUL(DADI)=CUMUL(DADI)+nint(ACCU)
             NAMALG(DADI) = NAMALG(DADI) + NAMALG(I)
             AMALG_COUNT = AMALG_COUNT+1
             IN = DADI
   75        IF (SUBORD(IN).EQ.0) GOTO 76
               IN = SUBORD(IN)
               GOTO 75
   76        CONTINUE
             SUBORD(IN) = I
             NV(I)      = 0
             IFSON = -FILS(DADI)
             IF (IFSON.EQ.I) THEN
              IF (FILS(I).LT.0) THEN
                FILS(DADI) =  FILS(I)
                GOTO 78
              ELSE
                IF (FRERE(I).GT.0) THEN
                  FILS(DADI) = -FRERE(I)
                ELSE
                  FILS(DADI) = 0
                ENDIF
                GOTO 90
              ENDIF
             ENDIF
             IN = IFSON
   77        INS = IN
             IN = FRERE(IN)
             IF (IN.NE.I) GOTO 77
             IF (FILS(I) .LT.0) THEN
               FRERE(INS) = -FILS(I)
             ELSE
               FRERE(INS) = FRERE(I)
               GOTO 90
             ENDIF
   78        CONTINUE
             IN = -FILS(I)
   79        INO = IN
             IN = FRERE(IN)
             IF (IN.GT.0) GOTO 79
             FRERE(INO) = FRERE(I)
   90        CONTINUE
             NODE(DADI) = NODE(DADI)+ NODE(I)
             NV(DADI)   = NV(DADI) +  NODE(I)
             NA(IL+1)   = NA(IL+1) + NA(IL)
             GOTO 120
           ENDIF
        ENDIF
        NE(IS) = NE(IS) + NODE(I)
        IF (IL.LT.N) NA(IL+1) = NA(IL+1) + 1
        NA(IS) = NA(IL)
        ND(IS) = NV(I)
        NODE(I) = IS
        IPS(I) = IPERM
        IPERM = IPERM + 1
        IN = I
  777   IF (SUBORD(IN).EQ.0) GO TO 778
          IN = SUBORD(IN)
          NODE(IN) = IS
          IPS(IN) = IPERM
          IPERM = IPERM + 1
          GO TO 777
  778   IF (NA(IS).LE.0) GO TO 110
  110   IS = IS + 1
  120   IB = FRERE(I)
        IF (IB.GE.0) THEN
          IF (IB.GT.0) NA(IL) = 0
          I = IB
        ELSE
          I = -IB
          IL = IL + 1
        ENDIF
  160 END DO
      NSTEPS = IS - 1
      DO I=1, N
        IF (NV(I).EQ.0) THEN
          FRERE(I) = N+1
        ELSE
          NFSIZ(I) = ND(NODE(I))
          IF (SUBORD(I) .NE.0) THEN
           INOS = -FILS(I)
           INO = I
           DO WHILE (SUBORD(INO).NE.0)
             IS = SUBORD(INO)
             FILS(INO) = IS
             INO = IS
           END DO
           FILS(INO) = -INOS
          ENDIF
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_557
      SUBROUTINE DAGMG_MUMPS_201(NE, ND, NSTEPS,                             &
     & MAXFR, MAXELIM, K50, MAXFAC, MAXNPIV,                            &
     & K5,K6,PANEL_SIZE)
      IMPLICIT NONE
      INTEGER NSTEPS,MAXNPIV
      INTEGER MAXFR, MAXELIM, K50, MAXFAC
      INTEGER K5,K6,PANEL_SIZE
      INTEGER NE(NSTEPS), ND(NSTEPS)
      INTEGER ITREE, NFR, NELIM
      INTEGER LKJIB
      LKJIB   = max(k5,k6)
      MAXFR   = 0
      MAXFAC  = 0
      MAXELIM = 0
      MAXNPIV = 0
      PANEL_SIZE = 0
      DO ITREE=1,NSTEPS
        NELIM = NE(ITREE)
        NFR = ND(ITREE)
        IF (NFR.GT.MAXFR)         MAXFR   = NFR
        IF (NFR-NELIM.GT.MAXELIM) MAXELIM = NFR - NELIM
        IF (NELIM .GT. MAXNPIV) THEN
           IF(NFR .NE. NELIM) MAXNPIV = NELIM
        ENDIF
        IF (K50.EQ.0) THEN
          MAXFAC = max(MAXFAC, (2*NFR - NELIM)*NELIM )
          PANEL_SIZE = max(PANEL_SIZE, NFR*LKJIB)
        ELSE
         MAXFAC = max(MAXFAC, NFR * NELIM)
         PANEL_SIZE = max(PANEL_SIZE, NELIM*LKJIB)
         PANEL_SIZE = max(PANEL_SIZE, (NFR-NELIM)*LKJIB)
        ENDIF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_201
      SUBROUTINE DAGMG_MUMPS_348( N, FILS, FRERE,                            &
     & NSTK, NA )
      IMPLICIT NONE
      INTEGER, INTENT(IN)    :: N
      INTEGER, INTENT(IN)    :: FILS(N), FRERE(N)
      INTEGER, INTENT(INOUT) ::  NSTK(N), NA(N)
      INTEGER NBROOT, NBLEAF, ILEAF, I, IN, ISON
      NA   = 0
      NSTK = 0
      NBROOT  = 0
      ILEAF   = 1
      DO 11 I=1,N
         IF (FRERE(I).EQ. N+1) CYCLE
         IF (FRERE(I).EQ.0) NBROOT = NBROOT + 1
         IN = I
   12    IN = FILS(IN)
         IF (IN.GT.0) GO TO 12
         IF (IN.EQ.0) THEN
            NA(ILEAF) = I
            ILEAF     = ILEAF + 1
            CYCLE
         ENDIF
         ISON = -IN
   13    NSTK(I) = NSTK(I) + 1
         ISON = FRERE(ISON)
         IF (ISON.GT.0) GO TO 13
   11 END DO
      NBLEAF = ILEAF-1
      IF (N.GT.1) THEN
         IF (NBLEAF.GT.N-2) THEN
            IF (NBLEAF.EQ.N-1) THEN
               NA(N-1) = -NA(N-1)-1
               NA(N)   = NBROOT
            ELSE
               NA(N) = -NA(N)-1
            ENDIF
         ELSE
            NA(N-1) = NBLEAF
            NA(N)   = NBROOT
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_348
      SUBROUTINE DAGMG_MUMPS_202( N, NZ, PERM, IRN, ICN, PTRAR, KEEP )
      IMPLICIT NONE
      INTEGER, INTENT(IN)      :: N, NZ
      INTEGER, INTENT(IN)      :: KEEP(500)
      INTEGER, TARGET          :: PTRAR(N,2)
      INTEGER, INTENT(IN)      :: IRN(NZ), ICN(NZ), PERM(N)
      INTEGER I
      INTEGER IOLD, K, JOLD, INEW, JNEW, ISHIFT
      DO 50 IOLD=1,N
         PTRAR(IOLD,1) = 0
         PTRAR(IOLD,2) = 0
   50 END DO
      DO 70 K=1,NZ
         IOLD = IRN(K)
         JOLD = ICN(K)
         IF ( (IOLD.GT.N).OR.(JOLD.GT.N).OR.(IOLD.LT.1)                 &
     &        .OR.(JOLD.LT.1) ) GOTO 70
         IF (IOLD.NE.JOLD) THEN
            INEW = PERM(IOLD)
            JNEW = PERM(JOLD)
            IF ( KEEP( 50 ) .EQ. 0 ) THEN
               IF (INEW.LT.JNEW) THEN
                  PTRAR(IOLD,2) = PTRAR(IOLD,2) + 1
               ELSE
                  PTRAR(JOLD,1) = PTRAR(JOLD,1) + 1
               ENDIF
            ELSE
               IF ( INEW .LT. JNEW ) THEN
                  PTRAR( IOLD, 1 ) = PTRAR( IOLD, 1 ) + 1
               ELSE
                  PTRAR( JOLD, 1 ) = PTRAR( JOLD, 1 ) + 1
               END IF
            ENDIF
         ENDIF
   70 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_202
      SUBROUTINE DAGMG_MUMPS_203( N, NZ, MTRANS, PERM,                       &
     &     id, ICNTL, INFO)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER N, NZ, LIWG
      INTEGER PERM(N)
      INTEGER MTRANS
      INTEGER ICNTL(40), INFO(40)
      INTEGER  allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: IW
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: S2
      TARGET :: S2
      INTEGER LS2,LSC
      INTEGER ICNTL64(10), INFO64(10)
      INTEGER ICNTL_SYM_MWM(10),INFO_SYM_MWM(10)
      DOUBLE PRECISION CNTL64(10)
      INTEGER LDW, LDWMIN
      INTEGER MPRINT,LP, MP, IPIW, LIW, LIWMIN
      INTEGER JPERM
      INTEGER NUMNZ, I, J, JPOS, K, NZREAL
      INTEGER PLENR, IP, IRNW,RSPOS,CSPOS
      LOGICAL PROK, IDENT, DUPPLI
      INTEGER NZTOT, K50, KER_SIZE, NZER_DIAG, MTRANSLOC,RZ_DIAG
      LOGICAL SCALINGLOC
      INTEGER,POINTER,DIMENSION(:) :: ZERODIAG
      INTEGER,POINTER,DIMENSION(:) :: STR_KER
      INTEGER,POINTER,DIMENSION(:) :: MARKED
      INTEGER,POINTER,DIMENSION(:) :: FLAG
      INTEGER,POINTER,DIMENSION(:) :: PIV_OUT
      DOUBLE PRECISION THEMIN, THEMAX, COLNORM,MAXDBL
      DOUBLE PRECISION ZERO,TWO,ONE
      PARAMETER(ZERO = 0.0D0,TWO = 2.0D0,ONE = 1.0D0)
      MPRINT = ICNTL(3)
      LP     = ICNTL(1)
      MP     = ICNTL(2)
      PROK = (MPRINT.GT.0)
      IF (PROK) WRITE(MPRINT,101)
  101 FORMAT(/'****** Preprocessing of original matrix '/)
      K50 = id%KEEP(50)
      SCALINGLOC = .FALSE.
      IF(id%KEEP(52) .EQ. -2) THEN
         IF(.not.associated(id%A)) THEN
            INFO(1) = -22
            INFO(2) = 4
            GOTO 500
         ELSE
            SCALINGLOC = .TRUE.
         ENDIF
      ELSE IF(id%KEEP(52) .EQ. 77) THEN
         SCALINGLOC = .TRUE.
         IF(K50 .NE. 2) THEN
            IF( MTRANS .NE. 5 .AND. MTRANS .NE. 6                       &
     &           .AND. MTRANS .NE. 7) THEN
               SCALINGLOC = .FALSE.
               IF (PROK)                                                &
     &              WRITE(MPRINT,*) 'Analysis: auto scaling set OFF'
            ENDIF
         ENDIF
         IF(.not.associated(id%A)) THEN
            SCALINGLOC = .FALSE.
            IF (PROK)                                                   &
     &           WRITE(MPRINT,*) 'Analysis: auto scaling set OFF'
         ENDIF
      ENDIF
      IF(SCALINGLOC) THEN
         IF (PROK) WRITE(MPRINT,*)                                      &
     &        'Scaling will be computed during analysis'
      ENDIF
      MTRANSLOC = MTRANS
      IF (MTRANS.LT.0 .OR. MTRANS.GT.7) GO TO 500
      IF (K50 .EQ. 0) THEN
         IF(.NOT. SCALINGLOC .AND. MTRANS .EQ. 7) THEN
            GO TO 500
         ENDIF
         IF(SCALINGLOC) THEN
            MTRANSLOC = 5
         ENDIF
      ELSE
         IF (MTRANS .EQ. 7) MTRANSLOC = 5
      ENDIF
      IF(SCALINGLOC .AND. MTRANSLOC .NE. 5 .AND.                        &
     &     MTRANSLOC .NE. 6 ) THEN
         IF (PROK) WRITE(MPRINT,*)                                      &
     &        'WARNING scaling required: set MTRANS option to 5'
         MTRANSLOC = 5
      ENDIF
      IF (N.EQ.1) THEN
        MTRANS=0
        GO TO 500
      ENDIF
      IF(K50 .EQ. 2) THEN
         NZTOT = 2*NZ+N
      ELSE
         NZTOT = NZ
      ENDIF
      ZERODIAG => id%IS1(N+1:2*N)
      STR_KER => id%IS1(2*N+1:3*N)
      CALL DAGMG_MUMPS_448(ICNTL64,CNTL64)
      ICNTL64(1) = ICNTL(1)
      ICNTL64(2) = ICNTL(2)
      ICNTL64(3) = ICNTL(2)
      ICNTL64(4) = -1
      IF (ICNTL(4).EQ.3) ICNTL64(4) = 0
      IF (ICNTL(4).EQ.4) ICNTL64(4) = 1
      ICNTL64(5) = -1
      IF (PROK) THEN
         WRITE(MPRINT,'(A,I3)')                                         &
     &     'Compute maximum matching (Maximum Transversal):',           &
     &        MTRANSLOC
         IF (MTRANSLOC.EQ.1)                                            &
     &   WRITE(MPRINT,'(A,I3)')' ... JOB =',MTRANSLOC
         IF (MTRANSLOC.EQ.2)                                            &
     &   WRITE(MPRINT,'(A,I3,A)')                                       &
     &     ' ... JOB =',MTRANSLOC,': BOTTLENECK THESIS'
         IF (MTRANSLOC.EQ.3)                                            &
     &   WRITE(MPRINT,'(A,I3,A)')                                       &
     &     ' ... JOB =',MTRANSLOC,': BOTTLENECK SIMAX'
         IF (MTRANSLOC.EQ.4)                                            &
     &   WRITE(MPRINT,'(A,I3,A)')                                       &
     &     ' ... JOB =',MTRANSLOC,': MAXIMIZE SUM DIAGIONAL'
         IF (MTRANSLOC.EQ.5 .OR. MTRANSLOC.EQ.6)                        &
     &   WRITE(MPRINT,'(A,I3,A)')                                       &
     &     ' ... JOB =',MTRANSLOC,                                      &
     &     ': MAXIMIZE PRODUCT DIAGONAL AND SCALE'
      ENDIF
      id%INFOG(23) = MTRANSLOC
      CNTL64(2) = huge(CNTL64(2))
      IRNW = 1
      IP = IRNW + NZTOT
      PLENR = IP + N + 1
      IPIW = PLENR
      IF (MTRANSLOC.EQ.1) LIWMIN = 5*N
      IF (MTRANSLOC.EQ.2) LIWMIN = 4*N
      IF (MTRANSLOC.EQ.3) LIWMIN = 10*N + NZTOT
      IF (MTRANSLOC.EQ.4) LIWMIN = 5*N
      IF (MTRANSLOC.EQ.5) LIWMIN = 5*N
      IF (MTRANSLOC.EQ.6) LIWMIN = 5*N + NZTOT
      LIW = LIWMIN
      LIWG  = LIW + (NZTOT + N + 1)
      ALLOCATE(IW(LIWG), stat=allocok)
      IF (allocok .GT. 0 ) GOTO 410
      IF (MTRANSLOC.EQ.1) THEN
       LDWMIN = N+3
      ENDIF
      IF (MTRANSLOC.EQ.2) LDWMIN = max(N+NZTOT,N+3)
      IF (MTRANSLOC.EQ.3) LDWMIN = max(NZTOT+1,N+3)
      IF (MTRANSLOC.EQ.4) LDWMIN = 2*N + max(NZTOT,N+3)
      IF (MTRANSLOC.EQ.5) LDWMIN = 3*N + NZTOT
      IF (MTRANSLOC.EQ.6) LDWMIN = 4*N + NZTOT
      LDW   = LDWMIN
      ALLOCATE(S2(LDW), stat=allocok)
      IF(MTRANSLOC .NE. 1) LDW = LDW-NZTOT
      RSPOS = NZTOT
      CSPOS = RSPOS+N
      IF (allocok .GT. 0 ) GOTO 430
      NZREAL = 0
      DO 5 J=1,N
        IW(PLENR+J-1) = 0
    5 END DO
      IF(K50 .EQ. 0) THEN
         DO 10 K=1,NZ
            I = id%IRN(K)
            J = id%JCN(K)
            IF ( (J.LE.N).AND.(J.GE.1).AND.                             &
     &           (I.LE.N).AND.(I.GE.1) ) THEN
               IW(PLENR+J-1) = IW(PLENR+J-1) + 1
               NZREAL = NZREAL + 1
            ENDIF
   10    CONTINUE
      ELSE
         ZERODIAG = 0
         NZER_DIAG = N
         RZ_DIAG = 0
         DO K=1,NZ
            I = id%IRN(K)
            J = id%JCN(K)
            IF ( (J.LE.N).AND.(J.GE.1).AND.                             &
     &           (I.LE.N).AND.(I.GE.1) ) THEN
               IW(PLENR+J-1) = IW(PLENR+J-1) + 1
               NZREAL = NZREAL + 1
               IF(I .NE. J) THEN
                  IW(PLENR+I-1) = IW(PLENR+I-1) + 1
                  NZREAL = NZREAL + 1
               ELSE
                  IF(ZERODIAG(I) .EQ. 0) THEN
                     ZERODIAG(I) = K
                     IF(associated(id%A)) THEN
                        IF(abs(id%A(K)) .EQ. dble(0.0D0)) THEN
                           RZ_DIAG = RZ_DIAG + 1
                        ENDIF
                     ENDIF
                     NZER_DIAG = NZER_DIAG - 1
                  ENDIF
               ENDIF
            ENDIF
         ENDDO
         IF(MTRANSLOC .GE. 4) THEN
            DO I =1, N
               IF(ZERODIAG(I) .EQ. 0) THEN
                  IW(PLENR+I-1) = IW(PLENR+I-1) + 1
                  NZREAL = NZREAL + 1
               ENDIF
            ENDDO
         ENDIF
      ENDIF
      IW(IP)   = 1
      DO 20 J=1,N
        IW(IP+J)   = IW(IP+J-1)+IW(PLENR+J-1)
   20 END DO
      DO 25 J=1, N
        IW(PLENR+J-1 ) = IW(IP+J-1 )
   25 END DO
      IF(K50 .EQ. 0) THEN
         IF (MTRANSLOC.EQ.1) THEN
            DO 30 K=1,NZ
               I = id%IRN(K)
               J = id%JCN(K)
               IF ( (J.LE.N).AND.(J.GE.1) .AND.                         &
     &              (I.LE.N).AND.(I.GE.1)) THEN
                  JPOS            = IW(PLENR+J-1)
                  IW(IRNW+JPOS-1) = I
                  IW(PLENR+J-1)   = IW(PLENR+J-1) + 1
              ENDIF
   30       CONTINUE
         ELSE
            IF ( .not.associated(id%A)) THEN
               INFO(1) = -22
               INFO(2) = 4
               GOTO 500
            ENDIF
            DO 35 K=1,NZ
               I = id%IRN(K)
               J = id%JCN(K)
               IF ( (J.LE.N).AND.(J.GE.1) .AND.                         &
     &              (I.LE.N).AND.(I.GE.1)) THEN
                  JPOS            = IW(PLENR+J-1)
                  IW(IRNW+JPOS-1) = I
                  S2(JPOS)         = abs(id%A(K))
                  IW(PLENR+J-1)   = IW(PLENR+J-1) + 1
               ENDIF
   35       CONTINUE
         ENDIF
      ELSE
         IF (MTRANSLOC.EQ.1) THEN
            DO K=1,NZ
               I = id%IRN(K)
               J = id%JCN(K)
               IF ( (J.LE.N).AND.(J.GE.1) .AND.                         &
     &              (I.LE.N).AND.(I.GE.1)) THEN
                  JPOS            = IW(PLENR+J-1)
                  IW(IRNW+JPOS-1) = I
                  IW(PLENR+J-1)   = IW(PLENR+J-1) + 1
                  IF(I.NE.J) THEN
                     JPOS            = IW(PLENR+I-1)
                     IW(IRNW+JPOS-1) = J
                     IW(PLENR+I-1)   = IW(PLENR+I-1) + 1
                  ENDIF
               ENDIF
            ENDDO
         ELSE
            IF ( .not.associated(id%A)) THEN
               INFO(1) = -22
               INFO(2) = 4
               GOTO 500
            ENDIF
            K = 1
            THEMIN = ZERO
            DO
               IF(THEMIN .NE. ZERO) EXIT
               THEMIN = abs(id%A(K))
               K = K+1
            ENDDO
            THEMAX = THEMIN
            DO K=1,NZ
               I = id%IRN(K)
               J = id%JCN(K)
               IF ( (J.LE.N).AND.(J.GE.1) .AND.                         &
     &              (I.LE.N).AND.(I.GE.1)) THEN
                  JPOS            = IW(PLENR+J-1)
                  IW(IRNW+JPOS-1) = I
                  S2(JPOS)         = abs(id%A(K))
                  IW(PLENR+J-1)   = IW(PLENR+J-1) + 1
                  IF(abs(id%A(K)) .GT. THEMAX) THEN
                     THEMAX = abs(id%A(K))
                  ELSE IF(abs(id%A(K)) .LT. THEMIN                      &
     &                    .AND. abs(id%A(K)).GT. ZERO) THEN
                     THEMIN = abs(id%A(K))
                  ENDIF
                  IF(I.NE.J) THEN
                     JPOS            = IW(PLENR+I-1)
                     IW(IRNW+JPOS-1) = J
                     S2(JPOS)         = abs(id%A(K))
                     IW(PLENR+I-1)   = IW(PLENR+I-1) + 1
                  ENDIF
               ENDIF
            ENDDO
            DO I =1, N
               IF(ZERODIAG(I) .EQ. 0) THEN
                  JPOS            = IW(PLENR+I-1)
                  IW(IRNW+JPOS-1) = I
                  S2(JPOS)         = ZERO
                  IW(PLENR+I-1)   = IW(PLENR+I-1) + 1
               ENDIF
            ENDDO
            CNTL64(2) = (log(THEMAX/THEMIN))*(dble(N))                  &
     &           - log(THEMIN) + ONE
         ENDIF
      ENDIF
      DUPPLI = .FALSE.
      I = NZREAL
      FLAG => id%IS1(3*N+1:4*N)
      IF(MTRANSLOC.NE.1) THEN
         CALL DAGMG_MUMPS_563(N,NZREAL,IW(IP),IW(IRNW),S2,                   &
     &        PERM,FLAG)
      ELSE
         CALL DAGMG_MUMPS_562(N,NZREAL,IW(IP),IW(IRNW),                      &
     &        PERM,FLAG)
      ENDIF
      IF(NZREAL .NE. I) DUPPLI = .TRUE.
      LS2 = NZTOT
      IF ( MTRANSLOC .EQ. 1 ) THEN
         LS2 = 1
         LDW = 1
      ENDIF
      CALL DAGMG_MUMPS_559(MTRANSLOC ,N, N, NZREAL,                          &
     &     IW(IP), IW(IRNW), S2(1), LS2,                                &
     &     NUMNZ, PERM, LIW, IW(IPIW), LDW, S2(LS2+1),                  &
     &     ICNTL64, CNTL64, INFO64)
      IF (INFO64(1).LT.0) THEN
         IF (LP.GT.0 .AND. ICNTL(4).GE.1)                               &
     &        WRITE(LP,'(A,I5)')                                        &
     &   ' INTERNAL ERROR in MAXTRANS INFO(1)=',INFO64(1)
         INFO(1) = -9964
         INFO(2) = INFO64(1)
         GO TO 500
      ENDIF
      IF (INFO64(1).GT.0) THEN
         IF (MP.GT.0 .AND. ICNTL(4).GE.2)                               &
     &        WRITE(MP,'(A,I5)')                                        &
     &        ' WARNING in MAXTRANS INFO(1)=',INFO64(1)
      ENDIF
      KER_SIZE = 0
      IF(K50 .EQ. 2) THEN
         DO I=1,N
            IF(ZERODIAG(I) .EQ. 0) THEN
               IF(PERM(I) .EQ. I) THEN
                  KER_SIZE = KER_SIZE + 1
                  PERM(I) = -I
                  STR_KER(KER_SIZE) = I
               ENDIF
            ENDIF
         ENDDO
      ENDIF
      IF (NUMNZ.LT.N) GO TO 400
      IF(KER_SIZE .GT. 0) GOTO 400
      IF(K50 .EQ. 0) THEN
         IDENT = .TRUE.
         IF (MTRANS .EQ. 0 ) GOTO 102
         DO 80 J=1,N
            JPERM = PERM(J)
            IW(PLENR+JPERM-1) = J
            IF (JPERM.NE.J) IDENT = .FALSE.
   80    CONTINUE
         IF(IDENT) THEN
            MTRANS = 0
         ELSE
            IF(MTRANS .EQ. 7) THEN
               MTRANS = -9876543
               GOTO 102
            ENDIF
            IF (PROK) WRITE(MPRINT,'(A)')                               &
     &           ' ... Apply column permutation'
            DO 100 K=1,NZ
               J = id%JCN(K)
               IF ((J.LE.0).OR.(J.GT.N)) GO TO 100
               id%JCN(K) = IW(PLENR+J-1)
  100       CONTINUE
            IF (MP.GT.0 .AND. ICNTL(4).GE.2)                            &
     &           WRITE(MP,'(/A)')                                       &
     &           ' WARNING input matrix data modified'
         ENDIF
  102    CONTINUE
         IF (SCALINGLOC) THEN
            IF ( associated(id%COLSCA))                                 &
     &           DEALLOCATE( id%COLSCA )
            IF ( associated(id%ROWSCA))                                 &
     &           DEALLOCATE( id%ROWSCA )
            ALLOCATE( id%COLSCA(N), stat=allocok)
            IF (allocok .GT.0) THEN
               id%INFO(1)=-5
               id%INFO(2)=N
               IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
                  WRITE (LP,'(/A)') '** Error in DMUMPS_203'
                  WRITE (LP,'(A)')                                      &
     &                 '** Failure during allocation of COLSCA'
                  GOTO 500
               ENDIF
            ENDIF
            ALLOCATE( id%ROWSCA(N), stat=allocok)
            IF (allocok .GT.0) THEN
               id%INFO(1)=-5
               id%INFO(2)=N
               IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
                  WRITE (LP,'(/A)') '** Error in DMUMPS_203'
                  WRITE (LP,'(A)')                                      &
     &                 '** Failure during allocation of ROWSCA'
                  GOTO 500
               ENDIF
            ENDIF
            id%KEEP(52) = -2
            id%KEEP(74) = 1
            MAXDBL = log(huge(MAXDBL))
            DO J=1,N
               IF(S2(RSPOS+J) .GT. MAXDBL) THEN
                  S2(RSPOS+J) = ZERO
               ENDIF
               IF(S2(CSPOS+J) .GT. MAXDBL) THEN
                  S2(CSPOS+J)= ZERO
               ENDIF
            ENDDO
            DO 105 J=1,N
               id%ROWSCA(J) = exp(S2(RSPOS+J))
               IF(id%ROWSCA(J) .EQ. ZERO) THEN
                  id%ROWSCA(J) = ONE
               ENDIF
               IF ( MTRANS .EQ.  -9876543 .OR. MTRANS.EQ. 0 ) THEN
                 id%COLSCA(J)= exp(S2(CSPOS+J))
                 IF(id%COLSCA(J) .EQ. ZERO) THEN
                   id%COLSCA(J) = ONE
                 ENDIF
               ELSE
                 id%COLSCA(IW(PLENR+J-1))= exp(S2(CSPOS+J))
                 IF(id%COLSCA(IW(PLENR+J-1)) .EQ. ZERO) THEN
                   id%COLSCA(IW(PLENR+J-1)) = ONE
                 ENDIF
               ENDIF
  105       CONTINUE
         ENDIF
      ELSE
         IDENT = .FALSE.
         IF(SCALINGLOC) THEN
            IF ( associated(id%COLSCA)) DEALLOCATE( id%COLSCA )
            IF ( associated(id%ROWSCA)) DEALLOCATE( id%ROWSCA )
            ALLOCATE( id%COLSCA(N), stat=allocok)
            IF (allocok .GT.0) THEN
               id%INFO(1)=-5
               id%INFO(2)=N
               IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
                  WRITE (LP,'(/A)') '** Error in DMUMPS_203'
                  WRITE (LP,'(A)')                                      &
     &                 '** Failure during allocation of COLSCA'
                  GOTO 500
               ENDIF
            ENDIF
            ALLOCATE( id%ROWSCA(N), stat=allocok)
            IF (allocok .GT.0) THEN
               id%INFO(1)=-5
               id%INFO(2)=N
               IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
                  WRITE (LP,'(/A)') '** Error in DMUMPS_203'
                  WRITE (LP,'(A)')                                      &
     &                 '** Failure during allocation of ROWSCA'
                  GOTO 500
               ENDIF
            ENDIF
            id%KEEP(52) = -2
            id%KEEP(74) = 1
            MAXDBL = log(huge(MAXDBL))
            DO J=1,N
               IF(S2(RSPOS+J)+S2(CSPOS+J) .GT. MAXDBL) THEN
                  S2(RSPOS+J) = ZERO
                  S2(CSPOS+J)= ZERO
               ENDIF
            ENDDO
            DO J=1,N
               IF(PERM(J) .GT. 0) THEN
                  id%ROWSCA(J) =                                        &
     &                 exp((S2(RSPOS+J)+S2(CSPOS+J))/TWO)
                  IF(id%ROWSCA(J) .EQ. ZERO) THEN
                     id%ROWSCA(J) = ONE
                  ENDIF
                  id%COLSCA(J)= id%ROWSCA(J)
               ENDIF
            ENDDO
            DO JPOS=1,KER_SIZE
               I = STR_KER(JPOS)
               COLNORM = ZERO
               DO J = IW(IP+I-1),IW(IP+J) - 1
                  COLNORM = max(COLNORM,S2(J))
               ENDDO
               COLNORM = exp(COLNORM)
               id%ROWSCA(I) = ONE / COLNORM
               id%COLSCA(I) = id%ROWSCA(I)
            ENDDO
         ENDIF
         IF(MTRANS .EQ. 7 .OR. id%KEEP(95) .EQ. 0) THEN
            IF( (NZER_DIAG+RZ_DIAG) .LT. (N/10)                         &
     &           .AND. id%KEEP(95) .EQ. 0) THEN
               MTRANS = 0
               id%KEEP(95) = 1
               GOTO 390
            ELSE
               IF(id%KEEP(95) .EQ. 0) THEN
                 IF(SCALINGLOC) THEN
                  id%KEEP(95) = 3
                 ELSE
                  id%KEEP(95) = 2
                 ENDIF
               ENDIF
               IF(MTRANS .EQ. 7) MTRANS = 5
            ENDIF
         ENDIF
         IF(MTRANS .EQ. 0) GOTO 390
         ICNTL_SYM_MWM = 0
         INFO_SYM_MWM = 0
         IF(MTRANS .EQ. 5 .OR. MTRANS .EQ. 6 .OR.                       &
     &        MTRANS .EQ. 7) THEN
            ICNTL_SYM_MWM(1) = 0
            ICNTL_SYM_MWM(2) = 1
         ELSE IF(MTRANS .EQ. 4) THEN
            ICNTL_SYM_MWM(1) = 2
            ICNTL_SYM_MWM(2) = 1
         ELSE
            ICNTL_SYM_MWM(1) = 0
            ICNTL_SYM_MWM(2) = 1
         ENDIF
         MARKED => id%IS1(2*N+1:3*N)
         FLAG => id%IS1(3*N+1:4*N)
         PIV_OUT => id%IS1(4*N+1:5*N)
         IF(MTRANSLOC .LT. 4) THEN
            LSC = 1
         ELSE
            LSC = 2*N
         ENDIF
         CALL DAGMG_MUMPS_551(                                               &
     &        N, NZREAL, IW(IP), IW(IRNW), S2(1),LSC, PERM, ZERODIAG,   &
     &        ICNTL_SYM_MWM, S2(LSC+1),MARKED,FLAG,                     &
     &        PIV_OUT, INFO_SYM_MWM)
         IF(INFO_SYM_MWM(1) .NE. 0) THEN
            WRITE(*,*) '** Error in DMUMPS_203'
            RETURN
         ENDIF
         IF(INFO_SYM_MWM(3) .EQ. N) THEN
            IDENT = .TRUE.
         ELSEIF( (N-INFO_SYM_MWM(4)-INFO_SYM_MWM(3)) .GT. N/10          &
     &           ) THEN
            IDENT = .TRUE.
            id%KEEP(95) = 1
         ELSE
            DO I=1,N
               PERM(I) = PIV_OUT(I)
            ENDDO
         ENDIF
         id%KEEP(93) = INFO_SYM_MWM(4)
         id%KEEP(94) = INFO_SYM_MWM(3)
         IF (IDENT) MTRANS=0
      ENDIF
  390 IF(MTRANS .EQ. 0) THEN
         id%KEEP(95) = 1
         IF (PROK) THEN
           WRITE (MPRINT,'(A)')                                         &
     &  ' ... Column permutation not used'
         ENDIF
      ENDIF
      GO TO 500
  400 IF ((LP.GE.0).AND.(ICNTL(4).GE.1))                                &
     &   WRITE (LP,'(/A)') '** Error: Matrix is structurally singular'
      INFO(1) = -6
      INFO(2) = NUMNZ
      GOTO 500
  410 IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
       WRITE (LP,'(/A)') '** Error in DMUMPS_203'
       WRITE (LP,'(A,I9)')                                              &
     & '** Failure during allocation of INTEGER array of size ',        &
     & LIWG
      ENDIF
      INFO(1) = -5
      INFO(2) = LIWG
      GOTO 500
  430 IF ((LP.GE.0).AND.(ICNTL(4).GE.1)) THEN
       WRITE (LP,'(/A)') '** Error in DMUMPS_203'
       WRITE (LP,'(A)') '** Failure during allocation of S2'
      ENDIF
      INFO(1) = -5
      INFO(2) = LDW
  500 CONTINUE
      IF (allocated(IW)) DEALLOCATE(IW)
      IF (allocated(S2)) DEALLOCATE(S2)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_203
      SUBROUTINE DAGMG_MUMPS_21( N, MYID,PROCNODE, ND,                       &
     &                         SSARBR, NBSA, FRERE, FILS,               &
     &                         SLAVEF,                                  &
     &                         KEEP,KEEP8, ICNTL, INFO )
      IMPLICIT NONE
      INTEGER KEEP(500), ICNTL(40), INFO(40)
      INTEGER*8 KEEP8(150)
      INTEGER N, NBSA, SLAVEF, MYID
      INTEGER PROCNODE( N ), ND( N )
      INTEGER SSARBR( NBSA ), FRERE( N ), FILS( N )
      LOGICAL  AGMG_MUMPS_167, AGMG_MUMPS_283
      INTEGER  AGMG_MUMPS_330, AGMG_MUMPS_275, AGMG_MUMPS_497
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275,                                    &
     &         AGMG_MUMPS_167, AGMG_MUMPS_283, AGMG_MUMPS_497
      INTEGER I, INODE, INODEROOT, IN, NPIV, NFRONT, NFR, NB_NIV2
      INTEGER IROOTTREE, SIZEROOT, PROCVAL, NSLAVES, KMAX
      INTEGER NNODE, ICT, TPN, MP, allocok
      LOGICAL ONE_LEVEL2
      INTEGER, ALLOCATABLE :: NUMNODE( : ), COST( : ),                  &
     &                        MEMUSED( : ), NODEMAP(:)
      MP = ICNTL(3)
      SIZEROOT  = -1
      IROOTTREE = -1
      NB_NIV2  = 0
      IF ( SLAVEF .eq. 1 ) THEN
       DO INODE = 1, N
          PROCNODE(INODE) = PROCNODE( INODE ) - SLAVEF
       END DO
      ELSE
       DO I = 1, NBSA
         INODEROOT = SSARBR( I )
         PROCNODE( INODEROOT ) = PROCNODE( INODEROOT )                  &
     &                         - SLAVEF
         INODE = INODEROOT
   30    CONTINUE
         IN = INODE
         DO WHILE ( IN .NE. 0 )
           INODE = IN
           DO WHILE ( IN .GT. 0 )
             IN = FILS( IN )
           END DO
           IF ( IN .LT. 0 ) IN = - IN
         END DO
   10    CONTINUE
         IF ( INODE .EQ. INODEROOT ) GOTO 100
         PROCNODE( INODE ) = PROCNODE( INODE ) - 2 * SLAVEF
         IN = FRERE( INODE )
         INODE = abs( IN )
         IF ( IN .LT. 0 ) THEN
             GO TO 10
         ELSE
             GO TO 30
         END IF
  100    CONTINUE
        END DO
      END IF
      ONE_LEVEL2 = .FALSE.
      DO INODE = 1, N
        IF ( FRERE( INODE ) .LT. N + 1 .AND.                            &
     &     .NOT. AGMG_MUMPS_167( INODE, PROCNODE, SLAVEF ) ) THEN
          IN = INODE
          NPIV = 0
          DO WHILE ( IN.GT.0 )
            IN = FILS( IN )
            NPIV = NPIV + 1
          END DO
          NFRONT = ND( INODE )
          IF ( (AGMG_MUMPS_283( INODE,PROCNODE,SLAVEF).AND.                  &
     &     (IN.NE.0.OR.NFRONT.NE.NPIV )) .OR. SLAVEF.EQ.1 ) GOTO 991
          IF ( NFRONT-NPIV > KEEP(9) .AND.                              &
     &         ( NPIV > KEEP(4) .OR. KEEP(45) .EQ. 0 )                  &
     &         .AND. ICNTL(40) .EQ. 0 ) THEN
            PROCNODE( INODE ) = PROCNODE( INODE ) + SLAVEF
            ONE_LEVEL2 = .TRUE.
            NB_NIV2 = NB_NIV2 + 1
          END IF
          IF ( NFRONT .EQ. NPIV ) THEN
            IF ( NFRONT .GT. SIZEROOT ) THEN
              IROOTTREE = INODE
              SIZEROOT  = NFRONT
            END IF
          END IF
        END IF
  991   CONTINUE
        IF ( ( SLAVEF .eq. 1 .OR.                                       &
     &         AGMG_MUMPS_283( INODE, PROCNODE, SLAVEF ) )                   &
     &         .AND. KEEP(53) .NE. 0 .AND.                              &
     &         FRERE( INODE ) .LT. N + 1 ) THEN
          IN = INODE
          NPIV = 0
          DO WHILE ( IN.GT.0 )
            IN = FILS( IN )
            NPIV = NPIV + 1
          END DO
          NFRONT = ND( INODE )
          IF ( NFRONT .EQ. NPIV ) THEN
            IF ( NFRONT .GT. SIZEROOT ) THEN
              IROOTTREE = INODE
              SIZEROOT  = NFRONT
            END IF
          END IF
        END IF
      END DO
      KEEP ( 56 ) = NB_NIV2
      IF ( SIZEROOT .GT. KEEP( 37 )                                     &
     &       .and. (ICNTL(13) .LE. 0 )                                  &
     &       .and. KEEP(60) .EQ. 0                                      &
     &       .and. KEEP(53) .eq. 0                                      &
     &  ) THEN
         IF ( MP .GT. 0 )                                               &
     &   WRITE( MP, * ) 'A root of estimated size ',SIZEROOT,           &
     &   ' has been selected for Scalapack'
        KEEP(38) = IROOTTREE
        PROCNODE( IROOTTREE ) = 1 + 2 * SLAVEF
      ELSE IF (KEEP(60) .EQ. 2 .OR. KEEP(60).EQ.3) THEN
        PROCNODE( KEEP(38) ) = 1 + 2 * SLAVEF
        IF ( MP .GT. 0 )                                                &
     &  WRITE( MP, * ) ' Largest root node of size ',SIZEROOT
      ELSE
        KEEP(38) = 0
        IF ( MP .GT. 0 )                                                &
     &  WRITE( MP, * ) ' Largest root node of size ',SIZEROOT
      END IF
      DO INODE = 1, N
        IF ( FRERE( INODE ) .LT. N + 1 ) THEN
          IN = FILS( INODE )
          DO WHILE ( IN > 0 )
            PROCNODE( IN ) = PROCNODE( INODE )
            IN = FILS( IN )
          END DO
        END IF
      END DO
      IF ( KEEP( 45 ) .NE. 0 ) RETURN
      NNODE = 0
      DO INODE = 1, N
        IF ( FRERE( INODE ) .LT. N + 1 ) THEN
          TPN = AGMG_MUMPS_330( INODE, PROCNODE, SLAVEF )
          IF ( TPN .NE. 3 .AND.                                         &
     &         .not. AGMG_MUMPS_283( INODE, PROCNODE, SLAVEF ) .AND.         &
     &         .not. AGMG_MUMPS_167( INODE, PROCNODE, SLAVEF ) ) THEN
               NNODE = NNODE + 1
          END IF
        END IF
      END DO
      IF ( NNODE .GT. 0 ) THEN
        ALLOCATE( NUMNODE( NNODE  ), stat = allocok )
        if (allocok .gt. 0) THEN
          INFO(1) = -7
          INFO(2) = NNODE
          RETURN
        endif
        ALLOCATE( NODEMAP( NNODE  ), stat = allocok )
        if (allocok .gt. 0) THEN
          INFO(1) = -7
          INFO(2) = NNODE
          RETURN
        endif
        ALLOCATE( COST   ( NNODE  ), stat = allocok )
        if (allocok .gt. 0) THEN
          INFO(1) = -7
          INFO(2) = NNODE
          RETURN
        endif
        ALLOCATE( MEMUSED( SLAVEF ), stat = allocok )
        if (allocok .gt. 0) THEN
          INFO(1) = -7
          INFO(2) = SLAVEF
          RETURN
        endif
        MEMUSED( 1: SLAVEF ) = 0
        ICT = 0
        DO INODE = 1, N
        IF ( FRERE( INODE ) .LT. N + 1 ) THEN
          TPN = AGMG_MUMPS_330( INODE, PROCNODE, SLAVEF )
          IF ( TPN .NE. 3 .AND.                                         &
     &       .not. AGMG_MUMPS_283( INODE, PROCNODE, SLAVEF ) .AND.           &
     &       .not. AGMG_MUMPS_167( INODE, PROCNODE, SLAVEF ) ) THEN
             ICT            = ICT + 1
             NUMNODE( ICT ) = INODE
             NFR  = ND( INODE )
             NPIV = 0
             IN   = INODE
             DO WHILE ( IN .GT. 0 )
               NPIV = NPIV + 1
               IN = FILS( IN )
             END DO
             IF ( TPN .eq. 1 ) THEN
               IF ( KEEP( 50 ) .eq. 0 ) THEN
                 COST( ICT ) = NPIV * ( 2 * NFR - NPIV )
               ELSE
                 COST( ICT ) = NPIV * NFR
               END IF
             ELSE
               KMAX  = AGMG_MUMPS_497( KEEP8(21), NFR - NPIV)
               NSLAVES     = max( min((NFR-NPIV)/KMAX, SLAVEF-1),       &
     &                            1 )
               IF ( KEEP(50) .eq. 0 ) THEN
                 COST( ICT ) = NPIV * NFR - NPIV *                      &
     &           ( ( NFR - NPIV ) / NSLAVES )
               ELSE
                 COST( ICT ) = NPIV * NPIV - NPIV *                     &
     &           ( ( NFR - NPIV ) / NSLAVES )
               END IF
             END IF
          ELSE IF ( AGMG_MUMPS_283( INODE, PROCNODE, SLAVEF ) .OR.           &
     &              AGMG_MUMPS_167( INODE, PROCNODE, SLAVEF )  ) THEN
               NFR  = ND( INODE )
               NPIV = 0
               IN   = INODE
               DO WHILE ( IN .GT. 0 )
                 NPIV = NPIV + 1
                 IN = FILS( IN )
               END DO
               IF ( KEEP( 50 ) .eq. 0 ) THEN
                 MEMUSED(1+AGMG_MUMPS_275( INODE, PROCNODE, SLAVEF))         &
     &           = MEMUSED(1+AGMG_MUMPS_275( INODE, PROCNODE, SLAVEF))       &
     &           + NPIV * ( 2 * NFR - NPIV )
               ELSE
                 MEMUSED(1+AGMG_MUMPS_275( INODE, PROCNODE, SLAVEF))         &
     &           = MEMUSED(1+AGMG_MUMPS_275( INODE, PROCNODE, SLAVEF))       &
     &           + NPIV * NFR
               END IF
          END IF
        END IF
        END DO
        CALL DAGMG_MUMPS_212( N, NNODE, NUMNODE, COST, MEMUSED,              &
     &                               PROCNODE, SLAVEF, NODEMAP )
        DO I = 1, NNODE
          INODE   = NUMNODE( I )
          PROCVAL = PROCNODE( INODE ) + ( NODEMAP( I ) - 1 )            &
     &            - AGMG_MUMPS_275( INODE, PROCNODE, SLAVEF )
          IN = INODE
          DO WHILE ( IN > 0 )
            PROCNODE( IN ) = PROCVAL
            IN = FILS( IN )
          END DO
        END DO
        DEALLOCATE( NUMNODE )
        DEALLOCATE( NODEMAP )
        DEALLOCATE( COST    )
        DEALLOCATE( MEMUSED )
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_21
      SUBROUTINE DAGMG_MUMPS_212( N, NNODE, NUMNODE, COST,                   &
     &       MEMUSED, PROCNODE, SLAVEF, NODEMAP )
      IMPLICIT NONE
      INTEGER N, NNODE, SLAVEF
      INTEGER PROCNODE( N )
      INTEGER NUMNODE( NNODE ), COST( NNODE ), NODEMAP( NNODE )
      INTEGER MEMUSED( SLAVEF )
      INTEGER IMAXLOAD, IMINLOAD, IPROC, INODE
      CALL DAGMG_MUMPS_149                                                   &
     &       ( MEMUSED, SLAVEF, IMINLOAD, IMAXLOAD )
      CALL DAGMG_MUMPS_260( NNODE, NUMNODE, COST )
      DO INODE = 1, NNODE
        IF ( COST( INODE ) > 0 ) THEN
          IPROC = IMINLOAD
        ELSE
          IPROC = IMAXLOAD
        END IF
        MEMUSED( IPROC ) = MEMUSED( IPROC ) + COST( INODE )
        NODEMAP( INODE ) = IPROC
        CALL DAGMG_MUMPS_149                                                 &
     &       ( MEMUSED, SLAVEF, IMINLOAD, IMAXLOAD )
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_212
      SUBROUTINE DAGMG_MUMPS_149                                             &
     &           ( MEMUSED, SLAVEF, IMINLOAD, IMAXLOAD )
      INTEGER SLAVEF, IMINLOAD, IMAXLOAD
      INTEGER MEMUSED( SLAVEF )
      INTEGER MINLOAD, MAXLOAD, IPROC
      MINLOAD = MEMUSED( 1 )
      MAXLOAD = MEMUSED( 1 )
      IMINLOAD = 1
      IMAXLOAD = 1
      DO IPROC = 2, SLAVEF
        IF ( MEMUSED( IPROC ) .GT. MAXLOAD ) THEN
          MAXLOAD  = MEMUSED( IPROC )
          IMAXLOAD = IPROC
        END IF
        IF ( MEMUSED( IPROC ) .LT. MINLOAD ) THEN
          MINLOAD  = MEMUSED( IPROC )
          IMINLOAD = IPROC
        END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_149
      SUBROUTINE DAGMG_MUMPS_260( NNODE, NUMNODE, COST )
      IMPLICIT NONE
      INTEGER NNODE
      INTEGER NUMNODE( NNODE ), COST( NNODE )
      LOGICAL FIN
      INTEGER I, LOC_COST, LOC_NUM
      FIN = .FALSE.
      DO WHILE ( .NOT. FIN )
        FIN = .TRUE.
        DO I = 1, NNODE - 1
          IF ( abs( COST( I ) ) .LT. abs( COST( I + 1 ) ) ) THEN
            LOC_COST      = COST( I )
            COST( I )     = COST( I + 1 )
            COST( I + 1 ) = LOC_COST
            LOC_NUM          = NUMNODE( I )
            NUMNODE( I )     = NUMNODE( I + 1 )
            NUMNODE( I + 1 ) = LOC_NUM
            FIN = .FALSE.
          END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_260
      SUBROUTINE DAGMG_MUMPS_100                                             &
     &( MYID, COMM, KEEP,KEEP8, INFO, INFOG, RINFO, RINFOG, ICNTL )
      IMPLICIT NONE
      INTEGER COMM, MYID, KEEP(500), INFO(40), ICNTL(40), INFOG(40)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION RINFO(20), RINFOG(20)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MASTER, IERR_MPI, MPG
      PARAMETER( MASTER = 0 )
      MPG = ICNTL(3)
      IF ( MYID.eq.MASTER.and.MPG.GT.0) THEN
       WRITE(MPG, 99992) INFO(1), INFO(2),                              &
     &  KEEP8(109), KEEP8(111), INFOG(4),                               &
     &  INFOG(5), KEEP(28), INFOG(32), INFOG(7), KEEP(23), ICNTL(7),    &
     &  KEEP(12), KEEP(56), KEEP(61), RINFOG(1)
       IF (KEEP(95).GT.1)                                               &
     &                    WRITE(MPG, 99993) KEEP(95)
       IF (KEEP(54).GT.0) WRITE(MPG, 99994) KEEP(54)
       IF (KEEP(60).GT.0) WRITE(MPG, 99995) KEEP(60)
      ENDIF
      RETURN
99992 FORMAT(/'Leaving analysis phase with  ...'/                       &
     &       'INFOG(1)                                       =',I16/    &
     &       'INFOG(2)                                       =',I16/    &
     &       ' -- (20) Number of entries in factors (estim.) =',I16/    &
     &       ' --  (3) Storage of factors  (REAL, estimated) =',I16/    &
     &       ' --  (4) Storage of factors  (INT , estimated) =',I16/    &
     &       ' --  (5) Maximum frontal size      (estimated) =',I16/    &
     &       ' --  (6) Number of nodes in the tree           =',I16/    &
     &       ' -- (32) Type of analysis effectively used     =',I16/    &
     &       ' --  (7) Ordering option effectively used      =',I16/    &
     &       'ICNTL(6) Maximum transversal option            =',I16/    &
     &       'ICNTL(7) Pivot order option                    =',I16/    &
     &       'Percentage of memory relaxation (effective)    =',I16/    &
     &       'Number of level 2 nodes                        =',I16/    &
     &       'Number of split nodes                          =',I16/    &
     &   'RINFOG(1) Operations during elimination (estim)=  ',1PD10.3)
99993 FORMAT('Ordering compressed/constrained (ICNTL(12))    =',I16)
99994 FORMAT('Distributed matrix entry format (ICNTL(18))    =',I16)
99995 FORMAT('Effective Schur option (ICNTL(19))             =',I16)
      END SUBROUTINE DAGMG_MUMPS_100
      SUBROUTINE DAGMG_MUMPS_97                                              &
     &           ( N, FRERE, FILS, NFSIZ, NSTEPS, NSLAVES,              &
     &             KEEP, KEEP8, SPLITROOT, MP, LDIAG, INFO1, INFO2 )
      IMPLICIT NONE
      INTEGER N, NSTEPS, NSLAVES, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER FRERE( N ), FILS( N ), NFSIZ( N )
      LOGICAL SPLITROOT
      INTEGER MP, LDIAG
      INTEGER INFO1, INFO2
      INTEGER, DIMENSION(:), ALLOCATABLE :: IPOOL
      INTEGER INODE, DEPTH, I, IBEG, IEND, IIPOOL, NROOT
      INTEGER MAX_DEPTH, ISON, TOT_CUT, MAX_CUT, STRAT
      INTEGER(8) :: K79
      INTEGER NFRONT, K82, allocok
      K79  = KEEP8(79)
      K82  = abs(KEEP(82))
      STRAT=KEEP(62)
      IF (KEEP(210).EQ.1) THEN
        MAX_DEPTH = 2*NSLAVES*K82
        STRAT     = STRAT/4
      ELSE
        IF (( NSLAVES .eq. 1 ).AND. (.NOT. SPLITROOT) ) RETURN
        MAX_DEPTH = int( log( dble( NSLAVES - 1 ) )                     &
     &                 / log(2.0D0) )
      ENDIF
      ALLOCATE(IPOOL(NSTEPS+1), stat=allocok)
      IF (allocok.GT.0) THEN
        INFO1= -7
        INFO2= NSTEPS+1
        RETURN
      ENDIF
      NROOT = 0
      DO INODE = 1, N
        IF ( FRERE(INODE) .eq. 0 ) THEN
          NROOT = NROOT + 1
          IPOOL( NROOT ) = INODE
        END IF
      END DO
      IBEG = 1
      IEND = NROOT
      IIPOOL   = NROOT + 1
      IF (SPLITROOT) MAX_DEPTH=1
      DO DEPTH = 1, MAX_DEPTH
        DO I = IBEG, IEND
          INODE = IPOOL( I )
          ISON = INODE
          DO WHILE ( ISON .GT. 0 )
            ISON = FILS( ISON )
          END DO
          ISON = - ISON
          DO WHILE ( ISON .GT. 0 )
            IPOOL( IIPOOL ) = ISON
            IIPOOL = IIPOOL + 1
            ISON = FRERE( ISON )
          END DO
        END DO
        IPOOL( IBEG ) = -IPOOL( IBEG )
        IBEG = IEND + 1
        IEND = IIPOOL - 1
      END DO
      IPOOL( IBEG ) = -IPOOL( IBEG )
      TOT_CUT = 0
      IF (SPLITROOT) THEN
        MAX_CUT = NROOT*max(K82,2)
        INODE = abs(IPOOL(1))
        NFRONT = NFSIZ( INODE )
        K79 = max(                                                      &
     &         int(NFRONT,8)*int(NFRONT,8)/(int(K82+1,8)*int(K82+1,8)), &
     &         1_8)
      ELSE
         MAX_CUT = 2 * NSLAVES
         IF (KEEP(210).EQ.1) THEN
            MAX_CUT = 4 * (MAX_CUT + 4)
         ENDIF
      ENDIF
      DEPTH   = -1
      DO I = 1, IIPOOL - 1
        INODE = IPOOL( I )
        IF ( INODE .LT. 0 ) THEN
          INODE = -INODE
          DEPTH = DEPTH + 1
        END IF
        CALL DAGMG_MUMPS_313                                                 &
     &           ( INODE, N, FRERE, FILS, NFSIZ, NSTEPS, NSLAVES,       &
     &             KEEP,KEEP8, TOT_CUT, STRAT, DEPTH,                   &
     &             K79, SPLITROOT, MP, LDIAG )
        IF ( TOT_CUT > MAX_CUT )  EXIT
      END DO
      KEEP(61) = TOT_CUT
      DEALLOCATE(IPOOL)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_97
      RECURSIVE SUBROUTINE DAGMG_MUMPS_313                                   &
     & ( INODE, N, FRERE, FILS, NFSIZ, NSTEPS, NSLAVES, KEEP,KEEP8,     &
     &   TOT_CUT, STRAT, DEPTH, K79, SPLITROOT, MP, LDIAG )
      IMPLICIT NONE
      INTEGER(8) :: K79
      INTEGER INODE, N, NSTEPS, NSLAVES, KEEP(500), STRAT,              &
     &        DEPTH, TOT_CUT, MP, LDIAG
      INTEGER*8 KEEP8(150)
      INTEGER FRERE( N ), FILS( N ), NFSIZ( N )
      LOGICAL SPLITROOT
      INTEGER I, IN, NPIV, NFRONT, NSLAVES_ESTIM
      DOUBLE PRECISION WK_SLAVE, WK_MASTER
      INTEGER INODE_SON, INODE_FATH, IN_SON, IN_FATH, IN_GRANDFATH
      INTEGER NPIV_SON, NPIV_FATH, MAX_CUT
      INTEGER NCB, KAVERAGE, NSLAVESMIN, NSLAVESMAX
      INTEGER  AGMG_MUMPS_50,                                                &
     &         AGMG_MUMPS_52
      EXTERNAL  AGMG_MUMPS_50,                                               &
     &         AGMG_MUMPS_52
      IF  ( (KEEP(210).EQ.1.AND.KEEP(60).EQ.0) .OR.                     &
     &       (SPLITROOT) ) THEN
        IF ( FRERE ( INODE ) .eq. 0 ) THEN
          NFRONT = NFSIZ( INODE )
          NPIV = NFRONT
          NCB = 0
          IF (int(NFRONT,8)*int(NFRONT,8).GT.K79) THEN
           GOTO 333
          ELSE IF ( (SPLITROOT).AND.                                    &
     &      (MP.GT.0 .AND. LDIAG.GE.2)) THEN
             WRITE(MP,'(A,I11)')                                        &
     &        ' Order of root node after splitting : ',                 &
     &        NFRONT
          ENDIF
        ENDIF
      ENDIF
      IF ( FRERE ( INODE ) .eq. 0 ) RETURN
      NFRONT = NFSIZ( INODE )
      IN = INODE
      NPIV = 0
      DO WHILE( IN > 0 )
        IN = FILS( IN )
        NPIV = NPIV + 1
      END DO
      NCB = NFRONT - NPIV
      IF ( (NFRONT - (NPIV/2)) .LE. KEEP(9)) RETURN
      IF ((KEEP(50) == 0.and.int(NFRONT,8) * int(NPIV,8) > K79 ) .OR.   &
     &(KEEP(50) .NE.0.and.int(NPIV,8) * int(NPIV,8) > K79 )) GOTO 333
      IF (KEEP(210).EQ.1) THEN
        NSLAVESMIN    = 1
        NSLAVESMAX    = 64
        NSLAVES_ESTIM = 32+NSLAVES
      ELSE
        NSLAVESMIN = AGMG_MUMPS_50                                           &
     &         ( NSLAVES, KEEP(48), KEEP8(21), KEEP(50),                &
     &         NFRONT, NCB)
        NSLAVESMAX = AGMG_MUMPS_52                                           &
     &        ( NSLAVES, KEEP(48), KEEP8(21), KEEP(50),                 &
     &          NFRONT, NCB)
        NSLAVES_ESTIM = max (1,                                         &
     &   nint( dble(NSLAVESMAX-NSLAVESMIN)/dble(3) )                    &
     &                    )
        NSLAVES_ESTIM = min (NSLAVES_ESTIM, NSLAVES-1)
      ENDIF
      IF ( KEEP(50) .eq. 0 ) THEN
       WK_MASTER = 0.6667D0 *                                           &
     &                dble(NPIV)*dble(NPIV)*dble(NPIV) +                &
     &                dble(NPIV)*dble(NPIV)*dble(NCB)
       WK_SLAVE  = dble( NPIV ) * dble( NCB ) *                         &
     &         ( 2.0D0 * dble(NFRONT) - dble(NPIV) )                    &
     &         / dble(NSLAVES_ESTIM)
      ELSE
       WK_MASTER = dble(NPIV)*dble(NPIV)*dble(NPIV) / dble(3)
       WK_SLAVE  =                                                      &
     &           (dble(NPIV)*dble(NCB)*dble(NFRONT))                    &
     &           / dble(NSLAVES_ESTIM)
      ENDIF
      IF (KEEP(210).EQ.1) THEN
        IF ( dble( 100 + STRAT )                                        &
     &        * WK_SLAVE / dble(100) .GE. WK_MASTER ) RETURN
      ELSE
        IF ( dble( 100 + STRAT * max( DEPTH-1, 1 ) )                    &
     &        * WK_SLAVE / dble(100) .GE. WK_MASTER ) RETURN
      ENDIF
  333 CONTINUE
      IF (NPIV .LE. 1 ) RETURN
       NSTEPS  = NSTEPS + 1
       TOT_CUT = TOT_CUT + 1
       NPIV_SON  = max(NPIV/2,1)
       NPIV_FATH = NPIV - NPIV_SON
       INODE_SON = INODE
       IN_SON = INODE
       DO I = 1, NPIV_SON - 1
         IN_SON = FILS( IN_SON )
       END DO
       INODE_FATH = FILS( IN_SON )
       IF ( INODE_FATH .LT. 0 ) THEN
       write(*,*) 'Error: INODE_FATH < 0 ', INODE_FATH
       END IF
       IN_FATH = INODE_FATH
       DO WHILE ( FILS( IN_FATH ) > 0 )
         IN_FATH = FILS( IN_FATH )
       END DO
       FRERE( INODE_FATH ) = FRERE( INODE_SON )
       FRERE( INODE_SON  ) = - INODE_FATH
       FILS ( IN_SON     ) = FILS( IN_FATH )
       FILS ( IN_FATH    ) = - INODE_SON
       IN = FRERE( INODE_FATH )
       DO WHILE ( IN > 0 )
           IN = FRERE( IN )
       END DO
       IF ( IN .eq. 0 )  GO TO 10
       IN = -IN
       DO WHILE ( FILS( IN ) > 0 )
           IN = FILS( IN )
       END DO
       IN_GRANDFATH = IN
       IF ( FILS( IN_GRANDFATH ) .eq. - INODE_SON ) THEN
           FILS( IN_GRANDFATH ) = -INODE_FATH
       ELSE
           IN = IN_GRANDFATH
           IN = - FILS ( IN )
           DO WHILE ( FRERE( IN ) > 0 )
             IF ( FRERE( IN ) .eq. INODE_SON ) THEN
               FRERE( IN ) = INODE_FATH
               GOTO 10
             END IF
             IN = FRERE( IN )
           END DO
           WRITE(*,*) 'ERROR 2 in SPLIT NODE',                          &
     &          IN_GRANDFATH, IN, FRERE(IN)
       END IF
   10  CONTINUE
       NFSIZ(INODE_SON) = NFRONT
       NFSIZ(INODE_FATH) = NFRONT - NPIV_SON
       KEEP(2) = max( KEEP(2), NFRONT - NPIV_SON )
      CALL DAGMG_MUMPS_313                                                   &
     &  ( INODE_FATH, N, FRERE, FILS, NFSIZ, NSTEPS,                    &
     &   NSLAVES, KEEP,KEEP8, TOT_CUT, STRAT, DEPTH,                    &
     &   K79, SPLITROOT, MP, LDIAG )
      IF (.NOT. SPLITROOT) THEN
        CALL DAGMG_MUMPS_313                                                 &
     &   ( INODE_SON, N, FRERE, FILS, NFSIZ, NSTEPS,                    &
     &   NSLAVES, KEEP,KEEP8, TOT_CUT, STRAT, DEPTH,                    &
     &   K79, SPLITROOT, MP, LDIAG )
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_313
      SUBROUTINE DAGMG_MUMPS_351                                             &
     & (N,NZ, IRN, ICN, IW, LW, IPE, LEN,                               &
     & IQ, FLAG, IWFR,                                                  &
     & NRORM, NIORM, IFLAG,IERROR, ICNTL,                               &
     & symmetry, SYM, MedDens, NBQD, AvgDens)
      INTEGER N,NZ,LW,IFLAG,IERROR,NRORM,NIORM,IWFR
      INTEGER symmetry, SYM
      INTEGER MedDens, NBQD, AvgDens
      INTEGER ICNTL(40)
      INTEGER  IRN(NZ), ICN(NZ)
      INTEGER LEN(N)
      INTEGER IPE(N+1)
      INTEGER FLAG(N), IW(LW)
      INTEGER IQ(N)
      INTEGER MP, MPG
      INTEGER I,K,J,N1,LAST,NDUP,K1,K2,L
      INTEGER NBERR, THRESH
      INTEGER NZOFFA, NDIAGA
      DOUBLE PRECISION RSYM
      INTRINSIC nint
      MP = ICNTL(2)
      MPG= ICNTL(3)
      NIORM  = 3*N
      NDIAGA = 0
      IERROR = 0
      DO 10 I=1,N
        IPE(I) = 0
   10 END DO
      DO 50 K=1,NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I.GT.N).OR.(J.GT.N).OR.(I.LT.1)                            &
     &                          .OR.(J.LT.1)) THEN
           IERROR = IERROR + 1
        ELSE
          IF (I.NE.J) THEN
           IPE(I) = IPE(I) + 1
           IPE(J) = IPE(J) + 1
           NIORM  = NIORM + 1
          ELSE
           NDIAGA = NDIAGA + 1
          ENDIF
        ENDIF
   50 END DO
      NZOFFA  = NIORM - 3*N
      IF (IERROR.GE.1) THEN
         NBERR  = 0
         IF (mod(IFLAG,2) .EQ. 0) IFLAG = IFLAG+1
         IF ((MP.GT.0).AND.(ICNTL(4).GE.2))  THEN
          WRITE (MP,99999)
          DO 70 K=1,NZ
           I = IRN(K)
           J = ICN(K)
           IF ((I.GT.N).OR.(J.GT.N).OR.(I.LT.1)                         &
     &                            .OR.(J.LT.1)) THEN
            NBERR = NBERR + 1
            IF (NBERR.LE.10)  THEN
               IF (mod(K,10).GT.3 .OR. mod(K,10).EQ.0 .OR.              &
     &             (10.LE.K .AND. K.LE.20)) THEN
                 WRITE (MP,'(I8,A,I8,A,I8,A)')                          &
     &             K,'th entry (in row',I,' and column',J,') ignored'
               ELSE
                 IF (mod(K,10).EQ.1) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'st entry (in row',I,' and column',J,') ignored'
                 IF (mod(K,10).EQ.2) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'nd entry (in row',I,' and column',J,') ignored'
                 IF (mod(K,10).EQ.3) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'rd entry (in row',I,' and column',J,') ignored'
               ENDIF
            ELSE
               GO TO 100
            ENDIF
           ENDIF
   70     CONTINUE
         ENDIF
      ENDIF
  100 NRORM = NIORM - 2*N
      IQ(1) = 1
      N1 = N - 1
      IF (N1.GT.0) THEN
        DO 110 I=1,N1
            IQ(I+1) = IPE(I) + IQ(I)
  110   CONTINUE
      ENDIF
      LAST = max(IPE(N)+IQ(N)-1,IQ(N))
      FLAG(1:N) = 0
      IPE(1:N)  = IQ(1:N)
      IW(1:LAST) = 0
      IWFR = LAST + 1
      DO 200 K=1,NZ
         I = IRN(K)
         J = ICN(K)
         IF (I.NE.J) THEN
          IF (I.LT.J) THEN
            IF ((I.GE.1).AND.(J.LE.N)) THEN
             IW(IQ(I)) = -J
             IQ(I)     = IQ(I) + 1
            ENDIF
          ELSE
            IF ((J.GE.1).AND.(I.LE.N)) THEN
             IW(IQ(J)) = -I
             IQ(J)     = IQ(J) + 1
            ENDIF
          ENDIF
         ENDIF
  200 END DO
      NDUP = 0
      DO 260 I=1,N
        K1 = IPE(I)
        K2 = IQ(I) -1
        IF (K1.GT.K2) THEN
         LEN(I) = 0
         IQ(I)  = 0
        ELSE
         DO 240 K=K1,K2
           J     = -IW(K)
           IF (J.LE.0) GO TO 250
           L     = IQ(J)
           IQ(J) = L + 1
           IF (FLAG(J).EQ.I) THEN
            NDUP = NDUP + 1
            IW(L) = 0
            IW(K) = 0
           ELSE
            IW(L)   = I
            IW(K)   = J
            FLAG(J) = I
           ENDIF
  240    CONTINUE
  250    IQ(I) = IQ(I) - IPE(I)
         IF (NDUP.EQ.0) LEN(I) = IQ(I)
        ENDIF
  260 END DO
      IF (NDUP.NE.0) THEN
       IWFR = 1
       DO 280 I=1,N
         IF (IQ(I).EQ.0) THEN
             LEN(I) = 0
            IPE(I) = IWFR
            GOTO 280
         ENDIF
         K1 = IPE(I)
         K2 = K1 + IQ(I) - 1
         L = IWFR
         IPE(I) = IWFR
         DO 270 K=K1,K2
           IF (IW(K).NE.0) THEN
            IW(IWFR) = IW(K)
            IWFR     = IWFR + 1
           ENDIF
  270    CONTINUE
         LEN(I) = IWFR - L
  280  CONTINUE
      ENDIF
      IPE(N+1) = IPE(N) + LEN(N)
      IWFR = IPE(N+1)
      IF (SYM.EQ.0) THEN
      RSYM =  dble(NDIAGA+2*NZOFFA - (IWFR-1))/                         &
     &            dble(NZOFFA+NDIAGA)
      symmetry = nint (100.0D0*RSYM)
         IF (MPG .GT. 0)                                                &
     &  write(MPG,'(A,I5)')                                             &
     &  ' ... Structural symmetry (in percent)=', symmetry
        IF (MP.GT.0 .AND. MPG.NE.MP)                                    &
     &  write(MP,'(A,I5)')                                              &
     &  ' ... Structural symmetry (in percent)=', symmetry
      ELSE
       symmetry = 100
      ENDIF
      AvgDens = nint(dble(IWFR-1)/dble(N))
      THRESH  = AvgDens*50 - AvgDens/10 + 1
      NBQD    = 0
      IF (N.GT.2) THEN
        IQ(1:N) = 0
        DO I= 1, N
          K = max(LEN(I),1)
          IQ(K) = IQ(K) + 1
          IF (K.GT.THRESH) NBQD = NBQD+1
        ENDDO
        K = 0
        MedDens = 0
        DO WHILE (K .LT. (N/2))
         MedDens = MedDens + 1
         K       = K+IQ(MedDens)
        ENDDO
      ELSE
        MedDens = AvgDens
      ENDIF
         IF (MPG .GT. 0)                                                &
     &  write(MPG,'(A,3I5)')                                            &
     &  ' Density: NBdense, Average, Median   =',                       &
     &  NBQD, AvgDens, MedDens
        IF (MP.GT.0 .AND. MPG.NE.MP)                                    &
     &  write(MP,'(A,3I5)')                                             &
     &  ' Density: NBdense, Average, Median   =',                       &
     &  NBQD, AvgDens, MedDens
      RETURN
99999 FORMAT (/'*** Warning message from analysis routine ***')
      END SUBROUTINE DAGMG_MUMPS_351
      SUBROUTINE DAGMG_MUMPS_701(N, SYM, NPROCS, IORD,                       &
     &                       symmetry,MedDens, NBQD, AvgDens,           &
     &                       PROK, MP)
      IMPLICIT NONE
      INTEGER, intent(in)    :: N, NPROCS, SYM
      INTEGER, intent(in)    :: symmetry,MedDens, NBQD, AvgDens, MP
      LOGICAL, intent(in)    :: PROK
      INTEGER, intent(inout)   :: IORD
      INTEGER MAXQD
      PARAMETER (MAXQD=2)
      INTEGER SMALLSYM, SMALLUNS
      PARAMETER (SMALLUNS=5000, SMALLSYM=10000)
      IF ( IORD .EQ. 5 ) THEN
        IF (PROK) WRITE(MP,*)                                           &
     &  'WARNING: METIS not available. Ordering set to default.'
        IORD = 7
      END IF
      IF ( IORD .EQ. 4 ) THEN
        IF (PROK) WRITE(MP,*)                                           &
     &  'WARNING: PORD not available. Ordering set to default.'
        IORD = 7
      END IF
      IF ( IORD .EQ. 3 ) THEN
        IF (PROK) WRITE(MP,*)                                           &
     &  'WARNING: SCOTCH not available. Ordering set to default.'
        IORD = 7
      END IF
      IF (IORD.EQ.7) THEN
        IF (SYM.NE.0) THEN
          IF ( N.LE.SMALLSYM ) THEN
             IF (NBQD.GE.MAXQD) THEN
               IORD = 6
             ELSE
               IORD = 2
             ENDIF
          ELSE
             IF (NBQD.GE.MedDens*NPROCS) THEN
               IORD = 6
               RETURN
             ENDIF
               IORD = 6
          ENDIF
        ELSE
          IF ( N.LE.SMALLUNS ) THEN
            IF (NBQD.GE.MAXQD) THEN
              IORD = 6
            ELSE
              IORD = 2
            ENDIF
          ELSE
            IF (NBQD.GE.MedDens*NPROCS) THEN
              IORD = 6
              RETURN
            ENDIF
              IORD = 6
          ENDIF
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_701
      SUBROUTINE DAGMG_MUMPS_510                                             &
     &     (KEEP821, KEEP2, KEEP48 ,KEEP50, NSLAVES)
      IMPLICIT NONE
      INTEGER NSLAVES, KEEP2, KEEP48, KEEP50
      INTEGER (8) :: KEEP821
      INTEGER(8) KEEP2_SQUARE, NSLAVES8
      NSLAVES8= int(NSLAVES,8)
      KEEP2_SQUARE = int(KEEP2,8) * int(KEEP2,8)
      KEEP821 = max(KEEP821*int(KEEP2,8),1_8)
      KEEP821 = min(2000000_8, KEEP821)
      IF (NSLAVES.GT.64) THEN
         KEEP821 =                                                      &
     &        min(6_8*KEEP2_SQUARE/NSLAVES8+1_8, KEEP821)
      ELSE
         KEEP821 =                                                      &
     &        min(4_8*KEEP2_SQUARE/NSLAVES8+1_8, KEEP821)
      ENDIF
         IF (KEEP50 .EQ. 0 ) THEN
            KEEP821 = max(KEEP821,(7_8*KEEP2_SQUARE /                   &
     &          4_8 / int(max(NSLAVES-1,1),8)) + int(KEEP2,8))
         ELSE
            KEEP821 = max(KEEP821,(7_8*KEEP2_SQUARE /                   &
     &          4_8 / int(max(NSLAVES-1,1),8)) + int(KEEP2,8))
         ENDIF
      IF (KEEP50 .EQ. 0 ) THEN
         KEEP821 = max(KEEP821,300000_8)
      ELSE
         KEEP821 = max(KEEP821,80000_8)
      ENDIF
      KEEP821 = -KEEP821
      RETURN
      END SUBROUTINE DAGMG_MUMPS_510
      SUBROUTINE DAGMG_MUMPS_559(JOB,M,N,NE,                                 &
     &     IP,IRN,A,LA,NUM,PERM,LIW,IW,LDW,DW,                          &
     &     ICNTL,CNTL,INFO)
      IMPLICIT NONE
      INTEGER NICNTL, NCNTL, NINFO
      PARAMETER (NICNTL=10, NCNTL=10, NINFO=10)
      INTEGER JOB,M,N,NE,NUM,LIW,LDW
      INTEGER IP(N+1),IRN(NE),PERM(M),IW(LIW)
      INTEGER ICNTL(NICNTL),INFO(NINFO)
      INTEGER LA
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION DW(LDW),CNTL(NCNTL)
      INTEGER I,J,K,WARN1,WARN2,WARN4
      DOUBLE PRECISION FACT,ZERO,ONE,RINF,RINF2,RINF3
      PARAMETER (ZERO=0.0D+00,ONE=1.0D+0)
      EXTERNAL DAGMG_MUMPS_457,DAGMG_MUMPS_444,DAGMG_MUMPS_451,                        &
     &         DAGMG_MUMPS_452,DAGMG_MUMPS_454
      INTRINSIC abs,log
      RINF = CNTL(2)
      RINF2 = huge(RINF2)/dble(2*N)
      RINF3 = 0.0D0
      WARN1 = 0
      WARN2 = 0
      WARN4 = 0
      IF (JOB.LT.1 .OR. JOB.GT.6) THEN
         INFO(1) = -1
         INFO(2) = JOB
         IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9001) INFO(1),'JOB',JOB
         GO TO 99
      ENDIF
      IF (M.LT.1 .OR. M.LT.N) THEN
         INFO(1) = -2
         INFO(2) = M
         IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9001) INFO(1),'M',M
         GO TO 99
      ENDIF
      IF (N.LT.1) THEN
         INFO(1) = -2
         INFO(2) = N
         IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9001) INFO(1),'N',N
         GO TO 99
      ENDIF
      IF (NE.LT.1) THEN
         INFO(1) = -3
         INFO(2) = NE
         IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9001) INFO(1),'NE',NE
         GO TO 99
      ENDIF
      IF (JOB.EQ.1) K = 4*N +   M
      IF (JOB.EQ.2) K = 2*N + 2*M
      IF (JOB.EQ.3) K = 8*N + 2*M + NE
      IF (JOB.EQ.4) K = 3*N + 2*M
      IF (JOB.EQ.5) K = 3*N + 2*M
      IF (JOB.EQ.6) K = 3*N + 2*M + NE
      IF (LIW.LT.K) THEN
         INFO(1) = -4
         INFO(2) = K
         IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9004) INFO(1),K
         GO TO 99
      ENDIF
      IF (JOB.GT.1) THEN
         IF (JOB.EQ.2) K =       M
         IF (JOB.EQ.3) K = 1
         IF (JOB.EQ.4) K =     2*M
         IF (JOB.EQ.5) K = N + 2*M
         IF (JOB.EQ.6) K = N + 3*M
         IF (LDW.LT.K) THEN
            INFO(1) = -5
            INFO(2) = K
            IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9005) INFO(1),K
            GO TO 99
         ENDIF
      ENDIF
      IF (ICNTL(5).EQ.0) THEN
         DO 3 I = 1,M
            IW(I) = 0
    3    CONTINUE
         DO 6 J = 1,N
            DO 4 K = IP(J),IP(J+1)-1
               I = IRN(K)
               IF (I.LT.1 .OR. I.GT.M) THEN
                  INFO(1) = -6
                  INFO(2) = J
                  IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9006) INFO(1),J,I
                  GO TO 99
               ENDIF
               IF (IW(I).EQ.J) THEN
                  INFO(1) = -7
                  INFO(2) = J
                  IF (ICNTL(1).GE.0) WRITE(ICNTL(1),9007) INFO(1),J,I
                  GO TO 99
               ELSE
                  IW(I) = J
               ENDIF
    4       CONTINUE
    6    CONTINUE
      ENDIF
      IF (ICNTL(3).GE.0) THEN
         IF (ICNTL(4).EQ.0 .OR. ICNTL(4).EQ.1) THEN
            WRITE(ICNTL(3),9020) JOB,M,N,NE
            IF (ICNTL(4).EQ.0) THEN
               WRITE(ICNTL(3),9021) (IP(J),J=1,min(10,N+1))
               WRITE(ICNTL(3),9022) (IRN(J),J=1,min(10,NE))
               IF (JOB.GT.1) WRITE(ICNTL(3),9023) (A(J),J=1,min(10,NE))
            ELSEIF (ICNTL(4).EQ.1) THEN
               WRITE(ICNTL(3),9021) (IP(J),J=1,N+1)
               WRITE(ICNTL(3),9022) (IRN(J),J=1,NE)
               IF (JOB.GT.1) WRITE(ICNTL(3),9023) (A(J),J=1,NE)
            ENDIF
            WRITE(ICNTL(3),9024) (ICNTL(J),J=1,NICNTL)
            WRITE(ICNTL(3),9025) (CNTL(J),J=1,NCNTL)
         ENDIF
      ENDIF
      DO 8 I=1,NINFO
         INFO(I) = 0
    8 END DO
      IF (JOB.EQ.1) THEN
         DO 10 J = 1,N
            IW(J) = IP(J+1) - IP(J)
   10    CONTINUE
         CALL DAGMG_MUMPS_457(M,N,IRN,NE,IP,IW(1),PERM,NUM,                  &
     &        IW(N+1),IW(2*N+1),IW(3*N+1),IW(3*N+M+1))
         GO TO 90
      ENDIF
      IF (JOB.EQ.2) THEN
         DW(1) = max(ZERO,CNTL(1))
         CALL DAGMG_MUMPS_444(M,N,NE,IP,IRN,A,PERM,NUM,                      &
     &        IW(1),IW(N+1),IW(2*N+1),IW(2*N+M+1),DW,RINF2)
         GO TO 90
      ENDIF
      IF (JOB.EQ.3) THEN
         DO 20 K = 1,NE
            IW(K) = IRN(K)
   20    CONTINUE
         CALL DAGMG_MUMPS_451(N,NE,IP,IW,A)
         FACT = max(ZERO,CNTL(1))
         CALL DAGMG_MUMPS_452(M,N,NE,IP,IW(1),A,PERM,NUM,IW(NE+1),           &
     &        IW(NE+N+1),IW(NE+2*N+1),IW(NE+3*N+1),IW(NE+4*N+1),        &
     &        IW(NE+5*N+1),IW(NE+5*N+M+1),FACT,RINF2)
         GO TO 90
      ENDIF
      IF (JOB.EQ.4) THEN
         DO 50 J = 1,N
            FACT = ZERO
            DO 30 K = IP(J),IP(J+1)-1
               IF (abs(A(K)).GT.FACT) FACT = abs(A(K))
   30       CONTINUE
            IF(FACT .GT. RINF3) RINF3 = FACT
            DO 40 K = IP(J),IP(J+1)-1
               A(K) = FACT - abs(A(K))
   40       CONTINUE
   50    CONTINUE
         DW(1) = max(ZERO,CNTL(1))
         DW(2) = RINF3
         IW(1) = JOB
         CALL DAGMG_MUMPS_454(M,N,NE,IP,IRN,A,PERM,NUM,                      &
     &        IW(1),IW(N+1),IW(2*N+1),IW(3*N+1),IW(3*N+M+1),            &
     &        DW(1),DW(M+1),RINF2)
         GO TO 90
      ENDIF
      IF (JOB.EQ.5 .or. JOB.EQ.6) THEN
         RINF3=ONE
         IF (JOB.EQ.5) THEN
            DO 75 J = 1,N
               FACT = ZERO
               DO 60 K = IP(J),IP(J+1)-1
                  IF (A(K).GT.FACT) FACT = A(K)
   60          CONTINUE
               DW(2*M+J) = FACT
               IF (FACT.NE.ZERO) THEN
                  FACT = log(FACT)
                  IF(FACT .GT. RINF3) RINF3=FACT
                  DO 70 K = IP(J),IP(J+1)-1
                     IF (A(K).NE.ZERO) THEN
                        A(K) = FACT - log(A(K))
                        IF(A(K) .GT. RINF3) RINF3=A(K)
                     ELSE
                        A(K) = FACT + RINF
                     ENDIF
   70             CONTINUE
               ELSE
                  DO 71 K = IP(J),IP(J+1)-1
                     A(K) = ONE
   71             CONTINUE
               ENDIF
   75       CONTINUE
         ENDIF
         IF (JOB.EQ.6) THEN
            DO 175 K = 1,NE
               IW(3*N+2*M+K) = IRN(K)
  175       CONTINUE
            DO 61 I = 1,M
               DW(2*M+N+I) = ZERO
   61       CONTINUE
            DO 63 J = 1,N
               DO 62 K = IP(J),IP(J+1)-1
                  I = IRN(K)
                  IF (A(K).GT.DW(2*M+N+I)) THEN
                     DW(2*M+N+I) = A(K)
                  ENDIF
   62          CONTINUE
   63       CONTINUE
            DO 64 I = 1,M
               IF (DW(2*M+N+I).NE.ZERO) THEN
                  DW(2*M+N+I) = 1.0D0/DW(2*M+N+I)
               ENDIF
   64       CONTINUE
            DO 66 J = 1,N
               DO 65 K = IP(J),IP(J+1)-1
                  I = IRN(K)
                  A(K) = DW(2*M+N+I) * A(K)
   65          CONTINUE
   66       CONTINUE
            CALL DAGMG_MUMPS_451(N,NE,IP,IW(3*N+2*M+1),A)
            DO 176 J = 1,N
               IF (IP(J).NE.IP(J+1)) THEN
                  FACT = A(IP(J))
               ELSE
                  FACT = ZERO
               ENDIF
               DW(2*M+J) = FACT
               IF (FACT.NE.ZERO) THEN
                  FACT = log(FACT)
                  DO 170 K = IP(J),IP(J+1)-1
                     IF (A(K).NE.ZERO) THEN
                        A(K) = FACT - log(A(K))
                        IF(A(K) .GT. RINF3) RINF3=A(K)
                     ELSE
                        A(K) = FACT + RINF
                     ENDIF
  170             CONTINUE
               ELSE
                  DO 171 K = IP(J),IP(J+1)-1
                     A(K) = ONE
  171             CONTINUE
               ENDIF
  176       CONTINUE
         ENDIF
         DW(1) = max(ZERO,CNTL(1))
         RINF3 = RINF3+ONE
         DW(2) = RINF3
         IW(1) = JOB
         IF (JOB.EQ.5) THEN
            CALL DAGMG_MUMPS_454(M,N,NE,IP,IRN,A,PERM,NUM,                   &
     &           IW(1),IW(N+1),IW(2*N+1),IW(3*N+1),IW(3*N+M+1),         &
     &           DW(1),DW(M+1),RINF2)
         ENDIF
         IF (JOB.EQ.6) THEN
            CALL DAGMG_MUMPS_454(M,N,NE,IP,IW(3*N+2*M+1),A,PERM,NUM,         &
     &           IW(1),IW(N+1),IW(2*N+1),IW(3*N+1),IW(3*N+M+1),         &
     &           DW(1),DW(M+1),RINF2)
         ENDIF
         IF (JOB.EQ.6) THEN
            DO 79 I = 1,M
               IF (DW(2*M+N+I).NE.0.0D0) THEN
                  DW(I) = DW(I) + log(DW(2*M+N+I))
               ENDIF
   79       CONTINUE
         ENDIF
         IF (NUM.EQ.N) THEN
            DO 80 J = 1,N
               IF (DW(2*M+J).NE.ZERO) THEN
                  DW(M+J) = DW(M+J) - log(DW(2*M+J))
               ELSE
                  DW(M+J) = ZERO
               ENDIF
   80       CONTINUE
         ENDIF
         FACT = 0.5D0*log(RINF2)
         DO 86 I = 1,M
            IF (DW(I).LT.FACT) GO TO 86
            WARN2 = 2
            GO TO 90
   86    CONTINUE
         DO 87 J = 1,N
            IF (DW(M+J).LT.FACT) GO TO 87
            WARN2 = 2
            GO TO 90
   87    CONTINUE
      ENDIF
   90 IF (NUM.LT.N) WARN1 = 1
      IF (JOB.EQ.4 .OR. JOB.EQ.5 .OR. JOB.EQ.6) THEN
         IF (CNTL(1).LT.ZERO) WARN4 = 4
      ENDIF
      IF (INFO(1).EQ.0) THEN
         INFO(1) = WARN1 + WARN2 + WARN4
         IF (INFO(1).GT.0 .AND. ICNTL(2).GT.0) THEN
            WRITE(ICNTL(2),9010) INFO(1)
            IF (WARN1.EQ.1) WRITE(ICNTL(2),9011)
            IF (WARN2.EQ.2) WRITE(ICNTL(2),9012)
            IF (WARN4.EQ.4) WRITE(ICNTL(2),9014)
         ENDIF
      ENDIF
      IF (ICNTL(3).GE.0) THEN
         IF (ICNTL(4).EQ.0 .OR. ICNTL(4).EQ.1) THEN
            WRITE(ICNTL(3),9030) (INFO(J),J=1,2)
            WRITE(ICNTL(3),9031) NUM
            IF (ICNTL(4).EQ.0) THEN
               WRITE(ICNTL(3),9032) (PERM(J),J=1,min(10,M))
               IF (JOB.EQ.5 .OR. JOB.EQ.6) THEN
                  WRITE(ICNTL(3),9033) (DW(J),J=1,min(10,M))
                  WRITE(ICNTL(3),9034) (DW(M+J),J=1,min(10,N))
               ENDIF
            ELSEIF (ICNTL(4).EQ.1) THEN
               WRITE(ICNTL(3),9032) (PERM(J),J=1,M)
               IF (JOB.EQ.5 .OR. JOB.EQ.6) THEN
                  WRITE(ICNTL(3),9033) (DW(J),J=1,M)
                  WRITE(ICNTL(3),9034) (DW(M+J),J=1,N)
               ENDIF
            ENDIF
         ENDIF
      ENDIF
   99 RETURN
 9001 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2,             &
     &     ' because ',(A),' = ',I10)
 9004 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2/             &
     &     '        LIW too small, must be at least ',I8)
 9005 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2/             &
     &     '        LDW too small, must be at least ',I8)
 9006 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2/             &
     &     '        Column ',I8,                                        &
     &     ' contains an entry with invalid row index ',I8)
 9007 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2/             &
     &     '        Column ',I8,                                        &
     &     ' contains two or more entries with row index ',I8)
 9008 FORMAT (' ****** Error in DMUMPS_443. INFO(1) = ',I2/             &
     &     '        CNTL(2) is negative or zero.')
 9010 FORMAT (' ****** Warning from DMUMPS_443. INFO(1) = ',I2)
 9011 FORMAT ('        - The matrix is structurally singular.')
 9012 FORMAT ('        - Some scaling factors may be too large.')
 9014 FORMAT ('        - CNTL(1) is negative and was treated as zero.')
 9020 FORMAT (' ****** Input parameters for DMUMPS_443:'/               &
     &     ' JOB =',I10/' M   =',I10/' N   =',I10/' NE  =',I10)
 9021 FORMAT (' IP(1:N+1)   = ',8I8/(15X,8I8))
 9022 FORMAT (' IRN(1:NE)   = ',8I8/(15X,8I8))
 9023 FORMAT (' A(1:NE)     = ',4(1PD14.4)/(15X,4(1PD14.4)))
 9024 FORMAT (' ICNTL(1:10) = ',8I8/(15X,2I8))
 9025 FORMAT (' CNTL(1:10)  = ',4(1PD14.4)/(15X,4(1PD14.4)))
 9030 FORMAT (' ****** Output parameters for DMUMPS_443:'/              &
     &     ' INFO(1:2)   = ',2I8)
 9031 FORMAT (' NUM         = ',I8)
 9032 FORMAT (' PERM(1:M)   = ',8I8/(15X,8I8))
 9033 FORMAT (' DW(1:M)     = ',5(F11.3)/(15X,5(F11.3)))
 9034 FORMAT (' DW(M+1:M+N) = ',5(F11.3)/(15X,5(F11.3)))
      END SUBROUTINE DAGMG_MUMPS_559
      SUBROUTINE DAGMG_MUMPS_563(N,NZ,IP,IRN,A,FLAG,POSI)
      IMPLICIT NONE
      INTEGER N,NZ
      INTEGER IP(N+1),IRN(NZ)
      DOUBLE PRECISION A(NZ)
      INTEGER WR_POS,BEG_COL,ROW,COL,K,SV_POS
      INTEGER FLAG(N), POSI(N)
      INTEGER ierr
      FLAG = 0
      WR_POS = 1
      DO COL=1,N
         BEG_COL = WR_POS
         DO K=IP(COL),IP(COL+1)-1
            ROW = IRN(K)
            IF(FLAG(ROW) .NE. COL) THEN
               IRN(WR_POS) = ROW
               A(WR_POS) = A(K)
               FLAG(ROW) = COL
               POSI(ROW) = WR_POS
               WR_POS = WR_POS+1
            ELSE
               SV_POS = POSI(ROW)
               A(SV_POS) = A(SV_POS) + A(K)
            ENDIF
         ENDDO
         IP(COL) = BEG_COL
      ENDDO
      IP(N+1) = WR_POS
      NZ = WR_POS-1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_563
      SUBROUTINE DAGMG_MUMPS_562(N,NZ,IP,IRN,FLAG,POSI)
      IMPLICIT NONE
      INTEGER N,NZ
      INTEGER IP(N+1),IRN(NZ)
      INTEGER WR_POS,BEG_COL,ROW,COL,K,SV_POS
      INTEGER FLAG(N), POSI(N)
      INTEGER ierr
      FLAG = 0
      WR_POS = 1
      DO COL=1,N
         BEG_COL = WR_POS
         DO K=IP(COL),IP(COL+1)-1
            ROW = IRN(K)
            IF(FLAG(ROW) .NE. COL) THEN
               IRN(WR_POS) = ROW
               FLAG(ROW) = COL
               POSI(ROW) = WR_POS
               WR_POS = WR_POS+1
            ENDIF
         ENDDO
         IP(COL) = BEG_COL
      ENDDO
      IP(N+1) = WR_POS
      NZ = WR_POS-1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_562
      SUBROUTINE DAGMG_MUMPS_181( N, POOL, NSTK,                             &
     &          PERM, FILS,                                             &
     &          DAD_STEPS, STEP, NSTEPS)
      IMPLICIT NONE
      INTEGER, INTENT(IN)  ::  N, NSTEPS
      INTEGER, INTENT(IN)  ::  FILS( N )
      INTEGER, INTENT(IN)  ::  DAD_STEPS ( NSTEPS ), STEP ( N )
      INTEGER, INTENT(INOUT) :: POOL(N), NSTK(N)
      INTEGER, INTENT(OUT) ::  PERM( N )
      INTEGER  :: IPERM, INODE, IN, I
      INTEGER  :: INBLEAF, INBROOT
      IF (N.GT.1) THEN
         IF(POOL(N-1) .LT. 0) THEN
            INBLEAF = N-1
            INBROOT = POOL(N)
            POOL(N-1) = -POOL(N-1)-1
         ELSE IF ((POOL(N-1) .GT. 0) .AND.                              &
     &           (POOL(N) .LT. 0)) THEN
            INBLEAF = N
            INBROOT = N
            POOL(N) = -POOL(N)-1
         ELSE
            INBLEAF = POOL(N-1)
            INBROOT = POOL(N)
         END IF
      END IF
      IPERM = 1
      DO WHILE ( INBLEAF .NE. 0 )
        INODE = POOL( INBLEAF )
        INBLEAF = INBLEAF - 1
        IN = INODE
        DO WHILE ( IN .GT. 0 )
          PERM ( IN ) = IPERM
          IPERM = IPERM + 1
          IN = FILS( IN )
        END DO
        IN = DAD_STEPS(STEP( INODE ))
        IF ( IN .eq. 0 ) THEN
          INBROOT = INBROOT - 1
        ELSE
          NSTK( IN ) = NSTK( IN ) - 1
          IF ( NSTK( IN ) .eq. 0 ) THEN
            INBLEAF = INBLEAF + 1
            POOL( INBLEAF ) = IN
          END IF
        END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_181
      SUBROUTINE DAGMG_MUMPS_746( ID, PTRAR )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE(DAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
      INTEGER, TARGET          :: PTRAR(ID%N,2)
      INTEGER          :: I, IERR
      INTEGER          :: IOLD, K, JOLD, INEW, JNEW, ISHIFT, INZ
      INTEGER, POINTER :: IIRN(:), IJCN(:), IWORK1(:), IWORK2(:)
      LOGICAL          :: IDO, PARANAL
      PARANAL = .TRUE.
      IF (PARANAL) THEN
         IF(ID%KEEP(54) .EQ. 3) THEN
            IIRN => ID%IRN_LOC
            IJCN => ID%JCN_LOC
            INZ  =  ID%NZ_LOC
            IWORK1 => PTRAR(1:ID%N,2)
            allocate(IWORK2(ID%N))
            IDO = .TRUE.
         ELSE
            IIRN => ID%IRN
            IJCN => ID%JCN
            INZ  =  ID%NZ
            IWORK1 => PTRAR(1:ID%N,1)
            IWORK2 => PTRAR(1:ID%N,2)
            IDO = ID%MYID .EQ. 0
         END IF
      ELSE
         IIRN => ID%IRN
         IJCN => ID%JCN
         INZ  =  ID%NZ
         IWORK1 => PTRAR(1:ID%N,1)
         IWORK2 => PTRAR(1:ID%N,2)
         IDO = ID%MYID .EQ. 0
      END IF
      DO 50 IOLD=1,ID%N
         IWORK1(IOLD) = 0
         IWORK2(IOLD) = 0
   50 END DO
      IF(IDO) THEN
         DO 70 K=1,INZ
            IOLD = IIRN(K)
            JOLD = IJCN(K)
            IF ( (IOLD.GT.ID%N).OR.(JOLD.GT.ID%N).OR.(IOLD.LT.1)        &
     &           .OR.(JOLD.LT.1) ) GOTO 70
            IF (IOLD.NE.JOLD) THEN
               INEW = ID%SYM_PERM(IOLD)
               JNEW = ID%SYM_PERM(JOLD)
               IF ( ID%KEEP( 50 ) .EQ. 0 ) THEN
                  IF (INEW.LT.JNEW) THEN
                     IWORK2(IOLD) = IWORK2(IOLD) + 1
                  ELSE
                     IWORK1(JOLD) = IWORK1(JOLD) + 1
                  ENDIF
               ELSE
                  IF ( INEW .LT. JNEW ) THEN
                     IWORK1( IOLD ) = IWORK1( IOLD ) + 1
                  ELSE
                     IWORK1( JOLD ) = IWORK1( JOLD ) + 1
                  END IF
               ENDIF
            ENDIF
   70    CONTINUE
      END IF
      IF(PARANAL .AND. (ID%KEEP(54) .EQ. 3) ) THEN
         CALL AGMG_COPY(IWORK1, PTRAR(:,1), ID%N, AGMG_MPF_INTEGER, IERR )
         CALL AGMG_COPY(IWORK2, PTRAR(:,2), ID%N, AGMG_MPF_INTEGER, IERR )
         deallocate(IWORK2)
      ELSE
         CALL AGMG_SETIERR( IERR )
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_746
      MODULE DAGMG_MUMPS_PARALLEL_ANALYSIS
      USE DAGMG_MUMPS_STRUC_DEF
      USE TOOLS_COMMON
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      PUBLIC DAGMG_MUMPS_715
      INTERFACE DAGMG_MUMPS_715
      MODULE PROCEDURE DAGMG_MUMPS_715
      END INTERFACE
      PRIVATE
      TYPE ORD_TYPE
      INTEGER           :: CBLKNBR, N
      INTEGER, POINTER  :: PERMTAB(:) => null()
      INTEGER, POINTER  :: PERITAB(:) => null()
      INTEGER, POINTER  :: RANGTAB(:) => null()
      INTEGER, POINTER  :: TREETAB(:) => null()
      INTEGER, POINTER  :: BROTHER(:) => null()
      INTEGER, POINTER  :: SON(:) => null()
      INTEGER, POINTER  :: NW(:) => null()
      INTEGER, POINTER  :: FIRST(:) => null()
      INTEGER, POINTER  :: LAST(:) => null()
      INTEGER, POINTER  :: TOPNODES(:) => null()
      INTEGER           :: COMM, COMM_NODES, NPROCS, NSLAVES, MYID
      INTEGER           :: TOPSTRAT, SUBSTRAT, ORDTOOL, TOPVARS
      LOGICAL           :: IDO
      END TYPE ORD_TYPE
      TYPE GRAPH_TYPE
      INTEGER           :: NZ_LOC, N, COMM
      INTEGER, POINTER  :: IRN_LOC(:) => null()
      INTEGER, POINTER  :: JCN_LOC(:) => null()
      END TYPE GRAPH_TYPE
      TYPE ARRPNT
      INTEGER, POINTER :: BUF(:) => null()
      END TYPE ARRPNT
      INTEGER :: MEMCNT, MAXMEM, MP, MPG, LP, NRL, TOPROWS
      LOGICAL :: PROK, PROKG
      CONTAINS
      SUBROUTINE DAGMG_MUMPS_715(id, WORK1, WORK2, NFSIZ, FILS,              &
     &     FRERE)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)   :: id
      INTEGER, POINTER     :: WORK1(:), WORK2(:),                       &
     &     NFSIZ(:), FILS(:), FRERE(:)
      TYPE(ORD_TYPE)       :: ord
      INTEGER, POINTER     :: IPE(:), NV(:),                            &
     &     NE(:), NA(:), NODE(:),                                       &
     &     ND(:), SUBORD(:), NAMALG(:),                                 &
     &     IPS(:), CUMUL(:),                                            &
     &     SAVEIRN(:), SAVEJCN(:)
      INTEGER              :: MYID, NPROCS, IERR, NEMIN, LDIAG
      LOGICAL              :: SPLITROOT
      INTEGER(8), PARAMETER :: K79REF=12000000_8
      nullify(IPE, NV, NE, NA, NODE, ND, SUBORD, NAMALG, IPS,           &
     &     CUMUL, SAVEIRN, SAVEJCN)
      CALL AGMG_SETIERR2( MYID, IERR)
      CALL AGMG_SETIERR12( NPROCS, IERR)
      LP    = id%ICNTL(1)
      MP    = id%ICNTL(2)
      MPG   = id%ICNTL(3)
      PROK  = (MP.GT.0)
      PROKG = (MPG.GT.0) .AND. (MYID .EQ. 0)
      LDIAG = id%ICNTL(4)
      ord%PERMTAB => WORK1(1        : id%N)
      ord%PERITAB => WORK1(id%N+1   : 2*id%N)
      ord%TREETAB => WORK1(2*id%N+1 : 3*id%N)
      IF(id%KEEP(54) .NE. 3) THEN
         IF(MYID.EQ.0) THEN
            SAVEIRN    => id%IRN_LOC
            SAVEJCN    => id%JCN_LOC
            id%IRN_LOC => id%IRN
            id%JCN_LOC => id%JCN
            id%NZ_LOC  =  id%NZ
         ELSE
            id%NZ_LOC = 0
         END IF
      END IF
      MAXMEM=0
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      CALL DAGMG_MUMPS_716(id, ord)
      id%INFOG(7) = id%KEEP(245)
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &     id%COMM, id%MYID )
      IF ( id%INFO(1) .LT. 0 ) RETURN
      CALL DAGMG_MUMPS_717(id, ord, WORK2)
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &     id%COMM, id%MYID )
      IF ( id%INFO(1) .LT. 0 ) RETURN
      IF(id%MYID .EQ. 0) THEN
         CALL AGMG_MUMPS_733(IPE, id%N, id%INFO, LP, FORCE=.FALSE.,          &
     &        COPY=.FALSE., STRING='',                                  &
     &        MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(NV, id%N, id%INFO, LP,                          &
     &        MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      END IF
      ord%SUBSTRAT = 0
      ord%TOPSTRAT = 0
      CALL DAGMG_MUMPS_720(id, ord, IPE, NV, WORK2)
      IF(id%KEEP(54) .NE. 3) THEN
         IF(MYID.EQ.0) THEN
            id%IRN_LOC => SAVEIRN
            id%JCN_LOC => SAVEJCN
         END IF
      END IF
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &     id%COMM, id%MYID )
      IF ( id%INFO(1) .LT. 0 ) RETURN
      NULLIFY(ord%PERMTAB)
      NULLIFY(ord%PERITAB)
      NULLIFY(ord%TREETAB)
      CALL AGMG_MUMPS_734(ord%FIRST, ord%LAST, MEMCNT=MEMCNT)
      IF (MYID .EQ. 0) THEN
         IPS => WORK1(1:id%N)
         NE     => WORK1(id%N+1   : 2*id%N)
         NA     => WORK1(2*id%N+1 : 3*id%N)
         NODE   => WORK2(1        : id%N  )
         ND     => WORK2(id%N+1   : 2*id%N)
         SUBORD => WORK2(2*id%N+1 : 3*id%N)
         NAMALG => WORK2(3*id%N+1 : 4*id%N)
      CALL AGMG_MUMPS_733(CUMUL, id%N, id%INFO, LP,                          &
     &     STRING='CUMUL', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
         NEMIN  = id%KEEP(1)
         CALL DAGMG_MUMPS_557(id%N, IPE, NV, IPS, NE, NA, NFSIZ, NODE,       &
     &        id%INFOG(6), FILS, FRERE, ND, NEMIN, SUBORD, id%KEEP(60), &
     &        id%KEEP(20),id%KEEP(38), NAMALG, id%KEEP(104), CUMUL,     &
     &        id%KEEP(50), id%ICNTL(13), id%KEEP(37), id%NSLAVES,       &
     &        id%KEEP(250).EQ.1)
         CALL AGMG_MUMPS_734(CUMUL, NV, IPE, MEMCNT=MEMCNT)
         CALL DAGMG_MUMPS_201(NE, ND, id%INFOG(6), id%INFOG(5),              &
     &        id%KEEP(2), id%KEEP(50), id%KEEP(101), id%KEEP(108),      &
     &        id%KEEP(5), id%KEEP(6), id%KEEP(226))
         IF ( id%KEEP(53) .NE. 0 ) THEN
            CALL AGMG_MUMPS_209(id%N, FRERE, FILS, NFSIZ, id%KEEP(20))
         END IF
         IF (  (id%KEEP(48) == 4 .AND. id%KEEP8(21).GT.0_8)             &
     &        .OR.                                                      &
     &        (id%KEEP (48)==5 .AND. id%KEEP8(21) .GT. 0_8 )            &
     &        .OR.                                                      &
     &        (id%KEEP(24).NE.0.AND.id%KEEP8(21).GT.0_8) ) THEN
            CALL DAGMG_MUMPS_510(id%KEEP8(21), id%KEEP(2),                   &
     &           id%KEEP(48), id%KEEP(50), id%NSLAVES)
         END IF
         IF ((id%KEEP(210).LT.0) .OR. (id%KEEP(210).GT.2))              &
     &        id%KEEP(210)=0
         IF ((id%KEEP(210).EQ.0) .AND. (id%KEEP(201).GT.0))             &
     &        id%KEEP(210)=1
         IF ((id%KEEP(210).EQ.0) .AND. (id%KEEP(201).EQ.0))             &
     &        id%KEEP(210)=2
         IF (id%KEEP(210).EQ.2) id%KEEP8(79)=huge(id%KEEP8(79))
         IF ((id%KEEP(210).EQ.1) .AND. (id%KEEP8(79).LE.0_8)) THEN
            IF ( huge(id%KEEP8(79)) / K79REF + 1_8 .GE.                 &
     &                                 int(id%NSLAVES,8) ) THEN
               id%KEEP8(79)=huge(id%KEEP8(79))
            ELSE
               id%KEEP8(79)=K79REF * int(id%NSLAVES,8)
            ENDIF
         ENDIF
         IF (id%KEEP(210).EQ.1) THEN
            SPLITROOT = .FALSE.
            IF ( id%KEEP(62).GE.1) THEN
               CALL DAGMG_MUMPS_97(id%N, FRERE, FILS, NFSIZ,                 &
     &              id%INFOG(6),                                        &
     &              id%NSLAVES, id%KEEP,id%KEEP8, SPLITROOT,            &
     &              MP, LDIAG, id%INFOG(1), id%INFOG(2))
               IF (id%INFOG(1).LT.0) RETURN
            ENDIF
         ENDIF
         SPLITROOT = (((id%ICNTL(13).GT.0) .AND.                        &
     &        (id%NSLAVES.GT.id%ICNTL(13))) .OR.                        &
     &        (id%ICNTL(13).EQ.-1)) .AND. (id%KEEP(60).EQ.0)
         IF (SPLITROOT) THEN
            CALL DAGMG_MUMPS_97(id%N, FRERE, FILS, NFSIZ, id%INFOG(6),       &
     &           id%NSLAVES, id%KEEP, id%KEEP8, SPLITROOT,              &
     &           MP, LDIAG, id%INFOG(1), id%INFOG(2))
            IF (id%INFOG(1).LT.0) RETURN
         ENDIF
      END IF
!     $     associated(NE), associated(NA), associated(NODE),
!     $     associated(ND), associated(SUBORD), associated(NAMALG),
!     $     associated(IPS), associated(CUMUL)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_715
      SUBROUTINE DAGMG_MUMPS_716(id, ord)
      TYPE(DAGMG_MUMPS_STRUC)  :: id
      TYPE(ORD_TYPE)      :: ord
      INTEGER  :: IERR, I, COLOR, BASE
      LOGICAL  :: IDO
      IF(id%MYID .EQ. 0) id%KEEP(245) = id%ICNTL(29)
      CALL AGMG_SETIERR( IERR )
      IF ((id%KEEP(245) .LT. 0) .OR. (id%KEEP(245) .GT. 2)) THEN
         id%KEEP(245) = 0
      END IF
      IF (id%KEEP(245) .EQ. 0) THEN
         id%INFO(1)  = -38
         id%INFOG(1) = -38
         IF(id%MYID .EQ.0 ) THEN
            WRITE(LP,                                                   &
     &           '("No parallel ordering tools available.")')
            WRITE(LP,                                                   &
     &           '("Please install PT-SCOTCH or ParMETIS.")')
         END IF
         RETURN
      ELSE IF (id%KEEP(245) .EQ. 1) THEN
         id%INFOG(1) = -38
         id%INFO(1)  = -38
         IF(id%MYID .EQ.0 ) WRITE(LP,                                   &
     &        '("PT-SCOTCH not available.")')
         RETURN
      ELSE IF (id%KEEP(245) .EQ. 2) THEN
         id%INFOG(1) = -38
         id%INFO(1)  = -38
         IF(id%MYID .EQ.0 ) WRITE(LP,                                   &
     &        '("ParMETIS not available.")')
         RETURN
      END IF
      END SUBROUTINE DAGMG_MUMPS_716
      SUBROUTINE DAGMG_MUMPS_717(id, ord, WORK)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)            :: id
      TYPE(ORD_TYPE)                :: ord
      INTEGER, POINTER              :: WORK(:)
      IF (ord%ORDTOOL .EQ. 1) THEN
         id%INFOG(1) = -38
         id%INFO(1)  = -38
         WRITE(LP,*)'PT-SCOTCH not available. Aborting...'
         CALL AGMG_MUMPS_ABORT()
      ELSE IF (ord%ORDTOOL .EQ. 2) THEN
         id%INFOG(1) = -38
         id%INFO(1)  = -38
         WRITE(LP,*)'ParMETIS not available. Aborting...'
         CALL AGMG_MUMPS_ABORT()
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_717
      FUNCTION DAGMG_MUMPS_STOP_DESCENT(id, ord, NACTIVE, ANODE, RPROC,      &
     &     ALIST, LIST, PEAKMEM, NNODES, CHECKMEM)
      IMPLICIT NONE
      LOGICAL              :: DAGMG_MUMPS_STOP_DESCENT
      INTEGER              :: NACTIVE, RPROC, ANODE, PEAKMEM, NNODES
      INTEGER              :: ALIST(NNODES), LIST(NNODES)
      TYPE(ORD_TYPE)       :: ord
      TYPE(DAGMG_MUMPS_STRUC)   :: id
      LOGICAL, OPTIONAL    :: CHECKMEM
      INTEGER              :: IPEAKMEM, BIG, MAX_NROWS, MIN_NROWS
      INTEGER              :: TOPROWS, NRL, HOSTMEM, SUBMEM, IMEM
      INTEGER              :: I, NZ_ROW, WEIGHT
      LOGICAL              :: ICHECKMEM
      IF(present(CHECKMEM)) THEN
         ICHECKMEM = CHECKMEM
      ELSE
         ICHECKMEM = .FALSE.
      END IF
      DAGMG_MUMPS_STOP_DESCENT = .FALSE.
      IF(NACTIVE .GE. RPROC) THEN
         DAGMG_MUMPS_STOP_DESCENT = .TRUE.
         RETURN
      END IF
      IF(NACTIVE .EQ. 0) THEN
         DAGMG_MUMPS_STOP_DESCENT = .TRUE.
         RETURN
      END IF
      IF(.NOT. ICHECKMEM) RETURN
      BIG = ALIST(NACTIVE)
      IF(NACTIVE .GT. 1) THEN
         MAX_NROWS = ord%NW(ALIST(NACTIVE-1))
         MIN_NROWS = ord%NW(ALIST(1))
      ELSE
         MAX_NROWS = 0
         MIN_NROWS = id%N
      END IF
      DO I=1, ANODE
         WEIGHT = ord%NW(LIST(I))
         IF(WEIGHT .GT. MAX_NROWS) MAX_NROWS = WEIGHT
         IF(WEIGHT .LT. MIN_NROWS) MIN_NROWS = WEIGHT
      END DO
      I = ord%SON(BIG)
      DO
         WEIGHT = ord%NW(I)
         IF(WEIGHT .GT. MAX_NROWS) MAX_NROWS = WEIGHT
         IF(WEIGHT .LT. MIN_NROWS) MIN_NROWS = WEIGHT
         IF(ord%BROTHER(I) .EQ. -1) EXIT
         I = ord%BROTHER(I)
      END DO
      TOPROWS = ord%TOPNODES(2)+ord%RANGTAB(BIG+1)-ord%RANGTAB(BIG)
      SUBMEM  = 7 *id%N
      HOSTMEM = 12*id%N
      NZ_ROW = 2*(id%NZ/id%N)
      IF(id%PAR .EQ. 0) THEN
         NRL = 0
      ELSE
         NRL = MIN_NROWS
      END IF
      HOSTMEM = HOSTMEM + 2*TOPROWS*NZ_ROW
      HOSTMEM = HOSTMEM +NRL
      HOSTMEM = HOSTMEM + MAX(NRL,TOPROWS)*(NZ_ROW+2)
      HOSTMEM = HOSTMEM + 6*MAX(NRL,TOPROWS)
      HOSTMEM = HOSTMEM + 3*TOPROWS
      NRL = MAX_NROWS
      SUBMEM = SUBMEM +NRL
      SUBMEM = SUBMEM + NRL*(NZ_ROW+2)
      SUBMEM = SUBMEM + 6*NRL
      IPEAKMEM = MAX(HOSTMEM, SUBMEM)
      IF((IPEAKMEM .GT. PEAKMEM) .AND.                                  &
     &     (PEAKMEM .NE. 0)) THEN
         DAGMG_MUMPS_STOP_DESCENT = .TRUE.
         RETURN
      ELSE
         DAGMG_MUMPS_STOP_DESCENT = .FALSE.
         PEAKMEM = IPEAKMEM
         RETURN
      END IF
      END FUNCTION DAGMG_MUMPS_STOP_DESCENT
      FUNCTION DAGMG_MUMPS_CNT_KIDS(NODE, ord)
      IMPLICIT NONE
      INTEGER :: DAGMG_MUMPS_CNT_KIDS
      INTEGER :: NODE
      TYPE(ORD_TYPE) :: ord
      INTEGER :: CURR
      DAGMG_MUMPS_CNT_KIDS = 0
      IF(ord%SON(NODE) .EQ. -1) THEN
         RETURN
      ELSE
         DAGMG_MUMPS_CNT_KIDS = 1
         CURR = ord%SON(NODE)
         DO
            IF(ord%BROTHER(CURR) .NE. -1) THEN
               DAGMG_MUMPS_CNT_KIDS = DAGMG_MUMPS_CNT_KIDS+1
               CURR = ord%BROTHER(CURR)
            ELSE
               EXIT
            END IF
         END DO
      END IF
      RETURN
      END FUNCTION DAGMG_MUMPS_CNT_KIDS
      SUBROUTINE DAGMG_MUMPS_GET_SUBTREES(ord, id)
      USE TOOLS_COMMON
      IMPLICIT NONE
      TYPE(ORD_TYPE)     :: ord
      TYPE(DAGMG_MUMPS_STRUC) :: id
      INTEGER, ALLOCATABLE :: ALIST(:), AWEIGHTS(:), LIST(:), WORK(:)
      INTEGER  :: NNODES, BIG, CURR, ND, NACTIVE, RPROC, ANODE, BASE, I,&
     &     NS, INFO, NK, PEAKMEM
      LOGICAL  :: SD
      NNODES = ord%NSLAVES
      ALLOCATE(ALIST(NNODES), AWEIGHTS(NNODES), LIST(NNODES),           &
     &     WORK(0:NNODES+1))
      ALIST(1)    = ord%CBLKNBR
      AWEIGHTS(1) = ord%NW(ord%CBLKNBR)
      NACTIVE     = 1
      RPROC       = NNODES
      ANODE       = 0
      PEAKMEM      = 0
      CALL AGMG_MUMPS_733(ord%TOPNODES, 2*max(NNODES,2), id%INFO, LP,        &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(ord%FIRST, id%NPROCS, id%INFO, LP,                 &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(ord%LAST, id%NPROCS, id%INFO, LP,                  &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      ord%TOPNODES = 0
      IF((ord%CBLKNBR .EQ. 1) .OR.                                      &
     &     ( RPROC .LT. DAGMG_MUMPS_CNT_KIDS(ord%CBLKNBR, ord) )) THEN
         ord%TOPNODES(1) = 1
         ord%TOPNODES(2) = ord%RANGTAB(ord%CBLKNBR+1) - ord%RANGTAB(1)
         ord%TOPNODES(3) = ord%RANGTAB(1)
         ord%TOPNODES(4) = ord%RANGTAB(ord%CBLKNBR+1)-1
         ord%FIRST = 0
         ord%LAST  = -1
         RETURN
      END IF
      DO
         IF(NACTIVE .EQ. 0) EXIT
         BIG = ALIST(NACTIVE)
         NK  = DAGMG_MUMPS_CNT_KIDS(BIG, ord)
         IF((NK .GT. (RPROC-NACTIVE+1)) .OR. (NK .EQ. 0)) THEN
            ANODE       = ANODE+1
            LIST(ANODE) = BIG
            NACTIVE     = NACTIVE-1
            RPROC       = RPROC-1
            CYCLE
         END IF
         SD = DAGMG_MUMPS_STOP_DESCENT(id, ord, NACTIVE, ANODE,              &
     &        RPROC, ALIST, LIST, PEAKMEM, NNODES, CHECKMEM=.TRUE.)
         IF ( SD )                                                      &
     &        THEN
            IF(NACTIVE.GT.0) THEN
               LIST(ANODE+1:ANODE+NACTIVE) = ALIST(1:NACTIVE)
               ANODE = ANODE+NACTIVE
            END IF
            EXIT
         END IF
         ord%TOPNODES(1) = ord%TOPNODES(1)+1
         ord%TOPNODES(2) = ord%TOPNODES(2) +                            &
     &        ord%RANGTAB(BIG+1) - ord%RANGTAB(BIG)
         ord%TOPNODES(2+2*(ord%TOPNODES(1)-1)+1) = ord%RANGTAB(BIG)
         ord%TOPNODES(2+2*(ord%TOPNODES(1)-1)+2) =                      &
     &        ord%RANGTAB(BIG+1)-1
         CURR              = ord%SON(BIG)
         ALIST(NACTIVE)    = CURR
         AWEIGHTS(NACTIVE) = ord%NW(CURR)
         DO
            IF(ord%BROTHER(CURR) .EQ. -1) EXIT
            NACTIVE           = NACTIVE+1
            CURR              = ord%BROTHER(CURR)
            ALIST(NACTIVE)    = CURR
            AWEIGHTS(NACTIVE) = ord%NW(CURR)
         END DO
         CALL DAGMG_MUMPS_MERGESORT(NACTIVE, AWEIGHTS(1:NACTIVE),            &
     &        WORK(0:NACTIVE+1))
         CALL DAGMG_MUMPS_MERGESWAP(NACTIVE, WORK(0:NACTIVE+1),              &
     &        AWEIGHTS(1:NACTIVE),                                      &
     &        ALIST(1:NACTIVE))
      END DO
      DO I=1, ANODE
         AWEIGHTS(I) = ord%NW(LIST(I))
      END DO
      CALL DAGMG_MUMPS_MERGESORT(ANODE, AWEIGHTS(1:ANODE), WORK(0:ANODE+1))
      CALL DAGMG_MUMPS_MERGESWAP(ANODE, WORK(0:ANODE+1), AWEIGHTS(1:ANODE),  &
     &     ALIST(1:ANODE))
      IF (id%PAR .EQ. 1) THEN
         BASE = 0
      ELSE
         ord%FIRST(1) = 0
         ord%LAST(1)  = -1
         BASE = 1
      END IF
      DO I=1, ANODE
         CURR = LIST(I)
         ND = CURR
         IF(ord%SON(ND) .NE. -1) THEN
            ND = ord%SON(ND)
            DO
               IF((ord%SON(ND) .EQ. -1) .AND.                           &
     &              (ord%BROTHER(ND).EQ.-1)) THEN
                  EXIT
               ELSE IF(ord%BROTHER(ND) .EQ. -1) THEN
                  ND = ord%SON(ND)
               ELSE
                  ND = ord%BROTHER(ND)
               END IF
            END DO
         END IF
         ord%FIRST(BASE+I) = ord%RANGTAB(ND)
         ord%LAST(BASE+I)  = ord%RANGTAB(CURR+1)-1
      END DO
      DO I=ANODE+1, id%NSLAVES
         ord%FIRST(BASE+I) = id%N+1
         ord%LAST(BASE+I) = id%N
      END DO
      DEALLOCATE(LIST, ALIST, AWEIGHTS, WORK)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_GET_SUBTREES
      SUBROUTINE DAGMG_MUMPS_720(id, ord, GPE, GNV, WORK)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)   :: id
      TYPE(ORD_TYPE)       :: ord
      INTEGER, POINTER     :: GPE(:), GNV(:)
      INTEGER, POINTER     :: WORK(:)
      TYPE(GRAPH_TYPE)     :: top_graph
      INTEGER, POINTER     :: PE(:), IPE(:),                            &
     &     LENG(:), I_HALO_MAP(:)
      INTEGER, POINTER     :: NDENSE(:), LAST(:),                       &
     &     DEGREE(:), W(:), PERM(:),                                    &
     &     LISTVAR_SCHUR(:), NEXT(:),                                   &
     &     HEAD(:), NV(:), ELEN(:),                                     &
     &     RCVCNT(:), LSTVAR(:)
      INTEGER, POINTER     :: NROOTS(:), MYLIST(:),                     &
     &     MYNVAR(:), LVARPT(:),                                        &
     &     DISPLS(:),  LPERM(:),                                        &
     &     LIPERM(:),                                                   &
     &     IPET(:), NVT(:), BUF_PE1(:),                                 &
     &     BUF_PE2(:), BUF_NV1(:),                                      &
     &     BUF_NV2(:), ROOTPERM(:),                                     &
     &     TMP1(:), TMP2(:), BWORK(:)
      INTEGER              :: HIDX, NCMPA, I, J, SIZE_SCHUR, MYID,      &
     &     NPROCS, IERR, NROWS_LOC, GLOB_IDX, MYNROOTS, PNT, TMP,       &
     &     NCLIQUES, NTVAR, PFREES, PFREET, TGSIZE, MAXS, RHANDPE,      &
     &     RHANDNV, STATUSPE(AGMG_MPF_STATUS_SIZE),                          &
     &     STATUSNV(AGMG_MPF_STATUS_SIZE), RIDX, PROC, NBBUCK, MEMS, MEMP,   &
     &     TOT, TOT1, PES, PFS_SAVE, PFT_SAVE
      LOGICAL              :: AGG6, SYMQAMD
      INTEGER              :: THRESH, NSTEPS
      CHARACTER            :: STRING*60
      nullify(PE, IPE, LENG, I_HALO_MAP)
      nullify(NDENSE, LAST, DEGREE, W, PERM, LISTVAR_SCHUR,             &
     &     NEXT, HEAD, NV, ELEN, RCVCNT, LSTVAR)
      nullify(NROOTS, MYLIST, MYNVAR, LVARPT, DISPLS,                   &
     &     LPERM, LIPERM, IPET, NVT, BUF_PE1, BUF_PE2,                  &
     &     BUF_NV1, BUF_NV2, ROOTPERM, TMP1, TMP2, BWORK)
      CALL AGMG_SETIERR2( MYID, IERR)
      CALL AGMG_SETIERR12( NPROCS, IERR)
      IF(AGMG_MUMPS_GETSIZE(WORK) .LT. 4*id%N) THEN
         WRITE(LP,*)'Insufficient workspace in DMUMPS_720'
         CALL AGMG_MUMPS_ABORT()
      ELSE
         HEAD => WORK(       1 :   id%N)
         ELEN => WORK(  id%N+1 : 2*id%N)
         LENG => WORK(2*id%N+1 : 3*id%N)
         PERM => WORK(3*id%N+1 : 4*id%N)
      END IF
      CALL DAGMG_MUMPS_GET_SUBTREES(ord, id)
      CALL AGMG_MUMPS_734(ord%SON, ord%BROTHER, ord%NW,                      &
     &     ord%RANGTAB, MEMCNT=MEMCNT)
      NROWS_LOC = ord%LAST(MYID+1)-ord%FIRST(MYID+1)+1
      NRL = NROWS_LOC
      TOPROWS = ord%TOPNODES(2)
      BWORK => WORK(1 : 2*id%N)
      CALL DAGMG_MUMPS_BUILD_LOC_GRAPH(id, ord, HIDX, IPE, PE, LENG,         &
     &     I_HALO_MAP, top_graph, BWORK)
      TMP = id%N
      DO I=1, NPROCS
         TMP = TMP-(ord%LAST(I)-ord%FIRST(I)+1)
      END DO
      TMP = ceiling(dble(TMP)*1.10D0)
      IF(MYID .EQ. 0) THEN
         TMP = max(max(TMP, HIDX),1)
      ELSE
         TMP = max(HIDX,1)
      END IF
      SIZE_SCHUR = HIDX - NROWS_LOC
      CALL AGMG_MUMPS_733(NDENSE, TMP, id%INFO, LP,                          &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(LAST, TMP, id%INFO, LP,                            &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(NEXT, TMP, id%INFO, LP,                            &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(DEGREE, TMP, id%INFO, LP,                          &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(W, TMP, id%INFO, LP,                               &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(NV, TMP, id%INFO, LP,                              &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(LISTVAR_SCHUR, SIZE_SCHUR, id%INFO, LP,            &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      DO I=1, SIZE_SCHUR
         LISTVAR_SCHUR(I) = NROWS_LOC+I
      END DO
      THRESH = -1
      AGG6   = .TRUE.
      PFREES = IPE(NROWS_LOC+1)
      PFS_SAVE = PFREES
      IF (ord%SUBSTRAT .EQ. 0) THEN
         DO I=1, HIDX
            PERM(I) = I
         END DO
         CALL AGMG_MUMPS_420(1, THRESH, NDENSE, HIDX,                        &
     &        AGMG_MUMPS_GETSIZE(PE), IPE, PFREES, LENG, PE, NV, ELEN,       &
     &        LAST, NCMPA, DEGREE, HEAD, NEXT, W, PERM, LISTVAR_SCHUR,  &
     &        SIZE_SCHUR, AGG6)
      ELSE
         NBBUCK = 2*TMP
         CALL AGMG_MUMPS_419 (ord%SUBSTRAT, 1, .FALSE., HIDX, NBBUCK,        &
     &        AGMG_MUMPS_GETSIZE(PE), IPE, PFREES, LENG, PE, NV, ELEN, LAST, &
     &        NCMPA, DEGREE, PERM, NEXT, W, HEAD, AGG6, SIZE_SCHUR,     &
     &        LISTVAR_SCHUR )
         DO I=1, HIDX
            PERM(I) = I
         END DO
      END IF
      CALL AGMG_MUMPS_733(W, 2*NPROCS, id%INFO,                              &
     &     LP, STRING='W', MEMCNT=MEMCNT, ERRCODE=-7)
      if(memcnt .gt. maxmem) maxmem=memcnt
      NROOTS => W
      DISPLS => W(NPROCS+1:2*NPROCS)
      MYNVAR => DEGREE
      MYLIST => NDENSE
      LVARPT => NEXT
      RCVCNT => HEAD
      LSTVAR => LAST
      NULLIFY(W, DEGREE, NDENSE, NEXT, HEAD, LAST)
      MYNROOTS = 0
      PNT = 0
      DO I=1, HIDX
         IF(IPE(I) .GT. 0) THEN
            PNT = PNT+LENG(I)
            MYNROOTS = MYNROOTS+1
         END IF
      END DO
      CALL AGMG_MUMPS_733(MYLIST, PNT, id%INFO,                              &
     &     LP, STRING='MYLIST', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      MYNROOTS = 0
      PNT = 0
      DO I=1, HIDX
         IF(IPE(I) .GT. 0) THEN
            MYNROOTS = MYNROOTS+1
            MYNVAR(MYNROOTS) =  LENG(I)
            MYLIST(PNT+1:PNT+LENG(I)) = I_HALO_MAP(PE(IPE(I):IPE(I)+    &
     &           LENG(I)-1)-NROWS_LOC)
            PNT = PNT+LENG(I)
         END IF
      END DO
      CALL AGMG_SETIERR( IERR)
      CALL AGMG_COPY(MYNROOTS, NROOTS, 1, AGMG_MPF_INTEGER, IERR)
      IF(MYID .EQ.0) THEN
         DISPLS(1) = 0
         DO I=2, NPROCS
            DISPLS(I) = DISPLS(I-1)+NROOTS(I-1)
         END DO
         NCLIQUES = sum(NROOTS(1:NPROCS))
         CALL AGMG_MUMPS_733(LVARPT, NCLIQUES+1, id%INFO,                    &
     &        LP, STRING='LVARPT', MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      ELSE
         CALL AGMG_MUMPS_733(LVARPT, 2, id%INFO,                             &
     &        LP, STRING='LVARPT', MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      END IF
      CALL AGMG_COPY(MYNVAR, LVARPT(2), MYNROOTS, AGMG_MPF_INTEGER, IERR)
      IF(MYID .EQ. 0) THEN
         DO I=1, NPROCS
            RCVCNT(I) = sum(LVARPT(2+DISPLS(I):2+DISPLS(I)+NROOTS(I)-1))
            IF(I .EQ. 1) THEN
               DISPLS(I) = 0
            ELSE
               DISPLS(I) = DISPLS(I-1)+RCVCNT(I-1)
            END IF
         END DO
         CALL AGMG_MUMPS_733(LSTVAR, SUM(RCVCNT(1:NPROCS)), id%INFO,         &
     &     LP, STRING='LSTVAR', MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      END IF
      CALL AGMG_COPY(MYLIST, LSTVAR, PNT, AGMG_MPF_INTEGER, IERR)
      NULLIFY(DISPLS)
      IF(MYID .EQ. 0) THEN
         LVARPT(1) = 1
         DO I=2, NCLIQUES+1
            LVARPT(I) = LVARPT(I-1) + LVARPT(I)
         END DO
         LPERM => WORK(3*id%N+1 : 4*id%N)
         NTVAR   = ord%TOPNODES(2)
         CALL DAGMG_MUMPS_MAKE_LOC_IDX(id, ord%TOPNODES, LPERM, LIPERM, ord)
         CALL DAGMG_MUMPS_ASSEMBLE_TOP_GRAPH(id, ord%TOPNODES(2), LPERM,     &
     &        top_graph, NCLIQUES, LSTVAR, LVARPT, IPET, PE, LENG, ELEN)
         TGSIZE = ord%TOPNODES(2)+NCLIQUES
         PFREET = IPET(TGSIZE+1)
         PFT_SAVE = PFREET
         nullify(LPERM)
         CALL AGMG_MUMPS_734(top_graph%IRN_LOC,                              &
     &        top_graph%JCN_LOC, ord%TOPNODES, MEMCNT=MEMCNT)
         W       => NROOTS
         DEGREE  => MYNVAR
         NDENSE  => MYLIST
         NEXT    => LVARPT
         HEAD    => RCVCNT
         LAST    => LSTVAR
         NULLIFY(NROOTS, MYNVAR, MYLIST, LVARPT, RCVCNT, LSTVAR)
         CALL AGMG_MUMPS_733(PE, PFREET+TGSIZE, id%INFO, LP,                 &
     &        COPY=.TRUE., STRING='J2:PE', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(NDENSE, TGSIZE, id%INFO, LP,                    &
     &        STRING='J2:NDENSE', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(NVT, TGSIZE, id%INFO, LP,                       &
     &        STRING='J2:NVT', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(LAST, TGSIZE, id%INFO, LP,                      &
     &        STRING='J2:LAST', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(DEGREE, TGSIZE, id%INFO, LP,                    &
     &        STRING='J2:DEGREE', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(NEXT, TGSIZE, id%INFO, LP,                      &
     &        STRING='J2:NEXT', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(W, TGSIZE, id%INFO, LP,                         &
     &        STRING='J2:W', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(LISTVAR_SCHUR, NCLIQUES, id%INFO, LP,           &
     &        STRING='J2:LVSCH', MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
         DO I=1, NCLIQUES
            LISTVAR_SCHUR(I) = NTVAR+I
         END DO
         THRESH = -1
         IF(ord%TOPSTRAT .EQ. 0) THEN
            CALL AGMG_MUMPS_733(HEAD, TGSIZE, id%INFO,                       &
     &        LP, STRING='J2:HEAD', MEMCNT=MEMCNT, ERRCODE=-7)
            CALL AGMG_MUMPS_733(PERM, TGSIZE, id%INFO,                       &
     &           LP, COPY=.TRUE., STRING='J2:PERM',                     &
     &           MEMCNT=MEMCNT, ERRCODE=-7)
            IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
            DO I=NROWS_LOC+1, TGSIZE
               PERM(I) = I
            END DO
            CALL AGMG_MUMPS_420(2, -1, NDENSE, TGSIZE,                       &
     &           AGMG_MUMPS_GETSIZE(PE), IPET, PFREET, LENG, PE, NVT, ELEN,  &
     &           LAST, NCMPA, DEGREE, HEAD, NEXT, W, PERM,              &
     &           LISTVAR_SCHUR, NCLIQUES, AGG6)
         ELSE
            NBBUCK = 2*TGSIZE
            CALL AGMG_MUMPS_733(HEAD,      NBBUCK+2, id%INFO,                &
     &        LP, STRING='J2:HEAD', MEMCNT=MEMCNT, ERRCODE=-7)
            CALL AGMG_MUMPS_733(PERM,      TGSIZE, id%INFO,                  &
     &        LP, STRING='J2:PERM', MEMCNT=MEMCNT, ERRCODE=-7)
            IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
            CALL AGMG_MUMPS_419 (ord%TOPSTRAT, 2, .FALSE., TGSIZE,           &
     &           NBBUCK, AGMG_MUMPS_GETSIZE(PE), IPET, PFREET, LENG, PE, NVT,&
     &           ELEN, LAST, NCMPA, DEGREE, PERM, NEXT, W, HEAD, AGG6,  &
     &           NCLIQUES, LISTVAR_SCHUR )
         END IF
      END IF
      CALL AGMG_SETIERR( IERR)
      CALL AGMG_MUMPS_734(LISTVAR_SCHUR, PE, MEMCNT=MEMCNT)
      IF(MYID .EQ. 0) THEN
         BUF_PE1 => WORK(       1 :   id%N)
         BUF_PE2 => WORK(  id%N+1 : 2*id%N)
         BUF_NV1 => WORK(2*id%N+1 : 3*id%N)
         BUF_NV2 => WORK(3*id%N+1 : 4*id%N)
         MAXS = NROWS_LOC
         DO I=2, NPROCS
            IF((ord%LAST(I)-ord%FIRST(I)+1) .GT. MAXS)                  &
     &           MAXS = (ord%LAST(I)-ord%FIRST(I)+1)
         END DO
         CALL AGMG_MUMPS_733(BUF_PE1, MAXS, id%INFO,                         &
     &        LP, STRING='BUF_PE1', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(BUF_PE2, MAXS, id%INFO,                         &
     &        LP, STRING='BUF_PE2', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(BUF_NV1, MAXS, id%INFO,                         &
     &        LP, STRING='BUF_NV1', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(BUF_NV2, MAXS, id%INFO,                         &
     &        LP, STRING='BUF_NV2', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(GPE, id%N, id%INFO,                             &
     &        LP, STRING='GPE', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(GNV, id%N, id%INFO,                             &
     &        LP, STRING='GNV', MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(ROOTPERM, NCLIQUES, id%INFO,                    &
     &        LP, STRING='ROOTPERM', MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
         RIDX = 0
         TMP1    => BUF_PE1
         TMP2    => BUF_NV1
         NULLIFY(BUF_PE1, BUF_NV1)
         BUF_PE1 => IPE
         BUF_NV1 => NV
         DO PROC=0, NPROCS-2
            CALL AGMG_SETIERR( IERR)
            CALL AGMG_SETIERR( IERR)
            DO I=1, ord%LAST(PROC+1)-ord%FIRST(PROC+1)+1
               GLOB_IDX = ord%PERITAB(I+ord%FIRST(PROC+1)-1)
               IF(BUF_PE1(I) .GT. 0) THEN
                  RIDX=RIDX+1
                  ROOTPERM(RIDX) = GLOB_IDX
                  GNV(GLOB_IDX) = BUF_NV1(I)
               ELSE IF (BUF_PE1(I) .EQ. 0) THEN
                  GPE(GLOB_IDX) = 0
                  GNV(GLOB_IDX) = BUF_NV1(I)
               ELSE
                  GPE(GLOB_IDX) = -ord%PERITAB(-BUF_PE1(I)+             &
     &                 ord%FIRST(PROC+1)-1)
                  GNV(GLOB_IDX) = BUF_NV1(I)
               END IF
            END DO
            CALL AGMG_NOCALL('MPI_WAIT')
            CALL AGMG_NOCALL('MPI_WAIT')
            IF(PROC .NE. 0) THEN
               TMP1    => BUF_PE1
               TMP2    => BUF_NV1
            END IF
            BUF_PE1 => BUF_PE2
            BUF_NV1 => BUF_NV2
            NULLIFY(BUF_PE2, BUF_NV2)
            BUF_PE2 => TMP1
            BUF_NV2 => TMP2
            NULLIFY(TMP1, TMP2)
         END DO
         DO I=1, ord%LAST(PROC+1)-ord%FIRST(PROC+1)+1
            GLOB_IDX = ord%PERITAB(I+ord%FIRST(PROC+1)-1)
            IF(BUF_PE1(I) .GT. 0) THEN
               RIDX=RIDX+1
               ROOTPERM(RIDX) = GLOB_IDX
               GNV(GLOB_IDX) = BUF_NV1(I)
            ELSE IF (BUF_PE1(I) .EQ. 0) THEN
               GPE(GLOB_IDX) = 0
               GNV(GLOB_IDX) = BUF_NV1(I)
            ELSE
               GPE(GLOB_IDX) = -ord%PERITAB(-BUF_PE1(I)+                &
     &              ord%FIRST(PROC+1)-1)
               GNV(GLOB_IDX) = BUF_NV1(I)
            END IF
         END DO
         DO I=1, NTVAR
            GLOB_IDX = LIPERM(I)
            IF(IPET(I) .EQ. 0) THEN
               GPE(GLOB_IDX) = 0
               GNV(GLOB_IDX) = NVT(I)
            ELSE
               GPE(GLOB_IDX) = -LIPERM(-IPET(I))
               GNV(GLOB_IDX) = NVT(I)
            END IF
         END DO
         DO I=1, NCLIQUES
            GLOB_IDX      = ROOTPERM(I)
            GPE(GLOB_IDX) = -LIPERM(-IPET(NTVAR+I))
         END DO
      ELSE
         CALL AGMG_NOCALL('MPI_SEND')
         CALL AGMG_NOCALL('MPI_SEND')
      END IF
      CALL AGMG_MUMPS_734(PE, IPE, I_HALO_MAP, NDENSE,                       &
     &     LAST, DEGREE, MEMCNT=MEMCNT)
      CALL AGMG_MUMPS_734(W, LISTVAR_SCHUR, NEXT,                            &
     &     NV, MEMCNT=MEMCNT)
      CALL AGMG_MUMPS_734(LSTVAR, NROOTS, MYLIST, MYNVAR,                    &
     &     LVARPT, MEMCNT=MEMCNT)
      CALL AGMG_MUMPS_734(LPERM, LIPERM, IPET, NVT,                          &
     &     MEMCNT=MEMCNT)
      CALL AGMG_MUMPS_734(ROOTPERM, TMP1, TMP2, MEMCNT=MEMCNT)
      NULLIFY(HEAD, ELEN, LENG, PERM, RCVCNT)
!     $     associated(LENG), associated(I_HALO_MAP),
!     $     associated(NDENSE), associated(LAST), associated(DEGREE),
!     $     associated(W), associated(PERM), associated(LISTVAR_SCHUR),
!     $     associated(NEXT), associated(HEAD), associated(NV),
!     $     associated(ELEN), associated(RCVCNT), associated(LSTVAR),
!     $     associated(NROOTS), associated(MYLIST), associated(MYNVAR),
!     $     associated(LVARPT), associated(DISPLS),  associated(LPERM),
!     $     associated(LIPERM), associated(IPET), associated(NVT),
!     $     associated(BUF_PE1), associated(BUF_PE2),
!     $     associated(BUF_NV1), associated(BUF_NV2),
!     $     associated(ROOTPERM), associated(TMP1), associated(TMP2)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_720
      SUBROUTINE DAGMG_MUMPS_MAKE_LOC_IDX(id, TOPNODES, LPERM, LIPERM, ord)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)   :: id
      INTEGER, POINTER  :: TOPNODES(:), LPERM(:), LIPERM(:)
      TYPE(ORD_TYPE)    :: ord
      INTEGER           :: I, J, K, GIDX
      CHARACTER         :: STRING*30
      CALL AGMG_MUMPS_733(LPERM , ord%N, id%INFO,                            &
     &        LP, STRING='LIDX:LPERM', MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(LIPERM, TOPNODES(2), id%INFO,                      &
     &        LP, STRING='LIDX:LIPERM', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      LPERM = 0
      K = 1
      DO I=1, TOPNODES(1)
         DO J=TOPNODES(2*I+1), TOPNODES(2*I+2)
            GIDX        = ord%PERITAB(J)
            LPERM(GIDX) = K
            LIPERM(K)   = GIDX
            K           = K+1
         END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_MAKE_LOC_IDX
      SUBROUTINE DAGMG_MUMPS_ASSEMBLE_TOP_GRAPH(id, NLOCVARS, LPERM,         &
     &     top_graph, NCLIQUES, LSTVAR, LVARPT, IPE, PE, LENG, ELEN)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC) :: id
      TYPE(GRAPH_TYPE)   :: top_graph
      INTEGER, POINTER   :: LPERM(:), LSTVAR(:), LVARPT(:),             &
     &     IPE(:), PE(:), LENG(:), ELEN(:)
      INTEGER            :: NCLIQUES, IERR
      INTEGER            :: I, J, IDX, NLOCVARS, PNT, SAVEPNT
      CHARACTER          :: STRING*30
      CALL AGMG_MUMPS_733(LENG, NLOCVARS+NCLIQUES  , id%INFO,                &
     &        LP, STRING='ATG:LENG', MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(ELEN, NLOCVARS+NCLIQUES  , id%INFO,                &
     &        LP, STRING='ATG:ELEN', MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(IPE , NLOCVARS+NCLIQUES+1, id%INFO,                &
     &        LP, STRING='ATG:IPE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      LENG = 0
      ELEN = 0
      DO I=1, top_graph%NZ_LOC
         IF((LPERM(top_graph%JCN_LOC(I)) .NE. 0) .AND.                  &
     &        (top_graph%JCN_LOC(I) .NE. top_graph%IRN_LOC(I))) THEN
            LENG(LPERM(top_graph%IRN_LOC(I))) =                         &
     &           LENG(LPERM(top_graph%IRN_LOC(I))) + 1
         END IF
      END DO
      DO I=1, NCLIQUES
         DO J=LVARPT(I), LVARPT(I+1)-1
            ELEN(LPERM(LSTVAR(J))) = ELEN(LPERM(LSTVAR(J)))+1
            LENG(NLOCVARS+I) = LENG(NLOCVARS+I)+1
         END DO
      END DO
      IPE(1) = 1
      DO I=1, NLOCVARS+NCLIQUES
         IPE(I+1) = IPE(I)+LENG(I)+ELEN(I)
      END DO
      CALL AGMG_MUMPS_733(PE, IPE(NLOCVARS+NCLIQUES+1)+NLOCVARS+NCLIQUES,    &
     &     id%INFO, LP, STRING='ATG:PE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      LENG = 0
      ELEN = 0
      DO I=1, NCLIQUES
         DO J=LVARPT(I), LVARPT(I+1)-1
            IDX = LPERM(LSTVAR(J))
            PE(IPE(IDX)+ELEN(IDX)) = NLOCVARS+I
            PE(IPE(NLOCVARS+I)+LENG(NLOCVARS+I)) = IDX
            ELEN(LPERM(LSTVAR(J))) = ELEN(LPERM(LSTVAR(J)))+1
            LENG(NLOCVARS+I) = LENG(NLOCVARS+I)+1
         end do
      end do
      DO I=1, top_graph%NZ_LOC
         IF((LPERM(top_graph%JCN_LOC(I)) .NE. 0) .AND.                  &
     &        (top_graph%JCN_LOC(I) .NE. top_graph%IRN_LOC(I))) THEN
            PE(IPE(LPERM(top_graph%IRN_LOC(I)))+                        &
     &           ELEN(LPERM(top_graph%IRN_LOC(I))) +                    &
     &           LENG(LPERM(top_graph%IRN_LOC(I)))) =                   &
     &           LPERM(top_graph%JCN_LOC(I))
            LENG(LPERM(top_graph%IRN_LOC(I))) =                         &
     &           LENG(LPERM(top_graph%IRN_LOC(I))) + 1
         END IF
      END DO
      LENG(1:NLOCVARS+NCLIQUES) = LENG(1:NLOCVARS+NCLIQUES)+            &
     &     ELEN(1:NLOCVARS+NCLIQUES)
      SAVEPNT = 1
      PNT = 0
      LPERM(1:NLOCVARS+NCLIQUES) = 0
      DO I=1, NLOCVARS+NCLIQUES
         DO J=IPE(I), IPE(I+1)-1
            IF(LPERM(PE(J)) .EQ. I) THEN
               LENG(I) = LENG(I)-1
            ELSE
               LPERM(PE(J)) = I
               PNT = PNT+1
               PE(PNT) = PE(J)
            END IF
         END DO
         IPE(I) = SAVEPNT
         SAVEPNT = PNT+1
      END DO
      IPE(NLOCVARS+NCLIQUES+1) = SAVEPNT
      RETURN
      END SUBROUTINE DAGMG_MUMPS_ASSEMBLE_TOP_GRAPH
      SUBROUTINE DAGMG_MUMPS_BUILD_TREETAB(TREETAB, RANGTAB, SIZES, CBLKNBR)
      INTEGER, POINTER  :: TREETAB(:), RANGTAB(:), SIZES(:)
      INTEGER           :: CBLKNBR, SUBNODES
      INTEGER           :: LCHILD, RCHILD, K, I
      INTEGER, POINTER  :: PERM(:)
      ALLOCATE(PERM(CBLKNBR))
      TREETAB(CBLKNBR) = -1
      IF(CBLKNBR .EQ. 1) THEN
         DEALLOCATE(PERM)
         TREETAB(1) = -1
         RANGTAB(1:2) = (/1, SIZES(1)+1/)
         RETURN
      END IF
      LCHILD = CBLKNBR - (CBLKNBR+1)/2
      RCHILD = CBLKNBR-1
      K = 1
      PERM(CBLKNBR) = CBLKNBR
      PERM(LCHILD) = CBLKNBR+1 - (2*K+1)
      PERM(RCHILD) = CBLKNBR+1 - (2*K)
      TREETAB(RCHILD) = CBLKNBR
      TREETAB(LCHILD) = CBLKNBR
      IF(CBLKNBR .GT. 3) THEN
         CALL REC_TREETAB(TREETAB, PERM, (CBLKNBR-1)/2,                 &
     &        LCHILD, CBLKNBR, 2*K+1)
         CALL REC_TREETAB(TREETAB, PERM, (CBLKNBR-1)/2,                 &
     &        RCHILD, CBLKNBR, 2*K)
      END IF
      RANGTAB(1)=1
      DO I=1, CBLKNBR
         RANGTAB(I+1) = RANGTAB(I)+SIZES(PERM(I))
      END DO
      DEALLOCATE(PERM)
      RETURN
      CONTAINS
      RECURSIVE SUBROUTINE REC_TREETAB(TREETAB, PERM, SUBNODES,         &
     &     ROOTN, CBLKNBR, K)
      INTEGER, POINTER  :: TREETAB(:), PERM(:)
      INTEGER           :: SUBNODES, ROOTN, K, CBLKNBR
      INTEGER           :: LCHILD, RCHILD
      LCHILD = ROOTN - (SUBNODES+1)/2
      RCHILD = ROOTN-1
      PERM(LCHILD) = CBLKNBR+1 - (2*K+1)
      PERM(RCHILD) = CBLKNBR+1 - (2*K)
      TREETAB(RCHILD) = ROOTN
      TREETAB(LCHILD) = ROOTN
      IF(SUBNODES .GT. 3) THEN
         CALL REC_TREETAB(TREETAB, PERM, (SUBNODES-1)/2, LCHILD,        &
     &        CBLKNBR, 2*K+1)
         CALL REC_TREETAB(TREETAB, PERM, (SUBNODES-1)/2, RCHILD,        &
     &        CBLKNBR, 2*K)
      END IF
      END SUBROUTINE REC_TREETAB
      END SUBROUTINE DAGMG_MUMPS_BUILD_TREETAB
      SUBROUTINE DAGMG_MUMPS_BUILD_SCOTCH_GRAPH(id, FIRST, LAST, IPE,        &
     &     PE, WORK)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)      :: id
      INTEGER, POINTER        :: FIRST(:), LAST(:), IPE(:), PE(:),      &
     &     WORK(:)
      INTEGER                 :: IERR, MYID, NPROCS
      INTEGER                 :: M, N, NNZ, IVAL, I, PROC, LOCNNZ,      &
     &     NEW_LOCNNZ, J, LOC_ROW
      INTEGER                 :: SENDSIZE, IDX, TOP_CNT, TIDX,          &
     &     NROWS_LOC, DUPS, TOTDUPS, OFFDIAG
      INTEGER                 :: STATUS(AGMG_MPF_STATUS_SIZE)
      INTEGER, POINTER        :: MAPTAB(:),                             &
     &     SNDCNT(:), RCVCNT(:), SDISPL(:)
      INTEGER, POINTER        :: RDISPL(:),                             &
     &     MSGCNT(:), SIPES(:,:), LENG(:)
      INTEGER, POINTER        :: PCNT(:), TSENDI(:),                    &
     &     TSENDJ(:), RCVBUF(:)
      TYPE(ARRPNT), POINTER   :: APNT(:)
      INTEGER                 :: BUFSIZE, SOURCE, RCVPNT, MAXS, PNT,    &
     &     SAVEPNT
      INTEGER, PARAMETER      :: ITAG=30
      LOGICAL                 :: FLAG
      DOUBLE PRECISION        :: SYMMETRY
      nullify(MAPTAB, SNDCNT, RCVCNT, SDISPL)
      nullify(RDISPL, MSGCNT, SIPES, LENG)
      nullify(PCNT, TSENDI, TSENDJ, RCVBUF, APNT)
      CALL AGMG_SETIERR2( MYID, IERR)
      CALL AGMG_SETIERR12( NPROCS, IERR)
      IF(AGMG_MUMPS_GETSIZE(WORK) .LT. id%N*2) THEN
         WRITE(LP,                                                      &
     &        '("Insufficient workspace inside BUILD_SCOTCH_GRAPH")')
         CALL AGMG_MUMPS_ABORT()
      END IF
      CALL AGMG_MUMPS_733(SNDCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(RCVCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(MSGCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      ALLOCATE(APNT(NPROCS))
      SNDCNT = 0
      TOP_CNT = 0
      BUFSIZE = 1000
      LOCNNZ = id%NZ_LOC
      NROWS_LOC = LAST(MYID+1)-FIRST(MYID+1)+1
      MAPTAB => WORK(     1 :   id%N)
      LENG   => WORK(id%N+1 : 2*id%N)
      MAXS = 0
      DO I=1, NPROCS
         IF((LAST(I)-FIRST(I)+1) .GT. MAXS) THEN
            MAXS = LAST(I)-FIRST(I)+1
         END IF
         DO J=FIRST(I), LAST(I)
            MAPTAB(J) = I
         END DO
      END DO
      ALLOCATE(SIPES(max(1,MAXS), NPROCS))
      OFFDIAG=0
      SIPES=0
      DO I=1, id%NZ_LOC
         IF(id%IRN_LOC(I) .NE. id%JCN_LOC(I)) THEN
            OFFDIAG = OFFDIAG+1
            PROC = MAPTAB(id%IRN_LOC(I))
            LOC_ROW = id%IRN_LOC(I)-FIRST(PROC)+1
            SIPES(LOC_ROW, PROC) = SIPES(LOC_ROW, PROC)+1
            SNDCNT(PROC) = SNDCNT(PROC)+1
            PROC = MAPTAB(id%JCN_LOC(I))
            LOC_ROW = id%JCN_LOC(I)-FIRST(PROC)+1
            SIPES(LOC_ROW, PROC) = SIPES(LOC_ROW, PROC)+1
            SNDCNT(PROC) = SNDCNT(PROC)+1
         END IF
      END DO
      CALL AGMG_COPY(OFFDIAG, id%KEEP(114), 1, AGMG_MPF_INTEGER, IERR)
      id%KEEP(114) = id%KEEP(114)+3*id%N
      id%KEEP(113) = id%KEEP(114)-2*id%N
      CALL AGMG_MPF_ALLTOALL(SNDCNT, 1, AGMG_MPF_INTEGER, RCVCNT, 1,              &
     &     AGMG_MPF_INTEGER, id%COMM, IERR)
      SNDCNT(:) = MAXS
      CALL AGMG_COPY( SIPES, LENG, SNDCNT, AGMG_MPF_INTEGER, IERR )
      DEALLOCATE(SIPES)
      CALL AGMG_MUMPS_733(IPE, NROWS_LOC+1, id%INFO,                         &
     &        LP, STRING='IPE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      IPE(1) = 1
      DO I=1, NROWS_LOC
         IPE(I+1) = IPE(I) + LENG(I)
      END DO
      CALL AGMG_MUMPS_733(PE, IPE(NROWS_LOC+1)-1, id%INFO,                   &
     &        LP, STRING='PE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      LENG(:) = 0
      CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE, PE, LENG,  &
     &     RCVBUF, MSGCNT, SNDCNT, id%COMM)
      NEW_LOCNNZ = sum(RCVCNT)
      MSGCNT = RCVCNT/BUFSIZE
      RCVPNT = 1
      SNDCNT = 0
      TIDX   = 0
      DO I=1, id%NZ_LOC
         IF(mod(I,BUFSIZE/10) .EQ. 0) THEN
            CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, ITAG, AGMG_MPF_COMM_WORLD,      &
     &           FLAG, STATUS, IERR )
            IF(FLAG) THEN
               SOURCE = STATUS(AGMG_MPF_SOURCE)
               CALL AGMG_NOCALL('MPI_RECV')
               CALL DAGMG_MUMPS_ASSEMBLE_MSG(BUFSIZE, RCVBUF, IPE, PE, LENG)
               MSGCNT(SOURCE+1)=MSGCNT(SOURCE+1)-1
               RCVPNT = RCVPNT + BUFSIZE
            END IF
         END IF
         IF(id%IRN_LOC(I) .NE. id%JCN_LOC(I)) THEN
            PROC = MAPTAB(id%IRN_LOC(I))
            APNT(PROC)%BUF(2*SNDCNT(PROC)+1) = id%IRN_LOC(I)-           &
     &           FIRST(PROC)+1
            APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = id%JCN_LOC(I)
            SNDCNT(PROC) = SNDCNT(PROC)+1
            IF(SNDCNT(PROC) .EQ. BUFSIZE) THEN
               CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE,   &
     &              PE, LENG, RCVBUF, MSGCNT, SNDCNT, id%COMM)
            END IF
            PROC = MAPTAB(id%JCN_LOC(I))
            APNT(PROC)%BUF(2*SNDCNT(PROC)+1) = id%JCN_LOC(I)-           &
     &           FIRST(PROC)+1
            APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = id%IRN_LOC(I)
            SNDCNT(PROC) = SNDCNT(PROC)+1
            IF(SNDCNT(PROC) .EQ. BUFSIZE) THEN
               CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE,   &
     &              PE, LENG, RCVBUF, MSGCNT, SNDCNT, id%COMM)
            END IF
         END IF
      END DO
      CALL DAGMG_MUMPS_SEND_BUF(APNT, -1, NPROCS, BUFSIZE, IPE, PE, LENG,    &
     &     RCVBUF, MSGCNT, SNDCNT, id%COMM)
      DUPS = 0
      PNT = 0
      SAVEPNT = 1
      MAPTAB = 0
      DO I=1, NROWS_LOC
         DO J=IPE(I),IPE(I+1)-1
            IF(MAPTAB(PE(J)) .EQ. I) THEN
               DUPS = DUPS+1
            ELSE
               MAPTAB(PE(J)) = I
               PNT = PNT+1
               PE(PNT) = PE(J)
            END IF
         END DO
         IPE(I) = SAVEPNT
         SAVEPNT = PNT+1
      END DO
      CALL AGMG_COPY( DUPS, TOTDUPS, 1, AGMG_MPF_INTEGER, IERR )
      SYMMETRY = dble(TOTDUPS)/(dble(id%NZ)-dble(id%N))
      IF(MYID .EQ. 0) THEN
         IF(id%SYM .GE. 1) SYMMETRY = 1.d0
         IF(PROKG) WRITE(MPG,'("Structual symmetry is:",i3,"%")')       &
     &        CEILING(SYMMETRY*100.d0)
      id%INFOG(8) = ceiling(SYMMETRY*100.0D0)
      END IF
      IPE(NROWS_LOC+1) = SAVEPNT
      CALL AGMG_MUMPS_734(SNDCNT, RCVCNT, MSGCNT, MEMCNT=MEMCNT)
      DEALLOCATE(APNT)
!     $     associated(SNDCNT), associated(RCVCNT),
!     $     associated(SDISPL), associated(RDISPL), associated(MSGCNT),
!     $     associated(SIPES), associated(LENG), associated(PCNT),
!     $     associated(TSENDI), associated(TSENDJ), associated(RCVBUF),
!     $     associated(APNT)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_BUILD_SCOTCH_GRAPH
      SUBROUTINE DAGMG_MUMPS_BUILD_LOC_GRAPH(id, ord, GSIZE, IPE, PE, LENG,  &
     &     I_HALO_MAP, top_graph, WORK)
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)   :: id
      TYPE(ORD_TYPE)       :: ord
      TYPE(GRAPH_TYPE)     :: top_graph
      INTEGER, POINTER     :: IPE(:), PE(:), LENG(:),                   &
     &     I_HALO_MAP(:), WORK(:)
      INTEGER              :: GSIZE
      INTEGER                :: IERR, MYID, NPROCS
      INTEGER                :: M, N, NNZ, IVAL, I, PROC, LOCNNZ,       &
     &     NEW_LOCNNZ, J, LOC_ROW
      INTEGER                :: SENDSIZE, IDX, TOP_CNT, TOTDUPS,        &
     &     IIDX, JJDX
      INTEGER                :: HALO_SIZE, TIDX, NROWS_LOC, DUPS
      INTEGER                :: STATUS(AGMG_MPF_STATUS_SIZE)
      INTEGER, POINTER       :: MAPTAB(:),                              &
     &     SNDCNT(:), RCVCNT(:),                                        &
     &     SDISPL(:), HALO_MAP(:)
      INTEGER, POINTER       :: RDISPL(:),                              &
     &     MSGCNT(:), SIPES(:,:)
      INTEGER, POINTER       :: PCNT(:), TSENDI(:),                     &
     &     TSENDJ(:), RCVBUF(:)
      TYPE(ARRPNT), POINTER  :: APNT(:)
      INTEGER                :: BUFSIZE, SOURCE, RCVPNT, MAXS, PNT,     &
     &     SAVEPNT
      INTEGER, PARAMETER     :: ITAG=30
      LOGICAL                :: FLAG
      DOUBLE PRECISION       :: SYMMETRY
      nullify(MAPTAB, SNDCNT, RCVCNT, SDISPL, HALO_MAP)
      nullify(RDISPL, MSGCNT, SIPES)
      nullify(PCNT, TSENDI, TSENDJ, RCVBUF, APNT)
      CALL AGMG_SETIERR2( MYID, IERR)
      CALL AGMG_SETIERR12( NPROCS, IERR)
      IF(AGMG_MUMPS_GETSIZE(WORK) .LT. id%N*2) THEN
         WRITE(LP,                                                      &
     &        '("Insufficient workspace inside BUILD_LOC_GRAPH")')
         CALL AGMG_MUMPS_ABORT()
      END IF
      MAPTAB   => WORK(     1 :   id%N)
      HALO_MAP => WORK(id%N+1 : 2*id%N)
      CALL AGMG_MUMPS_733(SNDCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(RCVCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(MSGCNT, NPROCS, id%INFO, LP,                       &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      ALLOCATE(APNT(NPROCS))
      SNDCNT = 0
      TOP_CNT = 0
      BUFSIZE = 10000
      LOCNNZ = id%NZ_LOC
      NROWS_LOC = ord%LAST(MYID+1)-ord%FIRST(MYID+1)+1
      MAPTAB = 0
      MAXS = 0
      DO I=1, NPROCS
         IF((ord%LAST(I)-ord%FIRST(I)+1) .GT. MAXS) THEN
            MAXS = ord%LAST(I)-ord%FIRST(I)+1
         END IF
         DO J=ord%FIRST(I), ord%LAST(I)
            MAPTAB(ord%PERITAB(J)) = I
         END DO
      END DO
      ALLOCATE(SIPES(max(1,MAXS), NPROCS))
      SIPES(:,:)  = 0
      TOP_CNT     = 0
      DO I=1, id%NZ_LOC
         IF(id%IRN_LOC(I) .NE. id%JCN_LOC(I)) THEN
            PROC = MAPTAB(id%IRN_LOC(I))
            IF(PROC .EQ. 0) THEN
               TOP_CNT = TOP_CNT+1
            ELSE
               IIDX = ord%PERMTAB(id%IRN_LOC(I))
               LOC_ROW = IIDX-ord%FIRST(PROC)+1
               SIPES(LOC_ROW, PROC) = SIPES(LOC_ROW, PROC)+1
               SNDCNT(PROC) = SNDCNT(PROC)+1
            END IF
            PROC = MAPTAB(id%JCN_LOC(I))
            IF(PROC .EQ. 0) THEN
               TOP_CNT = TOP_CNT+1
            ELSE
               IIDX = ord%PERMTAB(id%JCN_LOC(I))
               LOC_ROW = IIDX-ord%FIRST(PROC)+1
               SIPES(LOC_ROW, PROC) = SIPES(LOC_ROW, PROC)+1
               SNDCNT(PROC) = SNDCNT(PROC)+1
            END IF
         END IF
      END DO
      CALL AGMG_MPF_ALLTOALL(SNDCNT, 1, AGMG_MPF_INTEGER, RCVCNT, 1,              &
     &     AGMG_MPF_INTEGER, id%COMM, IERR)
      I = ceiling(dble(MAXS)*1.20D0)
      CALL AGMG_MUMPS_733(LENG, I, id%INFO,                                  &
     &        LP, STRING='B_L_G:LENG', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      SNDCNT(:) = MAXS
      CALL AGMG_COPY( SIPES, LENG, SNDCNT, AGMG_MPF_INTEGER, IERR )
      DEALLOCATE(SIPES)
      I = ceiling(dble(NROWS_LOC+1)*1.20D0)
      CALL AGMG_MUMPS_733(IPE, I, id%INFO,                                   &
     &        LP, STRING='B_L_G:IPE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      IPE(1) = 1
      DO I=1, NROWS_LOC
         IPE(I+1) = IPE(I) + LENG(I)
      END DO
      CALL AGMG_MUMPS_733(TSENDI, TOP_CNT, id%INFO, LP,                      &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      CALL AGMG_MUMPS_733(TSENDJ, TOP_CNT, id%INFO, LP,                      &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      LENG(:) = 0
      CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE, PE,        &
     &     LENG, RCVBUF, MSGCNT, SNDCNT, id%COMM)
      NEW_LOCNNZ = sum(RCVCNT)
      MSGCNT = RCVCNT/BUFSIZE
      CALL AGMG_MUMPS_733(PE, NEW_LOCNNZ+2*NROWS_LOC, id%INFO,               &
     &        LP, STRING='B_L_G:PE', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      RCVPNT = 1
      SNDCNT = 0
      TIDX   = 0
      DO I=1, id%NZ_LOC
         IF(mod(I,BUFSIZE/10) .EQ. 0) THEN
            CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, ITAG, AGMG_MPF_COMM_WORLD,      &
     &           FLAG, STATUS, IERR )
            IF(FLAG) THEN
               SOURCE = STATUS(AGMG_MPF_SOURCE)
               CALL AGMG_NOCALL('MPI_RECV')
               CALL DAGMG_MUMPS_ASSEMBLE_MSG(BUFSIZE, RCVBUF, IPE, PE, LENG)
               MSGCNT(SOURCE+1)=MSGCNT(SOURCE+1)-1
               RCVPNT = RCVPNT + BUFSIZE
            END IF
         END IF
         IF(id%IRN_LOC(I) .NE. id%JCN_LOC(I)) THEN
            PROC = MAPTAB(id%IRN_LOC(I))
            IF(PROC .EQ. 0) THEN
               TIDX = TIDX+1
               TSENDI(TIDX) = id%IRN_LOC(I)
               TSENDJ(TIDX) = id%JCN_LOC(I)
            ELSE
               IIDX = ord%PERMTAB(id%IRN_LOC(I))
               JJDX = ord%PERMTAB(id%JCN_LOC(I))
               APNT(PROC)%BUF(2*SNDCNT(PROC)+1) =IIDX-ord%FIRST(PROC)+1
               IF( (JJDX .GE. ord%FIRST(PROC)) .AND.                    &
     &              (JJDX .LE. ord%LAST(PROC)) ) THEN
               APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = JJDX-ord%FIRST(PROC)+1
            ELSE
               APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = -id%JCN_LOC(I)
            END IF
            SNDCNT(PROC) = SNDCNT(PROC)+1
            IF(SNDCNT(PROC) .EQ. BUFSIZE) THEN
               CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE,   &
     &              PE, LENG, RCVBUF, MSGCNT, SNDCNT, id%COMM)
            END IF
         END IF
         PROC = MAPTAB(id%JCN_LOC(I))
         IF(PROC .EQ. 0) THEN
            TIDX = TIDX+1
            TSENDI(TIDX) = id%JCN_LOC(I)
            TSENDJ(TIDX) = id%IRN_LOC(I)
         ELSE
            IIDX = ord%PERMTAB(id%JCN_LOC(I))
            JJDX = ord%PERMTAB(id%IRN_LOC(I))
            APNT(PROC)%BUF(2*SNDCNT(PROC)+1) = IIDX-ord%FIRST(PROC)+1
            IF( (JJDX .GE. ord%FIRST(PROC)) .AND.                       &
     &           (JJDX .LE. ord%LAST(PROC)) ) THEN
            APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = JJDX-ord%FIRST(PROC)+1
         ELSE
            APNT(PROC)%BUF(2*SNDCNT(PROC)+2) = -id%IRN_LOC(I)
         END IF
         SNDCNT(PROC) = SNDCNT(PROC)+1
         IF(SNDCNT(PROC) .EQ. BUFSIZE) THEN
            CALL DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE, PE,  &
     &           LENG, RCVBUF, MSGCNT, SNDCNT, id%COMM)
         END IF
      END IF
      END IF
      END DO
      CALL DAGMG_MUMPS_SEND_BUF(APNT, -1, NPROCS, BUFSIZE, IPE, PE, LENG,    &
     &     RCVBUF, MSGCNT, SNDCNT, id%COMM)
      DUPS = 0
      PNT = 0
      SAVEPNT = 1
      MAPTAB(:) = 0
      HALO_MAP(:) = 0
      HALO_SIZE = 0
      DO I=1, NROWS_LOC
         DO J=IPE(I),IPE(I+1)-1
            IF(PE(J) .LT. 0) THEN
               IF(HALO_MAP(-PE(J)) .EQ. 0) THEN
                  HALO_SIZE = HALO_SIZE+1
                  HALO_MAP(-PE(J)) = NROWS_LOC+HALO_SIZE
               END IF
               PE(J) = HALO_MAP(-PE(J))
            END IF
            IF(MAPTAB(PE(J)) .EQ. I) THEN
               DUPS = DUPS+1
               LENG(I) = LENG(I)-1
            ELSE
               MAPTAB(PE(J)) = I
               PNT = PNT+1
               PE(PNT) = PE(J)
            END IF
         END DO
         IPE(I) = SAVEPNT
         SAVEPNT = PNT+1
      END DO
      IPE(NROWS_LOC+1) = SAVEPNT
      CALL AGMG_MUMPS_733(I_HALO_MAP, HALO_SIZE, id%INFO, LP,                &
     &     MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      J=0
      DO I=1, id%N
         IF(HALO_MAP(I) .GT. 0) THEN
            J = J+1
            I_HALO_MAP(HALO_MAP(I)-NROWS_LOC) = I
         END IF
         IF(J .EQ. HALO_SIZE) EXIT
      END DO
      CALL AGMG_MUMPS_733(LENG, NROWS_LOC+HALO_SIZE, id%INFO,                &
     &     LP, COPY=.TRUE.,                                             &
     &     STRING='lcgrph:leng', MEMCNT=MEMCNT, ERRCODE=-7)
      LENG(NROWS_LOC+1:NROWS_LOC+HALO_SIZE) = 0
      CALL AGMG_MUMPS_733(IPE, NROWS_LOC+HALO_SIZE+1, id%INFO,               &
     &     LP, COPY=.TRUE.,                                             &
     &     STRING='lcgrph:ipe', MEMCNT=MEMCNT, ERRCODE=-7)
      IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      IPE(NROWS_LOC+2:NROWS_LOC+HALO_SIZE+1) = IPE(NROWS_LOC+1)
      GSIZE = NROWS_LOC + HALO_SIZE
      CALL AGMG_COPY(TOP_CNT, RCVCNT, 1, AGMG_MPF_INTEGER, IERR)
      RDISPL => MSGCNT
      NULLIFY(MSGCNT)
      IF(MYID.EQ.0) THEN
         NEW_LOCNNZ = sum(RCVCNT)
         RDISPL(1) = 0
         DO I=2, NPROCS
            RDISPL(I) = RDISPL(I-1)+RCVCNT(I-1)
         END DO
         top_graph%NZ_LOC = NEW_LOCNNZ
         top_graph%COMM = id%COMM
         CALL AGMG_MUMPS_733(top_graph%IRN_LOC, NEW_LOCNNZ, id%INFO,         &
     &        LP, MEMCNT=MEMCNT, ERRCODE=-7)
         CALL AGMG_MUMPS_733(top_graph%JCN_LOC, NEW_LOCNNZ, id%INFO,         &
     &        LP, MEMCNT=MEMCNT, ERRCODE=-7)
         IF(MEMCNT .GT. MAXMEM) MAXMEM=MEMCNT
      ELSE
         ALLOCATE(top_graph%IRN_LOC(1), top_graph%JCN_LOC(1))
      END IF
      CALL AGMG_COPY(TSENDI, top_graph%IRN_LOC, TOP_CNT, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_COPY(TSENDJ, top_graph%JCN_LOC, TOP_CNT, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_MUMPS_734(SNDCNT, RCVCNT, RDISPL,                            &
     &        TSENDI, TSENDJ, MEMCNT=MEMCNT)
      DEALLOCATE(APNT)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_BUILD_LOC_GRAPH
      SUBROUTINE DAGMG_MUMPS_SEND_BUF(APNT, PROC, NPROCS, BUFSIZE, IPE, PE,  &
     &     LENG, RCVBUF, MSGCNT, SNDCNT, COMM)
      IMPLICIT NONE
      INTEGER                 :: NPROCS, PROC, COMM
      TYPE(ARRPNT)            :: APNT(NPROCS)
      INTEGER                 :: BUFSIZE
      INTEGER, POINTER        :: RCVBUF(:), LENG(:), PE(:), IPE(:)
      INTEGER                 :: MSGCNT(NPROCS), SNDCNT(NPROCS)
      LOGICAL, SAVE           :: INIT = .TRUE.
      INTEGER, POINTER, SAVE  :: SPACE(:,:,:)
      LOGICAL, POINTER, SAVE  :: PENDING(:)
      INTEGER, POINTER, SAVE  :: REQ(:), CPNT(:)
      INTEGER                 :: IERR, MYID, I, SOURCE, J, TOTMSG
      LOGICAL                 :: FLAG, TFLAG
      INTEGER                 :: STATUS(AGMG_MPF_STATUS_SIZE),               &
     &     TSTATUS(AGMG_MPF_STATUS_SIZE)
      INTEGER, PARAMETER      :: ITAG=30, FTAG=31
      INTEGER, POINTER        :: TMPI(:), RCVCNT(:)
      CALL AGMG_SETIERR2( MYID, IERR)
      CALL AGMG_SETIERR12( NPROCS, IERR)
      IF(INIT) THEN
         ALLOCATE(SPACE(2*BUFSIZE, 2, NPROCS))
         ALLOCATE(RCVBUF(2*BUFSIZE))
         ALLOCATE(PENDING(NPROCS), CPNT(NPROCS))
         ALLOCATE(REQ(NPROCS))
         PENDING = .FALSE.
         DO I=1, NPROCS
            APNT(I)%BUF => SPACE(:,1,I)
            CPNT(I)   = 1
         END DO
         INIT = .FALSE.
         RETURN
      END IF
      IF(PROC .EQ. -1) THEN
         TOTMSG = sum(MSGCNT)
         DO
            IF(TOTMSG .EQ. 0) EXIT
            CALL AGMG_NOCALL('MPI_RECV')
            CALL DAGMG_MUMPS_ASSEMBLE_MSG(BUFSIZE, RCVBUF, IPE, PE, LENG)
            SOURCE = STATUS(AGMG_MPF_SOURCE)
            TOTMSG = TOTMSG-1
            MSGCNT(SOURCE+1)=MSGCNT(SOURCE+1)-1
         END DO
         DO I=1, NPROCS
            IF(PENDING(I)) THEN
               CALL AGMG_NOCALL('MPI_WAIT')
            END IF
         END DO
         ALLOCATE(RCVCNT(NPROCS))
         CALL AGMG_MPF_ALLTOALL(SNDCNT, 1, AGMG_MPF_INTEGER, RCVCNT, 1,           &
     &        AGMG_MPF_INTEGER, COMM, IERR)
         DO I=1, NPROCS
            IF(SNDCNT(I) .GT. 0) THEN
               TMPI => APNT(I)%BUF(:)
               CALL AGMG_NOCALL('MPI_ISEND')
            END IF
         END DO
         DO I=1, NPROCS
            IF(RCVCNT(I) .GT. 0) THEN
               CALL AGMG_NOCALL('MPI_RECV')
               CALL DAGMG_MUMPS_ASSEMBLE_MSG(RCVCNT(I), RCVBUF,              &
     &              IPE, PE, LENG)
            END IF
         END DO
         DO I=1, NPROCS
            IF(SNDCNT(I) .GT. 0) THEN
               CALL AGMG_NOCALL('MPI_WAIT')
            END IF
         END DO
         DEALLOCATE(SPACE)
         DEALLOCATE(PENDING, CPNT)
         DEALLOCATE(REQ)
         DEALLOCATE(RCVBUF, RCVCNT)
         nullify(SPACE, PENDING, CPNT, REQ, RCVBUF, RCVCNT)
         INIT = .TRUE.
         RETURN
      END IF
      IF(PENDING(PROC)) THEN
         DO
            CALL AGMG_MPF_TEST(REQ(PROC), TFLAG, TSTATUS, IERR)
            IF(TFLAG) THEN
               PENDING(PROC) = .FALSE.
               EXIT
            ELSE
               CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, ITAG, COMM,             &
     &              FLAG, STATUS, IERR )
               IF(FLAG) THEN
                  SOURCE = STATUS(AGMG_MPF_SOURCE)
                  CALL AGMG_NOCALL('MPI_RECV')
                  CALL DAGMG_MUMPS_ASSEMBLE_MSG(BUFSIZE, RCVBUF, IPE,        &
     &                 PE, LENG)
                  MSGCNT(SOURCE+1)=MSGCNT(SOURCE+1)-1
               END IF
            END IF
         END DO
      END IF
      TMPI => APNT(PROC)%BUF(:)
      CALL AGMG_NOCALL('MPI_ISEND')
      PENDING(PROC) = .TRUE.
      CPNT(PROC) = mod(CPNT(PROC),2)+1
      APNT(PROC)%BUF => SPACE(:,CPNT(PROC),PROC)
      SNDCNT(PROC)  = 0
      RETURN
      END SUBROUTINE DAGMG_MUMPS_SEND_BUF
      SUBROUTINE DAGMG_MUMPS_ASSEMBLE_MSG(BUFSIZE, RCVBUF, IPE, PE, LENG)
      IMPLICIT NONE
      INTEGER          :: BUFSIZE
      INTEGER, POINTER :: RCVBUF(:), IPE(:), PE(:), LENG(:)
      INTEGER          :: I, ROW, COL, IERR
      DO I=1, 2*BUFSIZE, 2
         ROW = RCVBUF(I)
         COL = RCVBUF(I+1)
         PE(IPE(ROW)+LENG(ROW)) = COL
         LENG(ROW) = LENG(ROW) + 1
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_ASSEMBLE_MSG
      SUBROUTINE DAGMG_MUMPS_BUILD_TREE(ord)
      TYPE(ORD_TYPE)  :: ord
      INTEGER :: I
      ord%SON     = -1
      ord%BROTHER = -1
      ord%NW      = 0
      DO I=1, ord%CBLKNBR
         ord%NW(I) = ord%NW(I)+ord%RANGTAB(I+1) - ord%RANGTAB(I)
         IF (ord%TREETAB(I) .NE. -1) THEN
            IF (ord%SON(ord%TREETAB(I)) .EQ. -1) THEN
               ord%SON(ord%TREETAB(I)) = I
            ELSE
               ord%BROTHER(I) = ord%SON(ord%TREETAB(I))
               ord%SON(ord%TREETAB(I)) = I
            END IF
            ord%NW(ord%TREETAB(I)) = ord%NW(ord%TREETAB(I))+ ord%NW(I)
         END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_BUILD_TREE
      SUBROUTINE DAGMG_MUMPS_MERGESWAP(N, L, A1, A2)
      INTEGER   :: I, LP, ISWAP, N
      INTEGER   :: L(0:N+1), A1(N), A2(N)
      LP = L(0)
      I  = 1
      DO
         IF ((LP==0).OR.(I>N)) EXIT
         DO
            IF (LP >= I) EXIT
            LP = L(LP)
         END DO
         ISWAP    = A1(LP)
         A1(LP)   = A1(I)
         A1(I)    = ISWAP
         ISWAP    = A2(LP)
         A2(LP)   = A2(I)
         A2(I)    = ISWAP
         ISWAP    = L(LP)
         L(LP) = L(I)
         L(I)  = LP
         LP = ISWAP
         I  = I + 1
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_MERGESWAP
      SUBROUTINE DAGMG_MUMPS_MERGESORT(N, K, L)
      INTEGER    :: N
      INTEGER    :: K(N), L(0:N+1)
      INTEGER    :: P, Q, S, T, I
  100 CONTINUE
      L(0) = 1
      T = N + 1
      DO  P = 1,N - 1
         IF (K(P) <= K(P+1)) THEN
            L(P) = P + 1
         ELSE
            L(T) = - (P+1)
            T = P
       END IF
      END DO
      L(T) = 0
      L(N) = 0
      IF (L(N+1) == 0) THEN
         RETURN
      ELSE
         L(N+1) = IABS(L(N+1))
      END IF
  200 CONTINUE
      S = 0
      T = N+1
      P = L(S)
      Q = L(T)
      IF(Q .EQ. 0) RETURN
  300 CONTINUE
      IF(K(P) .GT. K(Q)) GOTO 600
  400 CONTINUE
      L(S) = SIGN(P,L(S))
      S = P
      P = L(P)
      IF (P .GT. 0) GOTO 300
  500 CONTINUE
      L(S) = Q
      S = T
      DO
         T = Q
         Q = L(Q)
         IF (Q .LE. 0) EXIT
      END DO
      GOTO 800
  600 CONTINUE
      L(S) = SIGN(Q, L(S))
      S = Q
      Q = L(Q)
      IF (Q .GT. 0) GOTO 300
  700 CONTINUE
      L(S) = P
      S = T
      DO
         T = P
         P = L(P)
         IF (P .LE. 0) EXIT
      END DO
  800 CONTINUE
      P = -P
      Q = -Q
      IF(Q.EQ.0) THEN
         L(S) = SIGN(P, L(S))
         L(T) = 0
         GOTO 200
      END IF
      GOTO 300
      END SUBROUTINE DAGMG_MUMPS_MERGESORT
      FUNCTION AGMG_MUMPS_GETSIZE(A)
      INTEGER, POINTER :: A(:)
      INTEGER          :: AGMG_MUMPS_GETSIZE
      IF(ASSOCIATED(A)) THEN
         AGMG_MUMPS_GETSIZE = SIZE(A)
      ELSE
         AGMG_MUMPS_GETSIZE = 0
      END IF
      RETURN
      END FUNCTION AGMG_MUMPS_GETSIZE
      SUBROUTINE AGMG_MUMPS_734(A1, A2, A3, A4, A5, A6, A7, MEMCNT)
      INTEGER, POINTER :: A1(:)
      INTEGER, POINTER, OPTIONAL :: A2(:), A3(:), A4(:), A5(:),         &
     &     A6(:), A7(:)
      INTEGER, OPTIONAL :: MEMCNT
      INTEGER :: IMEMCNT
      IMEMCNT = 0
      IF(ASSOCIATED(A1)) THEN
         IMEMCNT = IMEMCNT+SIZE(A1)
         DEALLOCATE(A1)
      END IF
      IF(PRESENT(A2)) THEN
         IF(ASSOCIATED(A2)) THEN
            IMEMCNT = IMEMCNT+SIZE(A2)
            DEALLOCATE(A2)
         END IF
      END IF
      IF(PRESENT(A3)) THEN
         IF(ASSOCIATED(A3)) THEN
            IMEMCNT = IMEMCNT+SIZE(A3)
            DEALLOCATE(A3)
         END IF
      END IF
      IF(PRESENT(A4)) THEN
         IF(ASSOCIATED(A4)) THEN
            IMEMCNT = IMEMCNT+SIZE(A4)
            DEALLOCATE(A4)
         END IF
      END IF
      IF(PRESENT(A5)) THEN
         IF(ASSOCIATED(A5)) THEN
            IMEMCNT = IMEMCNT+SIZE(A5)
            DEALLOCATE(A5)
         END IF
      END IF
      IF(PRESENT(A6)) THEN
         IF(ASSOCIATED(A6)) THEN
            IMEMCNT = IMEMCNT+SIZE(A6)
            DEALLOCATE(A6)
         END IF
      END IF
      IF(PRESENT(A7)) THEN
         IF(ASSOCIATED(A7)) THEN
            IMEMCNT = IMEMCNT+SIZE(A7)
            DEALLOCATE(A7)
         END IF
      END IF
      IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT-IMEMCNT
      RETURN
      END SUBROUTINE AGMG_MUMPS_734
      END MODULE
      SUBROUTINE DAGMG_MUMPS_448(ICNTL,CNTL)
      IMPLICIT NONE
      INTEGER NICNTL, NCNTL
      PARAMETER (NICNTL=10, NCNTL=10)
      INTEGER ICNTL(NICNTL)
      DOUBLE PRECISION CNTL(NCNTL)
      INTEGER I
      ICNTL(1) =  6
      ICNTL(2) =  6
      ICNTL(3) = -1
      ICNTL(4) = -1
      ICNTL(5) =  0
      DO 10 I = 6,NICNTL
        ICNTL(I) = 0
   10 END DO
      CNTL(1) = 0.0D0
      CNTL(2) = 0.0D0
      DO 20 I = 3,NCNTL
        CNTL(I) = 0.0D0
   20 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_448
      SUBROUTINE DAGMG_MUMPS_444                                             &
     &           (M,N,NE,IP,IRN,A,IPERM,NUM,JPERM,PR,Q,L,D,RINF)
      IMPLICIT NONE
      INTEGER M,N,NE,NUM
      INTEGER IP(N+1),IRN(NE),IPERM(M),JPERM(N),PR(N),Q(M),L(M)
      DOUBLE PRECISION A(NE)
      DOUBLE PRECISION D(M), RINF
      INTEGER I,II,J,JJ,JORD,Q0,QLEN,IDUM,JDUM,ISP,JSP,                 &
     &        K,KK,KK1,KK2,I0,UP,LOW
      DOUBLE PRECISION    CSP,DI,DNEW,DQ0,AI,A0,BV,TBV,RLX
      DOUBLE PRECISION    ZERO,MINONE,ONE
      PARAMETER (ZERO=0.0D0,MINONE=-1.0D0,ONE=1.0D0)
      INTRINSIC abs,min
      EXTERNAL DAGMG_MUMPS_445, DAGMG_MUMPS_446, DAGMG_MUMPS_447, DAGMG_MUMPS_455
      RLX = D(1)
      NUM = 0
      BV = RINF
      DO 10 K = 1,N
        JPERM(K) = 0
        PR(K) = IP(K)
   10 END DO
      DO 12 K = 1,M
        IPERM(K) = 0
        D(K) = ZERO
   12 END DO
      DO 30 J = 1,N
        A0 = MINONE
        DO 20 K = IP(J),IP(J+1)-1
          I = IRN(K)
          AI = abs(A(K))
          IF (AI.GT.D(I)) D(I) = AI
          IF (JPERM(J).NE.0) GO TO 20
          IF (AI.GE.BV) THEN
            A0 = BV
            IF (IPERM(I).NE.0) GO TO 20
            JPERM(J) = I
            IPERM(I) = J
            NUM = NUM + 1
          ELSE
            IF (AI.LE.A0) GO TO 20
            A0 = AI
            I0 = I
          ENDIF
   20   CONTINUE
        IF (A0.NE.MINONE .AND. A0.LT.BV) THEN
          BV = A0
          IF (IPERM(I0).NE.0) GO TO 30
          IPERM(I0) = J
          JPERM(J) = I0
          NUM = NUM + 1
        ENDIF
   30 END DO
      IF (M.EQ.N) THEN
        DO 35 I = 1,M
          BV = min(BV,D(I))
   35   CONTINUE
      ENDIF
      IF (NUM.EQ.N) GO TO 1000
      DO 95 J = 1,N
        IF (JPERM(J).NE.0) GO TO 95
        DO 50 K = IP(J),IP(J+1)-1
          I = IRN(K)
          AI = abs(A(K))
          IF (AI.LT.BV) GO TO 50
          IF (IPERM(I).EQ.0) GO TO 90
          JJ = IPERM(I)
          KK1 = PR(JJ)
          KK2 = IP(JJ+1) - 1
          IF (KK1.GT.KK2) GO TO 50
          DO 70 KK = KK1,KK2
            II = IRN(KK)
            IF (IPERM(II).NE.0) GO TO 70
            IF (abs(A(KK)).GE.BV) GO TO 80
   70     CONTINUE
          PR(JJ) = KK2 + 1
   50   CONTINUE
        GO TO 95
   80   JPERM(JJ) = II
        IPERM(II) = JJ
        PR(JJ) = KK + 1
   90   NUM = NUM + 1
        JPERM(J) = I
        IPERM(I) = J
        PR(J) = K + 1
   95 END DO
      IF (NUM.EQ.N) GO TO 1000
      DO 99 I = 1,M
        D(I) = MINONE
        L(I) = 0
   99 END DO
      TBV = BV * (ONE-RLX)
      DO 100 JORD = 1,N
        IF (JPERM(JORD).NE.0) GO TO 100
        QLEN = 0
        LOW = M + 1
        UP = M + 1
        CSP = MINONE
        J = JORD
        PR(J) = -1
        DO 115 K = IP(J),IP(J+1)-1
          I = IRN(K)
          DNEW = abs(A(K))
          IF (CSP.GE.DNEW) GO TO 115
          IF (IPERM(I).EQ.0) THEN
            CSP = DNEW
            ISP = I
            JSP = J
            IF (CSP.GE.TBV) GO TO 160
          ELSE
            D(I) = DNEW
            IF (DNEW.GE.TBV) THEN
              LOW = LOW - 1
              Q(LOW) = I
            ELSE
              QLEN = QLEN + 1
              L(I) = QLEN
              CALL DAGMG_MUMPS_445(I,M,Q,D,L,1)
            ENDIF
            JJ = IPERM(I)
            PR(JJ) = J
          ENDIF
  115   CONTINUE
        DO 150 JDUM = 1,NUM
          IF (LOW.EQ.UP) THEN
            IF (QLEN.EQ.0) GO TO 160
            I = Q(1)
            IF (CSP.GE.D(I)) GO TO 160
            BV = D(I)
            TBV = BV * (ONE-RLX)
            DO 152 IDUM = 1,M
              CALL DAGMG_MUMPS_446(QLEN,M,Q,D,L,1)
              L(I) = 0
              LOW = LOW - 1
              Q(LOW) = I
              IF (QLEN.EQ.0) GO TO 153
              I = Q(1)
              IF (D(I).LT.TBV) GO TO 153
  152       CONTINUE
          ENDIF
  153     UP = UP - 1
          Q0 = Q(UP)
          DQ0 = D(Q0)
          L(Q0) = UP
          J = IPERM(Q0)
          DO 155 K = IP(J),IP(J+1)-1
            I = IRN(K)
            IF (L(I).GE.UP) GO TO 155
            DNEW = min(DQ0,abs(A(K)))
            IF (CSP.GE.DNEW) GO TO 155
            IF (IPERM(I).EQ.0) THEN
              CSP = DNEW
              ISP = I
              JSP = J
              IF (CSP.GE.TBV) GO TO 160
            ELSE
              DI = D(I)
              IF (DI.GE.TBV .OR. DI.GE.DNEW) GO TO 155
              D(I) = DNEW
              IF (DNEW.GE.TBV) THEN
                IF (DI.NE.MINONE) THEN
                  CALL DAGMG_MUMPS_447(L(I),QLEN,M,Q,D,L,1)
                ENDIF
                L(I) = 0
                LOW = LOW - 1
                Q(LOW) = I
              ELSE
                IF (DI.EQ.MINONE) THEN
                  QLEN = QLEN + 1
                  L(I) = QLEN
                ENDIF
                CALL DAGMG_MUMPS_445(I,M,Q,D,L,1)
              ENDIF
              JJ = IPERM(I)
              PR(JJ) = J
            ENDIF
  155     CONTINUE
  150   CONTINUE
  160   IF (CSP.EQ.MINONE) GO TO 190
        BV = min(BV,CSP)
        TBV = BV * (ONE-RLX)
        NUM = NUM + 1
        I = ISP
        J = JSP
        DO 170 JDUM = 1,NUM+1
          I0 = JPERM(J)
          JPERM(J) = I
          IPERM(I) = J
          J = PR(J)
          IF (J.EQ.-1) GO TO 190
          I = I0
  170   CONTINUE
  190   DO 191 KK = UP,M
          I = Q(KK)
          D(I) = MINONE
          L(I) = 0
  191   CONTINUE
        DO 192 KK = LOW,UP-1
          I = Q(KK)
          D(I) = MINONE
  192   CONTINUE
        DO 193 KK = 1,QLEN
          I = Q(KK)
          D(I) = MINONE
          L(I) = 0
  193   CONTINUE
  100 END DO
 1000 IF (M.EQ.N .and. NUM.EQ.N) GO TO 2000
      CALL DAGMG_MUMPS_455(M,N,IPERM,L,JPERM)
 2000 RETURN
      END SUBROUTINE DAGMG_MUMPS_444
      SUBROUTINE DAGMG_MUMPS_445(I,N,Q,D,L,IWAY)
      IMPLICIT NONE
      INTEGER I,N,IWAY
      INTEGER Q(N),L(N)
      DOUBLE PRECISION D(N)
      INTEGER IDUM,K,POS,POSK,QK
      PARAMETER (K=2)
      DOUBLE PRECISION DI
      POS = L(I)
      IF (POS.LE.1) GO TO 20
      DI = D(I)
      IF (IWAY.EQ.1) THEN
        DO 10 IDUM = 1,N
          POSK = POS/K
          QK = Q(POSK)
          IF (DI.LE.D(QK)) GO TO 20
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
          IF (POS.LE.1) GO TO 20
   10   CONTINUE
      ELSE
        DO 15 IDUM = 1,N
          POSK = POS/K
          QK = Q(POSK)
          IF (DI.GE.D(QK)) GO TO 20
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
          IF (POS.LE.1) GO TO 20
   15   CONTINUE
      ENDIF
   20 Q(POS) = I
      L(I) = POS
      RETURN
      END SUBROUTINE DAGMG_MUMPS_445
      SUBROUTINE DAGMG_MUMPS_446(QLEN,N,Q,D,L,IWAY)
      IMPLICIT NONE
      INTEGER QLEN,N,IWAY
      INTEGER Q(N),L(N)
      DOUBLE PRECISION D(N)
      INTEGER I,IDUM,K,POS,POSK
      PARAMETER (K=2)
      DOUBLE PRECISION DK,DR,DI
      I = Q(QLEN)
      DI = D(I)
      QLEN = QLEN - 1
      POS = 1
      IF (IWAY.EQ.1) THEN
        DO 10 IDUM = 1,N
          POSK = K*POS
          IF (POSK.GT.QLEN) GO TO 20
          DK = D(Q(POSK))
          IF (POSK.LT.QLEN) THEN
            DR = D(Q(POSK+1))
            IF (DK.LT.DR) THEN
              POSK = POSK + 1
              DK = DR
            ENDIF
          ENDIF
          IF (DI.GE.DK) GO TO 20
          Q(POS) = Q(POSK)
          L(Q(POS)) = POS
          POS = POSK
   10   CONTINUE
      ELSE
        DO 15 IDUM = 1,N
          POSK = K*POS
          IF (POSK.GT.QLEN) GO TO 20
          DK = D(Q(POSK))
          IF (POSK.LT.QLEN) THEN
            DR = D(Q(POSK+1))
            IF (DK.GT.DR) THEN
              POSK = POSK + 1
              DK = DR
            ENDIF
          ENDIF
          IF (DI.LE.DK) GO TO 20
          Q(POS) = Q(POSK)
          L(Q(POS)) = POS
          POS = POSK
   15   CONTINUE
      ENDIF
   20 Q(POS) = I
      L(I) = POS
      RETURN
      END SUBROUTINE DAGMG_MUMPS_446
      SUBROUTINE DAGMG_MUMPS_447(POS0,QLEN,N,Q,D,L,IWAY)
      IMPLICIT NONE
      INTEGER POS0,QLEN,N,IWAY
      INTEGER Q(N),L(N)
      DOUBLE PRECISION D(N)
      INTEGER I,IDUM,K,POS,POSK,QK
      PARAMETER (K=2)
      DOUBLE PRECISION DK,DR,DI
      IF (QLEN.EQ.POS0) THEN
        QLEN = QLEN - 1
        RETURN
      ENDIF
      I = Q(QLEN)
      DI = D(I)
      QLEN = QLEN - 1
      POS = POS0
      IF (IWAY.EQ.1) THEN
        IF (POS.LE.1) GO TO 20
        DO 10 IDUM = 1,N
          POSK = POS/K
          QK = Q(POSK)
          IF (DI.LE.D(QK)) GO TO 20
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
          IF (POS.LE.1) GO TO 20
   10   CONTINUE
   20   Q(POS) = I
        L(I) = POS
        IF (POS.NE.POS0) RETURN
        DO 30 IDUM = 1,N
          POSK = K*POS
          IF (POSK.GT.QLEN) GO TO 40
          DK = D(Q(POSK))
          IF (POSK.LT.QLEN) THEN
            DR = D(Q(POSK+1))
            IF (DK.LT.DR) THEN
              POSK = POSK + 1
              DK = DR
            ENDIF
          ENDIF
          IF (DI.GE.DK) GO TO 40
          QK = Q(POSK)
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
   30   CONTINUE
      ELSE
        IF (POS.LE.1) GO TO 34
        DO 32 IDUM = 1,N
          POSK = POS/K
          QK = Q(POSK)
          IF (DI.GE.D(QK)) GO TO 34
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
          IF (POS.LE.1) GO TO 34
   32   CONTINUE
   34   Q(POS) = I
        L(I) = POS
        IF (POS.NE.POS0) RETURN
        DO 36 IDUM = 1,N
          POSK = K*POS
          IF (POSK.GT.QLEN) GO TO 40
          DK = D(Q(POSK))
          IF (POSK.LT.QLEN) THEN
            DR = D(Q(POSK+1))
            IF (DK.GT.DR) THEN
              POSK = POSK + 1
              DK = DR
            ENDIF
          ENDIF
          IF (DI.LE.DK) GO TO 40
          QK = Q(POSK)
          Q(POS) = QK
          L(QK) = POS
          POS = POSK
   36   CONTINUE
      ENDIF
   40 Q(POS) = I
      L(I) = POS
      RETURN
      END SUBROUTINE DAGMG_MUMPS_447
      SUBROUTINE DAGMG_MUMPS_450(IP,LENL,LENH,W,WLEN,A,NVAL,VAL)
      IMPLICIT NONE
      INTEGER WLEN,NVAL
      INTEGER IP(*),LENL(*),LENH(*),W(*)
      DOUBLE PRECISION A(*),VAL
      INTEGER XX,J,K,II,S,POS
      PARAMETER (XX=10)
      DOUBLE PRECISION SPLIT(XX),HA
      NVAL = 0
      DO 10 K = 1,WLEN
        J = W(K)
        DO 15 II = IP(J)+LENL(J),IP(J)+LENH(J)-1
          HA = A(II)
          IF (NVAL.EQ.0) THEN
            SPLIT(1) = HA
            NVAL = 1
          ELSE
            DO 20 S = NVAL,1,-1
              IF (SPLIT(S).EQ.HA) GO TO 15
              IF (SPLIT(S).GT.HA) THEN
                POS = S + 1
                GO TO 21
              ENDIF
   20       CONTINUE
            POS = 1
   21       DO 22 S = NVAL,POS,-1
              SPLIT(S+1) = SPLIT(S)
   22       CONTINUE
            SPLIT(POS) = HA
            NVAL = NVAL + 1
          ENDIF
          IF (NVAL.EQ.XX) GO TO 11
   15   CONTINUE
   10 END DO
   11 IF (NVAL.GT.0) VAL = SPLIT((NVAL+1)/2)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_450
      SUBROUTINE DAGMG_MUMPS_451(N,NE,IP,IRN,A)
      IMPLICIT NONE
      INTEGER N,NE
      INTEGER IP(N+1),IRN(NE)
      DOUBLE PRECISION A(NE)
      INTEGER THRESH,TDLEN
      PARAMETER (THRESH=15,TDLEN=50)
      INTEGER J,IPJ,K,LEN,R,S,HI,FIRST,MID,LAST,TD
      DOUBLE PRECISION HA,KEY
      INTEGER TODO(TDLEN)
      DO 100 J = 1,N
        LEN = IP(J+1) - IP(J)
        IF (LEN.LE.1) GO TO 100
        IPJ = IP(J)
        IF (LEN.LT.THRESH) GO TO 400
        TODO(1) = IPJ
        TODO(2) = IPJ + LEN
        TD = 2
  500   CONTINUE
        FIRST = TODO(TD-1)
        LAST = TODO(TD)
        KEY = A((FIRST+LAST)/2)
        DO 475 K = FIRST,LAST-1
          HA = A(K)
          IF (HA.EQ.KEY) GO TO 475
          IF (HA.GT.KEY) GO TO 470
          KEY = HA
          GO TO 470
  475   CONTINUE
        TD = TD - 2
        GO TO 425
  470   MID = FIRST
        DO 450 K = FIRST,LAST-1
          IF (A(K).LE.KEY) GO TO 450
          HA = A(MID)
          A(MID) = A(K)
          A(K) = HA
          HI = IRN(MID)
          IRN(MID) = IRN(K)
          IRN(K) = HI
          MID = MID + 1
  450   CONTINUE
        IF (MID-FIRST.GE.LAST-MID) THEN
          TODO(TD+2) = LAST
          TODO(TD+1) = MID
          TODO(TD) = MID
        ELSE
          TODO(TD+2) = MID
          TODO(TD+1) = FIRST
          TODO(TD) = LAST
          TODO(TD-1) = MID
        ENDIF
        TD = TD + 2
  425   CONTINUE
        IF (TD.EQ.0) GO TO 400
        IF (TODO(TD)-TODO(TD-1).GE.THRESH) GO TO 500
        TD = TD - 2
        GO TO 425
  400   DO 200 R = IPJ+1,IPJ+LEN-1
          IF (A(R-1) .LT. A(R)) THEN
            HA = A(R)
            HI = IRN(R)
            A(R) = A(R-1)
            IRN(R) = IRN(R-1)
            DO 300 S = R-1,IPJ+1,-1
              IF (A(S-1) .LT. HA) THEN
                A(S) = A(S-1)
                IRN(S) = IRN(S-1)
              ELSE
                A(S) = HA
                IRN(S) = HI
                GO TO 200
              END IF
  300       CONTINUE
            A(IPJ) = HA
            IRN(IPJ) = HI
          END IF
  200   CONTINUE
  100 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_451
      SUBROUTINE DAGMG_MUMPS_452(M,N,NE,IP,IRN,A,IPERM,NUMX,                 &
     &           W,LEN,LENL,LENH,FC,IW,IW4,RLX,RINF)
      IMPLICIT NONE
      INTEGER M,N,NE,NUMX
      INTEGER IP(N+1),IRN(NE),IPERM(N),                                 &
     &        W(N),LEN(N),LENL(N),LENH(N),FC(N),IW(M),IW4(3*N+M)
      DOUBLE PRECISION A(NE),RLX,RINF
      INTEGER NUM,NVAL,WLEN,II,I,J,K,L,CNT,MOD,IDUM1,IDUM2,IDUM3
      DOUBLE PRECISION    BVAL,BMIN,BMAX
      EXTERNAL DAGMG_MUMPS_450,DAGMG_MUMPS_453,DAGMG_MUMPS_455
      DO 20 J = 1,N
        FC(J) = J
        LEN(J) = IP(J+1) - IP(J)
   20 END DO
      DO 21 I = 1,M
        IW(I) = 0
   21 END DO
      CNT = 1
      MOD = 1
      NUMX = 0
      CALL DAGMG_MUMPS_453(CNT,MOD,M,N,IRN,NE,IP,LEN,FC,IW,NUMX,N,           &
     &            IW4(1),IW4(N+1),IW4(2*N+1),IW4(2*N+M+1))
      NUM = NUMX
      IF (NUM.NE.N) THEN
        BMAX = RINF
      ELSE
        BMAX = RINF
        DO 30 J = 1,N
          BVAL = 0.0D0
          DO 25 K = IP(J),IP(J+1)-1
            IF (A(K).GT.BVAL) BVAL = A(K)
   25     CONTINUE
          IF (BVAL.LT.BMAX) BMAX = BVAL
   30   CONTINUE
        BMAX = 1.001D0 * BMAX
      ENDIF
      BVAL = 0.0D0
      BMIN = 0.0D0
      WLEN = 0
      DO 48 J = 1,N
        L = IP(J+1) - IP(J)
        LENH(J) = L
        LEN(J) = L
        DO 45 K = IP(J),IP(J+1)-1
          IF (A(K).LT.BMAX) GO TO 46
   45   CONTINUE
        K = IP(J+1)
   46   LENL(J) = K - IP(J)
        IF (LENL(J).EQ.L) GO TO 48
        WLEN = WLEN + 1
        W(WLEN) = J
   48 END DO
      DO 90 IDUM1 = 1,NE
        IF (NUM.EQ.NUMX) THEN
          DO 50 I = 1,M
            IPERM(I) = IW(I)
   50     CONTINUE
          DO 80 IDUM2 = 1,NE
            BMIN = BVAL
            IF (BMAX-BMIN .LE. RLX) GO TO 1000
            CALL DAGMG_MUMPS_450(IP,LENL,LEN,W,WLEN,A,NVAL,BVAL)
            IF (NVAL.LE.1) GO TO 1000
            K = 1
            DO 70 IDUM3 = 1,N
              IF (K.GT.WLEN) GO TO 71
              J = W(K)
              DO 55 II = IP(J)+LEN(J)-1,IP(J)+LENL(J),-1
                IF (A(II).GE.BVAL) GO TO 60
                I = IRN(II)
                IF (IW(I).NE.J) GO TO 55
                IW(I) = 0
                NUM = NUM - 1
                FC(N-NUM) = J
   55         CONTINUE
   60         LENH(J) = LEN(J)
              LEN(J) = II - IP(J) + 1
              IF (LENL(J).EQ.LENH(J)) THEN
                W(K) = W(WLEN)
                WLEN = WLEN - 1
              ELSE
                K = K + 1
              ENDIF
   70       CONTINUE
   71       IF (NUM.LT.NUMX) GO TO 81
   80     CONTINUE
   81     MOD = 1
        ELSE
          BMAX = BVAL
          IF (BMAX-BMIN .LE. RLX) GO TO 1000
          CALL DAGMG_MUMPS_450(IP,LEN,LENH,W,WLEN,A,NVAL,BVAL)
          IF (NVAL.EQ.0 .OR. BVAL.EQ.BMIN) GO TO 1000
          K = 1
          DO 87 IDUM3 = 1,N
            IF (K.GT.WLEN) GO TO 88
            J = W(K)
            DO 85 II = IP(J)+LEN(J),IP(J)+LENH(J)-1
              IF (A(II).LT.BVAL) GO TO 86
   85       CONTINUE
   86       LENL(J) = LEN(J)
            LEN(J) = II - IP(J)
            IF (LENL(J).EQ.LENH(J)) THEN
              W(K) = W(WLEN)
              WLEN = WLEN - 1
            ELSE
              K = K + 1
            ENDIF
   87     CONTINUE
   88     MOD = 0
        ENDIF
        CNT = CNT + 1
        CALL DAGMG_MUMPS_453(CNT,MOD,M,N,IRN,NE,IP,LEN,FC,IW,NUM,NUMX,       &
     &              IW4(1),IW4(N+1),IW4(2*N+1),IW4(2*N+M+1))
   90 END DO
 1000 IF (M.EQ.N .and. NUMX.EQ.N) GO TO 2000
      CALL DAGMG_MUMPS_455(M,N,IPERM,IW,W)
 2000 RETURN
      END SUBROUTINE DAGMG_MUMPS_452
      SUBROUTINE DAGMG_MUMPS_453                                             &
     &           (ID,MOD,M,N,IRN,LIRN,IP,LENC,FC,IPERM,NUM,NUMX,        &
     &           PR,ARP,CV,OUT)
      IMPLICIT NONE
      INTEGER ID,MOD,M,N,LIRN,NUM,NUMX
      INTEGER ARP(N),CV(M),IRN(LIRN),IP(N),                             &
     &        FC(N),IPERM(M),LENC(N),OUT(N),PR(N)
      INTEGER I,II,IN1,IN2,J,J1,JORD,K,KK,LAST,NFC,                     &
     &        NUM0,NUM1,NUM2,ID0,ID1
      IF (ID.EQ.1) THEN
        DO 5 I = 1,M
          CV(I) = 0
    5   CONTINUE
        DO 6 J = 1,N
          ARP(J) = 0
    6   CONTINUE
        NUM1 = N
        NUM2 = N
      ELSE
        IF (MOD.EQ.1) THEN
          DO 8 J = 1,N
            ARP(J) = 0
    8     CONTINUE
        ENDIF
        NUM1 = NUMX
        NUM2 = N - NUMX
      ENDIF
      NUM0 = NUM
      NFC = 0
      ID0 = (ID-1)*N
      DO 100 JORD = NUM0+1,N
        ID1 = ID0 + JORD
        J = FC(JORD-NUM0)
        PR(J) = -1
        DO 70 K = 1,JORD
          IF (ARP(J).GE.LENC(J)) GO TO 30
          IN1 = IP(J) + ARP(J)
          IN2 = IP(J) + LENC(J) - 1
          DO 20 II = IN1,IN2
            I = IRN(II)
            IF (IPERM(I).EQ.0) GO TO 80
   20     CONTINUE
          ARP(J) = LENC(J)
   30     OUT(J) = LENC(J) - 1
          DO 60 KK = 1,JORD
            IN1 = OUT(J)
            IF (IN1.LT.0) GO TO 50
            IN2 = IP(J) + LENC(J) - 1
            IN1 = IN2 - IN1
            DO 40 II = IN1,IN2
              I = IRN(II)
              IF (CV(I).EQ.ID1) GO TO 40
              J1 = J
              J = IPERM(I)
              CV(I) = ID1
              PR(J) = J1
              OUT(J1) = IN2 - II - 1
              GO TO 70
   40       CONTINUE
   50       J1 = PR(J)
            IF (J1.EQ.-1) THEN
              NFC = NFC + 1
              FC(NFC) = J
              IF (NFC.GT.NUM2) THEN
                LAST = JORD
                GO TO 101
              ENDIF
              GO TO 100
            ENDIF
            J = J1
   60     CONTINUE
   70   CONTINUE
   80   IPERM(I) = J
        ARP(J) = II - IP(J) + 1
        NUM = NUM + 1
        DO 90 K = 1,JORD
          J = PR(J)
          IF (J.EQ.-1) GO TO 95
          II = IP(J) + LENC(J) - OUT(J) - 2
          I = IRN(II)
          IPERM(I) = J
   90   CONTINUE
   95   IF (NUM.EQ.NUM1) THEN
          LAST = JORD
          GO TO 101
        ENDIF
  100 END DO
      LAST = N
  101 DO 110 JORD = LAST+1,N
        NFC = NFC + 1
        FC(NFC) = FC(JORD-NUM0)
  110 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_453
      SUBROUTINE DAGMG_MUMPS_454(M,N,NE,IP,IRN,A,IPERM,NUM,                  &
     &           JPERM,OUT,PR,Q,L,U,D,RINF)
      IMPLICIT NONE
      INTEGER M,N,NE,NUM
      INTEGER IP(N+1),IRN(NE),IPERM(M),JPERM(N),OUT(N),PR(N),Q(M),L(M)
      DOUBLE PRECISION A(NE),U(M),D(M),RINF,RINF3
      INTEGER I,I0,II,J,JJ,JORD,Q0,QLEN,JDUM,ISP,JSP,                   &
     &        K,K0,K1,K2,KK,KK1,KK2,UP,LOW
      DOUBLE PRECISION    CSP,DI,DMIN,DNEW,DQ0,VJ,RLX
      LOGICAL LORD
      DOUBLE PRECISION    ZERO, ONE
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      EXTERNAL DAGMG_MUMPS_445, DAGMG_MUMPS_446, DAGMG_MUMPS_447, DAGMG_MUMPS_455
      RLX = U(1)
      RINF3 = U(2)
      LORD = (JPERM(1).EQ.6)
      NUM = 0
      DO 10 K = 1,N
        JPERM(K) = 0
        PR(K) = IP(K)
        D(K) = RINF
   10 END DO
      DO 15 K = 1,M
        U(K) = RINF3
        IPERM(K) = 0
        L(K) = 0
   15 END DO
      DO 30 J = 1,N
         IF (IP(J+1)-IP(J) .GT. N/10 .AND. N.GT.50) GO TO 30
        DO 20 K = IP(J),IP(J+1)-1
          I = IRN(K)
          IF (A(K).GT.U(I)) GO TO 20
          U(I) = A(K)
          IPERM(I) = J
          L(I) = K
   20   CONTINUE
   30 END DO
      DO 40 I = 1,M
        J = IPERM(I)
        IF (J.EQ.0) GO TO 40
        IF (JPERM(J).EQ.0) THEN
          JPERM(J) = L(I)
          D(J) = U(I)
          NUM = NUM + 1
        ELSEIF (D(J).GT.U(I)) THEN
          K = JPERM(J)
          II = IRN(K)
          IPERM(II) = 0
          JPERM(J) = L(I)
          D(J) = U(I)
        ELSE
          IPERM(I) = 0
        ENDIF
   40 END DO
      IF (NUM.EQ.N) GO TO 1000
      DO 45 K = 1,M
        D(K) = ZERO
   45 END DO
      DO 95 J = 1,N
        IF (JPERM(J).NE.0) GO TO 95
        K1 = IP(J)
        K2 = IP(J+1) - 1
        IF (K1.GT.K2) GO TO 95
        VJ = RINF
        DO 50 K = K1,K2
          I = IRN(K)
          DI = A(K) - U(I)
          IF (DI.GT.VJ) GO TO 50
          IF (DI.LT.VJ .OR. DI.EQ.RINF) GO TO 55
          IF (IPERM(I).NE.0 .OR. IPERM(I0).EQ.0) GO TO 50
   55     VJ = DI
          I0 = I
          K0 = K
   50   CONTINUE
        D(J) = VJ
        K = K0
        I = I0
        IF (IPERM(I).EQ.0) GO TO 90
        DO 60 K = K0,K2
          I = IRN(K)
          IF (A(K)-U(I).GT.VJ) GO TO 60
          JJ = IPERM(I)
          KK1 = PR(JJ)
          KK2 = IP(JJ+1) - 1
          IF (KK1.GT.KK2) GO TO 60
          DO 70 KK = KK1,KK2
            II = IRN(KK)
            IF (IPERM(II).GT.0) GO TO 70
            IF (A(KK)-U(II).LE.D(JJ)) GO TO 80
   70     CONTINUE
          PR(JJ) = KK2 + 1
   60   CONTINUE
        GO TO 95
   80   JPERM(JJ) = KK
        IPERM(II) = JJ
        PR(JJ) = KK + 1
   90   NUM = NUM + 1
        JPERM(J) = K
        IPERM(I) = J
        PR(J) = K + 1
   95 END DO
      IF (NUM.EQ.N) GO TO 1000
      DO 99 I = 1,M
        D(I) = RINF
        L(I) = 0
   99 END DO
      DO 100 JORD = 1,N
        IF (JPERM(JORD).NE.0) GO TO 100
        DMIN = RINF
        QLEN = 0
        LOW = M + 1
        UP = M + 1
        CSP = RINF
        J = JORD
        PR(J) = -1
        DO 115 K = IP(J),IP(J+1)-1
          I = IRN(K)
          DNEW = A(K) - U(I)
          IF (DNEW.GE.CSP) GO TO 115
          IF (IPERM(I).EQ.0) THEN
            CSP = DNEW
            ISP = K
            JSP = J
          ELSE
            IF (DNEW.LT.DMIN) DMIN = DNEW
            D(I) = DNEW
            QLEN = QLEN + 1
            Q(QLEN) = K
          ENDIF
  115   CONTINUE
        Q0 = QLEN
        QLEN = 0
        DO 120 KK = 1,Q0
          K = Q(KK)
          I = IRN(K)
          IF (CSP.LE.D(I)) THEN
            D(I) = RINF
            GO TO 120
          ENDIF
          IF (D(I).LE.DMIN) THEN
            LOW = LOW - 1
            Q(LOW) = I
            L(I) = LOW
          ELSE
            QLEN = QLEN + 1
            L(I) = QLEN
            CALL DAGMG_MUMPS_445(I,M,Q,D,L,2)
          ENDIF
          JJ = IPERM(I)
          OUT(JJ) = K
          PR(JJ) = J
  120   CONTINUE
        DO 150 JDUM = 1,NUM
          IF (LOW.EQ.UP) THEN
            IF (QLEN.EQ.0) GO TO 160
            I = Q(1)
            IF (D(I).LT.RINF) DMIN = D(I)*(ONE+RLX)
            IF (DMIN.GE.CSP) GO TO 160
  152       CALL DAGMG_MUMPS_446(QLEN,M,Q,D,L,2)
            LOW = LOW - 1
            Q(LOW) = I
            L(I) = LOW
            IF (QLEN.EQ.0) GO TO 153
            I = Q(1)
            IF (D(I).GT.DMIN) GO TO 153
            GO TO 152
          ENDIF
  153     Q0 = Q(UP-1)
          DQ0 = D(Q0)
          IF (DQ0.GE.CSP) GO TO 160
          IF (DMIN.GE.CSP) GO TO 160
          UP = UP - 1
          J = IPERM(Q0)
          VJ = DQ0 - A(JPERM(J)) + U(Q0)
          K1 = IP(J+1)-1
          IF (LORD) THEN
            IF (CSP.NE.RINF) THEN
              DI = CSP - VJ
              IF (A(K1).GE.DI) THEN
                K0 = JPERM(J)
                IF (K0.GE.K1-6) GO TO 178
  177           CONTINUE
                  K = (K0+K1)/2
                  IF (A(K).GE.DI) THEN
                    K1 = K
                  ELSE
                    K0 = K
                  ENDIF
                  IF (K0.GE.K1-6) GO TO 178
                GO TO 177
  178           DO 179 K = K0+1,K1
                  IF (A(K).LT.DI) GO TO 179
                  K1 = K - 1
                  GO TO 181
  179           CONTINUE
              ENDIF
            ENDIF
  181       IF (K1.EQ.JPERM(J)) K1 = K1 - 1
          ENDIF
          K0 = IP(J)
          DI = CSP - VJ
          DO 155 K = K0,K1
            I = IRN(K)
            IF (L(I).GE.LOW) GO TO 155
            DNEW = A(K) - U(I)
            IF (DNEW.GE.DI) GO TO 155
            DNEW = DNEW + VJ
            IF (DNEW.GT.D(I)) GO TO 155
            IF (IPERM(I).EQ.0) THEN
              CSP = DNEW
              ISP = K
              JSP = J
              DI = CSP - VJ
            ELSE
              IF (DNEW.GE.D(I)) GO TO 155
              D(I) = DNEW
              IF (DNEW.LE.DMIN) THEN
                IF (L(I).NE.0) THEN
                  CALL DAGMG_MUMPS_447(L(I),QLEN,M,Q,D,L,2)
                ENDIF
                LOW = LOW - 1
                Q(LOW) = I
                L(I) = LOW
              ELSE
                IF (L(I).EQ.0) THEN
                  QLEN = QLEN + 1
                  L(I) = QLEN
                ENDIF
                CALL DAGMG_MUMPS_445(I,M,Q,D,L,2)
              ENDIF
              JJ = IPERM(I)
              OUT(JJ) = K
              PR(JJ) = J
            ENDIF
  155     CONTINUE
  150   CONTINUE
  160   IF (CSP.EQ.RINF) GO TO 190
        NUM = NUM + 1
        I = IRN(ISP)
        J = JSP
        IPERM(I) = J
        JPERM(J) = ISP
        DO 170 JDUM = 1,NUM
          JJ = PR(J)
          IF (JJ.EQ.-1) GO TO 180
          K = OUT(J)
          I = IRN(K)
          IPERM(I) = JJ
          JPERM(JJ) = K
          J = JJ
  170   CONTINUE
  180   DO 182 KK = UP,M
          I = Q(KK)
          U(I) = U(I) + D(I) - CSP
  182   CONTINUE
  190   DO 191 KK = UP,M
          I = Q(KK)
          D(I) = RINF
          L(I) = 0
  191   CONTINUE
        DO 192 KK = LOW,UP-1
          I = Q(KK)
          D(I) = RINF
          L(I) = 0
  192   CONTINUE
        DO 193 KK = 1,QLEN
          I = Q(KK)
          D(I) = RINF
          L(I) = 0
  193   CONTINUE
  100 END DO
 1000 CONTINUE
      DO 1200 J = 1,N
        K = JPERM(J)
        IF (K.NE.0) THEN
          D(J) = A(K) - U(IRN(K))
        ELSE
          D(J) = ZERO
        ENDIF
 1200 END DO
      DO 1201 I = 1,M
        IF (IPERM(I).EQ.0) U(I) = ZERO
 1201 END DO
      IF (M.EQ.N .and. NUM.EQ.N) GO TO 2000
      CALL DAGMG_MUMPS_455(M,N,IPERM,L,JPERM)
 2000 RETURN
      END SUBROUTINE DAGMG_MUMPS_454
      SUBROUTINE DAGMG_MUMPS_457                                             &
     &           (M,N,IRN,LIRN,IP,LENC,IPERM,NUM,PR,ARP,CV,OUT)
      IMPLICIT NONE
      INTEGER LIRN,M,N,NUM
      INTEGER ARP(N),CV(M),IRN(LIRN),IP(N),IPERM(M),LENC(N),OUT(N),PR(N)
      INTEGER I,II,IN1,IN2,J,J1,JORD,K,KK
      EXTERNAL DAGMG_MUMPS_455
      DO 10 I = 1,M
        CV(I) = 0
        IPERM(I) = 0
   10 END DO
      DO 12 J = 1,N
        ARP(J) = LENC(J) - 1
   12 END DO
      NUM = 0
      DO 1000 JORD = 1,N
        J = JORD
        PR(J) = -1
        DO 70 K = 1,JORD
          IN1 = ARP(J)
          IF (IN1.LT.0) GO TO 30
          IN2 = IP(J) + LENC(J) - 1
          IN1 = IN2 - IN1
          DO 20 II = IN1,IN2
            I = IRN(II)
            IF (IPERM(I).EQ.0) GO TO 80
   20     CONTINUE
          ARP(J) = -1
   30     CONTINUE
          OUT(J) = LENC(J) - 1
          DO 60 KK = 1,JORD
            IN1 = OUT(J)
            IF (IN1.LT.0) GO TO 50
            IN2 = IP(J) + LENC(J) - 1
            IN1 = IN2 - IN1
            DO 40 II = IN1,IN2
              I = IRN(II)
              IF (CV(I).EQ.JORD) GO TO 40
              J1 = J
              J = IPERM(I)
              CV(I) = JORD
              PR(J) = J1
              OUT(J1) = IN2 - II - 1
              GO TO 70
   40       CONTINUE
   50       CONTINUE
            J = PR(J)
            IF (J.EQ.-1) GO TO 1000
   60     CONTINUE
   70   CONTINUE
   80   CONTINUE
        IPERM(I) = J
        ARP(J) = IN2 - II - 1
        NUM = NUM + 1
        DO 90 K = 1,JORD
          J = PR(J)
          IF (J.EQ.-1) GO TO 1000
          II = IP(J) + LENC(J) - OUT(J) - 2
          I = IRN(II)
          IPERM(I) = J
   90   CONTINUE
 1000 END DO
      IF (M.EQ.N .and. NUM.EQ.N) GO TO 2000
      CALL DAGMG_MUMPS_455(M,N,IPERM,CV,ARP)
 2000 RETURN
      END SUBROUTINE DAGMG_MUMPS_457
      SUBROUTINE DAGMG_MUMPS_455(M,N,IPERM,RW,CW)
      IMPLICIT NONE
      INTEGER M,N
      INTEGER RW(M),CW(N),IPERM(M)
      INTEGER I,J,K
      DO 10 J = 1,N
        CW(J) = 0
   10 END DO
      K = 0
      DO 20 I = 1,M
        IF (IPERM(I).EQ.0) THEN
          K = K + 1
          RW(K) = I
        ELSE
          J = IPERM(I)
          CW(J) = I
        ENDIF
   20 END DO
      K = 0
      DO 30 J = 1,N
        IF (CW(J).NE.0) GO TO 30
        K = K + 1
        I = RW(K)
        IPERM(I) = -J
   30 END DO
      DO 40 J = N+1,M
        K = K + 1
        I = RW(K)
        IPERM(I) = -J
   40 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_455
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      RECURSIVE SUBROUTINE DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,            &
     &  BUFR, LBUFR, LBUFR_BYTES,                                       &
     &  INODE_PERE, ISON, NSLAVES_PERE, LIST_SLAVES_PERE,               &
     &  NFRONT_PERE, NASS_PERE, NFS4FATHER,LMAP, TROW,                  &
     &  PROCNODE_STEPS, SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,   &
     &  LRLUS, N, IW,                                                   &
     &  LIW, A, LA,                                                     &
     &  PTRIST, PTLUST_S, PTRFAC,                                       &
     &  PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,                   &
     &  IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL, LEAF,      &
     &  NBFIN, ICNTL, KEEP,KEEP8,                                       &
     &  root, OPASSW, OPELIW,                                           &
     &  ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR, ND, FRERE,         &
     &  LPTRAR, NELT, FRTPTR, FRTELT,                                   &
     &  ISTEP_TO_INIV2, TAB_POS_IN_PERE                                 &
     &  )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC ) :: root
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER ICNTL( 40 ), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER BUFR( LBUFR )
      INTEGER SLAVEF, NBFIN
      INTEGER(8) :: LA, IPTRLU, LRLU, LRLUS, POSFAC
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N),                                                  &
     & PIMASTER(KEEP(28))
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER COMP
      INTEGER NSTK( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM, MYID
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER INODE_PERE, ISON
      INTEGER NFS4FATHER
      INTEGER NBROWS_ALREADY_SENT
      INTEGER NSLAVES_PERE, NFRONT_PERE, NASS_PERE
      INTEGER LIST_SLAVES_PERE( * )
      INTEGER LMAP
      INTEGER TROW( LMAP )
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER LPTRAR, NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER NOSLA, I, ISTCHK, ISTCHK_LOC
      INTEGER INDICE_PERE
      INTEGER INDICE_PERE_ARRAY_ARG(1)
      INTEGER PDEST, PDEST_MASTER
      INTEGER NFRONT
      INTEGER(8) :: SIZFR
      LOGICAL FLAG
      INTEGER LDA_SON
      INTEGER NSLSON, NBCOLS, NROW, NROWS_TO_SEND, IROW_SON,            &
     &        NPIV, NROWS_TO_STACK, II, COLLIST
      INTEGER(8) :: POSROW, SHIFTCB_SON
      INTEGER NBCOLS_EFF
      INTEGER PDEST_MASTER_ISON, IPOS_IN_SLAVE
      INTEGER ROW_LENGTH
      LOGICAL DESCLU, SLAVE_ISON
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER MSGSOU, MSGTAG
      INTEGER LP
      INTEGER ITMP
      LOGICAL SAME_PROC, COMPRESSCB
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTEGER LMAP_LOC, allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: NBROW
      INTEGER, ALLOCATABLE, DIMENSION(:) :: SLAVES_PERE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: MAP, PERM
      INTEGER ITYPE
      LP = ICNTL(1)
      IF (ICNTL(4) .LE. 0) LP = -1
      ALLOCATE(SLAVES_PERE(0:NSLAVES_PERE), stat=allocok)
      if (allocok .GT. 0) THEN
        IF (LP > 0) write(LP,*) MYID,                                   &
     &  ' : PB allocation SLAVES_PERE in DMUMPS_210'
        IFLAG  =-13
        IERROR = NSLAVES_PERE+1
        GOTO 700
      endif
      IF (NSLAVES_PERE.GT.0)                                            &
     &SLAVES_PERE(1:NSLAVES_PERE) = LIST_SLAVES_PERE(1:NSLAVES_PERE)
      SLAVES_PERE(0) = AGMG_MUMPS_275( STEP(INODE_PERE),                     &
     &                 PROCNODE_STEPS, SLAVEF )
      ALLOCATE(NBROW(0:NSLAVES_PERE), stat=allocok)
      if (allocok .GT. 0) THEN
        IF (LP>0) write(LP,*) MYID,                                     &
     &  ' : PB allocation NBROW in DMUMPS_210'
        IFLAG  =-13
        IERROR = NSLAVES_PERE+1
        GOTO 700
      endif
      LMAP_LOC = LMAP
      ALLOCATE(MAP(LMAP_LOC), stat=allocok)
      if (allocok .GT. 0) THEN
        IF (LP>0) THEN
        write(LP,*) MYID, ' : PB allocation LMAP in DMUMPS_210'
        ENDIF
        IFLAG  =-13
        IERROR = LMAP
        GOTO 700
      endif
      MAP( 1 : LMAP ) = TROW( 1 : LMAP )
      PDEST_MASTER_ISON = AGMG_MUMPS_275(STEP(ISON),                         &
     &                    PROCNODE_STEPS,SLAVEF)
      SLAVE_ISON = PDEST_MASTER_ISON .NE. MYID
      IF (SLAVE_ISON) THEN
        DO WHILE ( PTRIST(STEP( ISON )) .EQ. 0 )
          BLOCKING = .TRUE.
          SET_IRECV= .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD,                                   &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    PDEST_MASTER_ISON, MAITRE_DESC_BANDE,                         &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,                 &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,         &
     &    NELT, FRTPTR, FRTELT,                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.                       &
     &    )
          IF ( IFLAG .LT. 0 ) GOTO 600
        END DO
        DO WHILE (                                                      &
     &     ( IW( PTRIST(STEP(ISON)) + 1 + KEEP(IXSZ) ) .NE.             &
     &       IW( PTRIST(STEP(ISON)) + 3 + KEEP(IXSZ) ) ) .OR.           &
     &     ( KEEP(50) .NE. 0 .AND.                                      &
     &       IW( PTRIST(STEP(ISON)) + 6 + KEEP(IXSZ) ) .NE. 0 ) )
          IF ( KEEP(50).eq.0) THEN
            MSGSOU = PDEST_MASTER_ISON
            MSGTAG = BLOC_FACTO
          ELSE
            IF ( IW( PTRIST(STEP(ISON)) + 1 + KEEP(IXSZ) ) .NE.         &
     &           IW( PTRIST(STEP(ISON)) + 3 + KEEP(IXSZ) ) ) THEN
              MSGSOU = PDEST_MASTER_ISON
              MSGTAG = BLOC_FACTO_SYM
            ELSE
              MSGSOU = AGMG_MPF_ANY_SOURCE
              MSGTAG = BLOC_FACTO_SYM_SLAVE
            END IF
          END IF
          BLOCKING = .TRUE.
          SET_IRECV= .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD,                                   &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    MSGSOU, MSGTAG,                                               &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,                 &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,         &
     &    NELT, FRTPTR, FRTELT,                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF ( IFLAG .LT. 0 ) GOTO 600
        END DO
      ENDIF
      IF ( NSLAVES_PERE .EQ. 0 ) THEN
        NBROW( 0 ) = LMAP
      ELSE
        DO I = 0, NSLAVES_PERE
          NBROW( I ) = 0
        END DO
        DO I = 1, LMAP_LOC
          INDICE_PERE = MAP( I )
          CALL AGMG_MUMPS_47(                                                &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &           NASS_PERE,                                             &
     &           NFRONT_PERE - NASS_PERE,                               &
     &           NSLAVES_PERE,                                          &
     &           INDICE_PERE,                                           &
     &           NOSLA,                                                 &
     &           IPOS_IN_SLAVE )
          NBROW( NOSLA ) = NBROW( NOSLA ) + 1
        END DO
        DO I = 1, NSLAVES_PERE
          NBROW(I)=NBROW(I)+NBROW(I-1)
        ENDDO
      ENDIF
      ALLOCATE(PERM(LMAP_LOC), stat=allocok)
      if (allocok .GT. 0) THEN
          IF (LP.GT.0) THEN
          write(LP,*) MYID,': PB allocation PERM in DMUMPS_210'
          ENDIF
          IFLAG  =-13
          IERROR = LMAP_LOC
          GOTO 700
      endif
         ISTCHK     = PTRIST(STEP(ISON))
         NBCOLS     = IW(ISTCHK+KEEP(IXSZ))
      DO I = LMAP_LOC, 1, -1
          INDICE_PERE = MAP( I )
          CALL AGMG_MUMPS_47(                                                &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &           NASS_PERE,                                             &
     &           NFRONT_PERE - NASS_PERE,                               &
     &           NSLAVES_PERE,                                          &
     &           INDICE_PERE,                                           &
     &           NOSLA,                                                 &
     &           IPOS_IN_SLAVE )
          PERM( NBROW( NOSLA ) ) = I
          NBROW( NOSLA ) = NBROW( NOSLA ) - 1
      ENDDO
      DO I = 0, NSLAVES_PERE
          NBROW(I)=NBROW(I)+1
      END DO
      PDEST_MASTER = SLAVES_PERE(0)
      DO I = 0, NSLAVES_PERE
        PDEST = SLAVES_PERE( I )
        IF ( PDEST .EQ. MYID ) THEN
            NBPROCFILS(STEP(INODE_PERE)) =                              &
     &                 NBPROCFILS(STEP(INODE_PERE)) - 1
            IF ( PDEST .EQ. PDEST_MASTER ) THEN
              NBPROCFILS(STEP(ISON))  = NBPROCFILS(STEP(ISON)) - 1
            ENDIF
            ISTCHK     = PTRIST(STEP(ISON))
            NBCOLS     = IW(ISTCHK+KEEP(IXSZ))
            NROW       = IW(ISTCHK+2+KEEP(IXSZ))
            NPIV       = IW(ISTCHK+3+KEEP(IXSZ))
            NSLSON     = IW(ISTCHK+5+KEEP(IXSZ))
            NFRONT     = NPIV + NBCOLS
            COMPRESSCB = (IW(ISTCHK+XXS).EQ.S_CB1COMP)
            CALL AGMG_MUMPS_729(SIZFR, IW(ISTCHK+XXR))
            IF (IW(ISTCHK+XXS).EQ.S_NOLCBCONTIG) THEN
               LDA_SON     = NBCOLS
               SHIFTCB_SON = int(NPIV,8)*int(NROW,8)
            ELSE IF (IW(ISTCHK+XXS).EQ.S_NOLCLEANED) THEN
               LDA_SON     = NBCOLS
               SHIFTCB_SON = 0_8
            ELSE
               LDA_SON     = NFRONT
               SHIFTCB_SON = int(NPIV,8)
            ENDIF
            IF (I == NSLAVES_PERE) THEN
              NROWS_TO_STACK=LMAP_LOC-NBROW(I)+1
            ELSE
              NROWS_TO_STACK=NBROW(I+1)-NBROW(I)
            ENDIF
            IF (PDEST .NE. PDEST_MASTER) THEN
               IF ( KEEP(55) .eq. 0 ) THEN
                 CALL DAGMG_MUMPS_539                                        &
     &           (N, INODE_PERE, IW, LIW,                               &
     &           A, LA, NROWS_TO_STACK, NBCOLS,                         &
     &           OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,           &
     &           FILS, PTRARW, PTRAIW, INTARR, DBLARR, ICNTL,           &
     &           KEEP,KEEP8, MYID )
               ELSE
                 CALL DAGMG_MUMPS_123(NELT, FRTPTR, FRTELT,                  &
     &           N, INODE_PERE, IW, LIW,                                &
     &           A, LA, NROWS_TO_STACK, NBCOLS,                         &
     &           OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,           &
     &           FILS, PTRARW, PTRAIW, INTARR, DBLARR, ICNTL,           &
     &           KEEP, KEEP8, MYID )
               ENDIF
            ENDIF
            DO II = 1,NROWS_TO_STACK
              IROW_SON = PERM(NBROW(I)+II-1)
              INDICE_PERE=MAP(IROW_SON)
             CALL AGMG_MUMPS_47(                                             &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &         NASS_PERE,                                               &
     &         NFRONT_PERE - NASS_PERE,                                 &
     &         NSLAVES_PERE,                                            &
     &         INDICE_PERE,                                             &
     &         NOSLA,                                                   &
     &         IPOS_IN_SLAVE )
              INDICE_PERE = IPOS_IN_SLAVE
              IF ( COMPRESSCB ) THEN
                IF (NBCOLS - NROW .EQ. 0 ) THEN
                  ITMP = IROW_SON
                  POSROW = PTRAST(STEP(ISON))+                          &
     &                     int(ITMP,8) * int(ITMP-1,8) / 2_8
                ELSE
                  ITMP = IROW_SON + NBCOLS - NROW
                  POSROW = PTRAST(STEP(ISON))                           &
     &               + int(ITMP,8) * int(ITMP-1,8) / 2_8                &
     &               - int(NBCOLS-NROW,8) * int(NBCOLS-NROW+1,8)/2_8
                ENDIF
              ELSE
              POSROW = PTRAST(STEP(ISON)) + SHIFTCB_SON                 &
     &               +int(IROW_SON-1,8)*int(LDA_SON,8)
              ENDIF
                IF (PDEST == PDEST_MASTER) THEN
                 IF (KEEP(50).NE.0) THEN
                   NBCOLS_EFF = IROW_SON + NBCOLS - NROW
                 ELSE
                   NBCOLS_EFF = NBCOLS
                 ENDIF
                 INDICE_PERE_ARRAY_ARG(1) = INDICE_PERE
                 CALL DAGMG_MUMPS_39(N, INODE_PERE, IW, LIW,                 &
     &            A, LA, ISON, 1, NBCOLS_EFF, INDICE_PERE_ARRAY_ARG,    &
     &            A(POSROW), PTLUST_S, PTRAST,                          &
     &            STEP, PIMASTER, OPASSW,                               &
     &            IWPOSCB, MYID, KEEP,KEEP8)
                ELSE
                 ISTCHK  = PTRIST(STEP(ISON))
                 COLLIST = ISTCHK + 6 + KEEP(IXSZ)                      &
     &                   + IW( ISTCHK + 5 +KEEP(IXSZ)) + NROW + NPIV
                 IF (KEEP(50).NE.0) THEN
                   NBCOLS_EFF = IROW_SON + NBCOLS - NROW
                 ELSE
                   NBCOLS_EFF = NBCOLS
                 ENDIF
                 INDICE_PERE_ARRAY_ARG(1) = INDICE_PERE
                 CALL DAGMG_MUMPS_40(N, INODE_PERE,                          &
     &            IW, LIW,                                              &
     &            A, LA, 1, NBCOLS_EFF, INDICE_PERE_ARRAY_ARG,          &
     &            IW( COLLIST ), A(POSROW),                             &
     &            OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,          &
     &            FILS, ICNTL, KEEP,KEEP8,                              &
     &            MYID )
                ENDIF
            ENDDO
            IF (PDEST.EQ.PDEST_MASTER) THEN
             IF (KEEP(219).NE.0) THEN
               IF(NSLAVES_PERE.GT.0 .AND. KEEP(50).EQ.2) THEN
                  IF (COMPRESSCB) THEN
                    WRITE(*,*) "Error 1 in PARPIV/DAGMG_MUMPS_210"
                    CALL AGMG_MUMPS_ABORT()
                  ELSE
                  POSROW = PTRAST(STEP(ISON))+SHIFTCB_SON+              &
     &                 int(NBROW(1)-1,8)*int(LDA_SON,8)
                  ENDIF
                  CALL DAGMG_MUMPS_617(NFS4FATHER,IERR)
                  IF (IERR .NE.0) THEN
                    IF (LP .GT. 0) THEN
                      WRITE(LP, *) "MAX_ARRAY allocation failed"
                    ENDIF
                    IFLAG=-13
                    IERROR=NFS4FATHER
                    GOTO 700
                  ENDIF
                  ITMP=-9999
                  IF ( LMAP_LOC-NBROW(1)+1 .NE. 0 ) THEN
                  CALL DAGMG_MUMPS_618(                                      &
     &                 A(POSROW),                                       &
     & SIZFR-SHIFTCB_SON-int(NBROW(1)-1,8)*int(LDA_SON,8),              &
     &                 LDA_SON, LMAP_LOC-NBROW(1)+1,                    &
     &                 BUF_MAX_ARRAY,NFS4FATHER,COMPRESSCB,ITMP)
                  ELSE
                       CALL DAGMG_MUMPS_757(                                 &
     &                 BUF_MAX_ARRAY, NFS4FATHER)
                  ENDIF
                  CALL DAGMG_MUMPS_619(N, INODE_PERE, IW, LIW,               &
     &                 A, LA, ISON, NFS4FATHER,                         &
     &                 BUF_MAX_ARRAY, PTLUST_S, PTRAST,                 &
     &                 STEP, PIMASTER,                                  &
     &                 OPASSW,IWPOSCB,MYID, KEEP,KEEP8)
               ENDIF
             ENDIF
             IF ( NBPROCFILS(STEP(ISON)) .EQ. 0) THEN
               ISTCHK_LOC = PIMASTER(STEP(ISON))
               SAME_PROC= ISTCHK_LOC .LT. IWPOSCB
               IF (SAME_PROC) THEN
                 CALL DAGMG_MUMPS_530(N, ISON, INODE_PERE,                   &
     &             IWPOSCB, PIMASTER, PTLUST_S, IW, LIW, STEP,          &
     &             KEEP,KEEP8)
               ENDIF
               IF (SAME_PROC) THEN
                 ISTCHK_LOC = PTRIST(STEP(ISON))
                 PTRIST(STEP( ISON) ) = -99999999
               ELSE
                 PIMASTER(STEP( ISON )) = -99999999
               ENDIF
               CALL DAGMG_MUMPS_152(.FALSE., MYID, N,                        &
     &            ISTCHK_LOC,                                           &
     &            PAMASTER(STEP(ISON)),                                 &
     &            IW, LIW, LRLU, LRLUS, IPTRLU, IWPOSCB,                &
     &            LA, KEEP,KEEP8, .FALSE.                               &
     &            )
             ENDIF
             IF ( NBPROCFILS(STEP(INODE_PERE)) .EQ. 0 ) THEN
               CALL DAGMG_MUMPS_507( N, IPOOL, LPOOL,                        &
     &           PROCNODE_STEPS,                                        &
     &           SLAVEF, KEEP(28), KEEP(76), KEEP(80),                  &
     &           KEEP(47), STEP, INODE_PERE+N )
               IF (KEEP(47) .GE. 3) THEN
                 CALL DAGMG_MUMPS_500(                                       &
     &          IPOOL, LPOOL,                                           &
     &          PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,          &
     &          MYID, STEP, N, ND, FILS )
               ENDIF
             END IF
            ELSE
             CALL DAGMG_MUMPS_531                                            &
     &       (N, INODE_PERE, IW, LIW,                                   &
     &       NBROW(I), STEP, PTRIST, ITLOC, KEEP,KEEP8)
            END IF
        END IF
      END DO
      DO I = NSLAVES_PERE, 0, -1
        PDEST = SLAVES_PERE( I )
        IF ( PDEST .NE. MYID ) THEN
            DESCLU = .FALSE.
            NBROWS_ALREADY_SENT = 0
            IF (I == NSLAVES_PERE) THEN
              NROWS_TO_SEND=LMAP_LOC-NBROW(I)+1
            ELSE
              NROWS_TO_SEND=NBROW(I+1)-NBROW(I)
            ENDIF
            COMPRESSCB=(IW(PTRIST(STEP(ISON))+XXS).EQ.S_CB1COMP)
   95       CONTINUE
            IF ( PTRIST(STEP(ISON)) .lt.0 .or.                          &
     &         IW ( PTRIST(STEP(ISON) )+KEEP(IXSZ) ) .GT. N ) THEN
              WRITE(*,*) MYID,': Internal error in Maplig'
              WRITE(*,*) MYID,': PTRIST(STEP(ISON))=',                  &
     &                           PTRIST(STEP(ISON))
              WRITE(*,*) MYID,': I, NBROW(I)=',I, NBROW(I)
              WRITE(*,*) MYID,': NSLAVES_PERE=',NSLAVES_PERE
              WRITE(*,*) MYID,': ISON, INODE_PERE=',ISON,INODE_PERE
              WRITE(*,*) MYID,': Son header=',                          &
     &        IW(PTRIST(STEP(ISON)): PTRIST(STEP(ISON))+5+KEEP(IXSZ))
              CALL AGMG_MUMPS_ABORT()
            END IF
            CALL DAGMG_MUMPS_67( NBROWS_ALREADY_SENT,                        &
     &      DESCLU, INODE_PERE,                                         &
     &      NFRONT_PERE, NASS_PERE, NFS4FATHER,                         &
     &           NSLAVES_PERE, ISON,                                    &
     &      NROWS_TO_SEND, LMAP_LOC, MAP,                               &
     &      PERM(min(LMAP_LOC,NBROW(I))),                               &
     &      IW( PTRIST(STEP(ISON))),                                    &
     &      A(PTRAST(STEP(ISON))), I, PDEST, PDEST_MASTER,              &
     &      COMM, IERR,                                                 &
     &      KEEP,KEEP8, STEP, N, SLAVEF,                                &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE, COMPRESSCB )
            IF ( IERR .EQ. -2 ) THEN
              IFLAG  = -17
              IF (LP .GT. 0) THEN
                WRITE(LP,*)                                             &
     &          "FAILURE: SEND BUFFER TOO SMALL IN DAGMG_MUMPS_210"
              ENDIF
              IERROR =  (NROWS_TO_SEND + 3 )* KEEP( 34 ) +              &
     &        NROWS_TO_SEND * IW(PTRIST(STEP(ISON))+KEEP(IXSZ))         &
     &        * KEEP( 35 )
              GO TO 700
            END IF
            IF ( IERR .EQ. -3 ) THEN
              IF (LP .GT. 0) THEN
                WRITE(LP,*)                                             &
     &          "FAILURE: RECV BUFFER TOO SMALL IN DAGMG_MUMPS_210"
              ENDIF
              IFLAG  = -20
              IERROR =  (NROWS_TO_SEND + 3 )* KEEP( 34 ) +              &
     &        NROWS_TO_SEND * IW(PTRIST(STEP(ISON))+KEEP(IXSZ))         &
     &        * KEEP( 35 )
              GOTO 700
            ENDIF
            IF (KEEP(219).NE.0) THEN
             IF ( IERR .EQ. -4 ) THEN
               IFLAG  = -13
              IERROR = NFS4FATHER
              IF (LP .GT. 0) THEN
                WRITE(LP, *)                                            &
     & "FAILURE: MAX_ARRAY allocation failed IN DAGMG_MUMPS_210"
              ENDIF
              GO TO 700
             END IF
            END IF
            IF ( IERR .EQ. -1 ) THEN
              BLOCKING = .FALSE.
              SET_IRECV = .TRUE.
              MESSAGE_RECEIVED = .FALSE.
              CALL DAGMG_MUMPS_329( COMM_LOAD,                               &
     &          ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,       &
     &          AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                            &
     &          STATUS,                                                 &
     &          BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,       &
     &          IWPOS, IWPOSCB, IPTRLU,                                 &
     &          LRLU, LRLUS, N, IW, LIW, A, LA,                         &
     &          PTRIST, PTLUST_S, PTRFAC,                               &
     &          PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,           &
     &          IFLAG, IERROR, COMM,                                    &
     &          NBPROCFILS,                                             &
     &          IPOOL, LPOOL, LEAF,                                     &
     &          NBFIN, MYID, SLAVEF,                                    &
     &          root, OPASSW, OPELIW, ITLOC, FILS,                      &
     &          PTRARW, PTRAIW,                                         &
     &          INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,   &
     &          NELT, FRTPTR, FRTELT,                                   &
     &          ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
              IF ( IFLAG .LT. 0 ) GOTO 600
              GO TO 95
            END IF
        END IF
      END DO
      ITYPE = AGMG_MUMPS_330(STEP(ISON), PROCNODE_STEPS,SLAVEF)
      IF (KEEP(214) .EQ. 2) THEN
        CALL DAGMG_MUMPS_314( N, ISON,                                       &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE          &
     &     )
      ENDIF
      CALL DAGMG_MUMPS_626( N, ISON, PTRIST, PTRAST, IW, LIW,                &
     &             A, LA, LRLU, LRLUS, IWPOSCB, IPTRLU,                 &
     &             STEP, MYID, KEEP                                     &
     &)
  600 CONTINUE
      DEALLOCATE(SLAVES_PERE)
      DEALLOCATE(NBROW)
      DEALLOCATE(MAP)
      DEALLOCATE(PERM)
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_210
      SUBROUTINE DAGMG_MUMPS_211( COMM_LOAD, ASS_IRECV,                      &
     &  BUFR, LBUFR, LBUFR_BYTES,                                       &
     &  INODE_PERE, ISON, NSLAVES_PERE, LIST_SLAVES_PERE,               &
     &  NFRONT_PERE, NASS_PERE, NFS4FATHER, LMAP, TROW,                 &
     &  PROCNODE_STEPS, SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,   &
     &  LRLUS, N, IW,                                                   &
     &  LIW, A, LA,                                                     &
     &  PTRIST, PTLUST_S, PTRFAC,                                       &
     &  PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,                   &
     &  IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL, LEAF,      &
     &  NBFIN, ICNTL, KEEP,KEEP8, root,                                 &
     &  OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,    &
     &  ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &  ISTEP_TO_INIV2, TAB_POS_IN_PERE                                 &
     &  )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER ICNTL( 40 ), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER SLAVEF, NBFIN
      INTEGER(8) :: LA, IPTRLU, LRLU, LRLUS, POSFAC
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      DOUBLE PRECISION A( LA )
      INTEGER COMP
      INTEGER IFLAG, IERROR, COMM, MYID
      INTEGER LPOOL, LEAF
      INTEGER INODE_PERE, ISON
      INTEGER NFS4FATHER
      INTEGER NSLAVES_PERE, NFRONT_PERE, NASS_PERE
      INTEGER LIST_SLAVES_PERE(NSLAVES_PERE)
      INTEGER NELIM, LMAP, TROW( LMAP )
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER LPTRAR, NELT, ROW_LENGTH
      INTEGER IW( LIW )
      INTEGER BUFR( LBUFR )
      INTEGER IPOOL( LPOOL )
      INTEGER NSTK( KEEP(28) ), ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N), PIMASTER(KEEP(28))
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER LP
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER NOSLA, I, ISTCHK, ISTCHK_LOC
      INTEGER NBROWS_ALREADY_SENT
      INTEGER INDICE_PERE, LREQI, LREQA
      INTEGER INDICE_PERE_ARRAY_ARG(1)
      INTEGER PDEST, PDEST_MASTER, NFRONT
      LOGICAL FLAG, SAME_PROC, FREE, DESCLU
      INTEGER(8) :: APOS, POSROW, ASIZE
      INTEGER SIZFI
      INTEGER NSLSON, NBCOLS, NROW, NROWS_TO_SEND,                      &
     &        NPIV, NROWS_TO_STACK, II, HS, IROW_SON,                   &
     &        IPOS_IN_SLAVE
      INTEGER NBCOLS_EFF
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      LOGICAL COMPRESSCB
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      INTEGER LMAP_LOC, allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: NBROW
      INTEGER, ALLOCATABLE, DIMENSION(:) :: SLAVES_PERE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: MAP, PERM
      LP = ICNTL(1)
      IF (ICNTL(4) .LE. 0) LP = -1
      if (NSLAVES_PERE.le.0) then
       write(6,*) ' error 2 in maplig_fils_niv1 ', NSLAVES_PERE
       CALL AGMG_MUMPS_ABORT()
      endif
      ALLOCATE(NBROW(0:NSLAVES_PERE), stat=allocok)
      IF (allocok .GT. 0) THEN
        IF (LP > 0)                                                     &
     &  write(LP,*) MYID,                                               &
     &  ' : PB allocation NBROW in DMUMPS_211'
        IFLAG  =-13
        IERROR = NSLAVES_PERE+1
        GOTO 700
      ENDIF
      ALLOCATE(SLAVES_PERE(0:NSLAVES_PERE), stat =allocok)
      IF ( allocok .GT. 0 ) THEN
        IF (LP > 0) write(LP,*) MYID,                                   &
     &  ' : PB allocation SLAVES_PERE in DMUMPS_211'
        IFLAG  =-13
        IERROR = NSLAVES_PERE+1
        GOTO 700
      ENDIF
      SLAVES_PERE(1:NSLAVES_PERE) = LIST_SLAVES_PERE(1:NSLAVES_PERE)
      SLAVES_PERE(0) = AGMG_MUMPS_275( STEP(INODE_PERE),                     &
     &      PROCNODE_STEPS, SLAVEF )
      LMAP_LOC = LMAP
      ALLOCATE(MAP(LMAP_LOC), stat=allocok)
      if (allocok .GT. 0) THEN
        IF (LP > 0) write(LP,*) MYID,                                   &
     &   ' : PB allocation LMAP in DMUMPS_211'
        IFLAG  =-13
        IERROR = LMAP_LOC
        GOTO 700
      endif
      MAP( 1 : LMAP_LOC ) = TROW( 1 : LMAP_LOC )
      DO I = 0, NSLAVES_PERE
        NBROW( I ) = 0
      END DO
      IF (NSLAVES_PERE == 0) THEN
        NBROW(0) = LMAP_LOC
      ELSE
       DO I = 1, LMAP_LOC
        INDICE_PERE = MAP( I )
        CALL AGMG_MUMPS_47(                                                  &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &         NASS_PERE,                                               &
     &         NFRONT_PERE - NASS_PERE,                                 &
     &         NSLAVES_PERE,                                            &
     &         INDICE_PERE,                                             &
     &         NOSLA,                                                   &
     &         IPOS_IN_SLAVE )
        NBROW( NOSLA ) = NBROW( NOSLA ) + 1
       END DO
        DO I = 1, NSLAVES_PERE
          NBROW(I)=NBROW(I)+NBROW(I-1)
        ENDDO
      ENDIF
      ALLOCATE(PERM(LMAP_LOC), stat=allocok)
      if (allocok .GT. 0) THEN
        IF (LP > 0) write(LP,*) MYID,                                   &
     &  ': PB allocation PERM in DMUMPS_211'
        IFLAG  =-13
        IERROR = LMAP_LOC
        GOTO 700
      endif
        ISTCHK     = PIMASTER(STEP(ISON))
        NBCOLS     = IW(ISTCHK+KEEP(IXSZ))
      DO I = LMAP_LOC, 1, -1
          INDICE_PERE = MAP( I )
          CALL AGMG_MUMPS_47(                                                &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &           NASS_PERE,                                             &
     &           NFRONT_PERE - NASS_PERE,                               &
     &           NSLAVES_PERE,                                          &
     &           INDICE_PERE,                                           &
     &           NOSLA,                                                 &
     &           IPOS_IN_SLAVE )
          PERM( NBROW( NOSLA ) ) = I
          NBROW( NOSLA ) = NBROW( NOSLA ) - 1
      ENDDO
      DO I = 0, NSLAVES_PERE
          NBROW(I)=NBROW(I)+1
      END DO
      PDEST_MASTER = MYID
      IF ( SLAVES_PERE(0) .NE. MYID ) THEN
        WRITE(*,*) 'Error 1 in MAPLIG_FILS_NIV1:',MYID, SLAVES_PERE
        CALL AGMG_MUMPS_ABORT()
      END IF
      PDEST        = PDEST_MASTER
        I = 0
        NBPROCFILS(STEP(INODE_PERE))=NBPROCFILS(STEP(INODE_PERE))-1
        NBPROCFILS(STEP(ISON))  = NBPROCFILS(STEP(ISON)) - 1
        ISTCHK     = PIMASTER(STEP(ISON))
        NBCOLS     = IW(ISTCHK+KEEP(IXSZ))
        NELIM      = IW(ISTCHK+1+KEEP(IXSZ))
        NROW       = IW(ISTCHK+2+KEEP(IXSZ))
        NPIV       = IW(ISTCHK+3+KEEP(IXSZ))
        IF (NPIV.LT.0) THEN
         write(6,*) ' Error 2 in DMUMPS_211 ', NPIV
         CALL AGMG_MUMPS_ABORT()
        ENDIF
        NSLSON     = IW(ISTCHK+5+KEEP(IXSZ))
        NFRONT     = NPIV + NBCOLS
        COMPRESSCB=(IW(PTRIST(STEP(ISON))+XXS) .eq. S_CB1COMP)
        IF (I == NSLAVES_PERE) THEN
          NROWS_TO_STACK=LMAP_LOC-NBROW(I)+1
        ELSE
          NROWS_TO_STACK=NBROW(I+1)-NBROW(I)
        ENDIF
        DO II = 1,NROWS_TO_STACK
          IROW_SON=PERM(NBROW(I)+II-1)
          INDICE_PERE = MAP(IROW_SON)
          CALL AGMG_MUMPS_47(                                                &
     &         KEEP,KEEP8, INODE_PERE, STEP, N, SLAVEF,                 &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &         NASS_PERE,                                               &
     &         NFRONT_PERE - NASS_PERE,                                 &
     &         NSLAVES_PERE,                                            &
     &         INDICE_PERE,                                             &
     &         NOSLA,                                                   &
     &         IPOS_IN_SLAVE )
          INDICE_PERE = IPOS_IN_SLAVE
          IF (COMPRESSCB) THEN
            IF (NELIM.EQ.0) THEN
            POSROW = PAMASTER(STEP(ISON)) +                             &
     &         int(IROW_SON,8)*int(IROW_SON-1,8)/2_8
            ELSE
            POSROW = PAMASTER(STEP(ISON)) +                             &
     &         int(NELIM+IROW_SON,8)*int(NELIM+IROW_SON-1,8)/2_8
            ENDIF
          ELSE
            POSROW = PAMASTER(STEP(ISON)) +                             &
     &             int(NELIM+IROW_SON-1,8)*int(NBCOLS,8)
          ENDIF
          IF (KEEP(50).NE.0) THEN
            NBCOLS_EFF = NELIM + IROW_SON
          ELSE
            NBCOLS_EFF = NBCOLS
          ENDIF
          INDICE_PERE_ARRAY_ARG(1) = INDICE_PERE
          CALL DAGMG_MUMPS_39(N, INODE_PERE, IW, LIW,                        &
     &    A, LA, ISON, 1, NBCOLS_EFF, INDICE_PERE_ARRAY_ARG,            &
     &    A(POSROW), PTLUST_S, PTRAST,                                  &
     &    STEP, PIMASTER, OPASSW, IWPOSCB,                              &
     &    MYID, KEEP,KEEP8)
        ENDDO
        IF (KEEP(219).NE.0) THEN
         IF(NSLAVES_PERE.GT.0 .AND. KEEP(50).EQ.2) THEN
           IF (COMPRESSCB) THEN
             POSROW = PAMASTER(STEP(ISON))                              &
     &          + int(NELIM+NBROW(1),8)*int(NELIM+NBROW(1)-1,8)/2_8
             ASIZE  = int(LMAP_LOC+NELIM,8)*int(NELIM+LMAP_LOC+1,8)/2_8 &
     &          - int(NELIM+NBROW(1),8)*int(NELIM+NBROW(1)-1,8)/2_8
           ELSE
             POSROW = PAMASTER(STEP(ISON)) +                            &
     &                 int(NELIM+NBROW(1)-1,8)*int(NBCOLS,8)
             ASIZE  = int(LMAP_LOC-NBROW(1)+1,8) * int(NBCOLS,8)
           ENDIF
           CALL DAGMG_MUMPS_617(NFS4FATHER,IERR)
           IF (IERR .NE.0) THEN
              IF (LP > 0) WRITE(LP,*) MYID,                             &
     &    ": PB allocation MAX_ARRAY during DAGMG_MUMPS_211"
              IFLAG=-13
              IERROR=NFS4FATHER
              GOTO 700
           ENDIF
           IF  ( LMAP_LOC-NBROW(1)+1 .NE. 0 ) THEN
           CALL DAGMG_MUMPS_618(                                             &
     &          A(POSROW),ASIZE,NBCOLS,LMAP_LOC-NBROW(1)+1,             &
     &          BUF_MAX_ARRAY,NFS4FATHER,COMPRESSCB,                    &
     &          NELIM+NBROW(1))
           ELSE
                CALL DAGMG_MUMPS_757(BUF_MAX_ARRAY,                          &
     &          NFS4FATHER)
           ENDIF
           CALL DAGMG_MUMPS_619(N, INODE_PERE, IW, LIW,                      &
     &          A, LA, ISON, NFS4FATHER,                                &
     &          BUF_MAX_ARRAY, PTLUST_S, PTRAST,                        &
     &          STEP, PIMASTER, OPASSW,                                 &
     &          IWPOSCB,MYID, KEEP,KEEP8)
         ENDIF
        ENDIF
          IF ( NBPROCFILS(STEP(ISON)) .EQ. 0) THEN
               ISTCHK_LOC = PIMASTER(STEP(ISON))
               SAME_PROC= ISTCHK_LOC .LT. IWPOSCB
               IF (SAME_PROC) THEN
                 CALL DAGMG_MUMPS_530(N, ISON, INODE_PERE,                   &
     &            IWPOSCB, PIMASTER, PTLUST_S, IW, LIW, STEP,           &
     &            KEEP,KEEP8)
               ENDIF
          ENDIF
          IF ( NBPROCFILS(STEP(INODE_PERE)) .EQ. 0 ) THEN
            CALL DAGMG_MUMPS_507( N, IPOOL, LPOOL,                           &
     &        PROCNODE_STEPS,                                           &
     &        SLAVEF, KEEP(28), KEEP(76), KEEP(80),                     &
     &        KEEP(47), STEP, INODE_PERE+N )
            IF (KEEP(47) .GE. 3) THEN
              CALL DAGMG_MUMPS_500(                                          &
     &       IPOOL, LPOOL,                                              &
     &       PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,             &
     &       MYID, STEP, N, ND, FILS )
            ENDIF
          END IF
      DO I = 0, NSLAVES_PERE
        PDEST = SLAVES_PERE( I )
        IF ( PDEST .NE. MYID ) THEN
           NBROWS_ALREADY_SENT = 0
   95      CONTINUE
           NFRONT = IW(PIMASTER(STEP(ISON))+KEEP(IXSZ))
           NELIM  = IW(PIMASTER(STEP(ISON))+1+KEEP(IXSZ))
           APOS = PAMASTER(STEP(ISON))
           DESCLU = .TRUE.
           IF (I == NSLAVES_PERE) THEN
             NROWS_TO_SEND=LMAP_LOC-NBROW(I)+1
           ELSE
             NROWS_TO_SEND=NBROW(I+1)-NBROW(I)
           ENDIF
           CALL DAGMG_MUMPS_67(NBROWS_ALREADY_SENT,                          &
     &      DESCLU, INODE_PERE,                                         &
     &      NFRONT_PERE, NASS_PERE, NFS4FATHER,                         &
     &           NSLAVES_PERE,                                          &
     &      ISON, NROWS_TO_SEND, LMAP_LOC,                              &
     &      MAP, PERM(min(LMAP_LOC,NBROW(I))),                          &
     &      IW(PIMASTER(STEP(ISON))),                                   &
     &      A(APOS), I, PDEST, PDEST_MASTER, COMM, IERR,                &
     &      KEEP,KEEP8, STEP, N, SLAVEF,                                &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE,                            &
     &      COMPRESSCB)
            IF ( IERR .EQ. -2 ) THEN
              IF (LP > 0) WRITE(LP,*) MYID,                             &
     &": FAILURE, SEND BUFFER TOO SMALL DURING DAGMG_MUMPS_211"
              IFLAG  = -17
              IERROR =  (NROWS_TO_SEND + 3 )* KEEP( 34 ) +              &
     &        NROWS_TO_SEND *  KEEP( 35 )
              GO TO 700
            END IF
            IF ( IERR .EQ. -3 ) THEN
              IF (LP > 0) WRITE(LP,*) MYID,                             &
     &": FAILURE, RECV BUFFER TOO SMALL DURING DAGMG_MUMPS_211"
              IFLAG  = -20
              IERROR =  (NROWS_TO_SEND + 3 )* KEEP( 34 ) +              &
     &        NROWS_TO_SEND *  KEEP( 35 )
              GO TO 700
            ENDIF
            IF (KEEP(219).NE.0) THEN
             IF ( IERR .EQ. -4 ) THEN
               IFLAG  = -13
               IERROR = BUF_LMAX_ARRAY
              IF (LP > 0) WRITE(LP,*) MYID,                             &
     &": FAILURE, MAX_ARRAY ALLOC FAILED DURING DAGMG_MUMPS_211"
               GO TO 700
             ENDIF
            ENDIF
            IF ( IERR .EQ. -1 ) THEN
              BLOCKING = .FALSE.
              SET_IRECV = .FALSE.
              MESSAGE_RECEIVED = .FALSE.
              CALL DAGMG_MUMPS_329( COMM_LOAD,                               &
     &          ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,       &
     &          AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                            &
     &          STATUS,                                                 &
     &          BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,       &
     &          IWPOS, IWPOSCB, IPTRLU,                                 &
     &          LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                 &
     &          PTLUST_S, PTRFAC,                                       &
     &          PTRAST, STEP, PIMASTER, PAMASTER, NSTK, COMP,           &
     &          IFLAG, IERROR, COMM,                                    &
     &          NBPROCFILS,                                             &
     &          IPOOL, LPOOL, LEAF,                                     &
     &          NBFIN, MYID, SLAVEF,                                    &
     &          root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,      &
     &          INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,           &
     &          LPTRAR, NELT, FRTPTR, FRTELT,                           &
     &          ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
              IF ( IFLAG .LT. 0 ) GOTO 600
              GO TO 95
            END IF
        END IF
      END DO
      ISTCHK = PTRIST(STEP(ISON))
      PTRIST(STEP( ISON )) = -77777777
            IF ( IW(ISTCHK+KEEP(IXSZ)) .GE. 0 ) THEN
              WRITE(*,*) 'error 3 in DMUMPS_211'
              CALL AGMG_MUMPS_ABORT()
            ENDIF
      CALL DAGMG_MUMPS_152(.FALSE., MYID, N, ISTCHK,                         &
     &     PAMASTER(STEP(ISON)),                                        &
     &     IW, LIW, LRLU, LRLUS, IPTRLU,                                &
     &     IWPOSCB, LA, KEEP,KEEP8, .FALSE.                             &
     &     )
  600 CONTINUE
      DEALLOCATE(NBROW)
      DEALLOCATE(MAP)
      DEALLOCATE(PERM)
      DEALLOCATE(SLAVES_PERE)
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44(MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_211
      SUBROUTINE DAGMG_MUMPS_93(SIZE_INPLACE,                                &
     &MYID,N,IOLDPS,TYPE,IW, LIW, A, LA,                                &
     &POSFAC, LRLU, LRLUS, IWPOS, PTRAST, PTRFAC, STEP, KEEP,KEEP8,     &
     &SSARBR,INODE,IERR)
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER MYID
      INTEGER IOLDPS, TYPE, LIW, N, KEEP(500)
      INTEGER(8) :: SIZE_INPLACE, LA, POSFAC, LRLU, LRLUS
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER*8 KEEP8(150)
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER IWPOS, LDLT
      INTEGER STEP( N )
      INTEGER (8) :: PTRFAC(KEEP(28))
      LOGICAL SSARBR
      INTEGER IOLDSHIFT, IPSSHIFT
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER LCONT, NELIM, NROW, NPIV, INTSIZ
      INTEGER NFRONT, NSLAVES
      INTEGER IPS, IPSIZE
      INTEGER(8) :: SIZELU, SIZECB, IAPOS, I
      LOGICAL MOVEPTRAST
      INTEGER INODE
      INTEGER IERR
      IERR=0
      LDLT = KEEP(50)
      IOLDSHIFT = IOLDPS + KEEP(IXSZ)
      IF ( IW( IOLDSHIFT ) < 0 ) THEN
        write(*,*) ' ERROR 1 compressLU:Should not point to a band.'
        CALL AGMG_MUMPS_ABORT()
      ELSE IF ( IW( IOLDSHIFT + 2 ) < 0 ) THEN
        write(*,*) ' ERROR 2 compressLU:Stack not performed yet',       &
     &  IW(IOLDSHIFT + 2)
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      LCONT  = IW( IOLDSHIFT )
      NELIM  = IW( IOLDSHIFT + 1 )
      NROW   = IW( IOLDSHIFT + 2 )
      NPIV   = IW( IOLDSHIFT + 3 )
      IAPOS  = PTRFAC(IW( IOLDSHIFT + 4 ))
      NSLAVES= IW( IOLDSHIFT + 5 )
      NFRONT = LCONT + NPIV
      INTSIZ = IW(IOLDPS+XXI)
      IF ( (NSLAVES > 0  .AND. TYPE .NE. 2) .OR.                        &
     &   (NSLAVES .eq. 0 .AND. TYPE .EQ. 2 ) ) THEN
          WRITE(*,*) ' ERROR 3 compressLU: problem with level of inode'
          CALL AGMG_MUMPS_ABORT()
      END IF
      IF (LDLT.EQ.0) THEN
        SIZELU = int(LCONT + NROW, 8) * int(NPIV,8)
      ELSE
        SIZELU =   int(NROW,8) * int(NPIV,8)
      ENDIF
      IF ( TYPE .EQ. 2 ) THEN
        IF (LDLT.EQ.0) THEN
          SIZECB = int(NELIM,8) * int(LCONT,8)
        ELSE
          IF (KEEP(219).NE.0.AND.KEEP(50).EQ.2) THEN
            SIZECB = int(NELIM+1,8) * int(NELIM + NPIV,8)
          ELSE
            SIZECB = int(NELIM,8) * int(NELIM + NPIV,8)
          ENDIF
        ENDIF
      ELSE
        IF (LDLT.EQ.0) THEN
         SIZECB = int(LCONT,8) * int(LCONT,8)
        ELSE
         SIZECB = int(NROW,8) * int(LCONT,8)
        ENDIF
      END IF
      CALL AGMG_MUMPS_724( IW(IOLDPS+XXR), SIZECB )
      IF ((SIZECB.EQ.0_8).AND.(KEEP(201).EQ.0)) THEN
         GOTO 500
      ENDIF
      IF (KEEP(201).EQ.2) THEN
         KEEP8(31)=KEEP8(31)+SIZELU
         CALL DAGMG_MUMPS_576(INODE,PTRFAC,KEEP,KEEP8,                       &
     &        A,LA,SIZELU, IERR)
         IF(IERR.LT.0)THEN
            WRITE(*,*)MYID,': Internal error in DMUMPS_576'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
      ENDIF
      IF ( IOLDPS + INTSIZ .NE. IWPOS ) THEN
         IPS = IOLDPS + INTSIZ
         MOVEPTRAST = .FALSE.
         DO WHILE ( IPS .NE. IWPOS )
           IPSIZE = IW(IPS+XXI)
           IPSSHIFT = IPS + KEEP(IXSZ)
           IF ( IW( IPSSHIFT + 2 ) < 0 ) THEN
             NFRONT = IW( IPSSHIFT )
             IF(KEEP(201).EQ.0)THEN
               PTRFAC(IW( IPSSHIFT + 4 )) =                             &
     &                      PTRFAC(IW( IPSSHIFT + 4 )) - SIZECB
             ELSE
               PTRFAC(IW(IPSSHIFT+4))=PTRFAC(IW(IPSSHIFT+4)) -          &
     &               SIZECB - SIZELU
             ENDIF
             MOVEPTRAST = .TRUE.
             IF(KEEP(201).EQ.0)THEN
               PTRAST(IW(IPSSHIFT+4))=PTRAST(IW(IPSSHIFT+4))-SIZECB
             ELSE
               PTRAST(IW(IPSSHIFT+4))=PTRAST(IW(IPSSHIFT+4))-SIZECB     &
     &               - SIZELU
             ENDIF
           ELSE IF ( IW( IPSSHIFT ) < 0 ) THEN
             IF(KEEP(201).EQ.0)THEN
               PTRFAC(IW(IPSSHIFT+3)) = PTRFAC(IW(IPSSHIFT+3))-SIZECB
             ELSE
               PTRFAC(IW(IPSSHIFT+3)) = PTRFAC(IW(IPSSHIFT+3))          &
     &                                  -SIZECB-SIZELU
             ENDIF
           ELSE
             NFRONT = IW( IPSSHIFT ) + IW( IPSSHIFT + 3 )
             IF(KEEP(201).EQ.0)THEN
                PTRFAC(IW( IPSSHIFT + 4 )) =                            &
     &                    PTRFAC(IW( IPSSHIFT + 4 )) - SIZECB
             ELSE
                PTRFAC(IW( IPSSHIFT + 4 )) =                            &
     &               PTRFAC(IW( IPSSHIFT + 4 )) - SIZECB                &
     &               - SIZELU
             ENDIF
           END IF
           IPS = IPS + IPSIZE
         END DO
         IF ((SIZECB .NE. 0_8).OR.(KEEP(201).NE.0)) THEN
            IF (KEEP(201).NE.0) THEN
               DO I=IAPOS, POSFAC - SIZECB - SIZELU - 1_8
                  A( I ) = A( I + SIZECB + SIZELU)
               END DO
            ELSE
               DO I=IAPOS + SIZELU, POSFAC - SIZECB - 1_8
                  A( I ) = A( I + SIZECB )
               END DO
            ENDIF
         END IF
      ENDIF
      IF (KEEP(201).NE.0) THEN
        POSFAC = POSFAC  - (SIZECB+SIZELU)
        LRLU   = LRLU    + (SIZECB+SIZELU)
        LRLUS  = LRLUS   + (SIZECB+SIZELU) - SIZE_INPLACE
      ELSE
        POSFAC = POSFAC - SIZECB
        LRLU   = LRLU   + SIZECB
        LRLUS  = LRLUS  + SIZECB - SIZE_INPLACE
      ENDIF
  500 CONTINUE
      CALL DAGMG_MUMPS_471(SSARBR,.FALSE.,                                   &
     &         LA-LRLUS,SIZELU,-SIZECB+SIZE_INPLACE,KEEP,KEEP8,LRLU)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_93
      SUBROUTINE DAGMG_MUMPS_314( N, ISON,                                   &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, TYPE_SON       &
     &     )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER(8) :: LA, LRLU, LRLUS, POSFAC, IPTRLU
      INTEGER N, ISON, LIW, IWPOS, IWPOSCB,                             &
     &        COMP, IFLAG, IERROR, SLAVEF, MYID, COMM,                  &
     &        TYPE_SON
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRAST(KEEP(28)), PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), STEP(N),                                &
     & PIMASTER(KEEP(28)), IW(LIW)
      INTEGER PTLUST_S(KEEP(28)), ITLOC(N)
      INTEGER(8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION OPELIW
      DOUBLE PRECISION FLOP1, FLOP1_EFFECTIVE
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: LREQA, SIZFR, POSA, POSALOC, OLDPOS
      INTEGER  NFRONT, NCOL_L, NROW_L, LREQI, NSLAVES_L,                &
     &         POSI, ISTCHK, SIZFI, I,                                  &
     &         NSLSON, HS, IROW_L, ICOL_L, NROW, NCOL,                  &
     &         LDA_BAND, NASS
      LOGICAL SAME_PROC, FREE, ALREADY_ON_DISK
      INTEGER(8) :: LAFAC, LREQA_HEADER
      INTEGER LIWFAC, STRAT, TYPEFile, NextPivDummy,                    &
     &        IOLDPS_CB
      LOGICAL LAST_CALL
      TYPE(IO_BLOCK) :: MonBloc
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
      FLOP1 = ZERO
      NCOL_L = IW( PTRIST(STEP( ISON )) + 3 + KEEP(IXSZ) )
      NROW_L = IW( PTRIST(STEP( ISON )) + 2 + KEEP(IXSZ) )
      NSLAVES_L = IW( PTRIST(STEP( ISON )) + 5 + KEEP(IXSZ) )
      LDA_BAND = NCOL_L + IW( PTRIST(STEP( ISON )) + KEEP(IXSZ) )
      IF  ( KEEP(50) .eq. 0 ) THEN
        NFRONT = LDA_BAND
      ELSE
        NFRONT = IW( PTRIST(STEP( ISON )) + 7 + KEEP(IXSZ) )
      END IF
      ALREADY_ON_DISK = .FALSE.
      IF (KEEP(201).EQ.1) THEN
          IOLDPS_CB = PTRIST(STEP( ISON ))
          CALL AGMG_MUMPS_729(LAFAC, IW(IOLDPS_CB+XXR))
          LIWFAC    = IW(IOLDPS_CB+XXI)
          TYPEFile  = TYPEF_L
          NextPivDummy      = -8888
          MonBloc%INODE    = ISON
          MonBloc%MASTER   = .FALSE.
          MonBloc%Typenode =  2
          MonBloc%NROW     = NROW_L
          MonBloc%NCOL     = LDA_BAND
          MonBloc%NFS      = IW(IOLDPS_CB+1+KEEP(IXSZ))
          MonBloc%LastPiv  = NCOL_L
          NULLIFY(MonBloc%INDICES)
          STRAT        = STRAT_WRITE_MAX
          LAST_CALL    = .TRUE.
          MonBloc%Last = .TRUE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(PTRAST(STEP(ISON))), LAFAC, MonBloc,                 &
     &           NextPivDummy, NextPivDummy,                            &
     &           IW(IOLDPS_CB), LIWFAC,                                 &
     &           MYID, KEEP8(31), IFLAG,LAST_CALL )
          ALREADY_ON_DISK = .TRUE.
          IF ((NCOL_L.EQ.0).OR.(NROW_L.EQ.0)) THEN
          ENDIF
      ENDIF
      IF ((NCOL_L.EQ.0).OR.(NROW_L.EQ.0)) THEN
        GOTO 80
      ENDIF
      LREQI   = 4 + NCOL_L + NROW_L + KEEP(IXSZ)
      LREQA_HEADER =  int(NCOL_L,8) * int(NROW_L,8)
      IF (ALREADY_ON_DISK) THEN
        LREQA = 0_8
      ELSE
        LREQA   = LREQA_HEADER
      ENDIF
      IF ( LRLU .LT. LREQA .OR.                                         &
     &  IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
        IF ( LRLUS .LT. LREQA ) THEN
          IFLAG  = -9
          CALL AGMG_MUMPS_731(LREQA - LRLUS, IERROR)
          GO TO 700
        END IF
        CALL DAGMG_MUMPS_94( N,KEEP(28), IW, LIW, A, LA,                     &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS,IWPOSCB, PTRIST, PTRAST,                            &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
        COMP = COMP+1
        IF ( LRLU .NE. LRLUS ) THEN
                  WRITE(*,*) 'PB compress Stack_band:LRLU,LRLUS=',      &
     &            LRLU, LRLUS
                  IFLAG = -9
                  CALL AGMG_MUMPS_731(LREQA - LRLUS, IERROR)
                  GOTO 700
        END IF
        IF ( IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
          IFLAG  = -8
          IERROR = IWPOS + LREQI - 1 - IWPOSCB
          GOTO 700
        END IF
      END IF
      IF (.NOT. ALREADY_ON_DISK) THEN
        POSA = POSFAC
        POSFAC = POSFAC + LREQA
        LRLU = LRLU - LREQA
        LRLUS = LRLUS - LREQA
        KEEP8(67) = min(LRLUS, KEEP8(67))
        IF(KEEP(201).NE.2)THEN
           CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                             &
     &          LA-LRLUS,LREQA,LREQA,KEEP,KEEP8,LRLU)
        ELSE
           CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                             &
     &          LA-LRLUS,0_8,LREQA,KEEP,KEEP8,LRLU)
        ENDIF
      ENDIF
      POSI = IWPOS
      IWPOS = IWPOS + LREQI
      PTLUST_S(STEP( ISON )) = POSI
      IW(POSI+XXI)=LREQI
      CALL AGMG_MUMPS_730(LREQA, IW(POSI+XXR))
      CALL AGMG_MUMPS_730(LREQA_HEADER, IW(POSI+XXR))
      IW(POSI+XXS)=-9999
      POSI=POSI+KEEP(IXSZ)
      IW( POSI     ) = - NCOL_L
      IW( POSI + 1 ) =   NROW_L
      IW( POSI + 2 ) =   NFRONT - NCOL_L
      IW( POSI + 3 ) =   STEP(ISON)
      IF (.NOT. ALREADY_ON_DISK) THEN
        PTRFAC(STEP(ISON)) = POSA
      ELSE
        PTRFAC(STEP(ISON)) = -77777_8
      ENDIF
      IROW_L = PTRIST(STEP(ISON)) + 6 + NSLAVES_L + KEEP(IXSZ)
      ICOL_L = PTRIST(STEP(ISON)) + 6 + NROW_L + NSLAVES_L + KEEP(IXSZ)
      IW( POSI + 4 : POSI + 3 + NROW_L ) =                              &
     &                       IW( IROW_L: IROW_L + NROW_L - 1 )
      IW( POSI + NROW_L + 4: POSI + NROW_L + NCOL_L + 3 ) =             &
     &                       IW( ICOL_L: ICOL_L + NCOL_L - 1 )
      IF (.NOT.ALREADY_ON_DISK) THEN
        POSALOC = POSA
        DO I = 1, NROW_L
          OLDPOS =  PTRAST( STEP(ISON)) + int(I-1,8)*int(LDA_BAND,8)
          A( POSALOC : POSALOC + int(NCOL_L-1,8) ) =                    &
     &                     A( OLDPOS: OLDPOS + int(NCOL_L-1,8) )
          POSALOC = POSALOC + int(NCOL_L,8)
        END DO
      ENDIF
      IF (KEEP(201).NE.0 .AND. KEEP(201).NE.1) THEN
       KEEP8(31)=KEEP8(31)+LREQA
      ENDIF
      KEEP8(10) = KEEP8(10) + int(NCOL_L,8) * int(NROW_L,8)
      IF (KEEP(201).EQ.2) THEN
       CALL DAGMG_MUMPS_576(ISON,PTRFAC,KEEP,KEEP8,A,LA,LREQA,IFLAG)
       IF(IFLAG.LT.0)THEN
         WRITE(*,*)MYID,': Internal error in DMUMPS_576'
         IERROR=0
         GOTO 700
       ENDIF
      ENDIF
      IF (KEEP(201).EQ.2) THEN
        POSFAC = POSFAC - LREQA
        LRLU = LRLU + LREQA
        LRLUS = LRLUS + LREQA
        CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                &
     &            LA-LRLUS,LREQA,0_8,KEEP,KEEP8,LRLU)
      ENDIF
   80 CONTINUE
      IF (TYPE_SON == 1) THEN
         GOTO 90
      ENDIF
      IF ( KEEP(50) .eq. 0 ) THEN
         FLOP1 = dble( NCOL_L * NROW_L) +                               &
     &     dble(NROW_L*NCOL_L)*dble(2*NFRONT-NCOL_L-1)
      ELSE
         FLOP1 = dble( NCOL_L ) * dble( NROW_L )                        &
     &         * dble( 2 * LDA_BAND - NROW_L - NCOL_L + 1)
      END IF
      OPELIW = OPELIW + FLOP1
      FLOP1_EFFECTIVE = FLOP1
      NASS = IW( PTRIST(STEP( ISON )) + 4 + KEEP(IXSZ) )
      IF ( NCOL_L .NE. NASS ) THEN
        IF ( KEEP(50).eq.0 ) THEN
           FLOP1 = dble( NASS * NROW_L) +                               &
     &     dble(NROW_L*NASS)*dble(2*NFRONT-NASS-1)
        ELSE
           FLOP1 = dble( NASS ) * dble( NROW_L ) *                      &
     &     dble( 2 * LDA_BAND - NROW_L - NASS + 1)
        END IF
      END IF
      CALL DAGMG_MUMPS_190(1,.FALSE.,FLOP1_EFFECTIVE-FLOP1,                  &
     &                        KEEP,KEEP8)
      CALL DAGMG_MUMPS_190(2,.FALSE.,-FLOP1,KEEP,KEEP8)
   90 CONTINUE
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_314
      SUBROUTINE DAGMG_MUMPS_626( N, ISON,                                   &
     &    PTRIST, PTRAST, IW, LIW, A, LA,                               &
     &    LRLU, LRLUS, IWPOSCB,                                         &
     &    IPTRLU, STEP, MYID, KEEP                                      &
     &     )
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER(8) :: LRLU, LRLUS, IPTRLU, LA
      INTEGER ISON, MYID, N, IWPOSCB
      INTEGER KEEP(500), STEP(N)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER PTRIST(KEEP(28))
      INTEGER LIW
      INTEGER IW(LIW)
      DOUBLE PRECISION A(LA)
      INTEGER ISTCHK
      ISTCHK = PTRIST(STEP(ISON))
      CALL DAGMG_MUMPS_152(.FALSE.,MYID, N, ISTCHK,                          &
     &     PTRAST(STEP(ISON)),                                          &
     &     IW, LIW, LRLU, LRLUS, IPTRLU,                                &
     &     IWPOSCB, LA, KEEP,KEEP8, .FALSE.                             &
     &     )
      PTRIST(STEP( ISON )) = -9999888
      PTRAST(STEP( ISON )) = -9999888_8
      RETURN
      END SUBROUTINE DAGMG_MUMPS_626
      SUBROUTINE DAGMG_MUMPS_214( KEEP,KEEP8,                                &
     &           MYID, N, NELT, LNA, NZ, NA_ELT, NSLAVES,               &
     &           MEMORY_MBYTES, EFF, OOC, PERLU_ON,                     &
     &           MEMORY_BYTES )
      IMPLICIT NONE
      LOGICAL,   INTENT(IN)  :: EFF, OOC, PERLU_ON
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER MYID, N, NELT, NSLAVES, LNA, NZ, NA_ELT
      INTEGER*8, INTENT(OUT) :: MEMORY_BYTES
      INTEGER,   INTENT(OUT) :: MEMORY_MBYTES
      LOGICAL    :: I_AM_SLAVE, I_AM_MASTER
      INTEGER    :: PERLU, NBRECORDS
      INTEGER(8) :: NB_REAL, MAXS_MIN
      INTEGER(8) :: TEMP, NB_BYTES, NB_INT
      INTEGER    :: DAGMG_MUMPS_LBUF_INT, DAGMG_MUMPS_LBUFR_BYTES, DAGMG_MUMPS_LBUF
      INTEGER    :: NBUFS
      INTEGER(8) :: TEMPI
      INTEGER(8) :: TEMPR
      INTEGER    :: MIN_PERLU
      INTEGER(8) :: BUF_OOC, BUF_OOC_PANEL, BUF_OOC_NOPANEL
      INTEGER(8) :: OOC_NB_FILE_TYPE
      INTEGER(8) :: NSTEPS8, N8, NELT8
      INTEGER(8) :: I8OVERI
      I8OVERI   = int(KEEP(10),8)
      PERLU     = KEEP(12)
      NSTEPS8   = int(KEEP(28),8)
      N8        = int(N,8)
      NELT8     = int(NELT,8)
      IF (.NOT.PERLU_ON) PERLU = 0
      I_AM_MASTER = ( MYID .eq. 0 )
      I_AM_SLAVE  = ( KEEP(46).eq. 1 .or. MYID .ne. 0 )
      TEMP    = 0_8
      NB_REAL = 0_8
      NB_BYTES = 0_8
      NB_INT  = 0_8
      NB_INT = NB_INT + 5_8 * NSTEPS8
      NB_INT = NB_INT + NSTEPS8 + int(KEEP(56),8)*int(NSLAVES+2,8)
      NB_INT = NB_INT + 3_8 * N8
      IF (KEEP(23).ne.0 .and. I_AM_MASTER) NB_INT=NB_INT + N8
      IF (KEEP(55).eq.0) THEN
        NB_INT = NB_INT + 2_8 * N8
      ELSE
        NB_INT = NB_INT + 2_8 * ( NELT8 + 1_8 )
      ENDIF
      IF (KEEP(55) .ne. 0 ) THEN
        NB_INT = NB_INT + N8 + 1_8 + NELT8
      END IF
      NB_INT = NB_INT + int(LNA,8)
      IF ( OOC ) THEN
        MAXS_MIN = KEEP8(14)
      ELSE
        MAXS_MIN = KEEP8(12)
      ENDIF
      IF ( .NOT. EFF ) THEN
        IF ( KEEP8(24).EQ.0_8 ) THEN
         NB_REAL = NB_REAL + MAXS_MIN +                                 &
     &             int(PERLU,8)*(MAXS_MIN / 100_8 + 1_8 )
        ENDIF
      ELSE
        NB_REAL = NB_REAL + KEEP8(67)
      ENDIF
      IF ( OOC .AND. I_AM_SLAVE ) THEN
        BUF_OOC_NOPANEL = 2_8 * KEEP8(119)
        IF (KEEP(50).EQ.0)THEN
          BUF_OOC_PANEL = 8_8 * int(KEEP(226),8)
        ELSE
          BUF_OOC_PANEL = 4_8 * int(KEEP(226),8)
        ENDIF
        BUF_OOC = BUF_OOC_PANEL
        NB_REAL = NB_REAL + min(BUF_OOC + int(max(PERLU,0),8) *         &
     &          (BUF_OOC/100_8+1_8),12000000_8)
        IF (KEEP(50).EQ.0) THEN
          OOC_NB_FILE_TYPE = 2_8
        ELSE
          OOC_NB_FILE_TYPE = 1_8
        ENDIF
        NB_INT = NB_INT + OOC_NB_FILE_TYPE * NSTEPS8 * I8OVERI
        NB_INT = NB_INT + OOC_NB_FILE_TYPE * NSTEPS8 * I8OVERI
        NB_INT = NB_INT + OOC_NB_FILE_TYPE * NSTEPS8
      ENDIF
      NB_REAL = NB_REAL + int(KEEP(13),8)
      IF ( .not. ( I_AM_SLAVE .and. I_AM_MASTER .and. KEEP(52) .eq. 0   &
     &         .and. KEEP(55) .ne. 0 ) ) THEN
        NB_INT  = NB_INT  + int(KEEP(14),8)
      END IF
      IF ( I_AM_SLAVE .and. KEEP(38) .ne. 0 ) THEN
        NB_INT = NB_INT + 2_8 * N8
      END IF
      TEMPI= 0_8
      TEMPR = 0_8
      NBRECORDS = KEEP(39)
      IF (KEEP(55).eq.0) THEN
        NBRECORDS = min(KEEP(39), NZ)
      ELSE
        NBRECORDS = min(KEEP(39), NA_ELT)
      ENDIF
      IF ( KEEP(54) .eq. 0 ) THEN
        IF ( I_AM_MASTER ) THEN
          IF ( KEEP(46) .eq. 0 ) THEN
            NBUFS = NSLAVES
          ELSE
            NBUFS = NSLAVES - 1
            IF (KEEP(55) .eq. 0 )                                       &
     &      TEMPI = TEMPI + 2_8 * N8
          END IF
          TEMPI = TEMPI + 2_8 * int(NBRECORDS,8) * int(NBUFS,8)
          TEMPR = TEMPR + int(NBRECORDS,8) * int(NBUFS,8)
        ELSE
          IF ( KEEP(55) .eq. 0 )THEN
            TEMPI = TEMPI + 2_8 * int(NBRECORDS,8)
            TEMPR = TEMPR + int(NBRECORDS,8)
          END IF
        END IF
      ELSE
        IF ( I_AM_SLAVE ) THEN
          TEMPI = TEMPI + int(1+4*NSLAVES,8) * int(NBRECORDS,8)
          TEMPR = TEMPR + int(1+2*NSLAVES,8) * int(NBRECORDS,8)
        END IF
      END IF
      TEMP = max( NB_BYTES + (NB_INT + TEMPI) * int(KEEP(34),8)         &
     &           + (NB_REAL+TEMPR) * int(KEEP(35),8)                    &
     &            , TEMP )
      IF ( I_AM_SLAVE ) THEN
        DAGMG_MUMPS_LBUFR_BYTES = KEEP( 44 ) * KEEP( 35 )
        DAGMG_MUMPS_LBUFR_BYTES = max( DAGMG_MUMPS_LBUFR_BYTES,                   &
     &                      100000 )
        IF (KEEP(48).EQ.5) THEN
          MIN_PERLU=2
        ELSE
          MIN_PERLU=0
        ENDIF
        DAGMG_MUMPS_LBUFR_BYTES = DAGMG_MUMPS_LBUFR_BYTES                         &
     &        + int( dble(max(PERLU,MIN_PERLU))*                        &
     &        dble(DAGMG_MUMPS_LBUFR_BYTES)/100D0)
        IF (KEEP(50).NE.1) THEN
           DAGMG_MUMPS_LBUFR_BYTES = DAGMG_MUMPS_LBUFR_BYTES                      &
     &            + int( dble(max(PERLU,0))*                            &
     &            dble(DAGMG_MUMPS_LBUFR_BYTES)/100D0)
        ENDIF
        NB_BYTES = NB_BYTES + int(DAGMG_MUMPS_LBUFR_BYTES,8)
        IF (NSLAVES.EQ.2) THEN
         DAGMG_MUMPS_LBUF = int( 1.01D0 * dble(KEEP( 43 ) * KEEP( 35 )) )
        ELSE
         DAGMG_MUMPS_LBUF = int( dble(KEEP(213)) / 100.0D0                   &
     &                     * dble(KEEP( 43 ) * KEEP( 35 )) )
        ENDIF
        DAGMG_MUMPS_LBUF = max( DAGMG_MUMPS_LBUF, 100000 )
        DAGMG_MUMPS_LBUF = DAGMG_MUMPS_LBUF                                       &
     &                 + int( 2.0D0 * dble(max(PERLU,0))*               &
     &                   dble(DAGMG_MUMPS_LBUF)/100D0)
        NB_BYTES = NB_BYTES + int(DAGMG_MUMPS_LBUF,8)
        DAGMG_MUMPS_LBUF_INT =                                               &
     &         NSLAVES * NSLAVES * 4                                    &
     &               * KEEP(34)
        NB_BYTES = NB_BYTES + int(DAGMG_MUMPS_LBUF_INT,8)
        IF ( EFF ) THEN
          IF (OOC) THEN
            NB_INT = NB_INT + int(KEEP(225),8)
          ELSE
            NB_INT = NB_INT + int(KEEP(15),8)
          ENDIF
        ELSE
          IF (OOC) THEN
            NB_INT = NB_INT +  int(                                     &
     &           KEEP(225) + 2 * max(PERLU,10) *                        &
     &           ( KEEP(225) / 100 + 1 )                                &
     &                              ,8)
          ELSE
            NB_INT = NB_INT +  int(                                     &
     &           KEEP(15) + 2 * max(PERLU,10) *                         &
     &           ( KEEP(15) / 100 + 1 )                                 &
     &                              ,8)
          ENDIF
        ENDIF
        NB_INT = NB_INT + NSTEPS8
        NB_INT = NB_INT + NSTEPS8 * I8OVERI
        NB_INT = NB_INT + N8 + 5_8 * NSTEPS8 + 3_8
        NB_INT = NB_INT + 2_8 * NSTEPS8 * I8OVERI
      END IF
      MEMORY_BYTES = NB_BYTES + NB_INT * int(KEEP(34),8) +              &
     &               NB_REAL * int(KEEP(35),8)
      MEMORY_BYTES = max( MEMORY_BYTES, TEMP )
      MEMORY_MBYTES = int( MEMORY_BYTES / 1000000_8 )  + 1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_214
      SUBROUTINE DAGMG_MUMPS_757(M_ARRAY, M_SIZE)
      IMPLICIT NONE
      INTEGER M_SIZE
      DOUBLE PRECISION M_ARRAY(M_SIZE)
      DOUBLE PRECISION ZERO
      PARAMETER (ZERO=0.0D0)
      M_ARRAY=ZERO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_757
      SUBROUTINE DAGMG_MUMPS_618(                                            &
     &     A,ASIZE,NCOL,NROW,                                           &
     &     M_ARRAY,NMAX,COMPRESSCB,LROW1)
      IMPLICIT NONE
      INTEGER(8) :: ASIZE
      INTEGER NROW,NCOL,NMAX,LROW1
      LOGICAL COMPRESSCB
      DOUBLE PRECISION A(ASIZE)
      DOUBLE PRECISION M_ARRAY(NMAX)
      INTEGER I
      INTEGER(8):: APOS, J, LROW
      DOUBLE PRECISION ZERO,TMP
      PARAMETER (ZERO=0.0D0)
      M_ARRAY(1:NMAX) = ZERO
      APOS = 0_8
      IF (COMPRESSCB) THEN
        LROW=int(LROW1,8)
      ELSE
        LROW=int(NCOL,8)
      ENDIF
      DO I=1,NROW
         DO J=1_8,int(NMAX,8)
            TMP = abs(A(APOS+J))
            IF(TMP.GT.M_ARRAY(J)) M_ARRAY(J) = TMP
         ENDDO
         APOS = APOS + LROW
         IF (COMPRESSCB) LROW=LROW+1_8
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_618
      SUBROUTINE DAGMG_MUMPS_710(id, NB_INT,NB_dble )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC) :: id
      INTEGER*8 NB_INT, NB_dble
      INTEGER*8 NB_REAL
      NB_INT        = 0_8
      NB_dble      = 0_8
      NB_REAL       = 0_8
      IF (associated(id%IS))          NB_INT=NB_INT+size(id%IS)
      IF (associated(id%IS1))         NB_INT=NB_INT+size(id%IS1)
      NB_INT=NB_INT+size(id%KEEP)
      NB_INT=NB_INT+size(id%ICNTL)
      NB_INT=NB_INT+size(id%INFO)
      NB_INT=NB_INT+size(id%INFOG)
      IF (associated(id%MAPPING))     NB_INT=NB_INT+size(id%MAPPING)
      IF (associated(id%POIDS))       NB_INT=NB_INT+size(id%POIDS)
      IF (associated(id%BUFR))        NB_INT=NB_INT+size(id%BUFR)
      IF (associated(id%STEP))        NB_INT=NB_INT+size(id%STEP)
      IF (associated(id%NE_STEPS  ))  NB_INT=NB_INT+size(id%NE_STEPS  )
      IF (associated(id%ND_STEPS))    NB_INT=NB_INT+size(id%ND_STEPS)
      IF (associated(id%Step2node))   NB_INT=NB_INT+size(id%Step2node)
      IF (associated(id%FRERE_STEPS)) NB_INT=NB_INT+size(id%FRERE_STEPS)
      IF (associated(id%DAD_STEPS))   NB_INT=NB_INT+size(id%DAD_STEPS)
      IF (associated(id%FILS))        NB_INT=NB_INT+size(id%FILS)
      IF (associated(id%PTRAR))       NB_INT=NB_INT+size(id%PTRAR)
      IF (associated(id%FRTPTR))      NB_INT=NB_INT+size(id%FRTPTR)
      NB_INT=NB_INT+size(id%KEEP8) * id%KEEP(10)
      IF (associated(id%PTRFAC)) NB_INT=NB_INT+size(id%PTRFAC) *        &
     &                                         id%KEEP(10)
      IF (associated(id%FRTELT))      NB_INT=NB_INT+size(id%FRTELT)
      IF (associated(id%NA))          NB_INT=NB_INT+size(id%NA)
      IF       (associated(id%PROCNODE_STEPS))                          &
     &  NB_INT=NB_INT+size(id%PROCNODE_STEPS)
      IF (associated(id%PTLUST_S)) NB_INT=NB_INT+size(id%PTLUST_S)
      IF (associated(id%PROCNODE)) NB_INT=NB_INT+size(id%PROCNODE)
      IF (associated(id%INTARR)) NB_INT=NB_INT+size(id%INTARR)
      IF (associated(id%ELTPROC))  NB_INT=NB_INT+size(id%ELTPROC)
      IF (associated(id%CANDIDATES))                                    &
     &  NB_INT=NB_INT+size(id%CANDIDATES)
      IF       (associated(id%ISTEP_TO_INIV2))                          &
     &  NB_INT=NB_INT+size(id%ISTEP_TO_INIV2)
      IF       (associated(id%FUTURE_NIV2))                             &
     &  NB_INT=NB_INT+size(id%FUTURE_NIV2)
      IF (associated(id%TAB_POS_IN_PERE))                               &
     &  NB_INT=NB_INT+size(id%TAB_POS_IN_PERE)
      IF (associated(id%I_AM_CAND))                                     &
     &  NB_INT=NB_INT+size(id%I_AM_CAND)
      IF (associated(id%MEM_DIST))                                      &
     &  NB_INT=NB_INT+size(id%MEM_DIST)
      IF (associated(id%POSINRHSCOMP))                                  &
     &  NB_INT=NB_INT+size(id%POSINRHSCOMP)
      IF       (associated(id%MEM_SUBTREE))                             &
     &  NB_INT=NB_INT+size(id%MEM_SUBTREE)
      IF       (associated(id%MY_ROOT_SBTR))                            &
     &  NB_INT=NB_INT+size(id%MY_ROOT_SBTR)
      IF       (associated(id%MY_FIRST_LEAF))                           &
     &  NB_INT=NB_INT+size(id%MY_FIRST_LEAF)
      IF (associated(id%MY_NB_LEAF)) NB_INT=NB_INT+size(id%MY_NB_LEAF)
      IF (associated(id%DEPTH_FIRST)) NB_INT=NB_INT+size(id%DEPTH_FIRST)
      IF (associated(id%COST_TRAV)) NB_INT=NB_INT+size(id%COST_TRAV)
      IF (associated(id%CB_SON_SIZE)) NB_INT=NB_INT+size(id%CB_SON_SIZE)
      IF       (associated(id%OOC_INODE_SEQUENCE))                      &
     &  NB_INT=NB_INT+size(id%OOC_INODE_SEQUENCE)
      IF       (associated(id%OOC_SIZE_OF_BLOCK))                       &
     &  NB_INT=NB_INT+size(id%OOC_SIZE_OF_BLOCK)
      IF       (associated(id%OOC_VADDR))                               &
     &  NB_INT=NB_INT+size(id%OOC_VADDR)
      IF       (associated(id%OOC_TOTAL_NB_NODES))                      &
     &  NB_INT=NB_INT+size(id%OOC_TOTAL_NB_NODES)
      IF       (associated(id%OOC_NB_FILES))                            &
     &  NB_INT=NB_INT+size(id%OOC_NB_FILES)
      IF       (associated(id%OOC_FILE_NAME_LENGTH))                    &
     &  NB_INT=NB_INT+size(id%OOC_FILE_NAME_LENGTH)
      IF (associated(id%PIVNUL_LIST)) NB_INT=NB_INT+size(id%PIVNUL_LIST)
      IF (associated(id%SUP_PROC))    NB_INT=NB_INT+size(id%SUP_PROC)
      IF (associated(id%DBLARR))  NB_dble=NB_dble+size(id%DBLARR)
      IF (associated(id%RHSCOMP)) NB_dble=NB_dble+size(id%RHSCOMP)
      IF (associated(id%S))       NB_dble=NB_dble+id%KEEP8(23)
      IF (associated(id%COLSCA))  NB_REAL=NB_REAL+size(id%COLSCA)
      IF (associated(id%ROWSCA))  NB_REAL=NB_REAL+size(id%ROWSCA)
      NB_REAL=NB_REAL+size(id%CNTL)
      NB_REAL=NB_REAL+size(id%RINFO)
      NB_REAL=NB_REAL+size(id%RINFOG)
      NB_REAL=NB_REAL+size(id%DKEEP)
      NB_dble = NB_dble + NB_REAL
      RETURN
      END SUBROUTINE DAGMG_MUMPS_710
      SUBROUTINE DAGMG_MUMPS_756(N8,SRC,DEST)
      IMPLICIT NONE
      INTEGER(8) :: N8
      DOUBLE PRECISION, intent(in)  :: SRC(N8)
      DOUBLE PRECISION, intent(out) :: DEST(N8)
      INTEGER(8) :: SHIFT8, HUG8
      INTEGER    :: N, I, I4SIZE
      HUG8=int(huge(I4SIZE),8)
      DO I = 1, int(( N8 + HUG8 - 1_8 ) / HUG8)
        SHIFT8 = 1_8 + (I-1) * HUG8
        I4SIZE = int(min(HUG8, N8-SHIFT8+1_8))
        CALL DCOPY(I4SIZE, SRC(SHIFT8), 1, DEST(SHIFT8), 1)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_756
      SUBROUTINE DAGMG_MUMPS_22( INPLACE, MIN_SPACE_IN_PLACE,                &
     &   SSARBR, PROCESS_BANDE,                                         &
     &   MYID,N, KEEP,KEEP8,                                            &
     &   IW, LIW, A, LA,                                                &
     &   LRLU, IPTRLU,IWPOS,IWPOSCB,                                    &
     &   PTRIST,PTRAST,STEP,PIMASTER,PAMASTER, ITLOC,                   &
     &   LREQ, LREQCB, NODE_ARG, STATE_ARG, SET_HEADER,                 &
     &   COMP, LRLUS, IFLAG, IERROR )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER N,LIW, KEEP(500)
      INTEGER(8) LA, LRLU, IPTRLU, LRLUS, LREQCB
      INTEGER(8) PAMASTER(KEEP(28)), PTRAST(KEEP(28))
      INTEGER IWPOS,IWPOSCB
      INTEGER(8) :: MIN_SPACE_IN_PLACE
      INTEGER NODE_ARG, STATE_ARG
      INTEGER*8 KEEP8(150)
      INTEGER IW(LIW),PTRIST(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28)), ITLOC(N)
      INTEGER MYID, IXXP
      DOUBLE PRECISION A(LA)
      LOGICAL INPLACE, PROCESS_BANDE, SSARBR, SET_HEADER
      INTEGER COMP, LREQ, IFLAG, IERROR
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER INODE_LOC,NPIV,NASS,NROW,NCB
      INTEGER ISIZEHOLE
      INTEGER(8) :: MEM_GAIN, RSIZEHOLE, LREQCB_EFF, LREQCB_WISHED
      LOGICAL DONE
      IF ( INPLACE ) THEN
        LREQCB_EFF = MIN_SPACE_IN_PLACE
        IF ( MIN_SPACE_IN_PLACE > 0_8 ) THEN
          LREQCB_WISHED = LREQCB
        ELSE
          LREQCB_WISHED = 0_8
        ENDIF
      ELSE
        LREQCB_EFF = LREQCB
        LREQCB_WISHED = LREQCB
      ENDIF
      IF (IWPOSCB.EQ.LIW) THEN
        IF (LREQ.NE.KEEP(IXSZ).OR.LREQCB.NE.0_8                         &
     &      .OR. .NOT. SET_HEADER) THEN
          WRITE(*,*) "Internal error in DAGMG_MUMPS_22",                     &
     &      SET_HEADER, LREQ, LREQCB
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF (IWPOSCB-IWPOS+1 .LT. KEEP(IXSZ)) THEN
          WRITE(*,*) "Problem with integer stack size",IWPOSCB,         &
     &               IWPOS, KEEP(IXSZ)
          IFLAG  = -8
          IERROR = LREQ
          RETURN
        ENDIF
        IWPOSCB=IWPOSCB-KEEP(IXSZ)
        IW(IWPOSCB+1+XXI)=KEEP(IXSZ)
        CALL AGMG_MUMPS_730(0_8,IW(IWPOSCB+1+XXR))
        IW(IWPOSCB+1+XXN)=-919191
        IW(IWPOSCB+1+XXS)=S_NOTFREE
        IW(IWPOSCB+1+XXP)=TOP_OF_STACK
        RETURN
      ENDIF
      IF (KEEP(214).EQ.1.AND.                                           &
     &    KEEP(216).EQ.1.AND.                                           &
     &    IWPOSCB.NE.LIW) THEN
       IF (IW(IWPOSCB+1 + XXS).EQ.S_NOLCBNOCONTIG.OR.                   &
     &     IW(IWPOSCB+1 + XXS).EQ.S_NOLCBNOCONTIG38) THEN
        NCB  = IW( IWPOSCB+1 + KEEP(IXSZ) )
        NROW = IW( IWPOSCB+1 + KEEP(IXSZ) + 2)
        NPIV = IW( IWPOSCB+1 + KEEP(IXSZ) + 3)
        INODE_LOC= IW( IWPOSCB+1 + XXN)
        CALL DAGMG_MUMPS_632(IWPOSCB+1,IW,LIW,                               &
     &                          ISIZEHOLE,RSIZEHOLE)
        IF (IW(IWPOSCB+1 + XXS).EQ.S_NOLCBNOCONTIG) THEN
          CALL DAGMG_MUMPS_627(A,LA,IPTRLU+1_8,                              &
     &                           NROW,NCB,NPIV+NCB,0,                   &
     &                           IW(IWPOSCB+1 + XXS),RSIZEHOLE)
          IW(IWPOSCB+1 + XXS) =S_NOLCLEANED
          MEM_GAIN            = int(NROW,8)*int(NPIV,8)
        ENDIF
        IF (IW(IWPOSCB+1 + XXS).EQ.S_NOLCBNOCONTIG38) THEN
          NASS = IW( IWPOSCB+1 + KEEP(IXSZ) + 4)
          CALL DAGMG_MUMPS_627(A,LA,IPTRLU+1_8,                              &
     &                           NROW,NCB,NPIV+NCB,NASS-NPIV,           &
     &                           IW(IWPOSCB+1 + XXS),RSIZEHOLE)
          IW(IWPOSCB+1 + XXS) =S_NOLCLEANED38
          MEM_GAIN = int(NROW,8)*int(NPIV+NCB-(NASS-NPIV),8)
        ENDIF
        IF (ISIZEHOLE.NE.0) THEN
          CALL DAGMG_MUMPS_630( IW,LIW,IWPOSCB+1,                            &
     &                       IWPOSCB+IW(IWPOSCB+1+XXI),                 &
     &                       ISIZEHOLE )
          IWPOSCB=IWPOSCB+ISIZEHOLE
          IW(IWPOSCB+1+XXP+IW(IWPOSCB+1+XXI))=IWPOSCB+1
          PTRIST(STEP(INODE_LOC))=PTRIST(STEP(INODE_LOC))+              &
     &    ISIZEHOLE
        ENDIF
        CALL AGMG_MUMPS_724(IW(IWPOSCB+1+XXR), MEM_GAIN)
        IPTRLU              = IPTRLU+MEM_GAIN+RSIZEHOLE
        LRLU                = LRLU+MEM_GAIN+RSIZEHOLE
        PTRAST(STEP(INODE_LOC))=                                        &
     &  PTRAST(STEP(INODE_LOC))+MEM_GAIN+RSIZEHOLE
       ENDIF
      ENDIF
      DONE =.FALSE.
      IF ((IPTRLU.LT.LREQCB_WISHED).OR.(LRLU.LT.LREQCB_WISHED)) THEN
        IF (LRLUS.LT.LREQCB_EFF) THEN
          GOTO 620
        ELSE
          CALL DAGMG_MUMPS_94(N,KEEP(28),IW,LIW,A,LA,                        &
     &                    LRLU,IPTRLU,IWPOS,IWPOSCB,                    &
     &                    PTRIST,PTRAST,                                &
     &                    STEP, PIMASTER,PAMASTER,ITLOC,KEEP(216),LRLUS,&
     &                    KEEP(IXSZ))
          IF ( LRLU .NE. LRLUS ) THEN
            WRITE(*,*) 'PB compress... alloc_cb',                       &
     &      'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 620
          END IF
          DONE = .TRUE.
          COMP = COMP + 1
        ENDIF
      ENDIF
      IF (IWPOSCB-IWPOS+1 .LT. LREQ) THEN
       IF (DONE) GOTO 600
                 CALL DAGMG_MUMPS_94(N,KEEP(28),IW,LIW,A,LA,                 &
     &                    LRLU,IPTRLU,IWPOS,IWPOSCB,                    &
     &                    PTRIST,PTRAST,                                &
     &                    STEP, PIMASTER,PAMASTER,ITLOC,KEEP(216),LRLUS,&
     &                    KEEP(IXSZ))
                 IF ( LRLU .NE. LRLUS ) THEN
                   WRITE(*,*) 'PB compress... alloc_cb',                &
     &             'LRLU,LRLUS=',LRLU,LRLUS
                   GOTO 620
                 END IF
          COMP = COMP + 1
          IF (IWPOSCB-IWPOS+1 .LT. LREQ) GOTO 600
      ENDIF
      IXXP=IWPOSCB+XXP+1
      IF (IXXP.GT.LIW) THEN
        WRITE(*,*) "Internal error 3 in DAGMG_MUMPS_22",IXXP
      ENDIF
      IF (IW(IXXP).GT.0) THEN
        WRITE(*,*) "Internal error 2 in DAGMG_MUMPS_22",IW(IXXP),IXXP
      ENDIF
      IWPOSCB = IWPOSCB - LREQ
      IF (SET_HEADER) THEN
        IW(IXXP)= IWPOSCB + 1
        IW(IWPOSCB+1+XXI)=LREQ
        CALL AGMG_MUMPS_730(LREQCB, IW(IWPOSCB+1+XXR))
        IW(IWPOSCB+1+XXS)=STATE_ARG
        IW(IWPOSCB+1+XXN)=NODE_ARG
        IW(IWPOSCB+1+XXP)=TOP_OF_STACK
      ENDIF
      IPTRLU = IPTRLU - LREQCB
      LRLU   = LRLU - LREQCB
      LRLUS  = LRLUS - LREQCB_EFF
      KEEP8(67) = min(LRLUS, KEEP8(67))
      CALL DAGMG_MUMPS_471(SSARBR,PROCESS_BANDE,                             &
     &              LA-LRLUS,0_8,LREQCB_EFF,KEEP,KEEP8,LRLU)
      RETURN
  600 IFLAG  = -8
      IERROR = LREQ
      RETURN
  620 IFLAG  = -9
      CALL AGMG_MUMPS_731(LREQCB_EFF - LRLUS, IERROR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_22
      SUBROUTINE DAGMG_MUMPS_244(N, NSTEPS,                                  &
     & A, LA, IW, LIW, SYM_PERM, NA, LNA,                               &
     & NE_STEPS, NFSIZ, FILS,                                           &
     & STEP, FRERE, DAD, CAND,                                          &
     & ISTEP_TO_INIV2, TAB_POS_IN_PERE,                                 &
     & PTRAR, LDPTRAR,                                                  &
     & PTRIST, PTLUST_S, PTRFAC, IW1, IW2, ITLOC, POOL, LPOOL,          &
     & CNTL1, ICNTL, INFO, RINFO, KEEP,KEEP8,PROCNODE_STEPS,            &
     & SLAVEF,                                                          &
     & COMM_NODES, MYID, MYID_NODES,                                    &
     & BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,                            &
     & root, NELT, FRTPTR, FRTELT, COMM_LOAD,                           &
     & ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,                               &
     & MEM_DISTRIB,                                                     &
     & DKEEP,PIVNUL_LIST,LPN_LIST)
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      !start pavel ferkl
      interface
      SUBROUTINE DAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
     &             FRERE, DAD, CAND,                                    &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
     &             KEEP,KEEP8,                                          &
     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
     &             MYID_NODES,                                          &
     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
     &             MEM_DISTRIB, NE,                                     &
     &     DKEEP,PIVNUL_LIST,LPN_LIST)
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
     &        IERROR, NSTEPS, INFO(40)
      INTEGER(8) :: LA
      DOUBLE PRECISION, TARGET :: A(LA)
      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER LPOOL
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER ITLOC(N)
      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
      INTEGER FILS(N),PTRIST(KEEP(28))
      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
      INTEGER PIMASTER(KEEP(28))
      INTEGER PTLUST_S(KEEP(28)), PERM(N)
      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER IPOOL(LPOOL)
      INTEGER NE(KEEP(28))
      DOUBLE PRECISION RINFO(20)
      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
      INTEGER IWPOS, LEAF, NBROOT
      INTEGER COMM_LOAD, ASS_IRECV
      DOUBLE PRECISION UU, SEUIL, SEUIL_LDLT_NIV2
      INTEGER NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER        INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      LOGICAL IS_ISOLATED_NODE
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      integer nbrtot
      end subroutine DAGMG_MUMPS_251
      end interface
      !end pavel ferkl
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER(8) :: LA
      INTEGER N,NSTEPS,LIW,LPOOL,SLAVEF,COMM_NODES
      INTEGER MYID, MYID_NODES,LNA
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION RINFO(20)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER, DIMENSION(0:SLAVEF - 1) :: MEM_DISTRIB
      INTEGER BUFR( LBUFR )
      INTEGER NELT, LDPTRAR
      INTEGER FRTPTR(*), FRTELT(*)
      DOUBLE PRECISION CNTL1
      INTEGER   ICNTL(40)
      INTEGER   INFO(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER   IW(LIW), SYM_PERM(N), NA(LNA),                          &
     &          NE_STEPS(KEEP(28)), FILS(N),                            &
     &          FRERE(KEEP(28)), NFSIZ(KEEP(28)),                       &
     &          DAD(KEEP(28))
      INTEGER   CAND(SLAVEF+1, max(1,KEEP(56)))
      INTEGER   STEP(N)
      INTEGER   PTRAR(LDPTRAR,2)
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER   PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER   IW1(3*KEEP(28)), ITLOC(N), POOL(LPOOL)
      INTEGER(8) :: IW2(2*KEEP(28))
      INTEGER   PROCNODE_STEPS(KEEP(28))
      INTEGER   COMM_LOAD, ASS_IRECV
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER   INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      DOUBLE PRECISION SEUIL, SEUIL_LDLT_NIV2
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
       INTEGER AGMG_MUMPS_275
       EXTERNAL AGMG_MUMPS_275
      DOUBLE PRECISION UULOC
      INTEGER LP, MPRINT
      INTEGER NSTK,PTRAST, NBPROCFILS
      INTEGER PIMASTER, PAMASTER
      LOGICAL PROK
      DOUBLE PRECISION ZERO, ONE
      DATA ZERO /0.0D0/
      DATA ONE /1.0D0/
      INTRINSIC int,real,log
      INTEGER IERR
      INTEGER NTOTPV, NTOTPVTOT, NMAXNPIV
      INTEGER(8) :: POSFAC, LRLU, IPTRLU, LRLUS
      INTEGER IWPOS, LEAF, NBROOT, NROOT
      KEEP(41)=0
      KEEP(42)=0
      NSTEPS   = 0
      LP     = ICNTL(1)
      MPRINT = ICNTL(2)
      PROK   = (MPRINT.GT.0)
      UULOC = CNTL1
      IF (UULOC.GT.ONE)   UULOC=ONE
      IF (UULOC.LT.ZERO)  UULOC=ZERO
      IF (KEEP(50).NE.0.AND.UULOC.GT.0.5D0) THEN
        UULOC = 0.5D0
      ENDIF
      PIMASTER   = 1
      NSTK       = PIMASTER + KEEP(28)
      NBPROCFILS = NSTK + KEEP(28)
      PTRAST = 1
      PAMASTER = 1 + KEEP(28)
      IF (KEEP(4).LE.0) KEEP(4)=32
      IF (KEEP(5).LE.0) KEEP(5)=16
      IF (KEEP(5).GT.KEEP(4)) KEEP(5) = KEEP(4)
      IF (KEEP(6).LE.0) KEEP(6)=24
      IF (KEEP(3).LE.KEEP(4)) KEEP(3)=KEEP(4)*2
      IF (KEEP(6).GT.KEEP(3)) KEEP(6) = KEEP(3)
      POSFAC = 1_8
      IWPOS  = 1
      LRLU = LA
      LRLUS = LRLU
      KEEP8(67) = LRLUS
      IPTRLU = LRLU
      NTOTPV   = 0
      NMAXNPIV = 0
      IW1(NSTK:NSTK+KEEP(28)-1) = NE_STEPS(1:KEEP(28))
      CALL AGMG_MUMPS_362(N, LEAF, NBROOT, NROOT,                            &
     &                     MYID_NODES,                                  &
     &                     SLAVEF, NA, LNA,                             &
     &                     KEEP,KEEP8, STEP,                            &
     &                     PROCNODE_STEPS,                              &
     &                     POOL, LPOOL)
      CALL DAGMG_MUMPS_506(POOL, LPOOL, LEAF)
      CALL DAGMG_MUMPS_555(POOL, LPOOL,KEEP,KEEP8)
      IF ( KEEP( 38 ) .NE. 0 ) THEN
        NBROOT = NBROOT + root%NPROW * root%NPCOL - 1
      END IF
      IF ( root%yes )  THEN
         IF ( AGMG_MUMPS_275( STEP(KEEP(38)),PROCNODE_STEPS, SLAVEF)         &
     &         .NE. MYID_NODES ) THEN
             NROOT = NROOT + 1
         END IF
      END IF
      CALL DAGMG_MUMPS_251(N,IW,LIW,A,LA,IW1(NSTK),IW1(NBPROCFILS),          &
     &         INFO(1),NFSIZ,FILS,STEP,FRERE, DAD, CAND,                &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE,                         &
     &         INFO(11), NTOTPV, NMAXNPIV, PTRIST,IW2(PTRAST),          &
     &         IW1(PIMASTER), IW2(PAMASTER), PTRAR(1,2),                &
     &         PTRAR(1,1),                                              &
     &         ITLOC,                                                   &
     &         INFO(2), POOL, LPOOL,                                    &
     &         RINFO,                                                   &
     &         POSFAC,IWPOS,LRLU,IPTRLU,                                &
     &         LRLUS, LEAF, NROOT, NBROOT,                              &
     &         UULOC,ICNTL,PTLUST_S,PTRFAC,NSTEPS,INFO,                 &
     &         KEEP,KEEP8,                                              &
     &         PROCNODE_STEPS,SLAVEF,MYID,COMM_NODES,                   &
     &         MYID_NODES,                                              &
     &         BUFR,LBUFR, LBUFR_BYTES,                                 &
     &         INTARR, DBLARR, root, SYM_PERM,                          &
     &         NELT, FRTPTR, FRTELT, LDPTRAR,                           &
     &         COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,            &
     &         MEM_DISTRIB,NE_STEPS,                                    &
     &     DKEEP(1),PIVNUL_LIST(1),LPN_LIST)
      POSFAC = POSFAC -1_8
      IWPOS = IWPOS -1
      IF (KEEP(201).EQ.0) THEN
        KEEP8(31) = POSFAC
      ENDIF
      KEEP(32) = IWPOS
      CALL AGMG_MUMPS_735(KEEP8(31), INFO(9))
      INFO(10) = KEEP(32)
      KEEP8(67) = LA - KEEP8(67)
      KEEP(89)  = NTOTPV
      KEEP(246) = NMAXNPIV
      INFO(23) = KEEP(89)
      CALL AGMG_COPY(NTOTPV, NTOTPVTOT, 1, AGMG_MPF_INTEGER, IERR)
      IF ( ( (INFO(1).EQ.-10 .OR. INFO(1).EQ.-40)                       &
     &       .AND. (NTOTPVTOT.EQ.N) )                                   &
     &              .OR. ( NTOTPVTOT.GT.N ) ) THEN
       write(*,*) ' Error 1 in mc51d NTOTPVTOT=', NTOTPVTOT
       CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF ( (KEEP(19).NE.0 ) .AND. (NTOTPVTOT.NE.N) .AND.                &
     & (INFO(1).GE.0) )  THEN
       write(*,*) ' Error 2 in mc51d NTOTPVTOT=', NTOTPVTOT
       CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF ( (INFO(1) .GE. 0 )                                            &
     &      .AND. (NTOTPVTOT.NE.N) ) THEN
         INFO(1) = -10
         INFO(2) = NTOTPVTOT
      ENDIF
      CALL AGMG_MUMPS_735( KEEP8(10), INFO(25) )
      IF (PROK) THEN
        WRITE (MPRINT,99980) INFO(1), INFO(2),                          &
     &       KEEP(28), KEEP8(31), INFO(10), INFO(11), INFO(12),         &
     &       INFO(13), INFO(14), INFO(25), RINFO(2), RINFO(3)
      ENDIF
      RETURN
99980 FORMAT (/' LEAVING FACTORIZATION PHASE WITH ...'/                 &
     &      ' INFO (1)                                      =',I15/     &
     &      '  --- (2)                                      =',I15/     &
     &      '           NUMBER OF NODES IN THE TREE         =',I15/     &
     &      ' INFO (9)  REAL SPACE FOR FACTORS              =',I15/     &
     &      '  --- (10) INTEGER SPACE FOR FACTORS           =',I15/     &
     &      '  --- (11) MAXIMUM SIZE OF FRONTAL MATRICES    =',I15/     &
     &      '  --- (12) NUMBER OF OFF DIAGONAL PIVOTS       =',I15/     &
     &      '  --- (13) NUMBER OF DELAYED PIVOTS            =',I15/     &
     &      '  --- (14) NUMBER OF MEMORY COMPRESSES         =',I15/     &
     &      '  --- (25) NUMBER OF ENTRIES IN FACTORS        =',I15/     &
     &  ' RINFO(2)  OPERATIONS DURING NODE ASSEMBLY     =',1PD10.3/     &
     &  ' -----(3)  OPERATIONS DURING NODE ELIMINATION  =',1PD10.3)
99990 FORMAT(/ ' NUMBER OF MSGS RECVD FOR DYNAMIC LOAD  =',I15)
      END SUBROUTINE DAGMG_MUMPS_244
      SUBROUTINE DAGMG_MUMPS_269( MYID,KEEP,KEEP8,                           &
     &           BUFR, LBUFR, LBUFR_BYTES,                              &
     &           IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS,                   &
     &           N, IW, LIW, A, LA,                                     &
     &           PTRIST, PTRAST, STEP, PIMASTER, PAMASTER,              &
     &           NSTK_S, COMP,                                          &
     &           FPERE, FLAG, IFLAG, IERROR, COMM, ITLOC )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR
      INTEGER MYID
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER KEEP(500), BUFR( LBUFR )
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRAST  (KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST( KEEP(28) )
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP, FPERE
      LOGICAL FLAG
      INTEGER NSTK_S( KEEP(28) ), ITLOC( N )
      INTEGER IFLAG, IERROR, COMM
      INTEGER POSITION, FINODE, FLCONT, LREQ
      INTEGER(8) :: LREQCB
      INTEGER(8) :: IPOS_NODE, ISHIFT_PACKET
      INTEGER SIZE_PACKET
      INTEGER NBROWS_ALREADY_SENT, NBROWS_PACKET
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL COMPRESSCB
      FLAG = .FALSE.
      POSITION = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      COMPRESSCB = (FLCONT.LT.0)
      IF (COMPRESSCB) THEN
        FLCONT   = -FLCONT
        LREQCB  = (int(FLCONT,8) * int(FLCONT+1,8)) / 2_8
      ELSE
        LREQCB  = int(FLCONT,8) * int(FLCONT,8)
      ENDIF
      IF (NBROWS_ALREADY_SENT == 0) THEN
        LREQ    = 2 * FLCONT + 6 + KEEP(IXSZ)
        IF (IPTRLU.LT.0_8) WRITE(*,*) 'before alloc_cb:IPTRLU = ',IPTRLU
        CALL DAGMG_MUMPS_22( .FALSE., 0_8, .FALSE.,.FALSE.,                  &
     &  MYID,N, KEEP,KEEP8, IW, LIW, A, LA,                             &
     &  LRLU, IPTRLU,IWPOS,IWPOSCB,                                     &
     &  PTRIST,PTRAST,STEP, PIMASTER,PAMASTER, ITLOC,                   &
     &  LREQ, LREQCB, FINODE, S_NOTFREE, .TRUE.,                        &
     &  COMP, LRLUS, IFLAG, IERROR                                      &
     &     )
        IF (IPTRLU.LT.0_8) WRITE(*,*) 'after alloc_cb:IPTRLU = ',IPTRLU
        IF ( IFLAG .LT. 0 ) RETURN
        PIMASTER(STEP( FINODE )) = IWPOSCB + 1
        PAMASTER(STEP( FINODE )) = IPTRLU  + 1_8
        IF (COMPRESSCB)  IW(IWPOSCB + 1 + XXS ) = S_CB1COMP
        CALL AGMG_NOCALL('MPI_UNPACK')
      ENDIF
      IF (COMPRESSCB) THEN
        ISHIFT_PACKET = int(NBROWS_ALREADY_SENT,8) *                    &
     &                  int(NBROWS_ALREADY_SENT+1,8) / 2_8
        SIZE_PACKET = (NBROWS_PACKET * (NBROWS_PACKET+1))/2 +           &
     &                 NBROWS_ALREADY_SENT * NBROWS_PACKET
      ELSE
        ISHIFT_PACKET = int(NBROWS_ALREADY_SENT,8) * int(FLCONT,8)
        SIZE_PACKET = NBROWS_PACKET * FLCONT
      ENDIF
      IF (NBROWS_PACKET.NE.0) THEN
        IF ( LREQCB .ne. 0_8 ) THEN
        IPOS_NODE = PAMASTER(STEP(FINODE))-1_8
        CALL AGMG_NOCALL('MPI_UNPACK')
        END IF
      ENDIF
      IF (NBROWS_ALREADY_SENT+NBROWS_PACKET == FLCONT) THEN
        NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
        IF ( NSTK_S(STEP(FPERE)).EQ.0 ) THEN
          FLAG =  .TRUE.
        END IF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_269
      SUBROUTINE DAGMG_MUMPS_270( TOT_ROOT_SIZE,                             &
     &    TOT_CONT_TO_RECV, root,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM, COMM_LOAD,                               &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND )
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER TOT_ROOT_SIZE, TOT_CONT_TO_RECV
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: IPTRLU, LRLU, LRLUS, LA, POSFAC
      INTEGER(8) :: PTRFAC(KEEP(28)), PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S( KEEP(28) ), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) ), ND( KEEP(28) )
      INTEGER IFLAG, IERROR, COMM, COMM_LOAD
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER MYID, SLAVEF, NBFIN
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER ITLOC(N), FILS(N), PTRARW(N), PTRAIW(N)
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER NEW_LOCAL_M, NEW_LOCAL_N
      INTEGER OLD_LOCAL_M, OLD_LOCAL_N
      INTEGER LREQI, IROOT
      INTEGER(8) :: LREQA
      INTEGER POSHEAD, IPOS_SON,IERR
      LOGICAL MASTER_OF_ROOT
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER NUMROC_FOOL, AGMG_MUMPS_275
      EXTERNAL NUMROC_FOOL, AGMG_MUMPS_275
      IROOT = KEEP( 38 )
      root%TOT_ROOT_SIZE = TOT_ROOT_SIZE
      MASTER_OF_ROOT = ( MYID .EQ. AGMG_MUMPS_275( STEP(IROOT),              &
     &                   PROCNODE_STEPS, SLAVEF ) )
      NEW_LOCAL_M  = NUMROC_FOOL( TOT_ROOT_SIZE, root%MBLOCK,                &
     &               root%MYROW, 0, root%NPROW )
      NEW_LOCAL_M  = max( 1, NEW_LOCAL_M )
      NEW_LOCAL_N  = NUMROC_FOOL( TOT_ROOT_SIZE, root%NBLOCK,                &
     &               root%MYCOL, 0, root%NPCOL )
      IF (KEEP(60) .NE. 0) THEN
        IF (root%yes) THEN
        IF ( NEW_LOCAL_M .NE. root%SCHUR_MLOC .OR.                      &
     &       NEW_LOCAL_N .NE. root%SCHUR_NLOC ) THEN
          WRITE(*,*) "Internal error 1 in DAGMG_MUMPS_270"
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        ENDIF
        PTLUST_S(STEP(IROOT)) = -4444
        PTRFAC(STEP(IROOT)) = -4445_8
        PTRIST(STEP(IROOT)) = 0
        IF ( MASTER_OF_ROOT ) THEN
          LREQI=6+2*TOT_ROOT_SIZE+KEEP(IXSZ)
          LREQA=0_8
          IF ( IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
           CALL DAGMG_MUMPS_94( N, KEEP(28), IW, LIW, A, LA,                 &
     &           LRLU, IPTRLU,                                          &
     &           IWPOS, IWPOSCB, PTRIST, PTRAST,                        &
     &           STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,       &
     &           KEEP(IXSZ))
           COMP = COMP + 1
           IF ( LRLU .NE. LRLUS ) THEN
                  WRITE(*,*) 'PB1 compress root2slave:LRLU,LRLUS=',     &
     &            LRLU, LRLUS
                  IFLAG = -9
                  CALL AGMG_MUMPS_731(LREQA-LRLUS, IERROR)
                  GOTO 700
           END IF
          ENDIF
          IF ( IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
            IFLAG = -8
            IERROR = IWPOS + LREQI - 1 - IWPOSCB
            GOTO 700
          ENDIF
          PTLUST_S(STEP(IROOT))= IWPOS
          IWPOS = IWPOS + LREQI
          POSHEAD = PTLUST_S( STEP(IROOT))
          IW( POSHEAD + XXI )=LREQI
          CALL AGMG_MUMPS_730( LREQA, IW(POSHEAD + XXR))
          IW( POSHEAD + XXS )=-9999
          IW( POSHEAD +KEEP(IXSZ)) = 0
          IW( POSHEAD + 1 +KEEP(IXSZ)) = -1
          IW( POSHEAD + 2 +KEEP(IXSZ)) = -1
          IW( POSHEAD + 4 +KEEP(IXSZ)) = STEP(IROOT)
          IW( POSHEAD + 5 +KEEP(IXSZ)) = 0
          IW( POSHEAD + 3 +KEEP(IXSZ)) = TOT_ROOT_SIZE
        ENDIF
        GOTO 100
      ENDIF
      IF ( MASTER_OF_ROOT ) THEN
        LREQI = 6 + 2 * TOT_ROOT_SIZE+KEEP(IXSZ)
      ELSE
        LREQI = 6+KEEP(IXSZ)
      END IF
      LREQA = int(NEW_LOCAL_M, 8) * int(NEW_LOCAL_N, 8)
      IF ( LRLU  .LT. LREQA .OR.                                        &
     &     IWPOS + LREQI - 1 .GT. IWPOSCB )THEN
           IF ( LRLUS .LT. LREQA ) THEN
             IFLAG  = -9
             CALL AGMG_MUMPS_731(LREQA - LRLUS, IERROR)
             GOTO 700
           END IF
           CALL DAGMG_MUMPS_94( N, KEEP(28), IW, LIW, A, LA,                 &
     &           LRLU, IPTRLU,                                          &
     &           IWPOS, IWPOSCB, PTRIST, PTRAST,                        &
     &           STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,       &
     &           KEEP(IXSZ))
           COMP = COMP + 1
           IF ( LRLU .NE. LRLUS ) THEN
                  WRITE(*,*) 'PB2 compress root2slave:LRLU,LRLUS=',     &
     &            LRLU, LRLUS
                  IFLAG = -9
                  CALL AGMG_MUMPS_731(LREQA - LRLUS, IERROR)
                  GOTO 700
           END IF
           IF ( IWPOS + LREQI - 1 .GT. IWPOSCB ) THEN
              IFLAG  = -8
              IERROR = IWPOS + LREQI - 1 - IWPOSCB
              GOTO 700
           END IF
      END IF
      PTLUST_S(STEP( IROOT )) = IWPOS
      IWPOS           = IWPOS + LREQI
      PTRAST (STEP(IROOT)) = POSFAC
      PTRFAC (STEP(IROOT)) = POSFAC
      POSFAC           = POSFAC + LREQA
      LRLU   = LRLU  - LREQA
      LRLUS  = LRLUS - LREQA
      KEEP8(67) = min(KEEP8(67), LRLUS)
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &          LA-LRLUS,0_8,LREQA,KEEP,KEEP8,LRLU)
      POSHEAD = PTLUST_S( STEP(IROOT))
      IW( POSHEAD + XXI )     = LREQI
      CALL AGMG_MUMPS_730( LREQA, IW(POSHEAD + XXR))
      IW( POSHEAD + XXS ) = S_NOTFREE
      IW( POSHEAD + KEEP(IXSZ) ) = 0
      IW( POSHEAD + 1 + KEEP(IXSZ) ) = NEW_LOCAL_N
      IW( POSHEAD + 2 + KEEP(IXSZ) ) = NEW_LOCAL_M
      IW( POSHEAD + 4 + KEEP(IXSZ) ) = STEP(IROOT)
      IW( POSHEAD + 5 + KEEP(IXSZ) ) = 0
      IF ( MASTER_OF_ROOT ) THEN
        IW( POSHEAD + 3 + KEEP(IXSZ) ) = TOT_ROOT_SIZE
      ELSE
        IW( POSHEAD + 3 + KEEP(IXSZ) ) = 0
      ENDIF
      IF ( KEEP( 50 ) .eq. 0 .OR. KEEP(50) .eq. 2 ) THEN
      OPELIW = OPELIW + ( dble(2*TOT_ROOT_SIZE) *                       &
     &         dble(TOT_ROOT_SIZE) * dble(TOT_ROOT_SIZE ) / dble(3)     &
     &       - 0.5D0 * dble( TOT_ROOT_SIZE ) * dble( TOT_ROOT_SIZE )    &
     &       - dble( TOT_ROOT_SIZE ) / dble( 6 ) )                      &
     &       / dble( root%NPROW * root%NPCOL )
      ELSE
      OPELIW = OPELIW + ( dble(TOT_ROOT_SIZE) *                         &
     &         dble( TOT_ROOT_SIZE) *                                   &
     &         dble( TOT_ROOT_SIZE + 1 ) )                              &
     &          / dble( 3 * root%NPROW * root%NPCOL )
      END IF
      IF ( PTRIST(STEP( IROOT )) .LT. 0 ) THEN
        A(PTRAST(STEP(IROOT)):                                          &
     &    PTRAST(STEP(IROOT))+LREQA-1_8) = dble(ZERO)
        PTRIST(STEP( IROOT ))            = 0
        PAMASTER(STEP( IROOT ))          = 0_8
      ELSE IF ( PTRIST( STEP(IROOT)) .eq. 0 ) THEN
        A(PTRAST(STEP(IROOT)):                                          &
     &    PTRAST(STEP(IROOT))+LREQA-1_8)=dble(ZERO)
        CALL DAGMG_MUMPS_35( N, root, IROOT,                                 &
     &       A(PTRAST(STEP(IROOT))), NEW_LOCAL_M, NEW_LOCAL_N,          &
     &       FILS, PTRAIW, PTRARW,                                      &
     &       INTARR, DBLARR, KEEP,KEEP8,                                &
     &       MYID )
      ELSE
        OLD_LOCAL_N = -IW( PTRIST(STEP( IROOT )) + KEEP(IXSZ) )
        OLD_LOCAL_M =  IW( PTRIST(STEP( IROOT )) + 1  + KEEP(IXSZ))
        IF ( TOT_ROOT_SIZE .eq. root%ROOT_SIZE ) THEN
          IF ( LREQA .NE. int(OLD_LOCAL_M,8) * int(OLD_LOCAL_N,8) )     &
     &    THEN
             write(*,*) 'error 1 in PROCESS_ROOT2SLAVE',                &
     &       OLD_LOCAL_M, OLD_LOCAL_N
             CALL AGMG_MUMPS_ABORT()
          END IF
          CALL DAGMG_MUMPS_756(LREQA,                                        &
     &                          A( PAMASTER(STEP(IROOT)) ),             &
     &                          A( PTRAST  (STEP(IROOT)) ) )
        ELSE
          CALL DAGMG_MUMPS_96( A( PTRAST(STEP(IROOT))),                      &
     &        NEW_LOCAL_M,                                              &
     &        NEW_LOCAL_N, A( PAMASTER( STEP(IROOT)) ), OLD_LOCAL_M,    &
     &        OLD_LOCAL_N )
        END IF
        IF ( PTRIST( STEP( IROOT ) ) .NE. 0 ) THEN
           IPOS_SON= PTRIST( STEP(IROOT))
           CALL DAGMG_MUMPS_152(.FALSE., MYID, N, IPOS_SON,                  &
     &          PAMASTER(STEP(IROOT)),                                  &
     &          IW, LIW, LRLU, LRLUS, IPTRLU,                           &
     &          IWPOSCB, LA, KEEP,KEEP8, .FALSE.                        &
     &         )
           PTRIST(STEP( IROOT ))   = 0
           PAMASTER(STEP( IROOT )) = 0_8
        END IF
      END IF
  100 CONTINUE
      NBPROCFILS(STEP(IROOT))=NBPROCFILS(STEP(IROOT)) + TOT_CONT_TO_RECV
      IF ( NBPROCFILS(STEP(IROOT)) .eq. 0 ) THEN
         IF (KEEP(201).EQ.1) THEN
            CALL DAGMG_MUMPS_681(IERR)
         ELSE IF (KEEP(201).EQ.2) THEN
            CALL DAGMG_MUMPS_580(IERR)
         ENDIF
        CALL DAGMG_MUMPS_507( N, IPOOL, LPOOL, PROCNODE_STEPS,               &
     &       SLAVEF, KEEP(28), KEEP(76), KEEP(80), KEEP(47),            &
     &       STEP, IROOT + N )
        IF (KEEP(47) .GE. 3) THEN
           CALL DAGMG_MUMPS_500(                                             &
     &          IPOOL, LPOOL,                                           &
     &          PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,          &
     &          MYID, STEP, N, ND, FILS )
        ENDIF
      END IF
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_270
      SUBROUTINE DAGMG_MUMPS_96                                              &
     &( NEW, M_NEW, N_NEW,OLD, M_OLD, N_OLD )
      INTEGER M_NEW, N_NEW, M_OLD, N_OLD
      DOUBLE PRECISION NEW( M_NEW, N_NEW ), OLD( M_OLD, N_OLD )
      INTEGER J
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      DO J = 1, N_OLD
        NEW( 1: M_OLD, J ) = OLD( 1: M_OLD, J )
        NEW( M_OLD + 1: M_NEW, J ) = dble(ZERO)
      END DO
      NEW( 1: M_NEW,N_OLD + 1: N_NEW ) = dble(ZERO)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_96
      INTEGER FUNCTION DAGMG_MUMPS_505(KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DAGMG_MUMPS_505 = KEEP(28) + 1 + 3
      RETURN
      END FUNCTION DAGMG_MUMPS_505
      SUBROUTINE DAGMG_MUMPS_506(IPOOL, LPOOL, LEAF)
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER LPOOL, LEAF
      INTEGER IPOOL(LPOOL)
      IPOOL(LPOOL-2) = 0
      IPOOL(LPOOL-1) = 0
      IPOOL(LPOOL)   = LEAF-1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_506
      SUBROUTINE DAGMG_MUMPS_507                                             &
     &           (N, POOL, LPOOL, PROCNODE, SLAVEF,                     &
     &           K28, K76, K80, K47, STEP, INODE)
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER N, INODE, LPOOL, K28, SLAVEF, K76, K80, K47
      INTEGER STEP(N), POOL(LPOOL), PROCNODE(K28)
      EXTERNAL AGMG_MUMPS_170
      LOGICAL AGMG_MUMPS_170, ATM_CURRENT_NODE
      INTEGER NBINSUBTREE, NBTOP, INODE_EFF,POS_TO_INSERT
      INTEGER IPOS1, IPOS2, ISWAP
      INTEGER NODE,J,I
      ATM_CURRENT_NODE = ( K76 == 2 .OR. K76 ==3 .OR.                   &
     &     K76==4 .OR. K76==5)
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      IF (INODE > N ) THEN
        INODE_EFF = INODE - N
      ELSE IF (INODE < 0) THEN
        INODE_EFF = - INODE
      ELSE
        INODE_EFF = INODE
      ENDIF
      IF(((INODE.GT.0).AND.(INODE.LE.N)).AND.(.NOT.                     &
     &     AGMG_MUMPS_170(STEP(INODE_EFF),                                   &
     &     PROCNODE, SLAVEF))) THEN
         IF ((K80 == 1 .AND. K47 .GE. 1) .OR.                           &
     &     (( K80 == 2 .OR. K80==3 ) .AND.                              &
     &          ( K47 == 4 ))) THEN
            CALL DAGMG_MUMPS_514(INODE,1)
         ENDIF
      ENDIF
      IF ( AGMG_MUMPS_170(STEP(INODE_EFF),                                   &
     &                             PROCNODE, SLAVEF) ) THEN
        POOL(NBINSUBTREE + 1 ) = INODE
        NBINSUBTREE = NBINSUBTREE + 1
      ELSE
         POS_TO_INSERT=NBTOP+1
         IF((K76.EQ.4).OR.(K76.EQ.5))THEN
            IF((INODE.GT.N).OR.(INODE.LE.0))THEN
               DO J=NBTOP,1,-1
                  IF((POOL(LPOOL-2-J).GT.0)                             &
     &                 .AND.(POOL(LPOOL-2-J).LE.N))THEN
                     GOTO 333
                  ENDIF
                  IF ( POOL(LPOOL-2-J) < 0 ) THEN
                     NODE=-POOL(LPOOL-2-J)
                  ELSE IF ( POOL(LPOOL-2-J) > N ) THEN
                     NODE = POOL(LPOOL-2-J) - N
                  ELSE
                     NODE = POOL(LPOOL-2-J)
                  ENDIF
                  IF(K76.EQ.4)THEN
                     IF(DEPTH_FIRST_LOAD(STEP(NODE)).GE.                &
     &                    DEPTH_FIRST_LOAD(STEP(INODE_EFF)))THEN
                        GOTO 333
                     ENDIF
                  ENDIF
                  IF(K76.EQ.5)THEN
                     IF(COST_TRAV(STEP(NODE)).LE.                       &
     &                    COST_TRAV(STEP(INODE_EFF)))THEN
                        GOTO 333
                     ENDIF
                  ENDIF
                  POS_TO_INSERT=POS_TO_INSERT-1
               ENDDO
               IF(J.EQ.0) J=1
  333          CONTINUE
               DO I=NBTOP,POS_TO_INSERT,-1
                  POOL(LPOOL-2-I-1)=POOL(LPOOL-2-I)
               ENDDO
               POOL(LPOOL-2-POS_TO_INSERT)=INODE
               NBTOP = NBTOP + 1
               GOTO 20
            ENDIF
            DO J=NBTOP,1,-1
               IF((POOL(LPOOL-2-J).GT.0).AND.(POOL(LPOOL-2-J).LE.N))THEN
                  GOTO 888
               ENDIF
               POS_TO_INSERT=POS_TO_INSERT-1
            ENDDO
  888       CONTINUE
            DO I=J,1,-1
               NODE=POOL(LPOOL-2-I)
               IF(K76.EQ.4)THEN
                  IF(DEPTH_FIRST_LOAD(STEP(NODE)).GE.                   &
     &                 DEPTH_FIRST_LOAD(STEP(INODE_EFF)))THEN
                     GOTO 999
                  ENDIF
               ENDIF
               IF(K76.EQ.5)THEN
                  IF(COST_TRAV(STEP(NODE)).LE.                          &
     &                 COST_TRAV(STEP(INODE_EFF)))THEN
                     GOTO 999
                  ENDIF
               ENDIF
               POS_TO_INSERT=POS_TO_INSERT-1
            ENDDO
            IF(I.EQ.0) I=1
  999       CONTINUE
            DO J=NBTOP,POS_TO_INSERT,-1
               POOL(LPOOL-2-J-1)=POOL(LPOOL-2-J)
            ENDDO
            POOL(LPOOL-2-POS_TO_INSERT)=INODE
            NBTOP = NBTOP + 1
            GOTO 20
         ENDIF
         POOL( LPOOL - 2 - ( NBTOP + 1 ) ) = INODE
         NBTOP = NBTOP + 1
        IPOS1 = LPOOL - 2 - NBTOP
        IPOS2 = LPOOL - 2 - NBTOP + 1
   10   CONTINUE
        IF ( IPOS2 == LPOOL - 2 ) GOTO 20
        IF ( POOL(IPOS1) < 0 ) GOTO 20
        IF ( POOL(IPOS2) < 0 ) GOTO 30
        IF ( ATM_CURRENT_NODE ) THEN
          IF ( POOL(IPOS1) > N ) GOTO 20
          IF ( POOL(IPOS2) > N ) GOTO 30
        END IF
        GOTO 20
   30   CONTINUE
        ISWAP = POOL(IPOS1)
        POOL(IPOS1) = POOL(IPOS2)
        POOL(IPOS2) = ISWAP
        IPOS1 = IPOS1 + 1
        IPOS2 = IPOS2 + 1
        GOTO 10
   20   CONTINUE
      ENDIF
      POOL(LPOOL) = NBINSUBTREE
      POOL(LPOOL - 1) = NBTOP
      RETURN
      END SUBROUTINE DAGMG_MUMPS_507
      LOGICAL FUNCTION DAGMG_MUMPS_508(POOL, LPOOL)
      IMPLICIT NONE
      INTEGER LPOOL
      INTEGER POOL(LPOOL)
      INTEGER NBINSUBTREE, NBTOP
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      DAGMG_MUMPS_508 = (NBINSUBTREE + NBTOP == 0)
      RETURN
      END FUNCTION DAGMG_MUMPS_508
      SUBROUTINE DAGMG_MUMPS_509( N, POOL, LPOOL, PROCNODE, SLAVEF,          &
     &           STEP, INODE, KEEP,KEEP8, MYID, ND,                     &
     &           FORCE_EXTRACT_TOP_SBTR )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER INODE, LPOOL, SLAVEF, N
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER STEP(N), POOL(LPOOL), PROCNODE(KEEP(28)),                 &
     &        ND(KEEP(28))
      EXTERNAL AGMG_MUMPS_167, AGMG_MUMPS_283, DAGMG_MUMPS_508
      LOGICAL AGMG_MUMPS_167, AGMG_MUMPS_283, DAGMG_MUMPS_508
      EXTERNAL AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_275
      INTEGER NBINSUBTREE, NBTOP, INSUBTREE, INODE_EFF, MYID
      LOGICAL LEFT, ATOMIC_SUBTREE,UPPER,FLAG_MEM,SBTR_FLAG,PROC_FLAG
      LOGICAL FORCE_EXTRACT_TOP_SBTR
      INTEGER NODE_TO_EXTRACT,POS_TO_EXTRACT,I,J,K,SON,                 &
     &     NSLAVES_TEMP,POS_TEMP,MIN_PROC
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      INSUBTREE   = POOL(LPOOL - 2)
      IF ( KEEP(76) > 6 .OR. KEEP(76) < 0 ) THEN
         WRITE(*,*) "Error 2 in DAGMG_MUMPS_509: unknown strategy"
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      ATOMIC_SUBTREE =  ( KEEP(76) == 1 .OR. KEEP(76) == 3)
      IF ( DAGMG_MUMPS_508(POOL, LPOOL) ) THEN
         WRITE(*,*) "Error 1 in DAGMG_MUMPS_509"
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF ( .NOT. ATOMIC_SUBTREE ) THEN
         LEFT = (NBTOP == 0)
         IF(.NOT.LEFT)THEN
            IF((KEEP(76).EQ.4).OR.(KEEP(76).EQ.5))THEN
               IF(NBINSUBTREE.EQ.0)THEN
                  LEFT=.FALSE.
               ELSE
                  IF ( POOL(NBINSUBTREE) < 0 ) THEN
                     I = -POOL(NBINSUBTREE)
                  ELSE IF ( POOL(NBINSUBTREE) > N ) THEN
                     I = POOL(NBINSUBTREE) - N
                  ELSE
                     I = POOL(NBINSUBTREE)
                  ENDIF
                  IF ( POOL(LPOOL-2-NBTOP) < 0 ) THEN
                     J = -POOL(LPOOL-2-NBTOP)
                  ELSE IF ( POOL(LPOOL-2-NBTOP) > N ) THEN
                     J = POOL(LPOOL-2-NBTOP) - N
                  ELSE
                     J = POOL(LPOOL-2-NBTOP)
                  ENDIF
                  IF(KEEP(76).EQ.4)THEN
                     IF(DEPTH_FIRST_LOAD(STEP(J)).GE.                   &
     &                    DEPTH_FIRST_LOAD(STEP(I)))THEN
                        LEFT=.TRUE.
                     ELSE
                        LEFT=.FALSE.
                     ENDIF
                  ENDIF
                  IF(KEEP(76).EQ.5)THEN
                     IF(COST_TRAV(STEP(J)).LE.                          &
     &                    COST_TRAV(STEP(I)))THEN
                        LEFT=.TRUE.
                     ELSE
                        LEFT=.FALSE.
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
      ELSE
         IF ( INSUBTREE == 1 ) THEN
            IF (NBINSUBTREE == 0) THEN
               WRITE(*,*) "Error 3 in DAGMG_MUMPS_509"
               CALL AGMG_MUMPS_ABORT()
            ENDIF
            LEFT = .TRUE.
         ELSE
            LEFT = ( NBTOP == 0)
         ENDIF
      ENDIF
  222 CONTINUE
      IF ( LEFT ) THEN
         INODE = POOL( NBINSUBTREE )
         IF(KEEP(81).EQ.2)THEN
            IF((INODE.GE.0).AND.(INODE.LE.N))THEN
               CALL DAGMG_MUMPS_561(INODE,POOL,LPOOL,N,                      &
     &              STEP,KEEP,KEEP8,PROCNODE,SLAVEF,MYID,SBTR_FLAG,     &
     &              PROC_FLAG,MIN_PROC)
               IF(.NOT.SBTR_FLAG)THEN
                  WRITE(*,*)MYID,': ca a change pour moi'
                  LEFT=.FALSE.
                  GOTO 222
               ENDIF
            ENDIF
         ELSEIF(KEEP(81).EQ.3)THEN
            IF((INODE.GE.0).AND.(INODE.LE.N))THEN
               NODE_TO_EXTRACT=INODE
               FLAG_MEM=.FALSE.
               CALL CHECK_MEM_CONST_FOR_POOL(FLAG_MEM)
               IF(FLAG_MEM)THEN
                  CALL DAGMG_MUMPS_561(INODE,POOL,LPOOL,N,                   &
     &                 STEP,KEEP,KEEP8,                                 &
     &                 PROCNODE,SLAVEF,MYID,SBTR_FLAG,                  &
     &                 PROC_FLAG,MIN_PROC)
                  IF(.NOT.SBTR_FLAG)THEN
                     LEFT=.FALSE.
                     WRITE(*,*)MYID,': ca a change pour moi (2)'
                     GOTO 222
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
         NBINSUBTREE = NBINSUBTREE - 1
         IF ( INODE < 0 ) THEN
            INODE_EFF = -INODE
         ELSE IF ( INODE > N ) THEN
            INODE_EFF = INODE - N
         ELSE
            INODE_EFF = INODE
         ENDIF
         IF ( AGMG_MUMPS_167( STEP(INODE_EFF), PROCNODE, SLAVEF) ) THEN
            IF((KEEP(47).GE.2.AND.KEEP(81).EQ.1).AND.                   &
     &           (INSUBTREE.EQ.0))THEN
               CALL DAGMG_MUMPS_513(.TRUE.)
            ENDIF
            INSUBTREE = 1
         ELSE IF ( AGMG_MUMPS_283( STEP(INODE_EFF), PROCNODE,                &
     &           SLAVEF)) THEN
            IF((KEEP(47).GE.2.AND.KEEP(81).EQ.1).AND.                   &
     &           (INSUBTREE.EQ.1))THEN
               CALL DAGMG_MUMPS_513(.FALSE.)
            ENDIF
            INSUBTREE = 0
         END IF
      ELSE
         IF (NBTOP < 1 ) THEN
            WRITE(*,*) "Error 5 in DAGMG_MUMPS_509", NBTOP
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         INODE = POOL( LPOOL - 2 - NBTOP )
         IF(KEEP(81).EQ.1)THEN
            CALL DAGMG_MUMPS_520                                             &
     &           (INODE,UPPER,SLAVEF,KEEP,KEEP8,                        &
     &            STEP,POOL,LPOOL,PROCNODE,N)
            IF(UPPER)THEN
               GOTO 666
            ELSE
               NBINSUBTREE=NBINSUBTREE-1
               IF ( AGMG_MUMPS_167( STEP(INODE), PROCNODE,                   &
     &              SLAVEF) ) THEN
                  INSUBTREE = 1
               ELSE IF ( AGMG_MUMPS_283( STEP(INODE), PROCNODE,              &
     &                 SLAVEF)) THEN
                  INSUBTREE = 0
               ENDIF
               GOTO 777
            ENDIF
         ENDIF
         IF(KEEP(81).EQ.2)THEN
            CALL DAGMG_MUMPS_561(INODE,POOL,LPOOL,N,STEP,                    &
     &           KEEP,KEEP8,                                            &
     &           PROCNODE,SLAVEF,MYID,SBTR_FLAG,PROC_FLAG,MIN_PROC)
            IF(SBTR_FLAG)THEN
               LEFT=.TRUE.
               WRITE(*,*)MYID,': ca a change pour moi (3)'
               GOTO 222
            ENDIF
         ELSE
            IF(KEEP(81).EQ.3)THEN
               IF((INODE.GE.0).AND.(INODE.LE.N))THEN
                  NODE_TO_EXTRACT=INODE
                  FLAG_MEM=.FALSE.
                  CALL CHECK_MEM_CONST_FOR_POOL(FLAG_MEM)
                  IF(FLAG_MEM)THEN
                     CALL DAGMG_MUMPS_561(INODE,POOL,LPOOL,N,                &
     &                    STEP,KEEP,KEEP8,                              &
     &                    PROCNODE,SLAVEF,MYID,SBTR_FLAG,               &
     &                    PROC_FLAG,MIN_PROC)
                     IF(SBTR_FLAG)THEN
                        LEFT=.TRUE.
                        WRITE(*,*)MYID,': ca a change pour moi (4)'
                        GOTO 222
                     ENDIF
                  ELSE
                     CALL CLEAN_POOL_MEM_INFO(INODE)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
  666    CONTINUE
         NBTOP = NBTOP - 1
         IF((INODE.GT.0).AND.(INODE.LE.N))THEN
            IF ((( KEEP(80) == 2 .OR. KEEP(80)==3 ) .AND.               &
     &           ( KEEP(47) == 4 ))) THEN
               CALL DAGMG_MUMPS_514(INODE,2)
            ENDIF
         ENDIF
         IF ( INODE < 0 ) THEN
            INODE_EFF = -INODE
         ELSE IF ( INODE > N ) THEN
            INODE_EFF = INODE - N
         ELSE
            INODE_EFF = INODE
         ENDIF
      END IF
  777 CONTINUE
      POOL(LPOOL)     = NBINSUBTREE
      POOL(LPOOL - 1) = NBTOP
      POOL(LPOOL - 2) = INSUBTREE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_509
      SUBROUTINE DAGMG_MUMPS_552(INODE,POOL,LPOOL,N,STEP,                    &
     &     KEEP,KEEP8,                                                  &
     &     PROCNODE,SLAVEF,MYID,SBTR,FLAG_SAME_PROC,MIN_PROC)
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER INODE,LPOOL,N,MYID,SLAVEF,PROC,MIN_PROC
      INTEGER POOL(LPOOL),KEEP(500),STEP(N),PROCNODE(KEEP(28))
      INTEGER*8 KEEP8(150)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      LOGICAL SBTR,FLAG_SAME_PROC
      INTEGER POS_TO_EXTRACT,NODE_TO_EXTRACT,NBTOP,I,INSUBTREE,         &
     &     NBINSUBTREE
      DOUBLE PRECISION MIN_COST, TMP_COST
      NBINSUBTREE = POOL(LPOOL)
      NBTOP       = POOL(LPOOL - 1)
      INSUBTREE   = POOL(LPOOL - 2)
      MIN_COST=huge(MIN_COST)
      TMP_COST=huge(TMP_COST)
      FLAG_SAME_PROC=.FALSE.
      SBTR=.FALSE.
      MIN_PROC=-9999
      IF((INODE.GT.0).AND.(INODE.LE.N))THEN
         POS_TO_EXTRACT=-1
         NODE_TO_EXTRACT=-1
         DO I=NBTOP,1,-1
            IF(NODE_TO_EXTRACT.LT.0)THEN
               POS_TO_EXTRACT=I
               NODE_TO_EXTRACT=POOL(LPOOL-2-I)
               CALL COMPUTE_MAX_MEM(NODE_TO_EXTRACT,TMP_COST,PROC)
               MIN_COST=TMP_COST
               MIN_PROC=PROC
            ELSE
               CALL COMPUTE_MAX_MEM(POOL(LPOOL-2-I),TMP_COST,PROC)
               IF((PROC.NE.MIN_PROC).OR.(TMP_COST.NE.MIN_COST))THEN
                  FLAG_SAME_PROC=.TRUE.
               ENDIF
               IF(TMP_COST.GT.MIN_COST)THEN
                  POS_TO_EXTRACT=I
                  NODE_TO_EXTRACT=POOL(LPOOL-2-I)
                  MIN_COST=TMP_COST
                  MIN_PROC=PROC
               ENDIF
            ENDIF
         ENDDO
         IF((KEEP(47).EQ.4).AND.(NBINSUBTREE.NE.0))THEN
            CALL DAGMG_MUMPS_554(NBINSUBTREE,INSUBTREE,NBTOP,                &
     &           MIN_COST,SBTR)
            IF(SBTR)THEN
               WRITE(*,*)MYID,': selecting from subtree'
               RETURN
            ENDIF
         ENDIF
         IF((.NOT.SBTR).AND.(.NOT.FLAG_SAME_PROC))THEN
            WRITE(*,*)MYID,': I must search for a task                  &
     &           to save My friend'
            RETURN
         ENDIF
         INODE = NODE_TO_EXTRACT
         DO I=POS_TO_EXTRACT,NBTOP
            IF(I.NE.NBTOP)THEN
               POOL(LPOOL-2-I)=POOL(LPOOL-2-I-1)
            ENDIF
         ENDDO
         POOL(LPOOL-2-NBTOP)=INODE
         CALL CLEAN_POOL_MEM_INFO(INODE)
      ELSE
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_552
      SUBROUTINE DAGMG_MUMPS_561(INODE,POOL,LPOOL,N,STEP,                    &
     &     KEEP,KEEP8,                                                  &
     &     PROCNODE,SLAVEF,MYID,SBTR_FLAG,PROC_FLAG,MIN_PROC)
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
      INTEGER INODE,LPOOL,N,SLAVEF,MYID,MIN_PROC
      INTEGER POOL(LPOOL),KEEP(500),PROCNODE(KEEP(28)),STEP(N)
      INTEGER*8 KEEP8(150)
      LOGICAL SBTR_FLAG,PROC_FLAG
      EXTERNAL AGMG_MUMPS_167
      LOGICAL AGMG_MUMPS_167
      INTEGER NODE_TO_EXTRACT,I,POS_TO_EXTRACT,NBTOP,NBINSUBTREE
      NBTOP= POOL(LPOOL - 1)
      NBINSUBTREE = POOL(LPOOL)
      IF(NBTOP.GT.0)THEN
         WRITE(*,*)MYID,': NBTOP=',NBTOP
      ENDIF
      SBTR_FLAG=.FALSE.
      PROC_FLAG=.FALSE.
      CALL DAGMG_MUMPS_552(INODE,POOL,LPOOL,N,STEP,KEEP,KEEP8,               &
     &     PROCNODE,SLAVEF,MYID,SBTR_FLAG,PROC_FLAG,MIN_PROC)
      IF(SBTR_FLAG)THEN
         RETURN
      ENDIF
      IF(MIN_PROC.EQ.-9999)THEN
         IF((INODE.GT.0).AND.(INODE.LT.N))THEN
            SBTR_FLAG=(NBINSUBTREE.NE.0)
         ENDIF
         RETURN
      ENDIF
      IF(.NOT.PROC_FLAG)THEN
         NODE_TO_EXTRACT=INODE
         IF((INODE.GE.0).AND.(INODE.LE.N))THEN
            CALL DAGMG_MUMPS_553(MIN_PROC,POOL,                              &
     &           LPOOL,INODE)
            IF(AGMG_MUMPS_167(STEP(INODE),PROCNODE,                          &
     &           SLAVEF))THEN
               WRITE(*,*)MYID,': Extracting from a subtree              &
     &              for helping',MIN_PROC
               SBTR_FLAG=.TRUE.
               RETURN
            ELSE
               IF(NODE_TO_EXTRACT.NE.INODE)THEN
                  WRITE(*,*)MYID,': Extracting from top                 &
     &                 inode=',INODE,'for helping',MIN_PROC
               ENDIF
               CALL CLEAN_POOL_MEM_INFO(INODE)
            ENDIF
         ENDIF
         DO I=1,NBTOP
            IF (POOL(LPOOL-2-I).EQ.INODE)THEN
               GOTO 452
            ENDIF
         ENDDO
  452    CONTINUE
         POS_TO_EXTRACT=I
         DO I=POS_TO_EXTRACT,NBTOP-1
            POOL(LPOOL-2-I)=POOL(LPOOL-2-I-1)
         ENDDO
         POOL(LPOOL-2-NBTOP)=INODE
      ENDIF
      END SUBROUTINE DAGMG_MUMPS_561
      SUBROUTINE DAGMG_MUMPS_574                                             &
     &           ( IPOOL, LPOOL, III, LEAF,                             &
     &             INODE, STRATEGIE )
            IMPLICIT NONE
      INTEGER, INTENT(IN) :: STRATEGIE, LPOOL
      INTEGER IPOOL (LPOOL)
      INTEGER III,LEAF
      INTEGER, INTENT(OUT) :: INODE
         LEAF  = LEAF - 1
         INODE = IPOOL( LEAF )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_574
      SUBROUTINE DAGMG_MUMPS_128(N, NELT, ELTPTR, ELTVAR, LIW,               &
     &            IKEEP, PTRAR,                                         &
     &            IORD, NFSIZ, FILS, FRERE,                             &
     &            LISTVAR_SCHUR, SIZE_SCHUR,                            &
     &            ICNTL, INFO, KEEP,KEEP8,                              &
     &            ELTNOD, NSLAVES,                                      &
     &            XNODEL, NODEL)
      IMPLICIT NONE
      INTEGER N,NELT,LIW,IORD, SIZE_SCHUR, NSLAVES
      INTEGER PTRAR(N,3), NFSIZ(N), FILS(N), FRERE(N)
      INTEGER ELTPTR(NELT+1)
      INTEGER XNODEL(N+1), NODEL(ELTPTR(NELT+1)-1)
      INTEGER ELTVAR(ELTPTR(NELT+1)-1)
      INTEGER IKEEP(N,3)
      INTEGER LISTVAR_SCHUR(SIZE_SCHUR)
      INTEGER INFO(40), ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER ELTNOD(NELT)
      INTEGER K,I,L1,L2,IWFR,NCMPA,LLIW,IFSON,IN
      INTEGER NEMIN, MPRINT, LP, MP, LDIAG
      INTEGER NZ, allocok, ITEMP
      LOGICAL PROK, NOSUPERVAR
      INTEGER(8) :: K79REF
      PARAMETER(K79REF=12000000_8)
      LOGICAL SPLITROOT
      INTEGER, DIMENSION(:), ALLOCATABLE :: IW
      INTEGER, DIMENSION(:), ALLOCATABLE :: IW2
          INTEGER OPT_METIS_SIZE, NUMFLAG
          PARAMETER(OPT_METIS_SIZE = 8, NUMFLAG = 1)
          INTEGER OPTIONS_METIS(OPT_METIS_SIZE)
      INTEGER IDUM
      INTEGER IDUMARR(1)
      INTEGER IDUMARR4(1)
      EXTERNAL AGMG_MUMPS_197, DAGMG_MUMPS_130, DAGMG_MUMPS_131,                       &
     &         DAGMG_MUMPS_129, DAGMG_MUMPS_132,                                  &
     &         DAGMG_MUMPS_133, DAGMG_MUMPS_134,                                  &
     &         DAGMG_MUMPS_199,                                              &
     &         DAGMG_MUMPS_557, DAGMG_MUMPS_201
        ALLOCATE( IW ( LIW ), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO( 1 ) = -7
          INFO( 2 ) = LIW
          RETURN
        ENDIF
      MPRINT= ICNTL(3)
      PROK  = (MPRINT.GT.0)
      LP    = ICNTL(1)
      MP    = ICNTL(3)
      LDIAG = ICNTL(4)
      IF (KEEP(60).NE.0) THEN
       NOSUPERVAR=.TRUE.
       IF (IORD.GT.1) IORD = 0
      ELSE
       NOSUPERVAR=.FALSE.
      ENDIF
      IF (IORD == 7) THEN
         IF ( N < 10000 ) THEN
           IORD = 0
         ELSE
           IORD = 0
         ENDIF
      END IF
      IF (IORD == 5) IORD = 0
      IF (KEEP(1).LT.1) KEEP(1) = 1
      NEMIN = KEEP(1)
      IF (LDIAG.LE.2 .OR. MP.LE.0) GO TO 10
      WRITE (MP,99999) N, NELT, LIW, INFO(1)
      K = min0(10,NELT+1)
      IF (LDIAG.EQ.4) K = NELT+1
      IF (K.GT.0) WRITE (MP,99998) (ELTPTR(I),I=1,K)
      K = min0(10,ELTPTR(NELT+1)-1)
      IF (LDIAG.EQ.4) K = ELTPTR(NELT+1)-1
      IF (K.GT.0) WRITE (MP,99995) (ELTVAR(I),I=1,K)
      K = min0(10,N)
      IF (LDIAG.EQ.4) K = N
      IF (IORD.EQ.1 .AND. K.GT.0) THEN
        WRITE (MP,99997) (IKEEP(I,1),I=1,K)
      ENDIF
   10 L1 = 1
      L2 = L1 + N
      IF (LIW .LT. 3*N) THEN
          INFO(1)= -2002
          INFO(2) = LIW
      ENDIF
      IF (NOSUPERVAR) THEN
        IF ( LIW .LT. 2*N ) THEN
          INFO(1)= -2002
          INFO(2) = LIW
          RETURN
        END IF
      ELSE
        IF ( LIW .LT.  4*N+4 ) THEN
          INFO(1)= -2002
          INFO(2) = LIW
          RETURN
        END IF
      ENDIF
      IDUM=0
      CALL DAGMG_MUMPS_258(NELT, N, ELTPTR(NELT+1)-1, ELTPTR, ELTVAR,        &
     &           XNODEL, NODEL, IW(L1), IDUM, ICNTL)
      IF (IORD.NE.1 .AND. IORD .NE. 5) THEN
        IORD = 0
        IF (NOSUPERVAR) THEN
          CALL DAGMG_MUMPS_129(N, NZ, NELT, ELTPTR(NELT+1)-1,                &
     &              ELTPTR, ELTVAR, XNODEL, NODEL,                      &
     &              PTRAR(1,2), IW(L1))
        ELSE
         CALL DAGMG_MUMPS_130(N, NZ, NELT, ELTPTR(NELT+1)-1,                 &
     &              ELTPTR, ELTVAR, XNODEL, NODEL,                      &
     &              PTRAR(1,2), 4*N+4, IW(L1))
        ENDIF
        LLIW = max(NZ,N)
        ALLOCATE( IW2(LLIW), stat = allocok )
        IF (allocok.GT.0) THEN
          INFO(1) = -7
          INFO(2) = LLIW
          RETURN
        ENDIF
        IF (NOSUPERVAR) THEN
         CALL DAGMG_MUMPS_132(N, NZ, NELT, ELTPTR(NELT+1)-1,                 &
     &              ELTPTR, ELTVAR, XNODEL, NODEL,                      &
     &              IW2, LLIW, PTRAR, PTRAR(1,2),                       &
     &              IW(L1), IWFR)
        ELSE
         CALL DAGMG_MUMPS_131(N, NZ, NELT, ELTPTR(NELT+1)-1,                 &
     &              ELTPTR, ELTVAR, XNODEL, NODEL,                      &
     &              IW2, LLIW, PTRAR, PTRAR(1,2),                       &
     &              IW(L1), IWFR)
        ENDIF
        IF (NOSUPERVAR) THEN
         CALL AGMG_MUMPS_162(N, LLIW, PTRAR, IWFR, PTRAR(1,2), IW2,          &
     &   IW(L1), IKEEP,                                                 &
     &   IKEEP(1,2), NCMPA, FILS, IKEEP(1,3), IW(L2), PTRAR(1,3),       &
     &   LISTVAR_SCHUR, SIZE_SCHUR)
         IF (KEEP(60) == 1) THEN
           KEEP(20) = LISTVAR_SCHUR(1)
         ELSEIF (KEEP(60) == 2 .OR. KEEP(60) == 3 ) THEN
           KEEP(38) = LISTVAR_SCHUR(1)
         ELSE
           WRITE(*,*) "Internal error in DAGMG_MUMPS_128",KEEP(60)
           CALL AGMG_MUMPS_ABORT()
         ENDIF
        ELSE
         CALL AGMG_MUMPS_23(N, LLIW, PTRAR, IWFR, PTRAR(1,2), IW2,           &
     &   IW(L1), IKEEP,                                                 &
     &   IKEEP(1,2), NCMPA, FILS, IKEEP(1,3), IW(L2), PTRAR(1,3))
        ENDIF
      ELSE
       DO K=1,N
         IW(L1+K) = 0
       ENDDO
       DO K=1,N
         IF ((IKEEP(K,1).LE.0).OR.(IKEEP(K,1).GT.N))                    &
     &    GO TO 40
         IF (IW(L1+IKEEP(K,1)).EQ.1) THEN
          GOTO 40
         ELSE
          IW(L1+IKEEP(K,1)) = 1
         ENDIF
       ENDDO
       CALL DAGMG_MUMPS_133(N, NZ, NELT, ELTPTR(NELT+1)-1,                   &
     &             ELTPTR, ELTVAR, XNODEL, NODEL,                       &
     &             IKEEP, PTRAR(1,2), IW(L1))
       LLIW = NZ+N
       ALLOCATE( IW2(LLIW), stat = allocok )
       IF (allocok.GT.0) THEN
         INFO(1) = -7
         INFO(2) = LLIW
         RETURN
       ENDIF
       CALL DAGMG_MUMPS_134(N, NZ, NELT, ELTPTR(NELT+1)-1,                   &
     &             ELTPTR, ELTVAR, XNODEL, NODEL,                       &
     &             IKEEP, IW2, LLIW, PTRAR, PTRAR(1,2),                 &
     &             IW(L1), IWFR)
       IF (KEEP(60) == 0) THEN
         ITEMP = 0
       ELSE
         ITEMP = SIZE_SCHUR
         IF (KEEP(60) == 1) THEN
           KEEP(20) = LISTVAR_SCHUR(1)
         ELSEIF (KEEP(60) == 2 .OR. KEEP(60) == 3 ) THEN
           KEEP(38) = LISTVAR_SCHUR(1)
         ELSE
           WRITE(*,*) "Internal error in DAGMG_MUMPS_128",KEEP(60)
           CALL AGMG_MUMPS_ABORT()
         ENDIF
       ENDIF
       CALL DAGMG_MUMPS_199(N, PTRAR, IW2, LLIW, IWFR, IKEEP,                &
     &    IKEEP(1,2), IW(L1),                                           &
     &    IW(L2), NCMPA, ITEMP)
      ENDIF
      CALL DAGMG_MUMPS_557(N, PTRAR, IW(L1), IKEEP, IKEEP(1,2),              &
     &     IKEEP(1,3),                                                  &
     &     NFSIZ, PTRAR(1,2),                                           &
     &     INFO(6), FILS, FRERE, PTRAR(1,3), NEMIN,                     &
     &     IW(L2),  KEEP(60), KEEP(20), KEEP(38),                       &
     &     IW2,KEEP(104),IW(L2+N),KEEP(50),                             &
     &     ICNTL(13), KEEP(37), NSLAVES, KEEP(250).EQ.1)
      DEALLOCATE(IW2)
      IF (KEEP(60).NE.0) THEN
         IF (KEEP(60)==1) THEN
           IN = KEEP(20)
         ELSE
           IN = KEEP(38)
         ENDIF
         DO WHILE (IN.GT.0)
          IN = FILS (IN)
         END DO
         IFSON = -IN
         IF (KEEP(60)==1) THEN
           IN = KEEP(20)
         ELSE
           IN = KEEP(38)
         ENDIF
         DO I=2,SIZE_SCHUR
          FILS(IN) = LISTVAR_SCHUR (I)
          IN       = FILS(IN)
          FRERE (IN) = N+1
         ENDDO
         FILS(IN) = -IFSON
      ENDIF
      CALL DAGMG_MUMPS_201(IKEEP(1,2),                                       &
     &  PTRAR(1,3), INFO(6),                                            &
     &  INFO(5), KEEP(2),KEEP(50),                                      &
     &  KEEP(101), KEEP(108),KEEP(5),                                   &
     &  KEEP(6), KEEP(226))
      IF ( KEEP(53) .NE. 0 ) THEN
        CALL AGMG_MUMPS_209( N, FRERE, FILS, NFSIZ, KEEP(20) )
      END IF
      IF ( KEEP(48) == 4 .OR.                                           &
     &   ( (KEEP(24).NE.0).AND.(KEEP8(21).GT.0_8) ) ) THEN
          CALL DAGMG_MUMPS_510(KEEP8(21), KEEP(2),                           &
     &    KEEP(48), KEEP(50), NSLAVES)
      END IF
      IF (KEEP(210).LT.0.OR.KEEP(210).GT.2) KEEP(210)=0
      IF (KEEP(210).EQ.0.AND.KEEP(201).GT.0) KEEP(210)=1
      IF (KEEP(210).EQ.0.AND.KEEP(201).EQ.0) KEEP(210)=2
      IF (KEEP(210).EQ.2) KEEP8(79)=huge(KEEP8(79))
      IF (KEEP(210).EQ.1.AND.KEEP8(79).LE.0_8) THEN
        IF ( huge(KEEP8(79)) / K79REF + 1_8 .GE. int(NSLAVES,8) ) THEN
        KEEP8(79)=huge(KEEP8(79))
        ELSE
        KEEP8(79)=K79REF * int(NSLAVES,8)
        ENDIF
      ENDIF
      IF (KEEP(210).EQ.1) THEN
       SPLITROOT = .FALSE.
       IF ( KEEP(62).GE.1) THEN
        CALL DAGMG_MUMPS_97(N, FRERE, FILS, NFSIZ,INFO(6),                   &
     &                       NSLAVES, KEEP,KEEP8, SPLITROOT,            &
     &                       MP, LDIAG, INFO(1), INFO(2))
        IF (INFO(1).LT.0) RETURN
       ENDIF
      ENDIF
      SPLITROOT = ((ICNTL(13).GT.0) .AND. (NSLAVES.GE.ICNTL(13)))
      IF (SPLITROOT) THEN
         CALL DAGMG_MUMPS_97(N, FRERE, FILS, NFSIZ,INFO(6),                  &
     &                    NSLAVES, KEEP,KEEP8, SPLITROOT,               &
     &                    MP, LDIAG, INFO(1), INFO(2))
         IF (INFO(1).LT.0) RETURN
      ENDIF
      IF (LDIAG.GT.2 .AND. MP.GT.0) THEN
       K = min0(10,N)
       IF (LDIAG.EQ.4) K = N
       IF (K.GT.0) WRITE (MP,99997) (IKEEP(I,1),I=1,K)
       IF (K.GT.0) WRITE (MP,99991) (IKEEP(I,2),I=1,K)
       IF (K.GT.0) WRITE (MP,99990) (IKEEP(I,3),I=1,K)
       IF (K.GT.0) WRITE (MP,99987) (NFSIZ(I),I=1,K)
       IF (K.GT.0) WRITE (MP,99989) (FILS(I),I=1,K)
       IF (K.GT.0) WRITE (MP,99988) (FRERE(I),I=1,K)
      ENDIF
      GO TO 90
   40 INFO(1) = -4
      INFO(2) = K
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1)) WRITE (LP,99996) INFO(1)
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1)) WRITE (LP,99982) INFO(2)
   90 CONTINUE
      DEALLOCATE(IW)
      RETURN
99999 FORMAT (/'Entering analysis phase with ...'/                      &
     & '                N         NELT       LIW       INFO(1)'/,       &
     & 9X, I8, I11, I12, I14)
99998 FORMAT ('Element pointers:  ELTPTR()   '/(9X, 7I10))
99995 FORMAT ('Element variables: ELTVAR()   '/(9X, 7I10))
99997 FORMAT ('IKEEP(.,1)=', 10I6/(12X, 10I6))
99996 FORMAT (/'** Error return ** from Analysis   *  INFO(1)=', I3)
99991 FORMAT ('IKEEP(.,2)=', 10I6/(12X, 10I6))
99990 FORMAT ('IKEEP(.,3)=', 10I6/(12X, 10I6))
99989 FORMAT ('FILS (.)  =', 10I6/(12X, 10I6))
99988 FORMAT ('FRERE(.)  =', 10I6/(12X, 10I6))
99987 FORMAT ('NFSIZ(.)  =', 10I6/(12X, 10I6))
99982 FORMAT ('Error in permutation array KEEP   INFO(2)=', I3)
      END SUBROUTINE DAGMG_MUMPS_128
      SUBROUTINE DAGMG_MUMPS_258( NELT, N, NELNOD, XELNOD, ELNOD,            &
     &                        XNODEL, NODEL, FLAG, IERROR, ICNTL )
      IMPLICIT NONE
      INTEGER NELT, N, NELNOD, IERROR, ICNTL(40)
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER XNODEL(N+1), NODEL(NELNOD),                               &
     &        FLAG(N)
      INTEGER I, J, K, MP, NBERR
      MP = ICNTL(2)
      FLAG(1:N) = 0
      XNODEL(1:N) = 0
      IERROR = 0
      DO I = 1, NELT
        DO K = XELNOD(I), XELNOD(I+1)-1
          J = ELNOD(K)
          IF ( J.LT.1 .OR. J.GT.N ) THEN
            IERROR = IERROR + 1
          ELSE
            IF ( FLAG(J).NE.I ) THEN
              XNODEL(J) = XNODEL(J) + 1
              FLAG(J) = I
            ENDIF
          ENDIF
        ENDDO
      ENDDO
      IF ( IERROR.GT.0 .AND. MP.GT.0 .AND. ICNTL(4).GE.2 ) THEN
        NBERR = 0
        WRITE(MP,99999)
        DO I = 1, NELT
          DO K = XELNOD(I), XELNOD(I+1)-1
            J = ELNOD(K)
            IF ( J.LT.1 .OR. J.GT.N ) THEN
              NBERR = NBERR + 1
              IF (NBERR.LE.10) THEN
                WRITE(MP,'(A,I8,A,I8,A)')                               &
     &          'Element ',I,' variable ',J,' ignored.'
              ELSE
                GO TO 100
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDIF
  100 CONTINUE
      K = 1
      DO I = 1, N
         K = K + XNODEL(I)
         XNODEL(I) = K
      ENDDO
      XNODEL(N+1) = XNODEL(N)
      FLAG(1:N) = 0
      DO I = 1, NELT
         DO K = XELNOD(I), XELNOD(I+1)-1
            J = ELNOD(K)
            IF (FLAG(J).NE.I) THEN
              XNODEL(J) = XNODEL(J) - 1
              NODEL(XNODEL(J)) = I
              FLAG(J) = I
            ENDIF
         ENDDO
      ENDDO
      RETURN
99999 FORMAT (/'*** Warning message from subroutine DMUMPS_258 ***')
      END SUBROUTINE DAGMG_MUMPS_258
      SUBROUTINE DAGMG_MUMPS_129(N, NZ, NELT, NELNOD,                        &
     &  XELNOD, ELNOD, XNODEL, NODEL,                                   &
     &  LEN, FLAG)
      IMPLICIT NONE
      INTEGER N, NELT, NELNOD, NZ
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER LEN(N)
      INTEGER  XNODEL(N+1), NODEL(NELNOD),                              &
     &        FLAG(N)
      INTEGER I,J,K1,K2,K3
      FLAG(1:N) = 0
      LEN(1:N) = 0
      DO I = 1,N
        DO K1 = XNODEL(I), XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2), XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF ((I.LT.J) .AND. (FLAG(J).NE.I)) THEN
                LEN(I) = LEN(I) + 1
                LEN(J) = LEN(J) + 1
                FLAG(J) = I
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      NZ = 0
      DO I = 1,N
        NZ = NZ + LEN(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_129
      SUBROUTINE DAGMG_MUMPS_538(N, NZ, NELT, NELNOD,                        &
     &  XELNOD, ELNOD, XNODEL, NODEL,                                   &
     &  IW, LW, IPE, LEN, FLAG, IWFR)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD,LW,IWFR
      INTEGER LEN(N)
      INTEGER IPE(N+1)
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER  XNODEL(N+1), NODEL(NELNOD),                              &
     &          IW(LW), FLAG(N)
      INTEGER I,J,K1,K2,K3
      IWFR = 1
      DO I = 1,N
        IWFR = IWFR + LEN(I)
          IPE(I) = IWFR
      ENDDO
      IPE(N+1)=IPE(N)
      FLAG(1:N) = 0
      DO I = 1,N
        DO K1 = XNODEL(I), XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2), XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF ((I.LT.J) .AND. (FLAG(J).NE.I)) THEN
                IPE(I) = IPE(I) - 1
                IW(IPE(I)) = J
                IPE(J) = IPE(J) - 1
                IW(IPE(J)) = I
                FLAG(J) = I
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_538
      SUBROUTINE DAGMG_MUMPS_132(N, NZ, NELT, NELNOD,                        &
     &  XELNOD, ELNOD, XNODEL, NODEL,                                   &
     &  IW, LW, IPE, LEN, FLAG, IWFR)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD,LW,IWFR
      INTEGER LEN(N)
      INTEGER IPE(N)
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER  XNODEL(N+1), NODEL(NELNOD),                              &
     &          IW(LW), FLAG(N)
      INTEGER I,J,K1,K2,K3
      IWFR = 1
      DO I = 1,N
        IWFR = IWFR + LEN(I)
        IF (LEN(I).GT.0) THEN
          IPE(I) = IWFR
        ELSE
          IPE(I) = 0
        ENDIF
      ENDDO
      FLAG(1:N) = 0
      DO I = 1,N
        DO K1 = XNODEL(I), XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2), XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF ((I.LT.J) .AND. (FLAG(J).NE.I)) THEN
                IPE(I) = IPE(I) - 1
                IW(IPE(I)) = J
                IPE(J) = IPE(J) - 1
                IW(IPE(J)) = I
                FLAG(J) = I
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_132
      SUBROUTINE DAGMG_MUMPS_133(N, NZ, NELT, NELNOD,                        &
     & XELNOD, ELNOD, XNODEL, NODEL,                                    &
     & PERM, LEN, FLAG)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER PERM(N)
      INTEGER LEN(N)
      INTEGER XNODEL(N+1), NODEL(NELNOD), FLAG(N)
      INTEGER I,J,K1,K2,K3
      FLAG(1:N) = 0
      LEN(1:N) = 0
      DO I = 1,N
        DO K1 = XNODEL(I),XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2),XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF ((I.NE.J) .AND. (FLAG(J).NE.I)) THEN
                IF (PERM(J).GT.PERM(I)) THEN
                  LEN(I) = LEN(I) + 1
                  FLAG(J) = I
                ENDIF
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      NZ = 0
      DO I = 1,N
        NZ = NZ + LEN(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_133
      SUBROUTINE DAGMG_MUMPS_134(N, NZ, NELT, NELNOD,                        &
     & XELNOD, ELNOD, XNODEL, NODEL,                                    &
     & PERM, IW, LW, IPE, LEN, FLAG, IWFR)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD,LW,IWFR
      INTEGER  XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER PERM(N)
      INTEGER IPE(N), LEN(N)
      INTEGER XNODEL(N+1), NODEL(NELNOD), IW(LW),                       &
     &          FLAG(N)
      INTEGER I,J,K1,K2,K3
      IWFR = 0
      DO I = 1,N
        IWFR = IWFR + LEN(I) + 1
        IPE(I) = IWFR
      ENDDO
      IWFR = IWFR + 1
      FLAG(1:N) = 0
      DO I = 1,N
        DO K1 = XNODEL(I),XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2),XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF ((I.NE.J) .AND. (FLAG(J).NE.I)) THEN
                IF (PERM(J).GT.PERM(I)) THEN
                  IW(IPE(I)) = J
                  IPE(I) = IPE(I) - 1
                  FLAG(J) = I
                ENDIF
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      DO I = 1,N
        J = IPE(I)
        IW(J) = LEN(I)
        IF (LEN(I).EQ.0) IPE(I) = 0
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_134
      SUBROUTINE DAGMG_MUMPS_25( MYID, SLAVEF, N,                            &
     &           PROCNODE, STEP, PTRAIW, PTRARW,                        &
     &           NELT, FRTPTR, FRTELT,                                  &
     &           KEEP,KEEP8, ICNTL, SYM )
      IMPLICIT NONE
      INTEGER MYID, SLAVEF, N, NELT, SYM
      INTEGER KEEP( 500 ), ICNTL( 40 )
      INTEGER*8 KEEP8(150)
      INTEGER PTRAIW( NELT+1 ), PTRARW( NELT+1 )
      INTEGER STEP( N )
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER PROCNODE( KEEP(28) )
      INTEGER MASTER
      PARAMETER (MASTER=0)
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      INTEGER ELT, I, K, IPTRI, IPTRR, NVAR
      INTEGER TYPE_PARALL, ITYPE, IRANK
      TYPE_PARALL = KEEP(46)
      PTRAIW( 1:NELT ) = 0
      DO I = 1, N
        IF (STEP(I).LT.0) CYCLE
        ITYPE = AGMG_MUMPS_330( abs(STEP(I)), PROCNODE, SLAVEF )
        IRANK = AGMG_MUMPS_275( abs(STEP(I)), PROCNODE, SLAVEF )
        IF ( TYPE_PARALL .eq. 0 ) THEN
          IRANK = IRANK + 1
        END IF
        IF ( (ITYPE .EQ. 2) .OR.                                        &
     &       (ITYPE .EQ. 1 .AND. IRANK .EQ. MYID) ) THEN
          DO K = FRTPTR(I),FRTPTR(I+1)-1
            ELT = FRTELT(K)
            PTRAIW( ELT ) = PTRARW(ELT+1) - PTRARW(ELT)
          ENDDO
        ELSE
        END IF
      END DO
      IPTRI = 1
      DO ELT = 1,NELT
        NVAR = PTRAIW( ELT )
        PTRAIW( ELT ) = IPTRI
        IPTRI = IPTRI + NVAR
      ENDDO
      PTRAIW( NELT+1 ) = IPTRI
      KEEP( 14 ) = IPTRI - 1
      IF ( .TRUE. ) THEN
        IF (SYM .EQ. 0) THEN
          IPTRR = 1
          DO ELT = 1,NELT
            NVAR = PTRAIW( ELT+1 ) - PTRAIW( ELT )
            PTRARW( ELT ) = IPTRR
            IPTRR = IPTRR + NVAR*NVAR
          ENDDO
          PTRARW( NELT+1 ) = IPTRR
        ELSE
          IPTRR = 1
          DO ELT = 1,NELT
            NVAR = PTRAIW( ELT+1 ) - PTRAIW( ELT )
            PTRARW( ELT ) = IPTRR
            IPTRR = IPTRR + (NVAR*(NVAR+1))/2
          ENDDO
          PTRARW( NELT+1 ) = IPTRR
        ENDIF
      ELSE
        IF (SYM .EQ. 0) THEN
          IPTRR = 1
          DO ELT = 1,NELT
            NVAR = PTRARW( ELT+1 ) - PTRARW( ELT )
            PTRARW( ELT ) = IPTRR
            IPTRR = IPTRR + NVAR*NVAR
          ENDDO
          PTRARW( NELT+1 ) = IPTRR
        ELSE
          IPTRR = 1
          DO ELT = 1,NELT
            NVAR = PTRARW( ELT+1 ) - PTRARW( ELT )
            PTRARW( ELT ) = IPTRR
            IPTRR = IPTRR + (NVAR*(NVAR+1))/2
          ENDDO
          PTRARW( NELT+1 ) = IPTRR
        ENDIF
      ENDIF
      KEEP( 13 ) = IPTRR - 1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_25
      SUBROUTINE DAGMG_MUMPS_120( N, NELT, ELTPROC, SLAVEF, PROCNODE )
      IMPLICIT NONE
      INTEGER N, NELT, SLAVEF
      INTEGER PROCNODE( N ), ELTPROC( NELT )
      INTEGER ELT, I, ITYPE, AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      DO ELT = 1, NELT
          I = ELTPROC(ELT)
          IF ( I .NE. 0) THEN
           ITYPE = AGMG_MUMPS_330(I,PROCNODE,SLAVEF)
           IF (ITYPE.EQ.1) THEN
             ELTPROC(ELT) = AGMG_MUMPS_275(I,PROCNODE,SLAVEF)
           ELSE IF (ITYPE.EQ.2) THEN
             ELTPROC(ELT) = -1
           ELSE
            ELTPROC(ELT) = -2
           ENDIF
          ELSE
           ELTPROC(ELT) = -3
          ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_120
      SUBROUTINE DAGMG_MUMPS_153(N, NELT, NELNOD, FRERE, FILS, NA, NE,       &
     &           XNODEL, NODEL, FRTPTR, FRTELT, ELTNOD)
      IMPLICIT NONE
      INTEGER  N, NELT, NELNOD
      INTEGER  FRERE(N), FILS(N), NA(N), NE(N)
      INTEGER  FRTPTR(N+1), FRTELT(NELT), ELTNOD(NELT)
      INTEGER  XNODEL(N+1), NODEL(NELNOD)
      INTEGER TNSTK( N ), IPOOL( N )
      INTEGER I, K, IFATH
      INTEGER INODE, LEAF, NBLEAF, NBROOT, III, IN
      TNSTK = NE
      LEAF = 1
      IF (N.EQ.1) THEN
        NBROOT = 1
        NBLEAF = 1
        IPOOL(1) = 1
        LEAF = LEAF + 1
      ELSEIF (NA(N).LT.0) THEN
        NBLEAF = N
        NBROOT = N
        DO 20 I=1,NBLEAF-1
           INODE = NA(I)
           IPOOL(LEAF) = INODE
           LEAF        = LEAF + 1
   20   CONTINUE
        INODE = -NA(N)-1
        IPOOL(LEAF) = INODE
        LEAF        = LEAF + 1
      ELSEIF (NA(N-1).LT.0) THEN
        NBLEAF = N-1
        NBROOT = NA(N)
        IF (NBLEAF-1.GT.0) THEN
         DO 30 I=1,NBLEAF-1
          INODE = NA(I)
          IPOOL(LEAF) = INODE
          LEAF        = LEAF + 1
   30    CONTINUE
        ENDIF
        INODE = -NA(N-1)-1
        IPOOL(LEAF) = INODE
        LEAF        = LEAF + 1
      ELSE
        NBLEAF = NA(N-1)
        NBROOT = NA(N)
        DO 40 I = 1,NBLEAF
          INODE = NA(I)
          IPOOL(LEAF) = INODE
          LEAF        = LEAF + 1
   40   CONTINUE
      ENDIF
      ELTNOD(1:NELT) = 0
      III = 1
   90 CONTINUE
        IF (III.NE.LEAF) THEN
           INODE=IPOOL(III)
           III = III + 1
        ELSE
           WRITE(6,*) ' ERROR 1 in file DMUMPS_153 '
           CALL AGMG_MUMPS_ABORT()
        ENDIF
   95   CONTINUE
        IN = INODE
  100   CONTINUE
        DO K = XNODEL(IN),XNODEL(IN+1)-1
          I = NODEL(K)
          IF (ELTNOD(I).EQ.0) ELTNOD(I) = INODE
        ENDDO
        IN = FILS(IN)
        IF (IN .GT. 0 ) GOTO 100
        IN = INODE
  110   IN = FRERE(IN)
        IF (IN.GT.0) GO TO 110
        IF (IN.EQ.0) THEN
         NBROOT = NBROOT - 1
         IF (NBROOT.EQ.0) GOTO 115
         GOTO 90
        ELSE
         IFATH = -IN
        ENDIF
        TNSTK(IFATH) = TNSTK(IFATH) - 1
        IF ( TNSTK(IFATH) .EQ. 0 ) THEN
            INODE = IFATH
            GOTO 95
        ELSE
            GOTO 90
        ENDIF
  115 CONTINUE
      FRTPTR(1:N) = 0
      DO I = 1,NELT
        IF (ELTNOD(I) .NE. 0) THEN
         FRTPTR(ELTNOD(I)) = FRTPTR(ELTNOD(I)) + 1
        ENDIF
      ENDDO
      K = 1
      DO I = 1,N
        K = K + FRTPTR(I)
        FRTPTR(I) = K
      ENDDO
      FRTPTR(N+1) = FRTPTR(N)
      DO K = 1,NELT
        INODE = ELTNOD(K)
        IF (INODE .NE. 0) THEN
         FRTPTR(INODE) = FRTPTR(INODE) - 1
         FRTELT(FRTPTR(INODE)) = K
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_153
      SUBROUTINE DAGMG_MUMPS_130(N, NZ, NELT, NELNOD,                        &
     &  XELNOD, ELNOD, XNODEL, NODEL,                                   &
     &  LEN, LW, IW)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD,LW
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER LEN(N)
      INTEGER XNODEL(N+1), NODEL(NELNOD),                               &
     &        IW(LW)
      INTEGER I,J,K1,K2,K3,LP,NSUP,SUPVAR
      INTEGER INFO44(6)
      EXTERNAL DAGMG_MUMPS_315
      LP = 6
      CALL DAGMG_MUMPS_315(N,NELT,XELNOD(NELT+1)-1,ELNOD,XELNOD,             &
     &           NSUP,IW(3*N+3+1),3*N+3,IW,LP,INFO44)
      IF (INFO44(1) .LT. 0) THEN
        IF (LP.GE.0) WRITE(LP,*)                                        &
     &     'Error return from DMUMPS_315. INFO(1) = ',INFO44(1)
      ENDIF
      IW(1:NSUP) = 0
      LEN(1:N) = 0
      DO I = 1,N
        SUPVAR = IW(3*N+3+1+I)
        IF (SUPVAR .EQ. 0) CYCLE
        IF (IW(SUPVAR).NE.0) THEN
          LEN(I) = -IW(SUPVAR)
        ELSE
          IW(SUPVAR) = I
        ENDIF
      ENDDO
      IW(N+1:2*N) = 0
      NZ = 0
      DO SUPVAR = 1,NSUP
        I = IW(SUPVAR)
        DO K1 = XNODEL(I),XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2),XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF (LEN(J).GE.0) THEN
                IF ((I.NE.J) .AND. (IW(N+J).NE.I)) THEN
                  IW(N+J) = I
                  LEN(I) = LEN(I) + 1
                ENDIF
              ENDIF
            ENDIF
          ENDDO
        ENDDO
        NZ = NZ + LEN(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_130
      SUBROUTINE DAGMG_MUMPS_131(N, NZ, NELT, NELNOD,                        &
     &  XELNOD, ELNOD, XNODEL, NODEL,                                   &
     &  IW, LW, IPE, LEN, FLAG, IWFR)
      IMPLICIT NONE
      INTEGER N,NZ,NELT,NELNOD,LW,IWFR
      INTEGER XELNOD(NELT+1), ELNOD(NELNOD)
      INTEGER LEN(N)
      INTEGER IPE(N)
      INTEGER XNODEL(N+1), NODEL(NELNOD),                               &
     &          IW(LW), FLAG(N)
      INTEGER I,J,K1,K2,K3
      IWFR = 1
      DO I = 1,N
        IF (LEN(I).GT.0) THEN
          IWFR = IWFR + LEN(I)
          IPE(I) = IWFR
        ELSE
          IPE(I) = 0
        ENDIF
      ENDDO
      FLAG(1:N) = 0
      DO I = 1,N
        IF (LEN(I).LE.0) CYCLE
        DO K1 = XNODEL(I), XNODEL(I+1)-1
          K2 = NODEL(K1)
          DO K3 = XELNOD(K2), XELNOD(K2+1)-1
            J = ELNOD(K3)
            IF ((J.GE.1) .AND. (J.LE.N)) THEN
              IF (LEN(J) .GT. 0) THEN
                IF ((I.NE.J) .AND. (FLAG(J).NE.I)) THEN
                  IPE(I) = IPE(I) - 1
                  IW(IPE(I)) = J
                  FLAG(J) = I
                ENDIF
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_131
      SUBROUTINE DAGMG_MUMPS_315(N,NELT,NZ,ELTVAR,ELTPTR,NSUP,SVAR,          &
     &                 LIW,IW,LP,INFO)
      INTEGER LIW,LP,N,NELT,NSUP,NZ
      INTEGER INFO(6)
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ)
      INTEGER IW(LIW),SVAR(0:N)
      INTEGER FLAG,NEW,VARS
      EXTERNAL DAGMG_MUMPS_316
      INFO(1) = 0
      INFO(2) = 0
      INFO(3) = 0
      INFO(4) = 0
      IF (N.LT.1) GO TO 10
      IF (NELT.LT.1) GO TO 20
      IF (NZ.LT.ELTPTR(NELT+1)-1) GO TO 30
      IF (LIW.LT.6) THEN
         INFO(4) = 3*N + 3
         GO TO 40
      END IF
      NEW = 1
      VARS = NEW + LIW/3
      FLAG = VARS + LIW/3
      CALL DAGMG_MUMPS_316(N,NELT,ELTPTR,NZ,ELTVAR,SVAR,NSUP,LIW/3-1,        &
     &           IW(NEW),IW(VARS),IW(FLAG),INFO)
      IF (INFO(1).EQ.-4) THEN
         INFO(4) = 3*N + 3
         GO TO 40
      ELSE
         INFO(4) = 3*NSUP + 3
      END IF
      GO TO 50
   10 INFO(1) = -1
      IF (LP.GT.0) WRITE (LP,FMT=9000) INFO(1)
      GO TO 50
   20 INFO(1) = -2
      IF (LP.GT.0) WRITE (LP,FMT=9000) INFO(1)
      GO TO 50
   30 INFO(1) = -3
      IF (LP.GT.0) WRITE (LP,FMT=9000) INFO(1)
      GO TO 50
   40 INFO(1) = -4
      IF (LP.GT.0) THEN
         WRITE (LP,FMT=9000) INFO(1)
         WRITE (LP,FMT=9010) INFO(4)
      END IF
   50 RETURN
 9000 FORMAT (/3X,'Error message from DMUMPS_315: INFO(1) = ',I2)
 9010 FORMAT (3X,'LIW is insufficient. Upper bound on required work',   &
     &       'space is ',I8)
      END SUBROUTINE DAGMG_MUMPS_315
      SUBROUTINE DAGMG_MUMPS_316( N, NELT, ELTPTR, NZ, ELTVAR,               &
     &           SVAR, NSUP, MAXSUP, NEW, VARS, FLAG, INFO )
      INTEGER MAXSUP,N,NELT,NSUP,NZ
      INTEGER ELTPTR(NELT+1),ELTVAR(NZ)
      INTEGER INFO(6)
      INTEGER FLAG(0:MAXSUP), NEW(0:MAXSUP),SVAR(0:N),                  &
     &          VARS(0:MAXSUP)
      INTEGER I,IS,J,JS,K,K1,K2
      DO 10 I = 0,N
         SVAR(I) = 0
   10 END DO
      VARS(0) = N + 1
      NEW(0) = -1
      FLAG(0) = 0
      NSUP = 0
      DO 40 J = 1,NELT
         K1 = ELTPTR(J)
         K2 = ELTPTR(J+1) - 1
         DO 20 K = K1,K2
            I = ELTVAR(K)
            IF (I.LT.1 .OR. I.GT.N) THEN
               INFO(2) = INFO(2) + 1
               GO TO 20
            END IF
            IS = SVAR(I)
            IF (IS.LT.0) THEN
               ELTVAR(K) = 0
               INFO(3) = INFO(3) + 1
               GO TO 20
            END IF
            SVAR(I) = SVAR(I) - N - 2
            VARS(IS) = VARS(IS) - 1
   20    CONTINUE
         DO 30 K = K1,K2
            I = ELTVAR(K)
            IF (I.LT.1 .OR. I.GT.N) GO TO 30
            IS = SVAR(I) + N + 2
            IF (FLAG(IS).LT.J) THEN
               FLAG(IS) = J
               IF (VARS(IS).GT.0) THEN
                  NSUP = NSUP + 1
                  IF (NSUP.GT.MAXSUP) THEN
                     INFO(1) = -4
                     RETURN
                  END IF
                  VARS(NSUP) = 1
                  FLAG(NSUP) = J
                  NEW(IS) = NSUP
                  SVAR(I) = NSUP
               ELSE
                  VARS(IS) = 1
                  NEW(IS) = IS
                  SVAR(I) = IS
               END IF
            ELSE
               JS = NEW(IS)
               VARS(JS) = VARS(JS) + 1
               SVAR(I) = JS
            END IF
   30    CONTINUE
   40 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_316
      SUBROUTINE DAGMG_MUMPS_36( COMM_LOAD, ASS_IRECV,                       &
     &    NELT, FRT_PTR, FRT_ELT,                                       &
     &    N, INODE, IW, LIW, A, LA, IFLAG,                              &
     &    IERROR, ND,                                                   &
     &    FILS, FRERE, MAXFRW, root,                                    &
     &    OPASSW, OPELIW, PTRIST, PTLUST_S, PTRFAC, PTRAST,             &
     &    STEP, PIMASTER, PAMASTER,PTRARW,                              &
     &    PTRAIW, ITLOC, NSTEPS, SON_LEVEL2,                            &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP,KEEP8,INTARR,DBLARR,                              &
     &    NSTK_S,NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM,MYID,         &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER IZERO
      PARAMETER (IZERO=0)
      INTEGER NELT,N,LIW,NSTEPS
      INTEGER(8) LA, LRLU, LRLUS, IPTRLU, POSFAC
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER IFLAG,IERROR,INODE,MAXFRW,                                &
     &        IWPOS, IWPOSCB, COMP, IERR_MPI
      INTEGER IDUMMY(1)
      INTEGER IW(LIW), ITLOC(N),                                        &
     &        PTRARW(NELT+1), PTRAIW(NELT+1), ND(KEEP(28)), PERM(N),    &
     &        FILS(N), FRERE(KEEP(28)),                                 &
     &        PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N), PIMASTER(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28)), PTRAST(KEEP(28)),                 &
     &              PAMASTER(KEEP(28))
      INTEGER COMM, NBFIN, SLAVEF, MYID
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      LOGICAL SON_LEVEL2
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION  OPASSW, OPELIW
      INTEGER FRT_PTR(N+1), FRT_ELT(NELT)
      INTEGER        INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER LPOOL, LEAF
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER IPOOL( LPOOL )
      INTEGER NBPROCFILS(KEEP(28)), NSTK_S(KEEP(28))
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER BUFR( LBUFR )
      INTEGER ETATASS
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL COMPRESSCB
      INTEGER(8) :: LCB
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTEGER LP, HS, HF
      INTEGER IN,NUMSTK,NASS,ISON,IFSON,NASS1,IELL
      INTEGER NFS4FATHER
      INTEGER NFRONT,NFRONT_EFF,ISTCHK,LSTK,LREQ
      INTEGER(8) NFRONT8
      INTEGER(8) LAELL8, APOS, APOS2, LAPOS2
      INTEGER(8) POSELT, POSEL1, ICT12, ICT21
      INTEGER(8) IACHK
      INTEGER(8) JJ8, JJ2
      INTEGER(8) LSTK8, SIZFR8
      INTEGER NBPANELS_L, NBPANELS_U, LREQ_OOC
      INTEGER SIZFI, NCB
      INTEGER JJ,J1,J2
      INTEGER NCOL, NROW, NCOLS, NROWS, LDA_SON
      INTEGER NELIM,JJ1,J3,                                             &
     &        IORG
      INTEGER JPOS,ICT11
      INTEGER JK,IJROW,NBCOL,NUMORG,IOLDPS,J4,                          &
     &        NUMELT, ELBEG
      INTEGER AINPUT,                                                   &
     &        AII, J
      INTEGER NSLAVES, NSLSON, NPIVS, NPIV_ANA, NPIV
      INTEGER PTRCOL, ISLAVE, PDEST,LEVEL
      LOGICAL LEVEL1, NIV1
      INTEGER TROW_SIZE, INDX, FIRST_INDEX, SHIFT_INDEX
      INTEGER ELTI, SIZE_ELTI
      INTEGER II, K, I
      LOGICAL FLAG, BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER NCBSON
      LOGICAL FREE, SAME_PROC
      INTRINSIC real
      DOUBLE PRECISION ZERO
      DATA ZERO /0.0D0/
      LOGICAL  AGMG_MUMPS_167, SSARBR
      EXTERNAL AGMG_MUMPS_167
      DOUBLE PRECISION FLOP1,FLOP1_EFF
      EXTERNAL AGMG_MUMPS_170
      LOGICAL AGMG_MUMPS_170
      NFS4FATHER = -1
      ETATASS    = 0
      COMPRESSCB=.FALSE.
      IN = INODE
      NBPROCFILS(STEP(IN)) = 0
      LEVEL = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      IF (LEVEL.NE.1) THEN
       write(6,*) 'Error1 in mpi51f_niv1 '
       CALL AGMG_MUMPS_ABORT()
      END IF
      NSLAVES = 0
      HF = 6 + NSLAVES + KEEP(IXSZ)
      NUMELT = FRT_PTR(INODE+1) - FRT_PTR(INODE)
      IF ( NUMELT .ne. 0 ) THEN
        ELBEG  = FRT_PTR(INODE)
      ELSE
        ELBEG  = 1
      END IF
      NUMORG = 0
      DO WHILE (IN.GT.0)
        NUMORG = NUMORG + 1
        IN = FILS(IN)
      END DO
      NPIV_ANA=NUMORG
      NSTEPS = NSTEPS + 1
      NUMSTK = 0
      NASS = 0
      IFSON = -IN
      ISON = IFSON
      DO WHILE (ISON .GT. 0)
         NUMSTK = NUMSTK + 1
         NASS = NASS + IW(PIMASTER(STEP(ISON)) + 1 + KEEP(IXSZ))
         ISON = FRERE(STEP(ISON))
      END DO
      NFRONT = ND(STEP(INODE)) + NASS
      NASS1 = NASS + NUMORG
      LREQ_OOC = 0
      IF (KEEP(201).EQ.1) THEN
        CALL DAGMG_MUMPS_684(KEEP(50), NFRONT, NFRONT, NASS1,                &
     &       NBPANELS_L, NBPANELS_U, LREQ_OOC)
      ENDIF
      LREQ = HF + 2 * NFRONT + LREQ_OOC
      IF ((IWPOS + LREQ -1) .GT. IWPOSCB) THEN
          CALL DAGMG_MUMPS_94(N, KEEP(28),                                   &
     &        IW, LIW, A, LA,                                           &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
          COMP = COMP+1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv1.F'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 270
          END IF
          IF ((IWPOS + LREQ -1) .GT. IWPOSCB) GOTO 270
      END IF
      IOLDPS = IWPOS
      IWPOS = IWPOS + LREQ
      NIV1 = .TRUE.
      IF (KEEP(50).EQ.0) THEN
        CALL  AGMG_MUMPS_124(                                                &
     &        NUMELT, FRT_ELT(ELBEG),                                   &
     &        MYID, INODE, N, IOLDPS, HF, NFRONT, NFRONT_EFF,           &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, NELT, IW, LIW,             &
     &        INTARR, KEEP(14), ITLOC, FILS, FRERE,                     &
     &        KEEP,                                                     &
     &        SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
      ELSE
        CALL AGMG_MUMPS_125(                                                 &
     &        NUMELT, FRT_ELT(ELBEG),                                   &
     &        MYID, INODE, N, IOLDPS, HF,                               &
     &        NFRONT, NFRONT_EFF, PERM,                                 &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, NELT, IW, LIW,             &
     &        INTARR, KEEP(14), ITLOC, FILS, FRERE,                     &
     &        KEEP,                                                     &
     &        SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
        IF (IFLAG.LT.0) GOTO 300
      END IF
      IF (NFRONT_EFF.NE.NFRONT) THEN
        IF (NFRONT.GT.NFRONT_EFF) THEN
           IF(AGMG_MUMPS_170(STEP(INODE),PROCNODE_STEPS,                     &
     &          SLAVEF))THEN
              NPIV=NASS1-(NFRONT_EFF-ND(STEP(INODE)))
              CALL AGMG_MUMPS_511(ND(STEP(INODE)),NPIV,NPIV,                 &
     &                                 KEEP(50),1,FLOP1)
              NPIV=NPIV_ANA
              CALL AGMG_MUMPS_511(ND(STEP(INODE)),NPIV,NPIV,                 &
     &                                 KEEP(50),1,FLOP1_EFF)
              CALL DAGMG_MUMPS_190(0,.FALSE.,FLOP1-FLOP1_EFF,                &
     &             KEEP,KEEP8)
           ENDIF
        IWPOS = IWPOS - ((2*NFRONT)-(2*NFRONT_EFF))
        NFRONT = NFRONT_EFF
        LREQ = HF + 2 * NFRONT + LREQ_OOC
        ELSE
         Write(*,*) ' ERROR 1 during ass_niv1_ELT'
         GOTO 270
        ENDIF
      ENDIF
      IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_691(KEEP(50),                                       &
     &       NBPANELS_L, NBPANELS_U, NASS1,                             &
     &       IOLDPS + HF + 2 * NFRONT, IW, LIW)
      ENDIF
      NCB   = NFRONT - NASS1
      MAXFRW = max0(MAXFRW, NFRONT)
      ICT11 = IOLDPS + HF - 1 + NFRONT
      NFRONT8=int(NFRONT,8)
      LAELL8 = NFRONT8*NFRONT8
      IF (LRLU .LT. LAELL8) THEN
        IF (LRLUS .LT. LAELL8) THEN
          GOTO 280
        ELSE
          CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                   &
     &         LRLU, IPTRLU,                                            &
     &         IWPOS, IWPOSCB, PTRIST, PTRAST,                          &
     &         STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,         &
     &         KEEP(IXSZ))
          COMP = COMP + 1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv1.F'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 280
          END IF
        END IF
      END IF
      LRLU = LRLU - LAELL8
      LRLUS = LRLUS - LAELL8
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSELT = POSFAC
      POSFAC = POSFAC + LAELL8
      SSARBR=AGMG_MUMPS_167(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      CALL DAGMG_MUMPS_471(SSARBR,.FALSE.,LA-LRLUS,0_8,LAELL8,               &
     &    KEEP,KEEP8,                                                   &
     &     LRLU)
      LAPOS2 = POSELT + LAELL8 - 1_8
      A(POSELT:LAPOS2) = dble(ZERO)
      NASS = NASS1
      PTRAST(STEP(INODE)) = POSELT
      PTRFAC(STEP(INODE)) = POSELT
      PTLUST_S(STEP(INODE)) = IOLDPS
      IW(IOLDPS+XXI) = LREQ
      CALL AGMG_MUMPS_730(LAELL8,IW(IOLDPS+XXR))
      IW(IOLDPS+XXS) =-9999
      IW(IOLDPS+XXS+1:IOLDPS+KEEP(IXSZ)-1)=-99999
      IW(IOLDPS+KEEP(IXSZ))   = NFRONT
      IW(IOLDPS+KEEP(IXSZ)+ 1) = 0
      IW(IOLDPS+KEEP(IXSZ) + 2) = -NASS1
      IW(IOLDPS+KEEP(IXSZ) + 3) = -NASS1
      IW(IOLDPS+KEEP(IXSZ) + 4) = STEP(INODE)
      IW(IOLDPS+KEEP(IXSZ)+5)   = NSLAVES
      IF (NUMSTK.NE.0) THEN
        ISON = IFSON
        DO 220 IELL = 1, NUMSTK
          ISTCHK    = PIMASTER(STEP(ISON))
          LSTK      = IW(ISTCHK+KEEP(IXSZ))
          LSTK8     = int(LSTK,8)
          NELIM     = IW(ISTCHK + 1+KEEP(IXSZ))
          NPIVS     = IW(ISTCHK + 3+KEEP(IXSZ))
          IF ( NPIVS .LT. 0 ) NPIVS = 0
          NSLSON    = IW(ISTCHK + 5+KEEP(IXSZ))
          HS        = 6 + NSLSON + KEEP(IXSZ)
          NCOLS     = NPIVS + LSTK
          SAME_PROC     = (ISTCHK.LE.IWPOS)
          IF ( SAME_PROC ) THEN
             COMPRESSCB =                                               &
     &           ( IW(PTRIST(STEP(ISON))+XXS) .EQ. S_CB1COMP )
          ELSE
             COMPRESSCB =  ( IW(ISTCHK + XXS) .EQ. S_CB1COMP )
          ENDIF
          LEVEL1    = NSLSON.EQ.0
          IF (.NOT.SAME_PROC) THEN
           NROWS = IW( ISTCHK + 2+KEEP(IXSZ))
          ELSE
           NROWS = NCOLS
          ENDIF
          SIZFI   = HS + NROWS + NCOLS
          J1 = ISTCHK + HS + NROWS + NPIVS
          IF ( .NOT. LEVEL1 .AND. NELIM.EQ.0 ) GOTO 205
          IF (LEVEL1) THEN
           J2 = J1 + LSTK - 1
           IF (COMPRESSCB) THEN
             SIZFR8 = (LSTK8*(LSTK8+1_8)/2_8)
           ELSE
             SIZFR8 = LSTK8*LSTK8
           ENDIF
          ELSE
           IF ( KEEP(50).eq.0 ) THEN
             SIZFR8 = int(NELIM,8) * LSTK8
           ELSE
             SIZFR8 = int(NELIM,8) * int(NELIM,8)
           END IF
           J2 = J1 + NELIM - 1
          ENDIF
          OPASSW = OPASSW + dble(SIZFR8)
          IACHK = PAMASTER(STEP(ISON))
          IF ( KEEP(50) .eq. 0 ) THEN
            POSEL1 = PTRAST(STEP(INODE)) - NFRONT8
            IF (J2.GE.J1) THEN
              DO 170 JJ = J1, J2
                APOS = POSEL1 + int(IW(JJ),8) * NFRONT8
                DO 160 JJ1 = 1, LSTK
                  JJ2 = APOS + int(IW(J1 + JJ1 - 1) - 1,8)
                  A(JJ2) = A(JJ2) + A(IACHK + int(JJ1 - 1,8))
  160           CONTINUE
                IACHK = IACHK + LSTK8
  170         CONTINUE
            END IF
          ELSE
            IF (LEVEL1) THEN
             LDA_SON = LSTK
            ELSE
             LDA_SON = NELIM
            ENDIF
            IF (COMPRESSCB) THEN
              LCB = SIZFR8
            ELSE
              LCB = int(LDA_SON,8)*int(J2 - J1 + 1,8)
            ENDIF
            CALL DAGMG_MUMPS_178(A, LA,                                      &
     &           PTRAST(STEP( INODE )), NFRONT, NASS1,                  &
     &           IACHK, LDA_SON, LCB,                                   &
     &           IW( J1 ), J2 - J1 + 1, NELIM, ETATASS,                 &
     &           COMPRESSCB,                                            &
     &           .FALSE.                                                &
     &          )
          ENDIF
  205     IF (LEVEL1) THEN
           IF (SAME_PROC) ISTCHK = PTRIST(STEP(ISON))
           IF (SAME_PROC) THEN
             IF (KEEP(50).NE.0) THEN
              J2 = J1 + LSTK - 1
              DO JJ = J1, J2
               IW(JJ) = IW(JJ - NROWS)
              END DO
             ELSE
              J2 = J1 + LSTK - 1
              J3 = J1 + NELIM
              DO JJ = J3, J2
               IW(JJ) = IW(JJ - NROWS)
              END DO
              IF (NELIM .NE. 0) THEN
                J3 = J3 - 1
                DO JJ = J1, J3
                 JPOS = IW(JJ) + ICT11
                 IW(JJ) = IW(JPOS)
                END DO
              ENDIF
             ENDIF
           ENDIF
           IF ( SAME_PROC ) THEN
               PTRIST(STEP( ISON )) = -99999999
           ELSE
               PIMASTER(STEP( ISON )) = -99999999
           ENDIF
           CALL DAGMG_MUMPS_152(SSARBR, MYID, N, ISTCHK,                     &
     &     IACHK,                                                       &
     &     IW, LIW, LRLU, LRLUS, IPTRLU,                                &
     &     IWPOSCB, LA, KEEP,KEEP8, .FALSE.                             &
     &     )
          ELSE
           PDEST = ISTCHK + 6 + KEEP(IXSZ)
           NCBSON  = LSTK - NELIM
           PTRCOL   = ISTCHK +  HS + NROWS + NPIVS + NELIM
           DO ISLAVE = 0, NSLSON-1
             IF (IW(PDEST+ISLAVE).EQ.MYID) THEN
              CALL AGMG_MUMPS_49(                                            &
     &                KEEP,KEEP8, ISON, STEP, N, SLAVEF,                &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE+1, NCBSON,                                 &
     &                NSLSON,                                           &
     &                TROW_SIZE, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
              INDX = PTRCOL + SHIFT_INDEX
               CALL DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,                   &
     &                           BUFR, LBUFR, LBUFR_BYTES,              &
     &                           INODE, ISON, NSLAVES, IDUMMY,          &
     &                           NFRONT, NASS1,NFS4FATHER,              &
     &         TROW_SIZE, IW( INDX ),                                   &
     &         PROCNODE_STEPS,                                          &
     &         SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,            &
     &         LRLUS, N, IW,                                            &
     &         LIW, A, LA,                                              &
     &         PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                  &
     &         PIMASTER, PAMASTER, NSTK_S, COMP,                        &
     &         IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL,     &
     &         LEAF, NBFIN, ICNTL, KEEP,KEEP8, root,                    &
     &         OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,             &
     &         INTARR, DBLARR, ND, FRERE,                               &
     &         NELT+1, NELT, FRT_PTR, FRT_ELT,                          &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE                          &
     &         )
               IF ( IFLAG .LT. 0 ) GOTO 500
               EXIT
             ENDIF
           END DO
           IF (PIMASTER(STEP(ISON)).GT.0) THEN
           IERR = -1
           DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON)) + HS + NROWS + NPIVS + NELIM
            PDEST  = PIMASTER(STEP(ISON)) + 6 + KEEP(IXSZ)
            CALL  DAGMG_MUMPS_71( INODE, NFRONT,                             &
     &       NASS1, NFS4FATHER,ISON, MYID,                              &
     &       IZERO, IDUMMY, IW(PTRCOL), NCBSON,                         &
     &       COMM, IERR, IW(PDEST), NSLSON,                             &
     &       SLAVEF,                                                    &
     &       KEEP,KEEP8, STEP, N,                                       &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE                            &
     &       )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                     &
     &         BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                   &
     &         AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                             &
     &         STATUS,                                                  &
     &         BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,        &
     &         IWPOS, IWPOSCB, IPTRLU,                                  &
     &         LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                  &
     &         PTLUST_S, PTRFAC,                                        &
     &         PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,          &
     &         IFLAG, IERROR, COMM,                                     &
     &         NBPROCFILS,                                              &
     &         IPOOL, LPOOL, LEAF,                                      &
     &         NBFIN, MYID, SLAVEF,                                     &
     &         root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,       &
     &         INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,            &
     &         NELT+1, NELT, FRT_PTR, FRT_ELT,                          &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
               IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
           END DO
           IF (IERR .EQ. -2) GOTO 290
           IF (IERR .EQ. -3) GOTO 295
           ENDIF
          ENDIF
  210   ISON = FRERE(STEP(ISON))
  220 END DO
      END IF
      DO IELL=ELBEG,ELBEG+NUMELT-1
        ELTI = FRT_ELT(IELL)
        J1= PTRAIW(ELTI)
        J2= PTRAIW(ELTI+1)-1
        AII = PTRARW(ELTI)
        SIZE_ELTI = J2 - J1 + 1
        DO II=J1,J2
         I = INTARR(II)
         IF (KEEP(50).EQ.0) THEN
          AINPUT    = AII + II - J1
          ICT12 = POSELT + int(I-1,8) * NFRONT8
          DO JJ=J1,J2
           APOS2 = ICT12 + int(INTARR(JJ) - 1,8)
           A(APOS2) = A(APOS2) + DBLARR(AINPUT)
           AINPUT = AINPUT + SIZE_ELTI
          END DO
         ELSE
          ICT12 = POSELT + int(- NFRONT + I - 1,8)
          ICT21 = POSELT + int(I-1,8)*NFRONT8 - 1_8
          DO JJ=II,J2
           J =  INTARR(JJ)
           IF (I.LT.J) THEN
              APOS2 = ICT12 + int(J,8)*NFRONT8
           ELSE
              APOS2 = ICT21 + int(J,8)
           ENDIF
           A(APOS2) = A(APOS2) + DBLARR(AII)
           AII = AII + 1
          END DO
         END IF
        END DO
      END DO
      GOTO 500
  270 CONTINUE
      IFLAG = -8
      IERROR = LREQ
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE IN INTEGER ALLOCATION DURING DMUMPS_36'
      ENDIF
      GOTO 490
  280 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, WORKSPACE TOO SMALL DURING DMUMPS_36'
      ENDIF
      IFLAG = -9
      CALL AGMG_MUMPS_731(LAELL8-LRLUS, IERROR)
      GOTO 500
  290 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE, SEND BUFFER TOO SMALL DURING DMUMPS_36'
      ENDIF
      IFLAG = -17
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  295 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE, RECV BUFFER TOO SMALL DURING DMUMPS_36'
      ENDIF
      IFLAG = -20
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  300 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * ) ' FAILURE IN INTEGER',                           &
     &                 ' DYNAMIC ALLOCATION DURING DMUMPS_36'
      ENDIF
      IFLAG   = -13
      IERROR  = NUMSTK
  490 CALL  DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_36
      SUBROUTINE DAGMG_MUMPS_37( COMM_LOAD, ASS_IRECV,                       &
     &    NELT, FRT_PTR, FRT_ELT,                                       &
     &    N, INODE, IW, LIW, A, LA, IFLAG,                              &
     &    IERROR, ND, FILS, FRERE,                                      &
     &    CAND,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    MAXFRW, root,                                                 &
     &    OPASSW, OPELIW, PTRIST, PTLUST_S, PTRFAC,                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER, PTRARW, NSTK_S,             &
     &    PTRAIW, ITLOC, NSTEPS,                                        &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP,KEEP8,INTARR,DBLARR,                              &
     &    NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM,MYID,                &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, LEAF, IPOOL, LPOOL,          &
     &    PERM,                                                         &
     &    MEM_DISTRIB)
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE )
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER NELT, N,LIW,NSTEPS, NBFIN
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER(8) LRLU, IPTRLU, LRLUS, POSFAC, LA
      INTEGER(8) LAELL8
      INTEGER JJ
      INTEGER IFLAG,IERROR,INODE,MAXFRW,                                &
     &        LPOOL, LEAF,                                              &
     &        IWPOS,                                                    &
     &        IWPOSCB, COMP, SLAVEF
      INTEGER, DIMENSION(0:SLAVEF - 1) :: MEM_DISTRIB
      INTEGER IPOOL(LPOOL)
      INTEGER IW(LIW), ITLOC(N),                                        &
     &        PTRARW(NELT+1), PTRAIW(NELT+1), ND(KEEP(28)),             &
     &        FILS(N), FRERE(KEEP(28)), STEP(N),                        &
     &        PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     & PIMASTER(KEEP(28)),                                              &
     &        NSTK_S(KEEP(28)), PERM(N)
      INTEGER(8) :: PTRFAC(KEEP(28)), PAMASTER(KEEP(28)),               &
     &              PTRAST(KEEP(28))
      INTEGER   CAND(SLAVEF+1,max(1,KEEP(56)))
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION  OPASSW, OPELIW
      INTEGER FRT_PTR(N+1), FRT_ELT(NELT)
      INTEGER        INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER MYID, COMM
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER NBPROCFILS(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER BUFR( LBUFR )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER LP, HS, HF, HF_OLD, NSLAVES_OLD,NCBSON
      INTEGER NCBSON_MAX
      INTEGER IN,NUMSTK,NASS,ISON,IFSON,NASS1,IELL
      LOGICAL COMPRESSCB
      INTEGER(8) :: LCB
      INTEGER NFS4FATHER
      INTEGER NFRONT,NFRONT_EFF,ISTCHK,LSTK,LREQ
      INTEGER LREQ_OOC, NBPANELS_L, NBPANELS_U
      INTEGER NCB, IERR_MPI
      INTEGER J1,J2,J3
      INTEGER(8) NFRONT8, LAPOS2, POSELT, POSEL1, LDAFS8,               &
     &           JJ8, JJ2, IACHK, ICT12, ICT21
      INTEGER(8) APOS, APOS2
      INTEGER NELIM,LDAFS,JJ1,NPIVS,NCOLS,NROWS,                        &
     &        IORG
      INTEGER LDA_SON
      INTEGER JK,IJROW,NBCOL,NUMORG,IOLDPS,J4
      INTEGER AINPUT
      INTEGER NSLAVES, NSLSON
      INTEGER NBLIG, PTRCOL, PTRROW, ISLAVE, PDEST
      INTEGER ELTI, SIZE_ELTI
      INTEGER II, ELBEG, NUMELT, I, J, AII
      LOGICAL FLAG, SAME_PROC, NIV1, SON_LEVEL2
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER TROW_SIZE, INDX, FIRST_INDEX, SHIFT_INDEX
      INTEGER NSLAVES_less, ITEMP, NMB_OF_CAND
      logical :: force_cand
      INTEGER(8) APOSMAX
      DOUBLE PRECISION  MAXARR
      INTEGER INIV2, SIZE_TMP_SLAVES_LIST, allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: TMP_SLAVES_LIST
      INTEGER IZERO
      INTEGER IDUMMY(1)
      INTEGER PDEST1(1)
      INTEGER ETATASS
      PARAMETER( IZERO = 0 )
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTRINSIC real
      DOUBLE PRECISION ZERO
      DATA ZERO /0.0D0/
      COMPRESSCB=.FALSE.
      ETATASS = 0
      IN = INODE
      NBPROCFILS(STEP(IN)) = 0
      NSTEPS = NSTEPS + 1
      NUMELT = FRT_PTR(INODE+1) - FRT_PTR(INODE)
      IF ( NUMELT .NE. 0 ) THEN
        ELBEG = FRT_PTR(INODE)
      ELSE
        ELBEG = 1
      END IF
      NUMORG = 0
      DO WHILE (IN.GT.0)
        NUMORG = NUMORG + 1
        IN = FILS(IN)
      END DO
      NUMSTK = 0
      NASS = 0
      IFSON = -IN
      ISON = IFSON
      NCBSON_MAX  = 0
      DO WHILE (ISON .GT. 0)
         NUMSTK = NUMSTK + 1
         IF ( KEEP(48)==5 .AND. AGMG_MUMPS_330(STEP(ISON),                   &
     &        PROCNODE_STEPS,SLAVEF) .EQ. 1) THEN
            NCBSON_MAX =                                                &
     &      max(NCBSON_MAX,IW(PIMASTER(STEP(ISON))+KEEP(IXSZ)))
         END IF
         NASS = NASS + IW(PIMASTER(STEP(ISON)) + 1 + KEEP(IXSZ))
         ISON = FRERE(STEP(ISON))
      END DO
      NFRONT = ND(STEP(INODE)) + NASS
      MAXFRW = max0(MAXFRW, NFRONT)
      NASS1 = NASS + NUMORG
      NCB   = NFRONT - NASS1
      IF((KEEP(24).eq.0).or.(KEEP(24).eq.1)) then
         force_cand=.FALSE.
      ELSE
         force_cand=(mod(KEEP(24),2).eq.0)
      end if
      IF (force_cand) THEN
         INIV2 = ISTEP_TO_INIV2( STEP( INODE ))
         SIZE_TMP_SLAVES_LIST = CAND( SLAVEF+1, INIV2 )
      ELSE
         INIV2 = 1
         SIZE_TMP_SLAVES_LIST = SLAVEF - 1
      ENDIF
      ALLOCATE(TMP_SLAVES_LIST(SIZE_TMP_SLAVES_LIST),stat=allocok)
      IF (allocok > 0 ) THEN
        GOTO 265
      ENDIF
      CALL DAGMG_MUMPS_472( NCBSON_MAX, SLAVEF,                              &
     &     KEEP,KEEP8,ICNTL,                                            &
     &     CAND(1,INIV2),                                               &
     &     MEM_DISTRIB(0), NCB, NFRONT, NSLAVES,                        &
     &     TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),              &
     &     TMP_SLAVES_LIST,                                             &
     &     SIZE_TMP_SLAVES_LIST,INODE )
      HF   = NSLAVES + 6 + KEEP(IXSZ)
      LREQ_OOC = 0
      IF (KEEP(201).EQ.1) THEN
        CALL DAGMG_MUMPS_684(KEEP(50), NASS1, NFRONT, NASS1,                 &
     &                               NBPANELS_L, NBPANELS_U, LREQ_OOC)
      ENDIF
      LREQ = HF + 2 * NFRONT + LREQ_OOC
      IF ((IWPOS + LREQ -1) .GT. IWPOSCB) THEN
          CALL DAGMG_MUMPS_94(N, KEEP(28),                                   &
     &        IW, LIW, A, LA,                                           &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
          COMP = COMP+1
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv2'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 270
          ENDIF
          IF ((IWPOS + LREQ -1) .GT. IWPOSCB) GOTO 270
      ENDIF
      IOLDPS = IWPOS
      IWPOS = IWPOS + LREQ
      NIV1 = .FALSE.
      IF (KEEP(50).EQ.0) THEN
        CALL  AGMG_MUMPS_124(                                                &
     &        NUMELT, FRT_ELT(ELBEG),                                   &
     &        MYID, INODE, N, IOLDPS, HF, NFRONT,NFRONT_EFF,            &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, NELT, IW, LIW,             &
     &        INTARR, KEEP(14), ITLOC, FILS, FRERE, KEEP,               &
     &        SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
      ELSE
        CALL AGMG_MUMPS_125(                                                 &
     &        NUMELT, FRT_ELT(ELBEG),                                   &
     &        MYID, INODE, N, IOLDPS, HF,                               &
     &        NFRONT, NFRONT_EFF, PERM,                                 &
     &        NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                     &
     &        IFSON, STEP, PIMASTER, PTRAIW, NELT, IW, LIW,             &
     &        INTARR, KEEP(14), ITLOC, FILS, FRERE,                     &
     &        KEEP, SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
        IF (IFLAG.LT.0) GOTO 250
      ENDIF
      IF ( NFRONT .NE. NFRONT_EFF ) THEN
        IF (NFRONT.GT.NFRONT_EFF) THEN
            NCB    = NFRONT_EFF - NASS1
            NSLAVES_OLD = NSLAVES
            HF_OLD      = HF
            CALL DAGMG_MUMPS_472( NCBSON_MAX,                                &
     &      SLAVEF, KEEP,KEEP8,ICNTL,                                   &
     &      CAND(1,INIV2),                                              &
     &      MEM_DISTRIB(0), NCB, NFRONT_EFF, NSLAVES,                   &
     &      TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),             &
     &      TMP_SLAVES_LIST, SIZE_TMP_SLAVES_LIST,INODE )
            HF = NSLAVES + 6 + KEEP(IXSZ)
            IWPOS = IWPOS - ((2*NFRONT)-(2*NFRONT_EFF)) -               &
     &                   (NSLAVES_OLD - NSLAVES)
            IF (NSLAVES_OLD .NE. NSLAVES) THEN
              IF (NSLAVES_OLD > NSLAVES) THEN
               IW(IOLDPS+HF: IOLDPS+HF+2*NFRONT_EFF-1) =                &
     &         IW(IOLDPS+HF_OLD: IOLDPS+HF_OLD+2*NFRONT_EFF-1)
              ELSE
               IF (IWPOS - 1 > IWPOSCB ) GOTO 270
               DO JJ=2*NFRONT_EFF-1, 0, -1
                 IW(IOLDPS+HF+JJ) = IW(IOLDPS+HF_OLD+JJ)
               ENDDO
              END IF
            END IF
            NFRONT = NFRONT_EFF
            LREQ = HF + 2 * NFRONT + LREQ_OOC
        ELSE
          Write(*,*) ' ERROR 2 during ass_niv2'
          GOTO 270
        ENDIF
      ENDIF
      NFRONT8=int(NFRONT,8)
      IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_691(KEEP(50),                                       &
     &       NBPANELS_L, NBPANELS_U, NASS1,                             &
     &       IOLDPS + HF + 2 * NFRONT, IW, LIW)
      ENDIF
      MAXFRW = max0(MAXFRW, NFRONT)
      PTLUST_S(STEP(INODE)) = IOLDPS
      IW(IOLDPS + 1+KEEP(IXSZ)) = 0
      IW(IOLDPS + 2+KEEP(IXSZ)) = -NASS1
      IW(IOLDPS + 3+KEEP(IXSZ)) = -NASS1
      IW(IOLDPS + 4+KEEP(IXSZ)) = STEP(INODE)
      IW(IOLDPS+KEEP(IXSZ))   = NFRONT
      IW(IOLDPS+5+KEEP(IXSZ)) = NSLAVES
      IW(IOLDPS+6+KEEP(IXSZ):IOLDPS+5+NSLAVES+KEEP(IXSZ))=              &
     &                     TMP_SLAVES_LIST(1:NSLAVES)
        CALL DAGMG_MUMPS_461(MYID, SLAVEF, COMM_LOAD,                        &
     &     TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),              &
     &     NASS1, KEEP, KEEP8, IW(IOLDPS+6+KEEP(IXSZ)), NSLAVES,INODE)
      IF(KEEP(86).EQ.1)THEN
         IF(mod(KEEP(24),2).eq.0)THEN
            CALL DAGMG_MUMPS_533(SLAVEF,CAND(SLAVEF+1,INIV2),                &
     &           TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),        &
     &           NASS1, KEEP,KEEP8, TMP_SLAVES_LIST, NSLAVES,INODE)
         ELSEIF((KEEP(24).EQ.0).OR.(KEEP(24).EQ.1))THEN
            CALL DAGMG_MUMPS_533(SLAVEF,SLAVEF-1,                            &
     &           TAB_POS_IN_PERE(1,ISTEP_TO_INIV2(STEP(INODE))),        &
     &           NASS1, KEEP,KEEP8,TMP_SLAVES_LIST, NSLAVES,INODE)
         ENDIF
      ENDIF
      DEALLOCATE(TMP_SLAVES_LIST)
      IF (KEEP(50).EQ.0) THEN
        LAELL8 = int(NASS1,8) * NFRONT8
        LDAFS = NFRONT
        LDAFS8 = NFRONT8
      ELSE
        LAELL8 = int(NASS1,8)*int(NASS1,8)
        IF (KEEP(219).NE.0) THEN
          IF(KEEP(50) .EQ. 2) LAELL8 = LAELL8+int(NASS1,8)
        ENDIF
        LDAFS = NASS1
        LDAFS8 = int(NASS1,8)
      ENDIF
      IF (LRLU .LT. LAELL8) THEN
        IF (LRLUS .LT. LAELL8) THEN
          GOTO 280
        ELSE
          CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                   &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
          IF (LRLU .NE. LRLUS) THEN
            WRITE( *, * ) 'PB compress ass..mpi51f_niv2'
            WRITE( *, * ) 'LRLU,LRLUS=',LRLU,LRLUS
            GOTO 280
          ENDIF
        ENDIF
      ENDIF
      LRLU = LRLU - LAELL8
      LRLUS = LRLUS - LAELL8
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSELT = POSFAC
      PTRAST(STEP(INODE)) = POSELT
      PTRFAC(STEP(INODE)) = POSELT
      POSFAC = POSFAC + LAELL8
      IW(IOLDPS+XXI)   = LREQ
      CALL AGMG_MUMPS_730(LAELL8,IW(IOLDPS+XXR))
      IW(IOLDPS+XXS) =-9999
      IW(IOLDPS+XXS+1:IOLDPS+KEEP(IXSZ)-1)=-99999
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,LA-LRLUS,0_8,LAELL8,              &
     & KEEP,KEEP8,                                                      &
     &LRLU)
      POSEL1 = POSELT - LDAFS8
      LAPOS2 = POSELT + LAELL8 - 1_8
      A(POSELT:LAPOS2) = dble(ZERO)
      IF ((NUMSTK.NE.0).AND.(NASS.NE.0)) THEN
        ISON = IFSON
        DO 220 IELL = 1, NUMSTK
          ISTCHK = PIMASTER(STEP(ISON))
          NELIM = IW(ISTCHK + KEEP(IXSZ) + 1)
          IF (NELIM.EQ.0) GOTO 210
          LSTK    = IW(ISTCHK + KEEP(IXSZ))
          NPIVS   = IW(ISTCHK + KEEP(IXSZ) + 3)
          IF (NPIVS.LT.0) NPIVS=0
          NSLSON  = IW(ISTCHK + KEEP(IXSZ) + 5)
          HS      = 6 + KEEP(IXSZ) + NSLSON
          NCOLS     = NPIVS + LSTK
          SAME_PROC     = (ISTCHK.LE.IWPOS)
          IF ( SAME_PROC ) THEN
            COMPRESSCB=( IW(PTRIST(STEP(ISON))+XXS) .EQ. S_CB1COMP )
          ELSE
            COMPRESSCB=( IW(ISTCHK + XXS) .EQ. S_CB1COMP )
          ENDIF
          IF (.NOT.SAME_PROC) THEN
           NROWS = IW(ISTCHK + KEEP(IXSZ) + 2)
          ELSE
           NROWS = NCOLS
          ENDIF
          OPASSW = OPASSW + dble(NELIM*LSTK)
          J1 = ISTCHK + HS + NROWS + NPIVS
          J2 = J1 + NELIM - 1
          IACHK = PAMASTER(STEP(ISON))
          IF (KEEP(50).eq.0) THEN
           DO 170 JJ = J1, J2
            APOS = POSEL1 + int(IW(JJ),8) * LDAFS8
            DO 160 JJ1 = 1, LSTK
              JJ2 = APOS + int(IW(J1 + JJ1 - 1),8) - 1_8
              A(JJ2) = A(JJ2) + A(IACHK + int(JJ1,8) - 1_8)
  160       CONTINUE
            IACHK = IACHK + int(LSTK,8)
  170      CONTINUE
          ELSE
            IF (NSLSON.EQ.0) THEN
             LDA_SON = LSTK
            ELSE
             LDA_SON = NELIM
            ENDIF
            IF (COMPRESSCB) THEN
              LCB = (int(NELIM,8)*int(NELIM+1,8))/2_8
            ELSE
              LCB = int(LDA_SON,8)*int(NELIM,8)
            ENDIF
            CALL DAGMG_MUMPS_178(A, LA,                                      &
     &           POSELT, LDAFS, NASS1,                                  &
     &           IACHK, LDA_SON, LCB,                                   &
     &           IW( J1 ), NELIM, NELIM, ETATASS,                       &
     &           COMPRESSCB,                                            &
     &           .FALSE.                                                &
     &          )
          ENDIF
  210     ISON = FRERE(STEP(ISON))
  220   CONTINUE
      ENDIF
      APOSMAX = POSELT + int(NASS1,8)*int(NASS1,8)
      IF (KEEP(219).NE.0) THEN
        IF (KEEP(50).EQ.2) THEN
          A( APOSMAX: APOSMAX+int(NASS1-1,8))=dble(ZERO)
        ENDIF
      ENDIF
      DO IELL=ELBEG,ELBEG+NUMELT-1
        ELTI = FRT_ELT(IELL)
        J1= PTRAIW(ELTI)
        J2= PTRAIW(ELTI+1)-1
        AII = PTRARW(ELTI)
        SIZE_ELTI = J2 - J1 + 1
        DO II=J1,J2
         I = INTARR(II)
         IF (KEEP(50).EQ.0) THEN
          IF (I.LE.NASS1) THEN
           AINPUT    = AII + II - J1
           ICT12 = POSELT + int(I-1,8) * LDAFS8
           DO JJ=J1,J2
            APOS2 = ICT12 + int(INTARR(JJ) - 1,8)
            A(APOS2) = A(APOS2) + DBLARR(AINPUT)
            AINPUT = AINPUT + SIZE_ELTI
           END DO
          ENDIF
         ELSE
          ICT12 = POSELT - LDAFS8 + int(I,8) - 1_8
          ICT21 = POSELT + int(I-1,8)*LDAFS8 - 1_8
          IF ( I .GT. NASS1 ) THEN
           IF (KEEP(219).NE.0) THEN
            IF (KEEP(50).EQ.2) THEN
              AINPUT=AII
              DO JJ=II,J2
               J=INTARR(JJ)
               IF (J.LE.NASS1) THEN
                A(APOSMAX+int(J-1,8))=dble(                             &
     &              max(dble(A(APOSMAX+int(J-1,8))),                    &
     &                  abs(DBLARR(AINPUT)))                            &
     &                 )
               ENDIF
               AINPUT=AINPUT+1
              ENDDO
            ELSE
              AII = AII + J2 - II + 1
              CYCLE
            ENDIF
           ELSE
             AII = AII + J2 - II + 1
             CYCLE
           ENDIF
          ELSE
            IF (KEEP(219).NE.0) THEN
              MAXARR = ZERO
            ENDIF
            DO JJ=II,J2
              J =  INTARR(JJ)
              IF ( J .LE. NASS1) THEN
                IF (I.LT.J) THEN
                  APOS2 = ICT12 + int(J,8)*LDAFS8
                ELSE
                  APOS2 = ICT21 + int(J,8)
                ENDIF
                A(APOS2) = A(APOS2) + DBLARR(AII)
              ELSE IF (KEEP(219).NE.0.AND.KEEP(50).EQ.2) THEN
                MAXARR = max(MAXARR,abs(DBLARR(AII)))
              ENDIF
              AII = AII + 1
            END DO
            IF(KEEP(219).NE.0.AND.KEEP(50) .EQ. 2) THEN
                A(APOSMAX+int(I-1,8)) = dble(                           &
     &             max( MAXARR, dble(A(APOSMAX+int(I-1,8))))            &
     &          )
            ENDIF
          ENDIF
         END IF
        END DO
      END DO
      PTRCOL = IOLDPS + HF + NFRONT
      PTRROW = IOLDPS + HF + NASS1
      PDEST  = IOLDPS + 6 + KEEP(IXSZ)
      DO ISLAVE = 1, NSLAVES
              CALL AGMG_MUMPS_49(                                            &
     &                KEEP,KEEP8, INODE, STEP, N, SLAVEF,               &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE, NCB,                                      &
     &                NSLAVES,                                          &
     &                NBLIG, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
        IERR = -1
        DO WHILE (IERR .EQ.-1)
         IF ( KEEP(50) .eq. 0 ) THEN
           NBCOL =  NFRONT
           CALL DAGMG_MUMPS_68( INODE,                                       &
     &      NBPROCFILS(STEP(INODE)),                                    &
     &      NBLIG, IW(PTRROW), NBCOL, IW(PTRCOL), NASS1,                &
     &      IZERO, IDUMMY,                                              &
     &      IW(PDEST), NFRONT, COMM, IERR)
         ELSE
           NBCOL = NASS1+SHIFT_INDEX+NBLIG
           CALL DAGMG_MUMPS_68( INODE,                                       &
     &      NBPROCFILS(STEP(INODE)),                                    &
     &      NBLIG, IW(PTRROW), NBCOL, IW(PTRCOL), NASS1,                &
     &      NSLAVES-ISLAVE,                                             &
     &      IW( PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)+ISLAVE),             &
     &      IW(PDEST), NFRONT, COMM, IERR)
         ENDIF
         IF (IERR.EQ.-1) THEN
          BLOCKING  = .FALSE.
          SET_IRECV = .TRUE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &     BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                       &
     &     AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                 &
     &     STATUS, BUFR, LBUFR,                                         &
     &     LBUFR_BYTES,                                                 &
     &     PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,              &
     &     LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                      &
     &     PTLUST_S, PTRFAC,                                            &
     &     PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,       &
     &     IERROR, COMM,                                                &
     &     NBPROCFILS,                                                  &
     &     IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                     &
     &     root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,           &
     &     INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                &
     &     NELT+1, NELT, FRT_PTR, FRT_ELT,                              &
     &     ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.)
           IF ( IFLAG .LT. 0 ) GOTO 500
          IF (MESSAGE_RECEIVED) THEN
           IOLDPS = PTLUST_S(STEP(INODE))
           PTRCOL = IOLDPS + HF + NFRONT
           PTRROW = IOLDPS + HF + NASS1 + SHIFT_INDEX
          ENDIF
         ENDIF
        END DO
        IF (IERR .EQ. -2) GOTO 300
        IF (IERR .EQ. -3) GOTO 305
        PTRROW = PTRROW + NBLIG
        PDEST  = PDEST + 1
      END DO
      IF (NUMSTK.EQ.0) GOTO 500
      ISON = IFSON
      DO IELL = 1, NUMSTK
        ISTCHK = PIMASTER(STEP(ISON))
        NELIM = IW(ISTCHK + 1 + KEEP(IXSZ))
        LSTK    = IW(ISTCHK + KEEP(IXSZ))
        NPIVS   = IW(ISTCHK + 3 + KEEP(IXSZ))
        IF ( NPIVS .LT. 0 ) NPIVS = 0
        NSLSON  = IW(ISTCHK + 5 + KEEP(IXSZ))
        HS      = 6 + NSLSON + KEEP(IXSZ)
        NCOLS     = NPIVS + LSTK
        SAME_PROC     = (ISTCHK.LE.IWPOS)
        IF (.NOT.SAME_PROC) THEN
         NROWS = IW(ISTCHK + 2 + KEEP(IXSZ) )
        ELSE
         NROWS = NCOLS
        ENDIF
        PDEST   = ISTCHK + 6 + KEEP(IXSZ)
        NCBSON  = LSTK - NELIM
        PTRCOL   = ISTCHK +  HS + NROWS + NPIVS + NELIM
        IF (KEEP(219).NE.0.AND.KEEP(50).EQ.2) THEN
           NFS4FATHER = NCBSON
           DO I=0,NCBSON-1
              IF(IW(PTRCOL+I) .GT. NASS1) THEN
                 NFS4FATHER = I
                 EXIT
              ENDIF
           ENDDO
           NFS4FATHER=NFS4FATHER + NELIM
        ELSE
          NFS4FATHER = 0
        ENDIF
        IF (NSLSON.EQ.0) THEN
          NSLSON = 1
          PDEST1(1)  = AGMG_MUMPS_275(STEP(ISON),                            &
     &                 PROCNODE_STEPS, SLAVEF)
          IF (PDEST1(1).EQ.MYID) THEN
            CALL DAGMG_MUMPS_211( COMM_LOAD, ASS_IRECV,                      &
     &      BUFR, LBUFR, LBUFR_BYTES,                                   &
     &      INODE, ISON, NSLAVES,                                       &
     &      IW( PTLUST_S(STEP(INODE)) + 6 +KEEP(IXSZ)),                 &
     &      NFRONT, NASS1, NFS4FATHER,NCBSON, IW( PTRCOL ),             &
     &      PROCNODE_STEPS,                                             &
     &      SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,               &
     &      LRLUS, N, IW, LIW, A, LA,                                   &
     &      PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                     &
     &      PIMASTER, PAMASTER, NSTK_S, COMP,                           &
     &      IFLAG, IERROR, MYID, COMM, NBPROCFILS,                      &
     &      IPOOL, LPOOL, LEAF, NBFIN, ICNTL, KEEP,KEEP8, root,         &
     &      OPASSW, OPELIW,                                             &
     &      ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,                &
     &      ND, FRERE, NELT+1, NELT,                                    &
     &      FRT_PTR, FRT_ELT,                                           &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE )
           IF ( IFLAG .LT. 0 ) GOTO 500
          ELSE
           IERR = -1
           DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON)) + HS + NROWS + NPIVS + NELIM
            CALL  DAGMG_MUMPS_71(                                            &
     &           INODE, NFRONT,NASS1,NFS4FATHER,                        &
     &           ISON, MYID,                                            &
     &      NSLAVES, IW( PTLUST_S(STEP(INODE)) + 6 +KEEP(IXSZ)),        &
     &      IW(PTRCOL), NCBSON,                                         &
     &      COMM, IERR, PDEST1, NSLSON, SLAVEF,                         &
     &      KEEP,KEEP8, STEP, N,                                        &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &       )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                     &
     &        BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                    &
     &        AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                              &
     &        STATUS, BUFR, LBUFR, LBUFR_BYTES,                         &
     &        PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,           &
     &        LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                   &
     &        PTLUST_S, PTRFAC,                                         &
     &        PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,    &
     &        IERROR, COMM,                                             &
     &        NBPROCFILS,                                               &
     &        IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                  &
     &        root,OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &        INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,             &
     &        NELT+1, NELT, FRT_PTR, FRT_ELT,                           &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.)
              IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
           END DO
           IF (IERR .EQ. -2) GOTO 290
           IF (IERR .EQ. -3) GOTO 295
          ENDIF
        ELSE
          DO ISLAVE = 0, NSLSON-1
            IF (IW(PDEST+ISLAVE).EQ.MYID) THEN
               CALL AGMG_MUMPS_49(                                           &
     &                KEEP,KEEP8, ISON, STEP, N, SLAVEF,                &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE+1, NCBSON,                                 &
     &                NSLSON,                                           &
     &                TROW_SIZE, FIRST_INDEX  )
              SHIFT_INDEX = FIRST_INDEX - 1
              INDX        = PTRCOL + SHIFT_INDEX
              CALL DAGMG_MUMPS_210( COMM_LOAD, ASS_IRECV,                    &
     &        BUFR, LBUFR, LBUFR_BYTES,                                 &
     &        INODE, ISON, NSLAVES,                                     &
     &        IW( PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)),                  &
     &        NFRONT, NASS1,NFS4FATHER,                                 &
     &        TROW_SIZE, IW( INDX ),                                    &
     &        PROCNODE_STEPS,                                           &
     &        SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,             &
     &        LRLUS, N, IW,                                             &
     &        LIW, A, LA,                                               &
     &        PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,                   &
     &        PIMASTER, PAMASTER, NSTK_S, COMP,                         &
     &        IFLAG, IERROR, MYID, COMM, NBPROCFILS, IPOOL, LPOOL, LEAF,&
     &        NBFIN, ICNTL, KEEP,KEEP8, root,                           &
     &        OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,              &
     &        INTARR, DBLARR, ND, FRERE,                                &
     &        NELT+1, NELT, FRT_PTR, FRT_ELT,                           &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE                           &
     &        )
              IF ( IFLAG .LT. 0 ) GOTO 500
              EXIT
            ENDIF
          END DO
          IF (PIMASTER(STEP(ISON)).GT.0) THEN
          IERR = -1
          DO WHILE (IERR.EQ.-1)
            PTRCOL = PIMASTER(STEP(ISON)) + HS + NROWS + NPIVS + NELIM
            PDEST  = PIMASTER(STEP(ISON)) + 6 + KEEP(IXSZ)
            CALL  DAGMG_MUMPS_71(                                            &
     &           INODE, NFRONT, NASS1, NFS4FATHER,                      &
     &           ISON, MYID,                                            &
     &      NSLAVES, IW(PTLUST_S(STEP(INODE))+6+KEEP(IXSZ)),            &
     &      IW(PTRCOL), NCBSON,                                         &
     &      COMM, IERR, IW(PDEST), NSLSON, SLAVEF,                      &
     &      KEEP,KEEP8, STEP, N,                                        &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE                             &
     &       )
            IF (IERR.EQ.-1) THEN
             BLOCKING  = .FALSE.
             SET_IRECV = .TRUE.
             MESSAGE_RECEIVED = .FALSE.
             CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                     &
     &        BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                    &
     &        AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                              &
     &        STATUS, BUFR, LBUFR,                                      &
     &        LBUFR_BYTES,                                              &
     &        PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,           &
     &        LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                   &
     &        PTLUST_S, PTRFAC,                                         &
     &        PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,    &
     &        IERROR, COMM,                                             &
     &        NBPROCFILS,                                               &
     &        IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                  &
     &        root,OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &        INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,             &
     &        NELT+1, NELT, FRT_PTR, FRT_ELT,                           &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
             IF ( IFLAG .LT. 0 ) GOTO 500
            ENDIF
          END DO
          IF (IERR .EQ. -2) GOTO 290
          IF (IERR .EQ. -3) GOTO 295
          ENDIF
        ENDIF
       ISON = FRERE(STEP(ISON))
      END DO
      GOTO 500
  250 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * ) ' FAILURE IN INTEGER',                           &
     &                 ' DYNAMIC ALLOCATION during assembly'
      ENDIF
      IFLAG   = -13
      IERROR  = NUMSTK + 1
      GOTO 490
  265 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * ) ' FAILURE ALLOCATING TMP_SLAVES_LIST',           &
     &                 ' DYNAMIC ALLOCATION during assembly'
      ENDIF
      IFLAG  = -13
      IERROR = SIZE_TMP_SLAVES_LIST
      GOTO 490
  270 CONTINUE
      IFLAG = -8
      IERROR = LREQ
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE IN INTEGER ALLOCATION DURING DMUMPS_37'
      ENDIF
      GOTO 490
  280 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &  ' FAILURE, WORKSPACE TOO SMALL DURING DMUMPS_37'
      ENDIF
      IFLAG = -9
      CALL AGMG_MUMPS_731(LAELL8 - LRLUS, IERROR)
      GOTO 490
  290 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, SEND BUFFER TOO SMALL (1) DURING DMUMPS_37'
      ENDIF
      IFLAG = -17
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  295 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, RECV BUFFER TOO SMALL (1) DURING DMUMPS_37'
      ENDIF
      IFLAG = -20
      LREQ = NCBSON + 6+NSLSON+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  300 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, SENDBUFFER TOO SMALL (2) DURING DMUMPS_37'
      ENDIF
      IFLAG = -17
      LREQ = NBLIG + NBCOL + 4+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  305 CONTINUE
      IF ((ICNTL(1) .GT. 0) .AND. (ICNTL(4) .GE. 1)) THEN
        LP = ICNTL(1)
        WRITE( LP, * )                                                  &
     &' FAILURE, RECVBUFFER TOO SMALL (2) DURING DMUMPS_37'
      ENDIF
      IFLAG = -17
      LREQ = NBLIG + NBCOL + 4+KEEP(IXSZ)
      IERROR =  LREQ  * KEEP( 34 )
      GOTO 490
  490 CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_37
      SUBROUTINE DAGMG_MUMPS_123(                                            &
     &    NELT, FRT_PTR, FRT_ELT,                                       &
     &    N, INODE, IW, LIW, A, LA,                                     &
     &    NBROWS, NBCOLS,                                               &
     &    OPASSW, OPELIW, STEP, PTRIST, PTRAST, ITLOC,                  &
     &    FILS, PTRARW, PTRAIW, INTARR, DBLARR,                         &
     &    ICNTL, KEEP, KEEP8, MYID)
      IMPLICIT NONE
      INTEGER NELT, N,LIW
      INTEGER(8) :: LA
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER INODE, MYID
      INTEGER NBROWS, NBCOLS
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER IW(LIW), ITLOC(N), STEP(N),                               &
     &        PTRIST(KEEP(28)),                                         &
     &        FILS(N), PTRARW(NELT+1),                                  &
     &        PTRAIW(NELT+1)
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER FRT_PTR(N+1), FRT_ELT(NELT)
      DOUBLE PRECISION A(LA),                                           &
     &        DBLARR(max(1,KEEP(13)))
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER(8) :: POSELT, APOS2, ICT12
      INTEGER IOLDPS, NBCOLF, NBROWF, NSLAVES, HF,                      &
     &        K1,K2,K,I,J,JPOS,NASS,JJ,                                 &
     &        IN,AINPUT,JK,J1,J2,IJROW,ILOC,                            &
     &        ELBEG, NUMELT, ELTI, SIZE_ELTI, IPOS,                     &
     &        IPOS1, IPOS2, AII, II, IELL
      DOUBLE PRECISION  ZERO
      PARAMETER (ZERO=0.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTRINSIC real
      IOLDPS  = PTRIST(STEP(INODE))
      POSELT  = PTRAST(STEP(INODE))
      NBCOLF  = IW(IOLDPS+KEEP(IXSZ))
      NBROWF  = IW(IOLDPS+2+KEEP(IXSZ))
      NASS    = IW(IOLDPS+1+KEEP(IXSZ))
       IF ( NBROWS .GT. NBROWF ) THEN
          WRITE(*,*) ' ERR: ERROR : NBROWS > NBROWF'
          WRITE(*,*) ' ERR: INODE =', INODE
          WRITE(*,*) ' ERR: NBROW=',NBROWS,'NBROWF=',NBROWF
          CALL AGMG_MUMPS_ABORT()
       END IF
      NSLAVES = IW(IOLDPS+5+KEEP(IXSZ))
      HF      = 6 + NSLAVES+KEEP(IXSZ)
      IF (NASS.LT.0) THEN
          NASS         = -NASS
          IW(IOLDPS+1+KEEP(IXSZ)) = NASS
          A(POSELT:POSELT+int(NBROWF,8)*int(NBCOLF,8)-1_8) =            &
     &    dble(ZERO)
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NBCOLF - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = -JPOS
           JPOS     = JPOS + 1
          END DO
          K1 = IOLDPS + HF
          K2 = K1 + NBROWF - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = -ITLOC(J)*NBCOLF + JPOS
           JPOS     = JPOS + 1
          END DO
          ELBEG  = FRT_PTR(INODE)
          NUMELT = FRT_PTR(INODE+1) - ELBEG
          DO IELL=ELBEG,ELBEG+NUMELT-1
           ELTI = FRT_ELT(IELL)
           J1= PTRAIW(ELTI)
           J2= PTRAIW(ELTI+1)-1
           AII = PTRARW(ELTI)
           SIZE_ELTI = J2 - J1 + 1
           DO II=J1,J2
            I = ITLOC(INTARR(II))
            IF (KEEP(50).EQ.0) THEN
             IF (I.LE.0) CYCLE
             AINPUT    = AII + II - J1
             IPOS = mod(I,NBCOLF)
             ICT12 = POSELT + int(IPOS-1,8) * int(NBCOLF,8)
             DO JJ = J1, J2
              JPOS = ITLOC(INTARR(JJ))
              IF (JPOS.LE.0) THEN
                   JPOS = -JPOS
              ELSE
                   JPOS = JPOS/NBCOLF
              END IF
              APOS2    = ICT12 + int(JPOS - 1,8)
              A(APOS2) = A(APOS2) +  DBLARR(AINPUT)
              AINPUT   = AINPUT + SIZE_ELTI
             END DO
            ELSE
              IF ( I .EQ. 0 ) THEN
               AII = AII + J2 - II + 1
               CYCLE
              ENDIF
              IF ( I .LE. 0 ) THEN
               IPOS1 = -I
               IPOS2 = 0
              ELSE
               IPOS1 = I/NBCOLF
               IPOS2 = mod(I,NBCOLF)
              END IF
              ICT12 =  POSELT + int(IPOS2-1,8)*int(NBCOLF,8)
              DO JJ=II,J2
               AII = AII + 1
               J = ITLOC(INTARR(JJ))
               IF ( J .EQ. 0 ) CYCLE
               IF ( IPOS2.EQ.0 .AND. J.LE.0) CYCLE
               IF ( J .LE. 0 ) THEN
                JPOS = -J
               ELSE
                JPOS = J/NBCOLF
               END IF
               IF ( (IPOS1.GE.JPOS) .AND. (IPOS2.GT.0) ) THEN
                 APOS2 = ICT12  + int(JPOS - 1,8)
                 A(APOS2) = A(APOS2) +  DBLARR(AII-1)
               END IF
               IF ( (IPOS1.LT.JPOS) .AND. (J.GT.0) ) THEN
                 IPOS = mod(J,NBCOLF)
                 JPOS = IPOS1
                 APOS2 = POSELT + int(IPOS-1,8)*int(NBCOLF,8)           &
     &                          + int(JPOS - 1,8)
                 A(APOS2) = A(APOS2) +  DBLARR(AII-1)
               END IF
              END DO
            END IF
           END DO
          END DO
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NBCOLF - 1
          DO K = K1, K2
           J = IW(K)
           ITLOC(J) = 0
          END DO
      END IF
      IF (NBROWS.GT.0) THEN
          K1 = IOLDPS + HF + NBROWF
          K2 = K1 + NBCOLF - 1
          JPOS = 1
          DO K = K1, K2
           J        = IW(K)
           ITLOC(J) = JPOS
           JPOS     = JPOS + 1
          END DO
      END IF
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_123
      SUBROUTINE DAGMG_MUMPS_126(                                            &
     &            N, NELT, NA_ELT,                                      &
     &            COMM, MYID, SLAVEF,                                   &
     &            IELPTR_LOC, RELPTR_LOC,                               &
     &            ELTVAR_LOC, ELTVAL_LOC,                               &
     &            KEEP,KEEP8, MAXELT_SIZE,                              &
     &            FRTPTR, FRTELT, A, LA, FILS,                          &
     &            id, root )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTEGER N, NELT, NA_ELT
      INTEGER COMM, MYID, SLAVEF, MAXELT_SIZE, MSGLEN
      INTEGER(8), intent(IN) :: LA
      INTEGER FRTPTR( N+1 )
      INTEGER FRTELT( NELT ), FILS ( N )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER IELPTR_LOC( NELT + 1 ), RELPTR_LOC( NELT + 1 )
      INTEGER ELTVAR_LOC( max(1,KEEP(14)) )
      DOUBLE PRECISION ELTVAL_LOC( max(1,KEEP(13)) )
      DOUBLE PRECISION A( LA )
      TYPE(DAGMG_MUMPS_STRUC)     :: id
      TYPE(DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER NUMROC_FOOL
      EXTERNAL NUMROC_FOOL
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR_MPI
      INTEGER MSGTAG
      INTEGER allocok
      INTEGER I, DEST, MAXELT_REAL_SIZE, MPG, IEL, SIZEI, SIZER
      INTEGER NBRECORDS, NBUF
      INTEGER RECV_IELTPTR, RECV_RELTPTR
      INTEGER IELTPTR, RELTPTR, INODE
      LOGICAL FINI, PROKG, I_AM_SLAVE
      INTEGER(8) :: PTR_ROOT
      INTEGER LOCAL_M, LOCAL_N, LP, IBEG, IGLOB, JGLOB
      INTEGER ARROW_ROOT
      INTEGER IELT, J, K, NB_REC, IREC
      INTEGER ILOCROOT, JLOCROOT, IPOSROOT, JPOSROOT, IPTR
      INTEGER JCOL_GRID, IROW_GRID
      INTEGER IVALPTR
      INTEGER NBELROOT
      INTEGER MASTER
      PARAMETER( MASTER = 0 )
      DOUBLE PRECISION  VAL
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      INTEGER, DIMENSION( :, : ), ALLOCATABLE :: BUFI
      DOUBLE PRECISION, DIMENSION( :, : ), ALLOCATABLE :: BUFR
      DOUBLE PRECISION, DIMENSION( : ), ALLOCATABLE :: TEMP_ELT_R
      INTEGER, DIMENSION( : ), ALLOCATABLE :: TEMP_ELT_I
      INTEGER, DIMENSION( : ), ALLOCATABLE :: ELROOTPOS
      INTEGER, DIMENSION( : ), ALLOCATABLE, TARGET :: RG2LALLOC
      INTEGER, DIMENSION( : ), POINTER     :: RG2L
      MPG = id%ICNTL(3)
      LP  = id%ICNTL(1)
      I_AM_SLAVE = ( KEEP(46) .eq. 1 .or. MYID .ne.MASTER )
      PROKG = ( MPG > 0 .and. MYID .eq. MASTER )
      KEEP(49) = 0
      ARROW_ROOT = 0
      IF ( MYID .eq. MASTER ) THEN
        IF ( KEEP(46) .eq. 0 ) THEN
          NBUF = SLAVEF
        ELSE
          NBUF = SLAVEF - 1
        END IF
        NBRECORDS = min(KEEP(39),NA_ELT)
        IF ( KEEP(50) .eq. 0 ) THEN
          MAXELT_REAL_SIZE = MAXELT_SIZE * MAXELT_SIZE
        ELSE
          MAXELT_REAL_SIZE = MAXELT_SIZE * (MAXELT_SIZE+1)/2
        END IF
        IF ( MAXELT_REAL_SIZE .GT. KEEP(39) ) THEN
          NBRECORDS = MAXELT_REAL_SIZE
          IF ( MPG .GT. 0 ) THEN
            WRITE(MPG,*)                                                &
     & ' ** Warning : For element distrib NBRECORDS set to ',           &
     & MAXELT_REAL_SIZE,' because one element is large'
          END IF
        END IF
        ALLOCATE( BUFI( 2*NBRECORDS+1, NBUF ), stat=allocok )
        IF ( allocok .gt. 0 ) THEN
          id%INFO(1) = -13
          id%INFO(2) = 2*NBRECORDS + 1
          GOTO 100
        END IF
        ALLOCATE( BUFR( NBRECORDS+1, NBUF ), stat=allocok )
        IF ( allocok .gt. 0 ) THEN
          id%INFO(1) = -13
          id%INFO(2) = NBRECORDS + 1
          GOTO 100
        END IF
        IF ( KEEP(52) .ne. 0 ) THEN
          ALLOCATE( TEMP_ELT_R( MAXELT_REAL_SIZE ), stat =allocok )
          IF ( allocok .gt. 0 ) THEN
            id%INFO(1) = -13
            id%INFO(2) = MAXELT_REAL_SIZE
            GOTO 100
          END IF
        END IF
        ALLOCATE( TEMP_ELT_I( MAXELT_SIZE ), stat=allocok )
        IF ( allocok .gt. 0 ) THEN
            id%INFO(1) = -13
            id%INFO(2) = MAXELT_SIZE
            GOTO 100
        END IF
        IF ( KEEP(38) .ne. 0 ) THEN
          NBELROOT = FRTPTR(KEEP(38)+1)-FRTPTR(KEEP(38))
          ALLOCATE( ELROOTPOS( max(NBELROOT,1) ),                       &
     &              stat = allocok )
          IF ( allocok .gt. 0 ) THEN
              id%INFO(1) = -13
              id%INFO(2) = NBELROOT
              GOTO 100
          END IF
          IF (KEEP(46) .eq. 0 ) THEN
           ALLOCATE( RG2LALLOC( N ), stat = allocok )
           IF ( allocok .gt. 0 ) THEN
               id%INFO(1) = -13
               id%INFO(2) = N
               GOTO 100
           END IF
           INODE = KEEP(38)
           I     = 1
           DO WHILE ( INODE .GT. 0 )
             RG2LALLOC( INODE ) = I
             INODE = FILS( INODE )
             I = I + 1
           END DO
           RG2L => RG2LALLOC
          ELSE
           RG2L => root%RG2L_ROW
          END IF
        END IF
        DO I = 1, NBUF
          BUFI( 1, I ) = 0
          BUFR( 1, I ) = dble(0)
        END DO
      END IF
  100 CONTINUE
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO, COMM, MYID )
      IF ( id%INFO(1) .LT. 0 ) RETURN
      CALL AGMG_SETIERR( IERR_MPI )
      RECV_IELTPTR = 1
      RECV_RELTPTR = 1
      IF ( MYID .eq. MASTER ) THEN
        NBELROOT = 0
        RELTPTR = 1
        RELPTR_LOC(1) = 1
        DO IEL = 1, NELT
          IELTPTR = id%ELTPTR( IEL )
          SIZEI   = id%ELTPTR( IEL + 1 ) - IELTPTR
          IF ( KEEP( 50 ) .eq. 0 ) THEN
            SIZER = SIZEI * SIZEI
          ELSE
            SIZER = SIZEI * ( SIZEI + 1 ) / 2
          END IF
          DEST = id%ELTPROC( IEL )
          IF ( DEST .eq. -2 ) THEN
            NBELROOT = NBELROOT + 1
            FRTELT( FRTPTR(KEEP(38)) + NBELROOT - 1 ) = IEL
            ELROOTPOS( NBELROOT ) = RELTPTR
            GOTO 200
          END IF
          IF ( DEST .ge. 0 .and. KEEP(46) .eq. 0 ) DEST = DEST + 1
          IF ( KEEP(52) .ne. 0 ) THEN
            CALL DAGMG_MUMPS_288( N, SIZEI, SIZER,                           &
     &               id%ELTVAR( IELTPTR ), id%A_ELT( RELTPTR ),         &
     &               TEMP_ELT_R(1), MAXELT_REAL_SIZE,                   &
     &               id%ROWSCA, id%COLSCA, KEEP(50) )
          END IF
          IF ( DEST .eq. 0 .or. ( DEST .eq. -1 .and. KEEP(46) .ne. 0 ) )&
     &      THEN
            ELTVAR_LOC( RECV_IELTPTR: RECV_IELTPTR + SIZEI - 1 )        &
     &      = id%ELTVAR( IELTPTR: IELTPTR + SIZEI - 1 )
            RECV_IELTPTR = RECV_IELTPTR + SIZEI
            IF ( KEEP(52) .ne. 0 ) THEN
              ELTVAL_LOC( RECV_RELTPTR: RECV_RELTPTR + SIZER - 1)       &
     &        = TEMP_ELT_R( 1: SIZER )
              RECV_RELTPTR = RECV_RELTPTR + SIZER
            END IF
          END IF
          IF ( DEST .NE. 0 .AND. DEST .NE. -3 ) THEN
            IF ( KEEP(52) .eq. 0 ) THEN
              CALL DAGMG_MUMPS_127(                                          &
     &           id%ELTVAR(IELTPTR),                                    &
     &           id%A_ELT (RELTPTR),                                    &
     &           SIZEI, SIZER,                                          &
     &           DEST, NBUF, NBRECORDS,                                 &
     &           BUFI, BUFR, COMM )
            ELSE
              CALL DAGMG_MUMPS_127(                                          &
     &           id%ELTVAR(IELTPTR),                                    &
     &           TEMP_ELT_R( 1 ),                                       &
     &           SIZEI, SIZER,                                          &
     &           DEST, NBUF, NBRECORDS,                                 &
     &           BUFI, BUFR, COMM )
            END IF
          END IF
  200     CONTINUE
          RELTPTR = RELTPTR + SIZER
          IF ( KEEP(46) .eq. 0 .OR. KEEP(52) .eq. 0 ) THEN
            RELPTR_LOC( IEL + 1 ) = RELTPTR
          ELSE
            RELPTR_LOC( IEL + 1 ) = RECV_RELTPTR
          ENDIF
        END DO
        IF ( KEEP(46) .eq. 0 .OR. KEEP(52) .eq. 0 ) THEN
          KEEP(13) = RELTPTR - 1
        ELSE
          KEEP(13) = RECV_RELTPTR - 1
        ENDIF
        IF ( RELTPTR - 1 .ne. id%NA_ELT ) THEN
          WRITE(*,*) ' ** ERROR ELT DIST: RELPTR - 1 / id%NA_ELT=',     &
     &               RELTPTR - 1,id%NA_ELT
          CALL AGMG_MUMPS_ABORT()
        END IF
        DEST = -2
        IELTPTR = 1
        RELTPTR = 1
        SIZEI   = 1
        SIZER   = 1
        CALL DAGMG_MUMPS_127(                                                &
     &           id%ELTVAR(IELTPTR),                                    &
     &           id%A_ELT (RELTPTR),                                    &
     &           SIZEI, SIZER,                                          &
     &           DEST, NBUF, NBRECORDS,                                 &
     &           BUFI, BUFR, COMM )
        IF ( KEEP(52) .NE. 0 ) DEALLOCATE( TEMP_ELT_R )
      ELSE
        FINI = ( RECV_IELTPTR .eq. IELPTR_LOC( NELT+1 )                 &
     &     .and. RECV_RELTPTR .eq. RELPTR_LOC( NELT+1 ) )
        DO WHILE ( .not. FINI )
          CALL AGMG_NOCALL('MPI_PROBE')
          MSGTAG = STATUS( AGMG_MPF_TAG    )
          SELECT CASE ( MSGTAG )
             CASE( ELT_INT )
               CALL AGMG_NOCALL('MPI_GET_COUNT')
               CALL AGMG_NOCALL('MPI_RECV')
               RECV_IELTPTR = RECV_IELTPTR + MSGLEN
             CASE( ELT_REAL )
                CALL AGMG_NOCALL('MPI_GET_COUNT')
                CALL AGMG_NOCALL('MPI_RECV')
                RECV_RELTPTR = RECV_RELTPTR + MSGLEN
          END SELECT
          FINI = ( RECV_IELTPTR .eq. IELPTR_LOC( NELT+1 )               &
     &       .and. RECV_RELTPTR .eq. RELPTR_LOC( NELT+1 ) )
        END DO
      END IF
      IF ( KEEP(38) .NE. 0 ) THEN
         IF ( I_AM_SLAVE .and. root%yes ) THEN
          IF (KEEP(60)==0) THEN
           LOCAL_M = NUMROC_FOOL( root%ROOT_SIZE, root%MBLOCK,               &
     &             root%MYROW, 0, root%NPROW )
           LOCAL_M = max( 1, LOCAL_M )
           LOCAL_N = NUMROC_FOOL( root%ROOT_SIZE, root%NBLOCK,               &
     &               root%MYCOL, 0, root%NPCOL )
           PTR_ROOT = LA - int(LOCAL_M,8) * int(LOCAL_N,8) + 1_8
           IF ( PTR_ROOT .LE. LA ) THEN
             A( PTR_ROOT:LA ) = dble(ZERO)
           END IF
          ELSE
           DO I = 1, root%SCHUR_NLOC
            root%SCHUR_POINTER((I-1)*root%SCHUR_LLD+1:                  &
     &      (I-1)*root%SCHUR_LLD+root%SCHUR_MLOC)=dble(ZERO)
           ENDDO
          ENDIF
         END IF
        IF ( MYID .NE. MASTER ) THEN
          ALLOCATE( BUFI( NBRECORDS * 2 + 1, 1 ), stat = allocok )
          IF ( allocok .GT. 0 ) THEN
            id%INFO(1) = -13
            id%INFO(2) = NBRECORDS * 2 + 1
            GOTO 250
          END IF
          ALLOCATE( BUFR( NBRECORDS, 1 )        , stat = allocok )
          IF ( allocok .GT. 0 ) THEN
            id%INFO(1) = -13
            id%INFO(2) = NBRECORDS
          END IF
        END IF
  250   CONTINUE
        CALL AGMG_MUMPS_276( id%ICNTL, id%INFO, COMM, MYID )
        IF ( id%INFO(1) .LT. 0 ) RETURN
        IF ( MYID .eq. MASTER ) THEN
        DO IPTR = FRTPTR(KEEP(38)), FRTPTR(KEEP(38)+1) - 1
          IELT = FRTELT( IPTR )
          SIZEI = id%ELTPTR( IELT + 1 ) - id%ELTPTR( IELT )
          DO I = 1, SIZEI
            TEMP_ELT_I( I ) = RG2L                                      &
     &              ( id%ELTVAR( id%ELTPTR(IELT) + I - 1 ) )
          END DO
          IVALPTR = ELROOTPOS( IPTR - FRTPTR(KEEP(38)) + 1 ) - 1
          K = 1
          DO J = 1, SIZEI
            JGLOB = id%ELTVAR( id%ELTPTR( IELT ) + J - 1 )
            IF ( KEEP(50).eq. 0 ) THEN
              IBEG = 1
            ELSE
              IBEG = J
            END IF
            DO I = IBEG, SIZEI
              IGLOB = id%ELTVAR( id%ELTPTR( IELT ) + I - 1 )
              IF ( KEEP(52) .eq. 0 ) THEN
                VAL = id%A_ELT( IVALPTR + K )
              ELSE
                VAL = id%A_ELT( IVALPTR + K ) *                         &
     &                id%ROWSCA( IGLOB ) * id%COLSCA( JGLOB )
              END IF
              IF ( KEEP(50).eq.0 ) THEN
                IPOSROOT = TEMP_ELT_I( I )
                JPOSROOT = TEMP_ELT_I( J )
              ELSE
                IF ( TEMP_ELT_I(I) .GT. TEMP_ELT_I(J) ) THEN
                  IPOSROOT = TEMP_ELT_I(I)
                  JPOSROOT = TEMP_ELT_I(J)
                ELSE
                  IPOSROOT = TEMP_ELT_I(J)
                  JPOSROOT = TEMP_ELT_I(I)
                END IF
              END IF
              IROW_GRID = mod( ( IPOSROOT - 1 )/root%MBLOCK,            &
     &                           root%NPROW )
              JCOL_GRID = mod( ( JPOSROOT - 1 )/root%NBLOCK,            &
     &                           root%NPCOL )
              IF ( KEEP(46) .eq. 0 ) THEN
                DEST = IROW_GRID * root%NPCOL + JCOL_GRID + 1
              ELSE
                DEST = IROW_GRID * root%NPCOL + JCOL_GRID
              END IF
              IF ( DEST .eq. MASTER ) THEN
                ARROW_ROOT = ARROW_ROOT + 1
                ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /           &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
                JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /           &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
              IF (KEEP(60)==0) THEN
                A( PTR_ROOT                                             &
     &             + int(JLOCROOT - 1,8) * int(LOCAL_M,8)               &
     &             + int(ILOCROOT - 1,8) )                              &
     &          =  A( PTR_ROOT                                          &
     &             + int(JLOCROOT - 1,8) * int(LOCAL_M,8)               &
     &             + int(ILOCROOT - 1,8) )                              &
     &          + VAL
              ELSE
                root%SCHUR_POINTER( int(JLOCROOT-1,8)                   &
     &                            * int(root%SCHUR_LLD,8)               &
     &                            + int(ILOCROOT,8) )                   &
     &          = root%SCHUR_POINTER( int(JLOCROOT-1,8)                 &
     &                            * int(root%SCHUR_LLD,8)               &
     &                            + int(ILOCROOT,8) )                   &
     &          + VAL
              ENDIF
              ELSE
                CALL DAGMG_MUMPS_34(                                         &
     &          IPOSROOT, JPOSROOT, VAL, DEST, BUFI, BUFR, NBRECORDS,   &
     &          NBUF, LP, COMM, KEEP(46) )
              END IF
              K = K + 1
            END DO
          END DO
        END DO
        CALL DAGMG_MUMPS_18(                                                 &
     &          BUFI, BUFR, NBRECORDS,                                  &
     &          NBUF, LP, COMM, KEEP(46) )
        ELSE
          FINI = .FALSE.
          DO WHILE ( .not. FINI )
            CALL AGMG_NOCALL('MPI_RECV')
            NB_REC = BUFI(1,1)
            IF (NB_REC.LE.0) THEN
              FINI = .TRUE.
              NB_REC = -NB_REC
            ENDIF
            IF (NB_REC.EQ.0) EXIT
            CALL AGMG_NOCALL('MPI_RECV')
            ARROW_ROOT = ARROW_ROOT + NB_REC
            DO IREC = 1, NB_REC
              IPOSROOT = BUFI( IREC * 2, 1 )
              JPOSROOT = BUFI( IREC * 2 + 1, 1 )
              VAL      = BUFR( IREC, 1 )
              ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /             &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
              JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /             &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
              IF (KEEP(60).eq.0) THEN
                 A( PTR_ROOT + int(JLOCROOT-1,8) * int(LOCAL_M,8)       &
     &                       + int(ILOCROOT-1,8))                       &
     &        =  A( PTR_ROOT + int(JLOCROOT-1,8) * int(LOCAL_M,8)       &
     &                       + int(ILOCROOT-1,8))                       &
     &           + VAL
              ELSE
                root%SCHUR_POINTER(int(JLOCROOT-1,8)                    &
     &                         * int(root%SCHUR_LLD,8)                  &
     &                         + int(ILOCROOT,8) )                      &
     &        = root%SCHUR_POINTER( int(JLOCROOT - 1,8)                 &
     &                         * int(root%SCHUR_LLD,8)                  &
     &                         + int(ILOCROOT,8))                       &
     &          + VAL
              ENDIF
            END DO
          END DO
          DEALLOCATE( BUFI )
          DEALLOCATE( BUFR )
        END IF
      END IF
      IF ( MYID .eq. MASTER ) THEN
        DEALLOCATE( BUFI )
        DEALLOCATE( BUFR )
        IF (KEEP(38).ne.0) THEN
          DEALLOCATE(ELROOTPOS)
          IF (KEEP(46) .eq. 0 ) THEN
             DEALLOCATE(RG2LALLOC)
          ENDIF
        ENDIF
        DEALLOCATE( TEMP_ELT_I )
      END IF
      KEEP(49) = ARROW_ROOT
      RETURN
      END SUBROUTINE DAGMG_MUMPS_126
      SUBROUTINE DAGMG_MUMPS_127(                                            &
     &       ELNODES, ELVAL, SIZEI, SIZER,                              &
     &       DEST, NBUF, NBRECORDS, BUFI, BUFR, COMM )
      IMPLICIT NONE
      INTEGER SIZEI, SIZER, DEST, NBUF, NBRECORDS, COMM
      INTEGER ELNODES( SIZEI ), BUFI( 2*NBRECORDS + 1, NBUF )
      DOUBLE PRECISION ELVAL( SIZER ), BUFR( NBRECORDS + 1, NBUF )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I, IBEG, IEND, IERR_MPI, NBRECR
      INTEGER NBRECI
      IF ( DEST .lt. 0 ) THEN
        IBEG = 1
        IEND = NBUF
      ELSE
        IBEG = DEST
        IEND = DEST
      END IF
      DO I = IBEG, IEND
        NBRECI = BUFI(1,I)
        IF ( NBRECI .ne.0  .and.                                        &
     &       ( DEST.eq.-2 .or.                                          &
     &         NBRECI + SIZEI .GT. 2*NBRECORDS ) ) THEN
           CALL AGMG_NOCALL('MPI_SEND')
           BUFI(1,I) = 0
           NBRECI    = 0
        END IF
        NBRECR = int(dble(BUFR(1,I))+0.5D0)
        IF ( NBRECR .ne.0  .and.                                        &
     &       ( DEST.eq.-2 .or.                                          &
     &         NBRECR + SIZER .GT. NBRECORDS ) ) THEN
           CALL AGMG_NOCALL('MPI_SEND')
           BUFR(1,I) = dble(0.0D0)
           NBRECR    = 0
        END IF
        IF ( DEST .ne. -2 ) THEN
          BUFI( 2 + NBRECI : 2 + NBRECI + SIZEI - 1, I ) =              &
     &    ELNODES( 1: SIZEI )
          BUFR( 2 + NBRECR : 2 + NBRECR + SIZER - 1, I ) =              &
     &    ELVAL( 1: SIZER )
          BUFI(1,I) = NBRECI + SIZEI
          BUFR(1,I) = dble( NBRECR + SIZER )
        END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_127
      SUBROUTINE DAGMG_MUMPS_213( ELTPTR, NELT, MAXELT_SIZE )
      INTEGER NELT, MAXELT_SIZE
      INTEGER ELTPTR( NELT + 1 )
      INTEGER I, S
      MAXELT_SIZE = 0
      DO I = 1, NELT
        S = ELTPTR( I + 1 ) - ELTPTR( I )
        MAXELT_SIZE = max( S, MAXELT_SIZE )
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_213
      SUBROUTINE DAGMG_MUMPS_288( N, SIZEI, SIZER,                           &
     &               ELTVAR, ELTVAL,                                    &
     &               SELTVAL, LSELTVAL,                                 &
     &               ROWSCA, COLSCA, K50 )
      INTEGER N, SIZEI, SIZER, LSELTVAL, K50
      INTEGER ELTVAR( SIZEI )
      DOUBLE PRECISION ELTVAL( SIZER )
      DOUBLE PRECISION SELTVAL( LSELTVAL )
      DOUBLE PRECISION ROWSCA( N ), COLSCA( N )
      INTEGER I, J, K
      K = 1
      IF ( K50 .eq. 0 ) THEN
        DO J = 1, SIZEI
          DO I = 1, SIZEI
            SELTVAL(K) = ELTVAL(K) *                                    &
     &                   ROWSCA(ELTVAR(I)) *                            &
     &                   COLSCA(ELTVAR(J))
            K = K + 1
          END DO
        END DO
      ELSE
        DO J = 1, SIZEI
          DO I = J, SIZEI
            SELTVAL(K) = ELTVAL(K) *                                    &
     &                   ROWSCA(ELTVAR(I)) *                            &
     &                   COLSCA(ELTVAR(J))
            K = K + 1
          END DO
        END DO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_288
      SUBROUTINE DAGMG_MUMPS_F77( JOB, SYM, PAR, COMM_F77, N, ICNTL, CNTL,   &
     &                      NZ, IRN, IRNhere, JCN, JCNhere, A, Ahere,   &
     &                      NZ_loc, IRN_loc, IRN_lochere,               &
     &                      JCN_loc, JCN_lochere,                       &
     &                      A_loc, A_lochere,                           &
     &                      NELT, ELTPTR, ELTPTRhere,  ELTVAR,          &
     &                      ELTVARhere, A_ELT, A_ELThere,               &
     &                      PERM_IN, PERM_INhere,                       &
     &                      RHS, RHShere, REDRHS, REDRHShere,           &
     &                      INFO, RINFO, INFOG, RINFOG,                 &
     &                      DEFICIENCY, LWK_USER,                       &
     &                      SIZE_SCHUR, LISTVAR_SCHUR,                  &
     &                      LISTVAR_SCHURhere, SCHUR, SCHURhere,        &
     &                      WK_USER, WK_USERhere,                       &
     &                      COLSCA, COLSCAhere, ROWSCA, ROWSCAhere,     &
     &                      INSTANCE_NUMBER, NRHS, LRHS, LREDRHS,       &
     &                      RHS_SPARSE, RHS_SPARSEhere,                 &
     &                      SOL_LOC, SOL_LOChere,                       &
     &                      IRHS_SPARSE, IRHS_SPARSEhere,               &
     &                      IRHS_PTR, IRHS_PTRhere,                     &
     &                      ISOL_LOC, ISOL_LOChere,                     &
     &                      NZ_RHS, LSOL_LOC                            &
     &                      ,                                           &
     & SCHUR_MLOC,                                                      &
     & SCHUR_NLOC,                                                      &
     & SCHUR_LLD,                                                       &
     & MBLOCK,                                                          &
     & NBLOCK,                                                          &
     & NPROW,                                                           &
     & NPCOL,                                                           &
     & OOC_TMPDIR,                                                      &
     & OOC_PREFIX,                                                      &
     & WRITE_PROBLEM,                                                   &
     & TMPDIRLEN,                                                       &
     & PREFIXLEN,                                                       &
     & WRITE_PROBLEMLEN                                                 &
     & )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTEGER OOC_PREFIX_MAX_LENGTH, OOC_TMPDIR_MAX_LENGTH
      INTEGER PB_MAX_LENGTH
      PARAMETER(OOC_PREFIX_MAX_LENGTH=63, OOC_TMPDIR_MAX_LENGTH=255)
      PARAMETER(PB_MAX_LENGTH=255)
      INTEGER JOB, SYM, PAR, COMM_F77, N, NZ, NZ_loc, NELT,             &
     &        DEFICIENCY, LWK_USER, SIZE_SCHUR, INSTANCE_NUMBER,        &
     &        NRHS, LRHS,                                               &
     &        NZ_RHS, LSOL_LOC, LREDRHS
      INTEGER ICNTL(40), INFO(40), INFOG(40)
      INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD
      INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
      INTEGER TMPDIRLEN, PREFIXLEN, WRITE_PROBLEMLEN
      DOUBLE PRECISION CNTL(15), RINFO(20), RINFOG(20)
      INTEGER, TARGET :: IRN(*), JCN(*), ELTPTR(*), ELTVAR(*)
      INTEGER, TARGET :: PERM_IN(*), IRN_loc(*), JCN_loc(*)
      INTEGER, TARGET :: LISTVAR_SCHUR(*)
      INTEGER, TARGET :: IRHS_PTR(*), IRHS_SPARSE(*), ISOL_LOC(*)
      DOUBLE PRECISION, TARGET :: A(*), A_ELT(*), A_loc(*), RHS(*)
      DOUBLE PRECISION, TARGET :: WK_USER(*)
      DOUBLE PRECISION, TARGET :: REDRHS(*)
      DOUBLE PRECISION, TARGET :: ROWSCA(*), COLSCA(*)
      DOUBLE PRECISION, TARGET :: SCHUR(*)
      DOUBLE PRECISION, TARGET :: RHS_SPARSE(*), SOL_LOC(*)
      INTEGER, INTENT(in) :: OOC_TMPDIR(OOC_TMPDIR_MAX_LENGTH)
      INTEGER, INTENT(in) :: OOC_PREFIX(OOC_PREFIX_MAX_LENGTH)
      INTEGER, INTENT(in) :: WRITE_PROBLEM(PB_MAX_LENGTH)
      INTEGER IRNhere, JCNhere, Ahere, ELTPTRhere, ELTVARhere,          &
     &        A_ELThere, PERM_INhere, WK_USERhere,                      &
     &        RHShere, REDRHShere, IRN_lochere,                         &
     &        JCN_lochere, A_lochere, LISTVAR_SCHURhere,                &
     &        SCHURhere, COLSCAhere, ROWSCAhere, RHS_SPARSEhere,        &
     &        SOL_LOChere, IRHS_PTRhere, IRHS_SPARSEhere, ISOL_LOChere, &
     &        DAGMG_MUMPS_OOC_PREFIXhere, DAGMG_MUMPS_OOC_TMDIRhere,              &
     &        DAGMG_MUMPS_WRITE_PROBLEMhere
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE DAGMG_MUMPS_STRUC_PTR
          TYPE (DAGMG_MUMPS_STRUC), POINTER :: PTR
      END TYPE DAGMG_MUMPS_STRUC_PTR
      TYPE (DAGMG_MUMPS_STRUC), POINTER :: AGMG_MUMPS_par
      TYPE (DAGMG_MUMPS_STRUC_PTR), DIMENSION (:), POINTER, SAVE ::          &
     &  AGMG_MUMPS_par_array
      TYPE (DAGMG_MUMPS_STRUC_PTR), DIMENSION (:), POINTER ::                &
     &  AGMG_MUMPS_par_array_bis
      INTEGER, SAVE :: DAGMG_MUMPS_STRUC_ARRAY_SIZE = 0
      INTEGER, SAVE :: N_INSTANCES = 0
      INTEGER A_ELT_SIZE, I, Np, IERR
      INTEGER DAGMG_MUMPS_STRUC_ARRAY_SIZE_INIT
      PARAMETER (DAGMG_MUMPS_STRUC_ARRAY_SIZE_INIT=10)
      IF (JOB == -1) THEN
        DO I = 1, DAGMG_MUMPS_STRUC_ARRAY_SIZE
          IF ( .NOT. associated(AGMG_MUMPS_par_array(I)%PTR) ) GOTO 10
        END DO
        ALLOCATE( AGMG_MUMPS_par_array_bis(DAGMG_MUMPS_STRUC_ARRAY_SIZE +         &
     &  DAGMG_MUMPS_STRUC_ARRAY_SIZE_INIT), stat=IERR)
        IF (IERR /= 0) THEN
          WRITE(*,*) ' ** Allocation Error 1 in DMUMPS_F77.'
          CALL AGMG_MUMPS_ABORT()
        END IF
        DO I = 1, DAGMG_MUMPS_STRUC_ARRAY_SIZE
          AGMG_MUMPS_par_array_bis(I)%PTR=>AGMG_MUMPS_par_array(I)%PTR
        ENDDO
        IF (associated(AGMG_MUMPS_par_array)) DEALLOCATE(AGMG_MUMPS_par_array)
        AGMG_MUMPS_par_array=>AGMG_MUMPS_par_array_bis
        NULLIFY(AGMG_MUMPS_par_array_bis)
        DO I = DAGMG_MUMPS_STRUC_ARRAY_SIZE+1, DAGMG_MUMPS_STRUC_ARRAY_SIZE +     &
     &  DAGMG_MUMPS_STRUC_ARRAY_SIZE_INIT
          NULLIFY(AGMG_MUMPS_par_array(I)%PTR)
        ENDDO
        I = DAGMG_MUMPS_STRUC_ARRAY_SIZE+1
        DAGMG_MUMPS_STRUC_ARRAY_SIZE = DAGMG_MUMPS_STRUC_ARRAY_SIZE +             &
     &  DAGMG_MUMPS_STRUC_ARRAY_SIZE_INIT
   10   CONTINUE
        INSTANCE_NUMBER = I
        N_INSTANCES = N_INSTANCES+1
        ALLOCATE( AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR,stat=IERR )
        IF (IERR /= 0) THEN
          WRITE(*,*) '** Allocation Error 2 in DMUMPS_F77.'
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR%KEEP(40) = 0
        AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR%INSTANCE_NUMBER =          &
     &  INSTANCE_NUMBER
      END IF
      IF ( INSTANCE_NUMBER .LE. 0 .OR. INSTANCE_NUMBER .GT.             &
     &     DAGMG_MUMPS_STRUC_ARRAY_SIZE ) THEN
        WRITE(*,*) ' ** Instance Error 1 in DMUMPS_F77',                &
     &             INSTANCE_NUMBER
        CALL AGMG_MUMPS_ABORT()
      END IF
      IF ( .NOT. associated ( AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR ) )  &
     &  THEN
        WRITE(*,*) ' Instance Error 2 in DMUMPS_F77',                   &
     &             INSTANCE_NUMBER
        CALL AGMG_MUMPS_ABORT()
      END IF
      AGMG_MUMPS_par => AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR
      AGMG_MUMPS_par%SYM = SYM
      AGMG_MUMPS_par%PAR = PAR
      AGMG_MUMPS_par%JOB = JOB
      AGMG_MUMPS_par%N   = N
      AGMG_MUMPS_par%NZ  = NZ
      AGMG_MUMPS_par%NZ_loc  = NZ_loc
      AGMG_MUMPS_par%LWK_USER = LWK_USER
      AGMG_MUMPS_par%SIZE_SCHUR  = SIZE_SCHUR
      AGMG_MUMPS_par%NELT= NELT
      AGMG_MUMPS_par%ICNTL(1:40)=ICNTL(1:40)
      AGMG_MUMPS_par%CNTL(1:15)=CNTL(1:15)
      AGMG_MUMPS_par%NRHS  = NRHS
      AGMG_MUMPS_par%LRHS  = LRHS
      AGMG_MUMPS_par%LREDRHS = LREDRHS
      AGMG_MUMPS_par%NZ_RHS   = NZ_RHS
      AGMG_MUMPS_par%LSOL_LOC = LSOL_LOC
      AGMG_MUMPS_par%SCHUR_MLOC   = SCHUR_MLOC
      AGMG_MUMPS_par%SCHUR_NLOC   = SCHUR_NLOC
      AGMG_MUMPS_par%SCHUR_LLD    = SCHUR_LLD
      AGMG_MUMPS_par%MBLOCK = MBLOCK
      AGMG_MUMPS_par%NBLOCK = NBLOCK
      AGMG_MUMPS_par%NPROW  = NPROW
      AGMG_MUMPS_par%NPCOL  = NPCOL
      IF ( COMM_F77 .NE. -987654 ) THEN
        AGMG_MUMPS_par%COMM = COMM_F77
      ELSE
        AGMG_MUMPS_par%COMM = AGMG_MPF_COMM_WORLD
      ENDIF
      CALL AGMG_SETIERR(IERR)
      IF ( IRNhere /= 0 ) AGMG_MUMPS_par%IRN => IRN(1:NZ)
      IF ( JCNhere /= 0 ) AGMG_MUMPS_par%JCN => JCN(1:NZ)
      IF ( Ahere /= 0 )   AGMG_MUMPS_par%A   => A(1:NZ)
      IF ( IRN_lochere /= 0 ) AGMG_MUMPS_par%IRN_loc => IRN_loc(1:NZ_loc)
      IF ( JCN_lochere /= 0 ) AGMG_MUMPS_par%JCN_loc => JCN_loc(1:NZ_loc)
      IF ( A_lochere /= 0 )   AGMG_MUMPS_par%A_loc   => A_loc(1:NZ_loc)
      IF ( ELTPTRhere /= 0 ) AGMG_MUMPS_par%ELTPTR => ELTPTR(1:NELT+1)
      IF ( ELTVARhere /= 0 ) AGMG_MUMPS_par%ELTVAR =>                        &
     &   ELTVAR(1:ELTPTR(NELT+1)-1)
      IF ( A_ELThere /= 0 ) THEN
        A_ELT_SIZE = 0
        DO I = 1, NELT
          Np = ELTPTR(I+1) -ELTPTR(I)
          IF (SYM == 0) THEN
            A_ELT_SIZE = A_ELT_SIZE + Np * Np
          ELSE
            A_ELT_SIZE = A_ELT_SIZE + Np * ( Np + 1 ) / 2
          END IF
        END DO
        AGMG_MUMPS_par%A_ELT => A_ELT(1:A_ELT_SIZE)
      END IF
      IF ( PERM_INhere /= 0) AGMG_MUMPS_par%PERM_IN => PERM_IN(1:N)
      IF ( LISTVAR_SCHURhere /= 0)                                      &
     &   AGMG_MUMPS_par%LISTVAR_SCHUR =>LISTVAR_SCHUR(1:SIZE_SCHUR)
      IF ( SCHURhere /= 0 ) THEN
        AGMG_MUMPS_par%SCHUR_CINTERFACE=>SCHUR(1:1)
      ENDIF
      IF (NRHS .NE. 1) THEN
        IF ( RHShere /= 0 ) AGMG_MUMPS_par%RHS => RHS(1:NRHS*LRHS)
        IF (REDRHShere /= 0)AGMG_MUMPS_par%REDRHS=>REDRHS(1:NRHS*LREDRHS)
      ELSE
        IF ( RHShere /= 0 ) AGMG_MUMPS_par%RHS => RHS(1:N)
        IF (REDRHShere /= 0)AGMG_MUMPS_par%REDRHS=>REDRHS(1:SIZE_SCHUR)
      ENDIF
      IF ( WK_USERhere /=0 ) THEN
        IF (LWK_USER > 0 ) THEN
          AGMG_MUMPS_par%WK_USER => WK_USER(1:LWK_USER)
        ELSE
          AGMG_MUMPS_par%WK_USER => WK_USER(1_8:-int(LWK_USER,8)*1000000_8)
        ENDIF
      ENDIF
      IF ( COLSCAhere /= 0) AGMG_MUMPS_par%COLSCA => COLSCA(1:N)
      IF ( ROWSCAhere /= 0) AGMG_MUMPS_par%ROWSCA => ROWSCA(1:N)
      IF ( RHS_SPARSEhere /=0 ) AGMG_MUMPS_par%RHS_SPARSE=>                  &
     &                          RHS_SPARSE(1:NZ_RHS)
      IF ( IRHS_SPARSEhere /=0 ) AGMG_MUMPS_par%IRHS_SPARSE=>                &
     &                          IRHS_SPARSE(1:NZ_RHS)
      IF ( SOL_LOChere /=0 ) AGMG_MUMPS_par%SOL_LOC=>                        &
     &                          SOL_LOC(1:LSOL_LOC*NRHS)
      IF ( ISOL_LOChere /=0 ) AGMG_MUMPS_par%ISOL_LOC=>                      &
     &                          ISOL_LOC(1:LSOL_LOC)
      IF ( IRHS_PTRhere /=0 ) AGMG_MUMPS_par%IRHS_PTR=>                      &
     &                          IRHS_PTR(1:NRHS+1)
      DO I=1,TMPDIRLEN
        AGMG_MUMPS_par%OOC_TMPDIR(I:I)=char(OOC_TMPDIR(I))
      ENDDO
      DO I=TMPDIRLEN+1,OOC_TMPDIR_MAX_LENGTH
        AGMG_MUMPS_par%OOC_TMPDIR(I:I)=' '
      ENDDO
      DO I=1,PREFIXLEN
        AGMG_MUMPS_par%OOC_PREFIX(I:I)=char(OOC_PREFIX(I))
      ENDDO
      DO I=PREFIXLEN+1,OOC_PREFIX_MAX_LENGTH
        AGMG_MUMPS_par%OOC_PREFIX(I:I)=' '
      ENDDO
      DO I=1,WRITE_PROBLEMLEN
        AGMG_MUMPS_par%WRITE_PROBLEM(I:I)=char(WRITE_PROBLEM(I))
      ENDDO
      DO I=WRITE_PROBLEMLEN+1,PB_MAX_LENGTH
        AGMG_MUMPS_par%WRITE_PROBLEM(I:I)=' '
      ENDDO
      CALL DAGMG_MUMPS( AGMG_MUMPS_par )
      INFO(1:40)=AGMG_MUMPS_par%INFO(1:40)
      INFOG(1:40)=AGMG_MUMPS_par%INFOG(1:40)
      RINFO(1:20)=AGMG_MUMPS_par%RINFO(1:20)
      RINFOG(1:20)=AGMG_MUMPS_par%RINFOG(1:20)
      ICNTL(1:40) = AGMG_MUMPS_par%ICNTL(1:40)
      CNTL(1:15) = AGMG_MUMPS_par%CNTL(1:15)
      SYM = AGMG_MUMPS_par%SYM
      PAR = AGMG_MUMPS_par%PAR
      JOB = AGMG_MUMPS_par%JOB
      N   = AGMG_MUMPS_par%N
      NZ  = AGMG_MUMPS_par%NZ
      NRHS = AGMG_MUMPS_par%NRHS
      LRHS = AGMG_MUMPS_par%LRHS
      LREDRHS = AGMG_MUMPS_par%LREDRHS
      NZ_loc  = AGMG_MUMPS_par%NZ_loc
      NZ_RHS  = AGMG_MUMPS_par%NZ_RHS
      LSOL_LOC= AGMG_MUMPS_par%LSOL_LOC
      SIZE_SCHUR  = AGMG_MUMPS_par%SIZE_SCHUR
      LWK_USER = AGMG_MUMPS_par%LWK_USER
      NELT= AGMG_MUMPS_par%NELT
      DEFICIENCY = AGMG_MUMPS_par%Deficiency
      SCHUR_MLOC   = AGMG_MUMPS_par%SCHUR_MLOC
      SCHUR_NLOC   = AGMG_MUMPS_par%SCHUR_NLOC
      SCHUR_LLD    = AGMG_MUMPS_par%SCHUR_LLD
      MBLOCK       = AGMG_MUMPS_par%MBLOCK
      NBLOCK       = AGMG_MUMPS_par%NBLOCK
      NPROW        = AGMG_MUMPS_par%NPROW
      NPCOL        = AGMG_MUMPS_par%NPCOL
      IF ( associated (AGMG_MUMPS_par%MAPPING) ) THEN
         CALL AGMG_NOCALL('MUMPS_AFFECT_MAPPING')
      ELSE
         CALL AGMG_NOCALL('MUMPS_NULLIFY_C_MAPPING')
      ENDIF
      IF ( associated (AGMG_MUMPS_par%PIVNUL_LIST) ) THEN
         CALL AGMG_NOCALL('MUMPS_AFFECT_PIVNUL_LIST')
      ELSE
         CALL AGMG_NOCALL('MUMPS_NULLIFY_C_PIVNUL_LIST')
      ENDIF
      IF ( associated (AGMG_MUMPS_par%SYM_PERM) ) THEN
         CALL AGMG_NOCALL('MUMPS_AFFECT_SYM_PERM')
      ELSE
         CALL AGMG_NOCALL('MUMPS_NULLIFY_C_SYM_PERM')
      ENDIF
      IF ( associated (AGMG_MUMPS_par%UNS_PERM) ) THEN
         CALL AGMG_NOCALL('MUMPS_AFFECT_UNS_PERM')
      ELSE
         CALL AGMG_NOCALL('MUMPS_NULLIFY_C_UNS_PERM')
      ENDIF
      IF ( JOB == -2 ) THEN
         IF (associated(AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR))THEN
           DEALLOCATE(AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR)
           NULLIFY   (AGMG_MUMPS_par_array(INSTANCE_NUMBER)%PTR)
           N_INSTANCES = N_INSTANCES - 1
           IF ( N_INSTANCES == 0 ) THEN
             DEALLOCATE(AGMG_MUMPS_par_array)
             DAGMG_MUMPS_STRUC_ARRAY_SIZE = 0
           END IF
         ELSE
           WRITE(*,*) "** Warning: instance already freed"
           WRITE(*,*) "            this should normally not happen."
         ENDIF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_F77
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_246(MYID, N, STEP, FRERE, FILS,                 &
     &     NA, LNA, NE, DAD, ND, PROCNODE, SLAVEF,                      &
     &     NRLADU, NIRADU, NIRNEC, NRLNEC,                              &
     &     NRLNEC_ACTIVE,                                               &
     &     NIRADU_OOC, NIRNEC_OOC,                                      &
     &     MAXFR, OPSA,                                                 &
     &     KEEP,KEEP8, LOCAL_M, LOCAL_N, SBUF_RECOLD,                   &
     &     SBUF_SEND, SBUF_REC, OPS_SUBTREE, NSTEPS,                    &
     &     I_AM_CAND,NMB_PAR2, ISTEP_TO_INIV2, CANDIDATES,              &
     &     IFLAG, IERROR                                                &
     &     ,MAX_FRONT_SURFACE_LOCAL                                     &
     &     ,MAX_SIZE_FACTOR, ENTRIES_IN_FACTORS_LOC,                    &
     &     ENTRIES_IN_FACTORS_TOT                                       &
     &     )
      IMPLICIT NONE
      INTEGER  MYID, N, LNA, IFLAG, IERROR
      INTEGER  NIRADU, NIRNEC
      INTEGER*8 NRLADU, NRLNEC, NRLNEC_ACTIVE
      INTEGER*8 NRLADU_CURRENT, NRLADU_ROOT_3
      INTEGER NIRADU_OOC, NIRNEC_OOC
      INTEGER MAXFR, NSTEPS
      INTEGER*8 MAX_FRONT_SURFACE_LOCAL
      INTEGER STEP(N)
      INTEGER FRERE(NSTEPS), FILS(N), NA(LNA), NE(NSTEPS),              &
     &        ND(NSTEPS), PROCNODE(NSTEPS), DAD(NSTEPS)
      INTEGER  SLAVEF, KEEP(500), LOCAL_M, LOCAL_N
      INTEGER*8 KEEP8(150)
      INTEGER*8 ENTRIES_IN_FACTORS_LOC, ENTRIES_IN_FACTORS_TOT
      INTEGER  SBUF_SEND, SBUF_REC
      INTEGER*8 SBUF_RECOLD
      INTEGER  NMB_PAR2
      INTEGER  ISTEP_TO_INIV2( KEEP(71) )
      LOGICAL  I_AM_CAND(NMB_PAR2)
      INTEGER  CANDIDATES( SLAVEF+1, NMB_PAR2 )
      INTEGER  PHASE
      PARAMETER (PHASE=0)
      DOUBLE PRECISION OPSA
      DOUBLE PRECISION OPSA_LOC
      INTEGER*8 MAX_SIZE_FACTOR
      DOUBLE PRECISION OPS_SUBTREE
      DOUBLE PRECISION OPS_SBTR_LOC
      INTEGER, ALLOCATABLE, DIMENSION(:) :: TNSTK, IPOOL, LSTKI
      INTEGER*8, ALLOCATABLE, DIMENSION(:) :: LSTKR
      INTEGER*8 SBUFS_CB, SBUFR_CB
      INTEGER SBUFR, SBUFS
      INTEGER BLOCKING_RHS
      INTEGER I,ITOP,NELIM,NFR
      INTEGER*8 ISTKR, LSTK
      INTEGER ISTKI,  STKI, ISTKI_OOC
      INTEGER K,NSTK, IFATH
      INTEGER INODE, LEAF, NBLEAF, NBROOT, IN
      INTEGER LEVEL, MAXITEMPCB
      INTEGER*8 CURRENT_ACTIVE_MEM, MAXTEMPCB
      LOGICAL UPDATE, UPDATEF, MASTER, MASTERF, INSSARBR
      INTEGER LEVELF, NCB, SIZECBI
      INTEGER*8 NCB8
      INTEGER*8 NFR8, NELIM8
      INTEGER*8 SIZECB, SIZECBINFR, SIZECB_SLAVE
      INTEGER SIZEHEADER, SIZEHEADER_OOC, XSIZE_OOC
      INTEGER EXTRA_PERM_INFO_OOC
      INTEGER NBROWMAX, NSLAVES_LOC, NSLAVES_PASSED,                    &
     &         NELIMF, NFRF, NCBF,                                      &
     &         NSLAVESF, NBROWMAXF, LKJIB,                              &
     &         LKJIBT, NBR, NBCOLFAC,                                   &
     &         NBROWAVG
      INTEGER*8 LEV3MAXREC, CBMAXR, CBMAXS
      INTEGER LWK_RR, LIWK_RR
      INTEGER IROOT, SIZE_ROOT
      INTEGER ALLOCOK
      INTEGER PANEL_SIZE
      LOGICAL ROOT_OWNER, COMPRESSCB
      DOUBLE PRECISION OPS_NODE, OPS_NODE_MASTER, OPS_NODE_SLAVE
      INTEGER*8 ENTRIES_NODE_UPPER_PART, ENTRIES_NODE_LOWER_PART
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER WHAT
      INTEGER*8 IDUMMY8
      INTRINSIC min, int, real
      INTEGER DAGMG_MUMPS_748
      EXTERNAL DAGMG_MUMPS_748
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      LOGICAL AGMG_MUMPS_170
      INTEGER AGMG_MUMPS_52
      EXTERNAL AGMG_MUMPS_503, AGMG_MUMPS_52
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330,                                    &
     &         AGMG_MUMPS_170
      logical :: FORCE_CAND, CONCERNED, UPDATES, STACKCB, MASTERSON
      integer :: istat, IFSON, LEVELSON
      IF (KEEP(50).eq.2) THEN
        EXTRA_PERM_INFO_OOC = 1
      ELSE IF (KEEP(50).eq.0) THEN
        EXTRA_PERM_INFO_OOC = 2
      ELSE
        EXTRA_PERM_INFO_OOC = 0
      ENDIF
      COMPRESSCB=( KEEP(215).EQ.0 .AND. KEEP(50).NE.0 )
      MAX_FRONT_SURFACE_LOCAL=0_8
      MAX_SIZE_FACTOR=0_8
      ALLOCATE( LSTKR(NSTEPS), TNSTK(NSTEPS), IPOOL(NSTEPS),            &
     &          LSTKI(NSTEPS) , stat=ALLOCOK)
      if (ALLOCOK .GT. 0) THEN
        IFLAG  =-7
        IERROR = 4*NSTEPS
        RETURN
      endif
      LKJIB = max(KEEP(5),KEEP(6))
      TNSTK = NE
      LEAF = NA(1)+1
      IPOOL(1:LEAF-1) = NA(3:3+LEAF-2)
      NBROOT = NA(2)
      IF (KEEP(50).EQ.0) THEN
              XSIZE_OOC=XSIZE_OOC_UNSYM
      ELSE
              XSIZE_OOC=XSIZE_OOC_SYM
      ENDIF
      SIZEHEADER_OOC = XSIZE_OOC+6
      SIZEHEADER = XSIZE_IC + 6
      ISTKR      = 0_8
      ISTKI      = 0
      ISTKI_OOC  = 0
      OPSA_LOC   = dble(0.0D0)
      ENTRIES_IN_FACTORS_LOC = 0_8
      ENTRIES_IN_FACTORS_TOT = 0_8
      OPS_SBTR_LOC = dble(0.0D0)
      NRLADU     = 0_8
      NIRADU     = 0
      NIRADU_OOC = 0
      NRLADU_CURRENT = 0_8
      NRLADU_ROOT_3 = 0_8
      NRLNEC_ACTIVE = 0_8
      NRLNEC     = 0_8
      NIRNEC     = 0
      NIRNEC_OOC = 0
      MAXFR      = 0
      ITOP       = 0
      MAXTEMPCB  = 0_8
      MAXITEMPCB = 0
      SBUFS_CB   = 1_8
      SBUFS      = 1
      SBUFR_CB   = 1_8
      SBUFR      = 1
      IF (KEEP(38) .NE. 0 .AND. KEEP(60).EQ.0) THEN
        INODE  = KEEP(38)
        NRLADU_ROOT_3 = int(LOCAL_M,KIND=8)*int(LOCAL_N,KIND=8)
        NRLADU = NRLADU_ROOT_3
        NRLNEC_ACTIVE = NRLADU_CURRENT
        MAX_SIZE_FACTOR=max(MAX_SIZE_FACTOR,NRLADU_ROOT_3)
        NRLNEC = NRLADU
        IF (AGMG_MUMPS_275(STEP(INODE),PROCNODE,SLAVEF)                      &
     &                                       .EQ. MYID) THEN
          NIRADU     = SIZEHEADER+2*ND(STEP(INODE))
          NIRADU_OOC = SIZEHEADER_OOC+2*ND(STEP(INODE))
        ELSE
          NIRADU     = SIZEHEADER
          NIRADU_OOC = SIZEHEADER_OOC
        ENDIF
        NIRNEC     = NIRADU
        NIRNEC_OOC = NIRADU_OOC
      ENDIF
      IF((KEEP(24).eq.0).OR.(KEEP(24).eq.1)) THEN
         FORCE_CAND=.FALSE.
      ELSE
         FORCE_CAND=(mod(KEEP(24),2).eq.0)
      END IF
   90 CONTINUE
      IF (LEAF.NE.1) THEN
         LEAF = LEAF - 1
         INODE = IPOOL(LEAF)
      ELSE
         WRITE(MYID+6,*) ' ERROR 1 in DMUMPS_246 '
         CALL AGMG_MUMPS_ABORT()
      ENDIF
   95 CONTINUE
      NFR    = ND(STEP(INODE))
      NFR8   = int(NFR,8)
      NSTK   = NE(STEP(INODE))
      NELIM = 0
        IN = INODE
  100   NELIM = NELIM + 1
      NELIM8=int(NELIM,8)
        IN = FILS(IN)
        IF (IN .GT. 0 ) GOTO 100
      IFSON = -IN
      IFATH = DAD(STEP(INODE))
      MASTER = AGMG_MUMPS_275(STEP(INODE),PROCNODE,SLAVEF)                   &
     &           .EQ. MYID
      LEVEL  = AGMG_MUMPS_330(STEP(INODE),PROCNODE,SLAVEF)
      INSSARBR = AGMG_MUMPS_170(STEP(INODE),                                 &
     &        PROCNODE,SLAVEF)
      UPDATE=.FALSE.
       if(.NOT.FORCE_CAND) then
         UPDATE = ( (MASTER.AND.(LEVEL.NE.3) ).OR. LEVEL.EQ.2 )
       else
         if(MASTER.and.(LEVEL.ne.3)) then
            UPDATE = .TRUE.
         else if(LEVEL.eq.2) then
            if ( I_AM_CAND(ISTEP_TO_INIV2(STEP(INODE)))) THEN
              UPDATE = .TRUE.
            end if
         end if
       end if
      NCB      = NFR-NELIM
      NCB8     = int(NCB,8)
      SIZECBINFR = NCB8*NCB8
      IF (KEEP(50).EQ.0) THEN
        SIZECB = SIZECBINFR
      ELSE
        IFATH = DAD(STEP(INODE))
        IF ( IFATH.NE.KEEP(38) .AND. COMPRESSCB ) THEN
          SIZECB    = (NCB8*(NCB8+1_8))/2_8
        ELSE
          SIZECB    = SIZECBINFR
        ENDIF
      ENDIF
      SIZECBI      = 2* NCB  + SIZEHEADER
      IF (LEVEL.NE.2) THEN
        NSLAVES_LOC     = -99999999
        SIZECB_SLAVE = -99999997_8
        NBROWMAX        = NCB
      ELSE
        IF (KEEP(48) .EQ. 5) THEN
          WHAT = 5
          IF (FORCE_CAND) THEN
            NSLAVES_LOC=CANDIDATES(SLAVEF+1,                            &
     &                    ISTEP_TO_INIV2(STEP(INODE)))
          ELSE
            NSLAVES_LOC=SLAVEF-1
          ENDIF
          NSLAVES_PASSED=NSLAVES_LOC
        ELSE
          WHAT = 2
          NSLAVES_PASSED=SLAVEF
          NSLAVES_LOC   =SLAVEF-1
        ENDIF
         CALL AGMG_MUMPS_503(WHAT, KEEP,KEEP8,                               &
     &     NCB, NFR, NSLAVES_PASSED, NBROWMAX, SIZECB_SLAVE)
      ENDIF
      IF (KEEP(60).GT.1) THEN
         IF (MASTER .AND. INODE.EQ.KEEP(38)) THEN
          NIRADU     = NIRADU+SIZEHEADER+2*ND(STEP(INODE))
          NIRADU_OOC = NIRADU_OOC+SIZEHEADER_OOC+2*ND(STEP(INODE))
         ENDIF
      ENDIF
      IF (LEVEL.EQ.3) THEN
         IF (                                                           &
     &     KEEP(60).LE.1                                                &
     &      ) THEN
           NRLNEC = max(NRLNEC,NRLADU+ISTKR+                            &
     &                 int(LOCAL_M,8)*int(LOCAL_N,8))
           NRLADU_CURRENT = int(LOCAL_M,8)*int(LOCAL_N,8)
           NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,NRLADU_ROOT_3 +            &
     &                        NRLADU_CURRENT+ISTKR)
         ENDIF
         IF (MASTER) THEN
            IF (NFR.GT.MAXFR) MAXFR = NFR
         ENDIF
      ENDIF
      IF(KEEP(86).EQ.1)THEN
         IF(MASTER.AND.(.NOT.AGMG_MUMPS_170(STEP(INODE),                     &
     &        PROCNODE,SLAVEF)))THEN
            IF(LEVEL.EQ.1)THEN
               MAX_FRONT_SURFACE_LOCAL=max(MAX_FRONT_SURFACE_LOCAL,     &
     &              NFR8*NFR8)
            ELSEIF(LEVEL.EQ.2)THEN
               IF(KEEP(50).EQ.0)THEN
                 MAX_FRONT_SURFACE_LOCAL=max(MAX_FRONT_SURFACE_LOCAL,   &
     &                 NFR8*NELIM8)
               ELSE
                 MAX_FRONT_SURFACE_LOCAL=max(MAX_FRONT_SURFACE_LOCAL,   &
     &                 NELIM8*NELIM8)
                 IF (KEEP(219).NE.0.AND.KEEP(50).EQ.2) THEN
                  MAX_FRONT_SURFACE_LOCAL=max(MAX_FRONT_SURFACE_LOCAL,  &
     &                  NELIM8*(NELIM8+1_8))
                 ENDIF
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      IF (LEVEL.EQ.2) THEN
        IF (MASTER) THEN
          IF (KEEP(50).EQ.0) THEN
             SBUFS = max(SBUFS, NFR*LKJIB+LKJIB+4)
          ELSE
             SBUFS = max(SBUFS, NELIM*LKJIB+NELIM+6)
          ENDIF
        ELSEIF (UPDATE) THEN
            if (KEEP(50).EQ.0) THEN
              SBUFR   = max(SBUFR, NFR*LKJIB+LKJIB+4)
            else
              SBUFR = max( SBUFR, NELIM*LKJIB+NELIM+6 )
              IF (KEEP(50).EQ.1) THEN
                LKJIBT  = LKJIB
              ELSE
                LKJIBT  = min( NELIM, LKJIB * 2 )
              ENDIF
              SBUFS = max(SBUFS,                                        &
     &                        LKJIBT*NBROWMAX+6)
              SBUFR = max( SBUFR, NBROWMAX*LKJIBT+6 )
            endif
        ENDIF
      ENDIF
      IF ( UPDATE ) THEN
          IF ( (MASTER) .AND. (LEVEL.EQ.1) ) THEN
            NIRADU     = NIRADU + 2*NFR + SIZEHEADER
            NIRADU_OOC = NIRADU_OOC + 2*NFR + SIZEHEADER_OOC
            PANEL_SIZE = DAGMG_MUMPS_748(                                    &
     &      2_8*int(KEEP(226),8), NFR, KEEP(227), KEEP(50))
            NIRADU_OOC = NIRADU_OOC +                                   &
     &      EXTRA_PERM_INFO_OOC*(2+NELIM + NELIM/PANEL_SIZE+1)
            IF (KEEP(50).EQ.0) THEN
             NRLADU_CURRENT = int(NELIM,8)*int(2*NFR-NELIM,8)
             NRLADU = NRLADU + NRLADU_CURRENT
             MAX_SIZE_FACTOR=max(MAX_SIZE_FACTOR,NRLADU_CURRENT)
            ELSE
             NRLADU_CURRENT = int(NELIM,8)*int(NFR,8)
             NRLADU = NRLADU + NRLADU_CURRENT
             MAX_SIZE_FACTOR=max(MAX_SIZE_FACTOR,NRLADU_CURRENT)
            ENDIF
            SIZECBI        = 2* NCB  + 6 + 3
          ELSEIF (LEVEL.EQ.2) THEN
            IF (MASTER) THEN
              NIRADU     = NIRADU+SIZEHEADER +SLAVEF-1+2*NFR
              NIRADU_OOC = NIRADU_OOC+SIZEHEADER_OOC +SLAVEF-1+2*NFR
              IF (KEEP(50).EQ.0) THEN
                NBCOLFAC=NFR
              ELSE
                NBCOLFAC=NELIM
              ENDIF
              PANEL_SIZE = DAGMG_MUMPS_748(                                  &
     &        2_8*int(KEEP(226),8), NBCOLFAC, KEEP(227), KEEP(50))
              NIRADU_OOC = NIRADU_OOC +                                 &
     &        EXTRA_PERM_INFO_OOC*(2+NELIM + NELIM/PANEL_SIZE+1)
              NRLADU_CURRENT = int(NBCOLFAC,8)*int(NELIM,8)
              NRLADU = NRLADU + NRLADU_CURRENT
              MAX_SIZE_FACTOR=max(MAX_SIZE_FACTOR,NRLADU_CURRENT)
               SIZECB     = 0_8
               SIZECBINFR = 0_8
               SIZECBI    = NCB + 5 +  SLAVEF - 1
            ELSE
             SIZECB=SIZECB_SLAVE
             SIZECBINFR = SIZECB
             NIRADU       = NIRADU+4+NELIM+NBROWMAX
             NIRADU_OOC   = NIRADU_OOC+4+NELIM+NBROWMAX
             IF (KEEP(50).EQ.0) THEN
               NRLADU   = NRLADU + int(NELIM,8)*int(NBROWMAX,8)
             ELSE
               NRLADU   = NRLADU + int(NELIM,8)*int(NCB/NSLAVES_LOC,8)
             ENDIF
             NRLADU_CURRENT = int(NELIM,8)*int(NBROWMAX,8)
             MAX_SIZE_FACTOR=max(MAX_SIZE_FACTOR,NRLADU_CURRENT)
             SIZECBI       = 4 + NBROWMAX + NCB
             IF (KEEP(50).NE.0) THEN
                     SIZECBI=SIZECBI+NSLAVES_LOC+                       &
     &                                  XTRA_SLAVES_SYM
             ELSE
                     SIZECBI=SIZECBI+NSLAVES_LOC+                       &
     &                                  XTRA_SLAVES_UNSYM
             ENDIF
            ENDIF
         ENDIF
         NIRNEC = max0(NIRNEC,                                          &
     &             NIRADU+ISTKI+SIZECBI+MAXITEMPCB)
         NIRNEC_OOC = max0(NIRNEC_OOC,                                  &
     &             NIRADU_OOC+ISTKI_OOC+SIZECBI+MAXITEMPCB +            &
     &             (XSIZE_OOC-XSIZE_IC) )
         CURRENT_ACTIVE_MEM = ISTKR+SIZECBINFR
         IF (NSTK .NE. 0 .AND. INSSARBR .AND.                           &
     &     KEEP(234).NE.0 .AND. KEEP(55).EQ.0) THEN
           CURRENT_ACTIVE_MEM = CURRENT_ACTIVE_MEM - LSTKR(ITOP)
         ENDIF
         IF (KEEP(50).NE.0.AND.UPDATE.AND.LEVEL.EQ.1) THEN
             CURRENT_ACTIVE_MEM = CURRENT_ACTIVE_MEM +                  &
     &              int(NELIM,8)*int(NCB,8)
         ENDIF
         IF (MASTER .AND.  KEEP(219).NE.0.AND.                          &
     &       KEEP(50).EQ.2.AND.LEVEL.EQ.2) THEN
             CURRENT_ACTIVE_MEM = CURRENT_ACTIVE_MEM + int(NELIM,8)
         ENDIF
         IF (SLAVEF.EQ.1) THEN
           NRLNEC = max(NRLNEC,NRLADU+CURRENT_ACTIVE_MEM)
           NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,NRLADU_CURRENT+            &
     &             NRLADU_ROOT_3+CURRENT_ACTIVE_MEM)
         ELSE
           NRLNEC = max(NRLNEC,NRLADU+CURRENT_ACTIVE_MEM+MAXTEMPCB)
           NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,NRLADU_CURRENT+            &
     &             NRLADU_ROOT_3+CURRENT_ACTIVE_MEM+MAXTEMPCB)
         ENDIF
         IF (NFR.GT.MAXFR) MAXFR = NFR
         IF (NSTK.GT.0) THEN
            DO 70 K=1,NSTK
               LSTK = LSTKR(ITOP)
               ISTKR = ISTKR - LSTK
               IF (K==1 .AND. INSSARBR.AND.KEEP(234).NE.0               &
     &            .AND.KEEP(55).EQ.0) THEN
               ELSE
                 CURRENT_ACTIVE_MEM = CURRENT_ACTIVE_MEM - LSTK
               ENDIF
               STKI = LSTKI( ITOP )
               ISTKI = ISTKI - STKI
               ISTKI_OOC = ISTKI_OOC - STKI - (XSIZE_OOC-XSIZE_IC)
               ITOP = ITOP - 1
               IF (ITOP.LT.0) THEN
                  write(*,*) MYID,                                      &
     &            ': ERROR 2 in DMUMPS_246. ITOP = ',ITOP
                  CALL AGMG_MUMPS_ABORT()
               ENDIF
   70       CONTINUE
         ENDIF
      ELSE IF (LEVEL.NE.3) THEN
         DO WHILE (IFSON.GT.0)
            UPDATES=.FALSE.
            MASTERSON = AGMG_MUMPS_275(STEP(IFSON),PROCNODE,SLAVEF)          &
     &                  .EQ.MYID
            LEVELSON  = AGMG_MUMPS_330(STEP(IFSON),PROCNODE,SLAVEF)
            if(.NOT.FORCE_CAND) then
               UPDATES =((MASTERSON.AND.(LEVELSON.NE.3)).OR.            &
     &                   LEVELSON.EQ.2)
            else
               if(MASTERSON.and.(LEVELSON.ne.3)) then
                  UPDATES = .TRUE.
               else if(LEVELSON.eq.2) then
                  if ( I_AM_CAND(ISTEP_TO_INIV2(STEP(IFSON)))) then
                    UPDATES = .TRUE.
                  end if
               end if
            end if
            IF (UPDATES) THEN
              LSTK = LSTKR(ITOP)
              ISTKR = ISTKR - LSTK
              STKI = LSTKI( ITOP )
              ISTKI = ISTKI - STKI
              ISTKI_OOC = ISTKI_OOC - STKI - (XSIZE_OOC-XSIZE_IC)
              ITOP = ITOP - 1
              IF (ITOP.LT.0) THEN
                write(*,*) MYID,                                        &
     &          ': ERROR 2 in DMUMPS_246. ITOP = ',ITOP
                CALL AGMG_MUMPS_ABORT()
              ENDIF
            ENDIF
            IFSON = FRERE(STEP(IFSON))
         END DO
      ENDIF
      IF (                                                              &
     &        ( (INODE.NE.KEEP(20)).OR.(KEEP(60).EQ.0) )                &
     &       .AND.                                                      &
     &        ( (INODE.NE.KEEP(38)).OR.(KEEP(60).LE.1) )                &
     &      )                                                           &
     &THEN
            ENTRIES_NODE_LOWER_PART = int(NFR-NELIM,8) * int(NELIM,8)
            IF ( KEEP(50).EQ.0 ) THEN
              ENTRIES_NODE_UPPER_PART = int(NFR,8) * int(NELIM,8)
            ELSE
              ENTRIES_NODE_UPPER_PART =                                 &
     &        (int(NELIM,8)*int(NELIM+1,8))/2_8
            ENDIF
            IF (KEEP(50).EQ.2 .AND. LEVEL.EQ.3) THEN
              CALL AGMG_MUMPS_511(NFR, NELIM, NELIM,0,                       &
     &           1,OPS_NODE)
            ELSE
              CALL AGMG_MUMPS_511(NFR, NELIM, NELIM,KEEP(50),                &
     &           1,OPS_NODE)
            ENDIF
            IF (LEVEL.EQ.2) THEN
              CALL AGMG_MUMPS_511(NFR, NELIM, NELIM,KEEP(50),                &
     &           2,OPS_NODE_MASTER)
              OPS_NODE_SLAVE=OPS_NODE-OPS_NODE_MASTER
            ENDIF
      ELSE
           OPS_NODE = 0.0D0
           ENTRIES_NODE_UPPER_PART = 0_8
           ENTRIES_NODE_LOWER_PART = 0_8
      ENDIF
      ENTRIES_IN_FACTORS_TOT = ENTRIES_IN_FACTORS_TOT +                 &
     &                            ENTRIES_NODE_UPPER_PART +             &
     &                            ENTRIES_NODE_LOWER_PART
      IF (UPDATE.OR.LEVEL.EQ.3) THEN
         IF ( LEVEL .EQ. 3 ) THEN
            OPSA_LOC = OPSA_LOC + OPS_NODE / dble( SLAVEF )
            ENTRIES_IN_FACTORS_LOC = ENTRIES_IN_FACTORS_LOC +           &
     &                            ENTRIES_NODE_UPPER_PART /             &
     &                            int(SLAVEF,8)
            IF (MASTER)                                                 &
     &      ENTRIES_IN_FACTORS_LOC = ENTRIES_IN_FACTORS_LOC +           &
     &                               mod(ENTRIES_NODE_UPPER_PART,       &
     &                                   int(SLAVEF,8))
         ELSE IF (MASTER .AND. LEVEL.EQ.2) THEN
            OPSA_LOC = OPSA_LOC + OPS_NODE_MASTER
            ENTRIES_IN_FACTORS_LOC = ENTRIES_IN_FACTORS_LOC +           &
     &                      ENTRIES_NODE_UPPER_PART +                   &
     &                      mod(ENTRIES_NODE_LOWER_PART,                &
     &                          int(NSLAVES_LOC,8))
         ELSE IF (MASTER .AND. LEVEL.EQ.1) THEN
            OPSA_LOC = OPSA_LOC + dble(OPS_NODE)
            ENTRIES_IN_FACTORS_LOC = ENTRIES_IN_FACTORS_LOC +           &
     &                               ENTRIES_NODE_UPPER_PART +          &
     &                               ENTRIES_NODE_LOWER_PART
         ELSE IF (UPDATE) THEN
            OPSA_LOC = OPSA_LOC +                                       &
     &            dble(OPS_NODE_SLAVE)/dble(NSLAVES_LOC)
            ENTRIES_IN_FACTORS_LOC = ENTRIES_IN_FACTORS_LOC             &
     &                 + ENTRIES_NODE_LOWER_PART /                      &
     &                 int(NSLAVES_LOC,8)
         ENDIF
         IF (AGMG_MUMPS_170(STEP(INODE),                                     &
     &   PROCNODE, SLAVEF) .OR. NE(STEP(INODE))==0) THEN
           IF (LEVEL == 1) THEN
             OPS_SBTR_LOC = OPS_SBTR_LOC + OPS_NODE
           ELSE
             CALL AGMG_MUMPS_511(NFR, NELIM, NELIM,KEEP(50),                 &
     &           1,OPS_NODE)
             OPS_SBTR_LOC = OPS_SBTR_LOC + OPS_NODE
           ENDIF
         ENDIF
        ENDIF
      IF (IFATH .EQ. 0) THEN
         NBROOT = NBROOT - 1
         IF (NBROOT.EQ.0) GOTO 115
         GOTO 90
      ELSE
         NFRF = ND(STEP(IFATH))
         IF (DAD(STEP(IFATH)).EQ.0) THEN
           NELIMF = NFRF
         ELSE
           NELIMF = 0
           IN = IFATH
           DO WHILE (IN.GT.0)
              IN = FILS(IN)
              NELIMF = NELIMF+1
           ENDDO
         ENDIF
         NCBF = NFRF - NELIMF
         LEVELF = AGMG_MUMPS_330(STEP(IFATH),PROCNODE,SLAVEF)
         MASTERF= AGMG_MUMPS_275(STEP(IFATH),PROCNODE,SLAVEF).EQ.MYID
         UPDATEF= .FALSE.
         if(.NOT.FORCE_CAND) then
            UPDATEF= ((MASTERF.AND.(LEVELF.NE.3)).OR.LEVELF.EQ.2)
         else
            if(MASTERF.and.(LEVELF.ne.3)) then
               UPDATEF = .TRUE.
            else if (LEVELF.eq.2) then
               if ( I_AM_CAND(ISTEP_TO_INIV2(STEP(IFATH)))) THEN
                 UPDATEF = .TRUE.
               end if
            end if
         end if
         CONCERNED  = UPDATEF .OR. UPDATE
         IF (LEVELF .NE. 2) THEN
           NBROWMAXF = -999999
         ELSE
           IF (KEEP(48) .EQ. 5) THEN
               WHAT = 4
               IF (FORCE_CAND) THEN
                 NSLAVES_LOC=CANDIDATES(SLAVEF+1,                       &
     &               ISTEP_TO_INIV2(STEP(IFATH)))
               ELSE
                 NSLAVES_LOC=SLAVEF-1
               ENDIF
           ELSE
               WHAT = 1
               NSLAVES_LOC=SLAVEF
           ENDIF
           CALL AGMG_MUMPS_503( WHAT, KEEP, KEEP8,                           &
     &     NCBF, NFRF, NSLAVES_LOC, NBROWMAXF, IDUMMY8 )
         ENDIF
         IF(LEVEL.EQ.1.AND.UPDATE.AND.                                  &
     &      (UPDATEF.OR.LEVELF.EQ.2)                                    &
     &      .AND.LEVELF.NE.3) THEN
             IF ( INSSARBR .AND. KEEP(234).NE.0) THEN
               NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,NRLADU_CURRENT+        &
     &           NRLADU_ROOT_3+CURRENT_ACTIVE_MEM)
               NRLNEC = max(NRLNEC,NRLADU+CURRENT_ACTIVE_MEM)
             ELSE
               NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,NRLADU_CURRENT+        &
     &           NRLADU_ROOT_3+CURRENT_ACTIVE_MEM+SIZECB)
               NRLNEC = max(NRLNEC,NRLADU+CURRENT_ACTIVE_MEM+SIZECB)
             ENDIF
         ENDIF
         IF (UPDATE .AND. LEVEL.EQ.2 .AND. .NOT. MASTER) THEN
             NRLNEC =                                                   &
     &         max(NRLNEC,NRLADU+CURRENT_ACTIVE_MEM+NRLADU_CURRENT)
             NRLNEC_ACTIVE = max(NRLNEC_ACTIVE,2_8*NRLADU_CURRENT+      &
     &         NRLADU_ROOT_3+CURRENT_ACTIVE_MEM)
         ENDIF
        IF (LEVELF.EQ.3) THEN
          IF (LEVEL.EQ.1) THEN
            LEV3MAXREC = int(min(NCB,LOCAL_M),8) *                      &
     &                   int(min(NCB,LOCAL_N),8)
          ELSE
            LEV3MAXREC = min(SIZECB,                                    &
     &                 int(min(NBROWMAX,LOCAL_M),8)                     &
     &                *int(min(NCB,LOCAL_N),8))
          ENDIF
          MAXTEMPCB  = max(MAXTEMPCB, LEV3MAXREC)
          MAXITEMPCB = max(MAXITEMPCB,SIZECBI+SIZEHEADER)
          SBUFR_CB   = max(SBUFR_CB, LEV3MAXREC+int(SIZECBI,8))
          NIRNEC = max(NIRNEC,NIRADU+ISTKI+                             &
     &    min(NCB,LOCAL_M)+ min(NCB,LOCAL_N)+SIZEHEADER)
          NIRNEC_OOC = max(NIRNEC_OOC,NIRADU_OOC+ISTKI_OOC+             &
     &    min(NCB,LOCAL_M)+ min(NCB,LOCAL_N)+SIZEHEADER)
        ENDIF
        IF (CONCERNED) THEN
         IF (LEVELF.EQ.2) THEN
           IF (UPDATE.AND.(LEVEL.NE.2.OR..NOT.MASTER)) THEN
             IF(MASTERF)THEN
                 NBR = min(NBROWMAXF,NBROWMAX)
             ELSE
                 NBR = min(max(NELIMF,NBROWMAXF),NBROWMAX)
             ENDIF
             IF (KEEP(50).EQ.0) THEN
               CBMAXS = int(NBR,8)*int(NCB,8)
             ELSE
               CBMAXS = int(NBR,8)*int(NCB,8) -                         &
     &                  (int(NBR,8)*int(NBR-1,8))/2_8
             ENDIF
           ELSE
              CBMAXS = 0_8
           END IF
           IF (MASTERF) THEN
             IF (LEVEL.EQ.1) THEN
                IF (.NOT.UPDATE) THEN
                  NBR = min(NELIMF, NCB)
                ELSE
                  NBR = 0
                ENDIF
             ELSE
                NBR = min(NELIMF, NBROWMAX)
             ENDIF
             IF (KEEP(50).EQ.0) THEN
                CBMAXR = int(NBR,8)*NCB8
             ELSE
                CBMAXR = int(NBR,8)*int(min(NCB,NELIMF),8)-             &
     &                   (int(NBR,8)*int(NBR-1,8))/2_8
                CBMAXR = min(CBMAXR, int(NELIMF,8)*int(NELIMF+1,8)/2_8)
                CBMAXR = min(CBMAXR, SIZECB)
                IF ((LEVEL.EQ.1).AND.(.NOT. COMPRESSCB)) THEN
                  CBMAXR = min(CBMAXR,(NCB8*(NCB8+1_8))/2_8)
                ENDIF
             ENDIF
           ELSE IF (UPDATEF) THEN
              NBR = min(NBROWMAXF,NBROWMAX)
              CBMAXR = int(NBR,8) * NCB8
              IF (KEEP(50).NE.0) THEN
                CBMAXR = CBMAXR - (int(NBR,8)*(int(NBR-1,8)))/2_8
              ENDIF
           ELSE
              CBMAXR = 0_8
           ENDIF
         ELSEIF (LEVELF.EQ.3) THEN
           CBMAXR = LEV3MAXREC
           IF (UPDATE.AND. .NOT. (MASTER.AND.LEVEL.EQ.2)) THEN
             CBMAXS = LEV3MAXREC
           ELSE
             CBMAXS = 0_8
           ENDIF
         ELSE
           IF (MASTERF) THEN
             CBMAXS = 0_8
             NBR = min(NFRF,NBROWMAX)
             IF ((LEVEL.EQ.1).AND.UPDATE) THEN
                NBR = 0
             ENDIF
             CBMAXR = int(NBR,8)*int(min(NFRF,NCB),8)
             IF (LEVEL.EQ.2)                                            &
     &       CBMAXR = min(CBMAXR, SIZECB_SLAVE)
             IF ( KEEP(50).NE.0 )  THEN
              CBMAXR = min(CBMAXR,(int(NFRF,8)*int(NFRF+1,8))/2_8)
             ELSE
              CBMAXR = min(CBMAXR,int(NFRF,8)*int(NFRF,8))
             ENDIF
           ELSE
             CBMAXR = 0_8
             CBMAXS = SIZECB
           ENDIF
         ENDIF
         IF (UPDATE) THEN
           CBMAXS = min(CBMAXS, SIZECB)
           IF ( .not. ( LEVELF .eq. 1 .AND. UPDATEF ) )THEN
              SBUFS_CB = max(SBUFS_CB, CBMAXS+int(SIZECBI,8))
           ENDIF
         ENDIF
         STACKCB = .FALSE.
         IF (UPDATEF) THEN
          STACKCB = .TRUE.
          SIZECBI     = 2 * NFR + SIZEHEADER
          IF (LEVEL.EQ.1) THEN
             IF (KEEP(50).NE.0.AND.LEVELF.NE.3                          &
     &           .AND.COMPRESSCB) THEN
                 SIZECB = (NCB8*(NCB8+1_8))/2_8
             ELSE
                 SIZECB = NCB8*NCB8
             ENDIF
             IF (MASTER) THEN
               SIZECBI     = 2+ XSIZE_IC
             ELSE IF (LEVELF.EQ.1) THEN
               SIZECB  = min(CBMAXR,SIZECB)
               SIZECBI    = 2 * NCB +  9
               SBUFR_CB   = max(SBUFR_CB, int(SIZECBI,8)+SIZECB)
               SIZECBI    =  2 * NCB + SIZEHEADER
             ELSE
               SIZECBI    = 2 * NCB +  9
               SBUFR_CB   = max(SBUFR_CB,                               &
     &                      min(SIZECB,CBMAXR) + int(SIZECBI,8))
               MAXTEMPCB  = max(MAXTEMPCB, min(SIZECB,CBMAXR))
               SIZECBI    =  2 * NCB + SIZEHEADER
               MAXITEMPCB = max(MAXITEMPCB, SIZECBI)
               SIZECBI     = 0
               SIZECB      = 0_8
             ENDIF
          ELSE
             SIZECB = SIZECB_SLAVE
             MAXTEMPCB  = max(MAXTEMPCB, min(CBMAXR,SIZECB) )
             MAXITEMPCB = max(MAXITEMPCB,NBROWMAX+NCB+SIZEHEADER)
             IF (.NOT.                                                  &
     &        (UPDATE.AND.(.NOT.MASTER).AND.(NSLAVES_LOC.EQ.1))         &
     &          )                                                       &
     &       SBUFR_CB = max(SBUFR_CB,                                   &
     &            min(CBMAXR,SIZECB) + int(NBROWMAX + NCB + 6,8))
             IF (MASTER) THEN
              SIZECBI     =  NCB + 5 +  SLAVEF - 1 + XSIZE_IC
              SIZECB  = 0_8
             ELSE IF (UPDATE) THEN
              SIZECBI      =  NFR + 6 + SLAVEF - 1 + XSIZE_IC
              IF (KEEP(50).EQ.0) THEN
                SIZECBI = SIZECBI + NBROWMAX + NFR +                    &
     &                    SIZEHEADER
              ELSE
                SIZECBI = SIZECBI + NBROWMAX + NFR +                    &
     &                    SIZEHEADER+ NSLAVES_LOC
              ENDIF
             ELSE
              SIZECB      = 0_8
              SIZECBI     = 0
             ENDIF
          ENDIF
         ELSE
           IF (LEVELF.NE.3) THEN
               STACKCB     = .TRUE.
               SIZECB      = 0_8
               SIZECBI     = 0
               IF ( (LEVEL.EQ.1) .AND. (LEVELF.NE.1) ) THEN
                  IF (COMPRESSCB) THEN
                      SIZECB  = (NCB8*(NCB8+1_8))/2_8
                  ELSE
                      SIZECB  = NCB8*NCB8
                  ENDIF
                  SIZECBI     = 2 * NCB + SIZEHEADER
               ELSE IF (LEVEL.EQ.2) THEN
                 IF (MASTER) THEN
                   SIZECBI     =  NCB + 5 +  SLAVEF - 1 + XSIZE_IC
                 ELSE
                   SIZECB  = SIZECB_SLAVE
                   SIZECBI = SIZECBI + NBROWMAX + NFR + SIZEHEADER
                 ENDIF
               ENDIF
           ENDIF
         ENDIF
         IF (STACKCB) THEN
           IF (FRERE(STEP(INODE)).EQ.0) THEN
                  write(*,*) ' ERROR 3 in DMUMPS_246'
                  CALL AGMG_MUMPS_ABORT()
           ENDIF
           ITOP = ITOP + 1
           IF ( ITOP .GT. NSTEPS ) THEN
             WRITE(*,*) 'ERROR 4 in DMUMPS_246 '
           ENDIF
           LSTKI(ITOP) = SIZECBI
           ISTKI=ISTKI + SIZECBI
           ISTKI_OOC = ISTKI_OOC + SIZECBI + (XSIZE_OOC-XSIZE_IC)
           LSTKR(ITOP) = SIZECB
           ISTKR = ISTKR + LSTKR(ITOP)
           NRLNEC = max(NRLNEC,NRLADU+ISTKR+MAXTEMPCB)
           NIRNEC = max0(NIRNEC,NIRADU+ISTKI+MAXITEMPCB)
           NIRNEC_OOC = max0(NIRNEC_OOC,NIRADU_OOC+ISTKI_OOC+           &
     &                  MAXITEMPCB +                                    &
     &                    (XSIZE_OOC-XSIZE_IC) )
         ENDIF
        ENDIF
         TNSTK(STEP(IFATH)) = TNSTK(STEP(IFATH)) - 1
         IF ( TNSTK(STEP(IFATH)) .EQ. 0 ) THEN
            INODE = IFATH
            GOTO 95
         ELSE
            GOTO 90
         ENDIF
      ENDIF
  115 CONTINUE
      BLOCKING_RHS = KEEP(84)
      IF (KEEP(84).EQ.0) BLOCKING_RHS=1
      NRLNEC = max(NRLNEC,                                              &
     &         NRLADU+int(4*KEEP(127)*abs(BLOCKING_RHS),8))
      IF (BLOCKING_RHS .LT. 0) THEN
        BLOCKING_RHS = - 2 * BLOCKING_RHS
      ENDIF
      NRLNEC_ACTIVE = max(NRLNEC_ACTIVE, MAX_SIZE_FACTOR+               &
     &                    int(4*KEEP(127)*BLOCKING_RHS,8))
      SBUF_RECOLD = max(int(SBUFR,8),SBUFR_CB)
      SBUF_RECOLD = max(SBUF_RECOLD,                                    &
     &        MAXTEMPCB+int(MAXITEMPCB,8)) + 10_8
      SBUF_REC = max(SBUFR, int(min(100000_8,SBUFR_CB)))
      SBUF_REC = SBUF_REC   + 17
      SBUF_REC = SBUF_REC + 2 * KEEP(127) + SLAVEF - 1 + 7
      SBUF_SEND = max(SBUFS, int(min(100000_8,SBUFR_CB)))
      SBUF_SEND = SBUF_SEND + 17
      IF(KEEP(219).NE.0.AND.KEEP(50) .EQ. 2) THEN
         SBUF_RECOLD = SBUF_RECOLD+int(KEEP(108)+1,8)
         SBUF_REC = SBUF_REC+KEEP(108)+1
         SBUF_SEND = SBUF_SEND+KEEP(108)+1
      ENDIF
      IF (SLAVEF.EQ.1) THEN
         SBUF_RECOLD = 1_8
         SBUF_REC = 1
         SBUF_SEND= 1
      ENDIF
      DEALLOCATE( LSTKR, TNSTK, IPOOL,                                  &
     &          LSTKI )
      OPS_SUBTREE = dble(OPS_SBTR_LOC)
      OPSA        = dble(OPSA_LOC)
      KEEP(66)    = int(OPSA_LOC/1000000.d0)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_246
      RECURSIVE SUBROUTINE                                              &
     &    DAGMG_MUMPS_271( COMM_LOAD, ASS_IRECV,                             &
     &    INODE, NELIM_ROOT, root,                                      &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,                 &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER KEEP(500), ICNTL( 40 )
      INTEGER*8 KEEP8(150)
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER INODE, NELIM_ROOT
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: LA, POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S( KEEP(28) ), PROCNODE_STEPS( KEEP(28) )
      INTEGER NBPROCFILS(KEEP(28))
      INTEGER IFLAG, IERROR, COMM
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER MYID, SLAVEF, NBFIN
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER ITLOC( N ), FILS( N )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER I, J, LCONT, NCOL_TO_SEND, LDA
      INTEGER(8) :: OPSFAC, APOS, SHIFT_VAL_SON, POSELT
      INTEGER FPERE, IOLDPS, NFRONT, NPIV, NASS, NSLAVES,               &
     &        H_INODE, NELIM, NBCOL, LIST_NELIM_ROW,                    &
     &        LIST_NELIM_COL, NELIM_LOCAL, TYPE_SON,                    &
     &        NROW, NCOL, NBROW, SHIFT_LIST_ROW_SON,                    &
     &        SHIFT_LIST_COL_SON, LDAFS, IERR,                          &
     &        STATUS( AGMG_MPF_STATUS_SIZE ), ISON, PDEST_MASTER_ISON
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER MSGSOU, MSGTAG
      LOGICAL INVERT, FLAG
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER  AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      FPERE = KEEP(38)
      TYPE_SON = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      IF ( AGMG_MUMPS_275( STEP(INODE), PROCNODE_STEPS,                      &
     &     SLAVEF ).EQ.MYID) THEN
       IOLDPS   = PTLUST_S(STEP(INODE))
       NFRONT   = IW(IOLDPS+KEEP(IXSZ))
       NPIV     = IW(IOLDPS+1+KEEP(IXSZ))
       NASS     = iabs(IW(IOLDPS + 2+KEEP(IXSZ)))
       NSLAVES  =  IW(IOLDPS+5+KEEP(IXSZ))
       H_INODE  = 6 + NSLAVES + KEEP(IXSZ)
       NELIM    = NASS - NPIV
       NBCOL = NFRONT - NPIV
       LIST_NELIM_ROW = IOLDPS + H_INODE + NPIV
       LIST_NELIM_COL = LIST_NELIM_ROW + NFRONT
           IF (NELIM.LE.0) THEN
            write(6,*) ' ERROR 1 in DMUMPS_271 ', NELIM
            write(6,*) MYID,':Process root2son: INODE=',INODE,          &
     & 'Header=',IW(PTLUST_S(STEP(INODE)):PTLUST_S(STEP(INODE))         &
     &  +5+KEEP(IXSZ))
            CALL AGMG_MUMPS_ABORT()
           ENDIF
       NELIM_LOCAL = NELIM_ROOT
       DO I=1, NELIM
        root%RG2L_ROW(IW(LIST_NELIM_ROW)) = NELIM_LOCAL
        root%RG2L_COL(IW(LIST_NELIM_COL)) = NELIM_LOCAL
        NELIM_LOCAL = NELIM_LOCAL + 1
        LIST_NELIM_ROW = LIST_NELIM_ROW + 1
        LIST_NELIM_COL = LIST_NELIM_COL + 1
       ENDDO
       NBROW = NFRONT - NPIV
       NROW = NELIM
       IF ( KEEP( 50 ) .eq. 0 ) THEN
         NCOL = NFRONT - NPIV
       ELSE
         NCOL = NELIM
       END IF
       SHIFT_LIST_ROW_SON = H_INODE + NPIV
       SHIFT_LIST_COL_SON = H_INODE + NFRONT + NPIV
       IF ( KEEP(50).eq.0 .OR. TYPE_SON .eq. 1 ) THEN
         LDAFS = NFRONT
       ELSE
         LDAFS = NASS
       END IF
       SHIFT_VAL_SON = int(NPIV,8) * int(LDAFS,8) + int(NPIV,8)
       CALL DAGMG_MUMPS_80( COMM_LOAD,                                       &
     &   ASS_IRECV,                                                     &
     &   N, INODE, FPERE,                                               &
     &   PTLUST_S(1), PTRAST(1),                                        &
     &   root, NROW, NCOL, SHIFT_LIST_ROW_SON,                          &
     &   SHIFT_LIST_COL_SON , SHIFT_VAL_SON, LDAFS,                     &
     &   ROOT_NON_ELIM_CB, MYID, COMM,                                  &
     &   BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,              &
     &   IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,           &
     &   PTRIST, PTLUST_S(1), PTRFAC(1), PTRAST(1),                     &
     &   STEP, PIMASTER, PAMASTER,                                      &
     &   NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                       &
     &   IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                             &
     &   OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                   &
     &   INTARR, DBLARR, ICNTL, KEEP,KEEP8, .FALSE., ND, FRERE,         &
     &   LPTRAR, NELT, FRTPTR, FRTELT,                                  &
     &   ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
       IF (IFLAG.LT.0 ) RETURN
       IF (TYPE_SON.EQ.1) THEN
        NROW = NFRONT - NASS
        NCOL = NELIM
        SHIFT_LIST_ROW_SON = H_INODE + NASS
        SHIFT_LIST_COL_SON = H_INODE + NFRONT + NPIV
        SHIFT_VAL_SON      = int(NASS,8) * int(NFRONT,8) + int(NPIV,8)
        IF ( KEEP( 50 ) .eq. 0 ) THEN
          INVERT = .FALSE.
        ELSE
          INVERT = .TRUE.
        END IF
        CALL DAGMG_MUMPS_80( COMM_LOAD, ASS_IRECV,                           &
     &    N, INODE, FPERE,                                              &
     &    PTLUST_S, PTRAST,                                             &
     &    root, NROW, NCOL, SHIFT_LIST_ROW_SON,                         &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, NFRONT,                   &
     &    ROOT_NON_ELIM_CB, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, INVERT, ND, FRERE,         &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &   ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
        IF (IFLAG.LT.0 ) RETURN
       ENDIF
       IOLDPS = PTLUST_S(STEP(INODE))
       POSELT = PTRAST(STEP(INODE))
       IW(IOLDPS + 4+KEEP(IXSZ)) = STEP(INODE)
       PTRFAC(STEP(INODE))=POSELT
       IF ( TYPE_SON .eq. 1 ) THEN
         NBROW = NFRONT - NPIV
       ELSE
         NBROW = NELIM
       END IF
       IF ( TYPE_SON .eq. 1 .OR. KEEP(50).EQ.0) THEN
         LDA = NFRONT
       ELSE
         LDA = NPIV+NBROW
       ENDIF
       CALL DAGMG_MUMPS_324(A(POSELT), LDA,                                  &
     &          NPIV, NBROW, KEEP(50))
       IW(IOLDPS + KEEP(IXSZ))     = NBCOL
       IW(IOLDPS + 1 +KEEP(IXSZ)) = NASS - NPIV
       IF (TYPE_SON.EQ.2) THEN
        IW(IOLDPS + 2 +KEEP(IXSZ)) = NASS
       ELSE
        IW(IOLDPS + 2 +KEEP(IXSZ)) = NFRONT
       ENDIF
       IW(IOLDPS + 3 +KEEP(IXSZ)) = NPIV
      CALL DAGMG_MUMPS_93(0_8,MYID,N,IOLDPS,TYPE_SON,IW,LIW,                 &
     &    A, LA, POSFAC, LRLU, LRLUS,                                   &
     &    IWPOS, PTRAST,PTRFAC,STEP, KEEP,KEEP8, .FALSE.,INODE,IERR)
      IF(IERR.LT.0)THEN
         IFLAG=IERR
         IERROR=0
         RETURN
      ENDIF
      ELSE
        ISON = INODE
        PDEST_MASTER_ISON = AGMG_MUMPS_275(STEP(ISON),                       &
     &      PROCNODE_STEPS,SLAVEF)
        DO WHILE ( PTRIST(STEP(ISON)) .EQ. 0)
          BLOCKING = .TRUE.
          SET_IRECV = .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &    BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                        &
     &    PDEST_MASTER_ISON, MAITRE_DESC_BANDE,                         &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,         &
     &    NELT, FRTPTR, FRTELT,                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF ( IFLAG .LT. 0 ) RETURN
        ENDDO
        DO WHILE (                                                      &
     &     ( IW( PTRIST(STEP(ISON)) + 1  +KEEP(IXSZ)) .NE.              &
     &       IW( PTRIST(STEP(ISON)) + 3  +KEEP(IXSZ)) ) .OR.            &
     &     ( KEEP(50) .NE. 0 .AND.                                      &
     &       IW( PTRIST(STEP(ISON)) + 6  +KEEP(IXSZ)) .NE. 0 ) )
          IF ( KEEP(50).eq.0) THEN
            MSGSOU = PDEST_MASTER_ISON
            MSGTAG = BLOC_FACTO
          ELSE
            IF ( IW( PTRIST(STEP(ISON)) + 1  +KEEP(IXSZ)) .NE.          &
     &           IW( PTRIST(STEP(ISON)) + 3  +KEEP(IXSZ)) ) THEN
              MSGSOU = PDEST_MASTER_ISON
              MSGTAG = BLOC_FACTO_SYM
            ELSE
              MSGSOU = AGMG_MPF_ANY_SOURCE
              MSGTAG = BLOC_FACTO_SYM_SLAVE
            END IF
          END IF
          BLOCKING  = .TRUE.
          SET_IRECV = .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &    BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                        &
     &    MSGSOU, MSGTAG,                                               &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE, LPTRAR,         &
     &    NELT, FRTPTR, FRTELT,                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF ( IFLAG .LT. 0 ) RETURN
        END DO
       IOLDPS = PTRIST(STEP(INODE))
       LCONT  = IW(IOLDPS+KEEP(IXSZ))
       NROW   = IW(IOLDPS+2+KEEP(IXSZ))
       NPIV   = IW(IOLDPS+3+KEEP(IXSZ))
       NASS   = IW(IOLDPS+4+KEEP(IXSZ))
       NELIM  = NASS-NPIV
       IF (NELIM.LE.0) THEN
         write(6,*) MYID,': INODE,LCONT, NROW, NPIV, NASS, NELIM=',     &
     &   INODE,LCONT, NROW, NPIV, NASS, NELIM
         write(6,*) MYID,': IOLDPS=',IOLDPS
         write(6,*) MYID,': ERROR 2 in DMUMPS_271 '
         CALL AGMG_MUMPS_ABORT()
       ENDIF
       NSLAVES= IW(IOLDPS+5+KEEP(IXSZ))
       H_INODE = 6 + NSLAVES + KEEP(IXSZ)
       LIST_NELIM_COL = IOLDPS + H_INODE + NROW + NPIV
       NELIM_LOCAL = NELIM_ROOT
       DO I = 1, NELIM
        root%RG2L_COL(IW(LIST_NELIM_COL)) = NELIM_LOCAL
        NELIM_LOCAL = NELIM_LOCAL + 1
        LIST_NELIM_COL = LIST_NELIM_COL + 1
       ENDDO
       SHIFT_LIST_ROW_SON = 6 + IW(IOLDPS+5+KEEP(IXSZ)) + KEEP(IXSZ)
       SHIFT_LIST_COL_SON = SHIFT_LIST_ROW_SON + NROW + NPIV
       NCOL_TO_SEND       = NELIM
       IF (IW(IOLDPS+XXS).EQ.S_NOLCBNOCONTIG38.OR.                      &
     &     IW(IOLDPS+XXS).EQ.S_ALL) THEN
         SHIFT_VAL_SON      = int(NPIV,8)
         LDA                = LCONT + NPIV
       ELSE IF (IW(IOLDPS+XXS).EQ.S_NOLCBCONTIG38) THEN
         SHIFT_VAL_SON = int(NROW,8)*int(LCONT+NPIV-NELIM,8)
         LDA           = NELIM
       ELSE IF (IW(IOLDPS+XXS).EQ.S_NOLCLEANED38) THEN
         SHIFT_VAL_SON=0_8
         LDA = NELIM
       ELSE
         write(*,*) MYID,": internal error in DAGMG_MUMPS_271",              &
     &   IW(IOLDPS+XXS), "INODE=",INODE
         CALL AGMG_MUMPS_ABORT()
       ENDIF
       IF ( KEEP( 50 ) .eq. 0 ) THEN
         INVERT = .FALSE.
       ELSE
         INVERT = .TRUE.
       END IF
       CALL DAGMG_MUMPS_80( COMM_LOAD, ASS_IRECV,                            &
     &    N, INODE, FPERE,                                              &
     &    PTRIST, PTRAST,                                               &
     &    root, NROW, NCOL_TO_SEND, SHIFT_LIST_ROW_SON,                 &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, LDA,                      &
     &    ROOT_NON_ELIM_CB, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, INVERT, ND, FRERE,         &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &   ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
        IF (IFLAG.LT.0 ) RETURN
       IF (KEEP(214).EQ.2) THEN
        CALL DAGMG_MUMPS_314( N, INODE,                                      &
     &      PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,           &
     &      LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                  &
     &      IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,            &
     &      IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, TYPE_SON     &
     &      )
       ENDIF
        IF (IFLAG.LT.0) THEN
           CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_271
      SUBROUTINE DAGMG_MUMPS_221(NFRONT,NASS,N,INODE,IW,LIW,A,LA,            &
     &    INOPV,NOFFW,IFLAG,IOLDPS,POSELT,UU, SEUIL,KEEP,KEEP8,         &
     &     DKEEP,PIVNUL_LIST,LPN_LIST,                                  &
     &     PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                       &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                       &
     &     PP_LastPIVRPTRFilled_U)
      IMPLICIT NONE
      INTEGER NFRONT,NASS,N,LIW,INODE,IFLAG,INOPV,NOFFW
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION UU, SEUIL
      INTEGER IW(LIW)
      INTEGER(8) :: POSELT
      INTEGER  IOLDPS
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION    DKEEP(30)
      INTEGER PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                    &
     &        PP_LastPIVRPTRFilled_L,                                   &
     &        PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                    &
     &        PP_LastPIVRPTRFilled_U
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION SWOP
      INTEGER XSIZE
      INTEGER(8) :: APOS, IDIAG
      INTEGER(8) :: J1, J2, J3, JJ
      INTEGER(8) :: NFRONT8
      DOUBLE PRECISION AMROW
      DOUBLE PRECISION ZERO,RMAX,ONE
      INTEGER NPIV,NASSW,IPIV
      INTEGER NPIVP1,JMAX,J,ISW,ISWPS1
      INTEGER ISWPS2,KSW
      INTEGER DAGMG_MUMPS_IXAMAX
      INTRINSIC max
      DATA ZERO /0.0D0/
      DATA ONE /1.0D0/
      INTEGER TYPEF_L, I_PIVRPTR_L, I_PIVR_L, NBPANELS_L
      INTEGER TYPEF_U, I_PIVRPTR_U, I_PIVR_U, NBPANELS_U
      PARAMETER (TYPEF_L=1, TYPEF_U=2)
        XSIZE   = KEEP(IXSZ)
        NPIV    = IW(IOLDPS+1+XSIZE)
        NPIVP1  = NPIV + 1
        NFRONT8 = int(NFRONT,8)
        IF (KEEP(201).EQ.1) THEN
          CALL DAGMG_MUMPS_667(TYPEF_L, NBPANELS_L,                          &
     &       I_PIVRPTR_L, I_PIVR_L,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE,                &
     &       IW, LIW)
          CALL DAGMG_MUMPS_667(TYPEF_U, NBPANELS_U,                          &
     &       I_PIVRPTR_U, I_PIVR_U,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE,                &
     &       IW, LIW)
        ENDIF
        NASSW   = iabs(IW(IOLDPS+3+XSIZE))
        IF(INOPV .EQ. -1) THEN
           APOS = POSELT + NFRONT8*int(NPIVP1-1,8) + int(NPIV,8)
           IDIAG = APOS
           IF(abs(A(APOS)).LT.SEUIL) THEN
              IF(dble(A(APOS)) .GE. ZERO) THEN
                 A(APOS) = dble(SEUIL)
              ELSE
                 A(APOS) = dble(-SEUIL)
              ENDIF
              KEEP(98) = KEEP(98)+1
           ENDIF
           IF (KEEP(201).EQ.1) THEN
             CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_L),                          &
     &               NBPANELS_L,                                        &
     &               IW(I_PIVR_L), NASS, NPIVP1, NPIVP1,                &
     &               PP_LastPanelonDisk_L,                              &
     &               PP_LastPIVRPTRFilled_L)
             CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_U),                          &
     &               NBPANELS_U,                                        &
     &               IW(I_PIVR_U), NASS, NPIVP1, NPIVP1,                &
     &               PP_LastPanelonDisk_U,                              &
     &               PP_LastPIVRPTRFilled_U)
           ENDIF
           GO TO 420
        ENDIF
        INOPV   = 0
          DO 460 IPIV=NPIVP1,NASSW
            APOS = POSELT + NFRONT8*int(IPIV-1,8) + int(NPIV,8)
            JMAX = 1
            IF (UU.GT.ZERO) GO TO 340
            IF (abs(A(APOS)).EQ.ZERO) GO TO 630
            GO TO 380
  340       AMROW = ZERO
            J1 = APOS
            J2 = APOS + int(- NPIV + NASS - 1,8)
             J     = NASS -NPIV
             JMAX  = DAGMG_MUMPS_IXAMAX(J,A(J1),1)
             JJ    = J1 + int(JMAX - 1,8)
             AMROW = abs(A(JJ))
            RMAX = AMROW
            J1 = J2 + 1_8
            J2 = APOS +int(- NPIV + NFRONT - 1,8)
            IF (J2.LT.J1) GO TO 370
            DO 360 JJ=J1,J2
              RMAX = max(abs(A(JJ)),RMAX)
  360       CONTINUE
  370       IDIAG = APOS + int(IPIV - NPIVP1,8)
            IF (RMAX.LE.DKEEP(1)) THEN
               KEEP(109) = KEEP(109)+1
               ISW = IOLDPS+IW(IOLDPS+1+XSIZE)+6+XSIZE+                 &
     &                      IW(IOLDPS+5+XSIZE)+IPIV-NPIVP1
               PIVNUL_LIST(KEEP(109)) = IW(ISW)
               IF(DKEEP(2).GT.ZERO) THEN
                  IF(dble(A(IDIAG)) .GE. ZERO) THEN
                     A(IDIAG) = dble(DKEEP(2))
                  ELSE
                     A(IDIAG) = dble(-DKEEP(2))
                  ENDIF
               ELSE
                 J1 = APOS
                 J2 = APOS +int(- NPIV + NFRONT - 1,8)
                 DO JJ=J1,J2
                   A(JJ)= dble(ZERO)
                 ENDDO
                 A(IDIAG) = dble(ONE)
               ENDIF
               JMAX = IPIV - NPIV
               GOTO 380
            ENDIF
            IF (abs(A(IDIAG)).GT. max(UU*RMAX,SEUIL)) THEN
              JMAX = IPIV - NPIV
              GO TO 380
            ENDIF
            IF (AMROW.LE. max(UU*RMAX,SEUIL)) GO TO 460
            NOFFW = NOFFW + 1
  380       IF (IPIV.EQ.NPIVP1) GO TO 400
            J1 = POSELT + int(NPIV,8)*NFRONT8
            J2 = J1 + NFRONT8 - 1_8
            J3 = POSELT + int(IPIV-1,8)*NFRONT8
            DO 390 JJ=J1,J2
              SWOP = A(JJ)
              A(JJ) = A(J3)
              A(J3) = SWOP
              J3 = J3 + 1_8
  390       CONTINUE
            ISWPS1 = IOLDPS + 5 + NPIVP1 + XSIZE
            ISWPS2 = IOLDPS + 5 + IPIV + XSIZE
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
  400       IF (JMAX.EQ.1) GO TO 420
            J1 = POSELT + int(NPIV,8)
            J2 = POSELT + int(NPIV + JMAX - 1,8)
            DO 410 KSW=1,NFRONT
              SWOP = A(J1)
              A(J1) = A(J2)
              A(J2) = SWOP
              J1 = J1 + NFRONT8
              J2 = J2 + NFRONT8
  410       CONTINUE
            ISWPS1 = IOLDPS + 5 + NFRONT + NPIV + 1 +XSIZE
            ISWPS2 = IOLDPS + 5 + NFRONT + NPIV + JMAX +XSIZE
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
            GO TO 420
  460     CONTINUE
      IF (NASSW.EQ.NASS) THEN
       INOPV = 1
      ELSE
       INOPV = 2
      ENDIF
      GO TO 430
  630 CONTINUE
      IFLAG = -10
      WRITE(*,*) 'Detected a null pivot, INODE/NPIV=',INODE,NPIV
      GOTO 430
  420 CONTINUE
              IF (KEEP(201).EQ.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_L),                       &
     &               NBPANELS_L,                                        &
     &               IW(I_PIVR_L), NASS, NPIVP1, IPIV,                  &
     &               PP_LastPanelonDisk_L,                              &
     &               PP_LastPIVRPTRFilled_L)
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_U),                       &
     &               NBPANELS_U,                                        &
     &               IW(I_PIVR_U), NASS, NPIVP1, NPIV+JMAX,             &
     &               PP_LastPanelonDisk_U,                              &
     &               PP_LastPIVRPTRFilled_U)
              ENDIF
  430 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_221
      SUBROUTINE DAGMG_MUMPS_220(NFRONT,NASS,N,INODE,IW,LIW,A,LA,            &
     &   INOPV,NOFFW,IOLDPS,POSELT,UU,SEUIL,KEEP,                       &
     &     PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                       &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                       &
     &     PP_LastPIVRPTRFilled_U)
      IMPLICIT NONE
      INTEGER NFRONT,NASS,N,LIW,INODE,INOPV
      INTEGER(8) :: LA
      INTEGER KEEP(500)
      DOUBLE PRECISION UU, SEUIL
      DOUBLE PRECISION A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION AMROW
      DOUBLE PRECISION ZERO,RMAX
      DOUBLE PRECISION  SWOP
      INTEGER(8) :: APOS, POSELT
      INTEGER(8) :: J1, J2, J3_8, JJ, IDIAG
      INTEGER(8) :: NFRONT8
      INTEGER IOLDPS
      INTEGER NOFFW,NPIV,IPIV
      INTEGER J, J3
      INTEGER NPIVP1,JMAX,ISW,ISWPS1
      INTEGER ISWPS2,KSW,XSIZE
      INTEGER TYPEF_L, I_PIVRPTR_L, I_PIVR_L, NBPANELS_L
      INTEGER TYPEF_U, I_PIVRPTR_U, I_PIVR_U, NBPANELS_U
      PARAMETER (TYPEF_L=1, TYPEF_U=2)
      INTEGER PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                    &
     &        PP_LastPIVRPTRFilled_L,                                   &
     &        PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                    &
     &        PP_LastPIVRPTRFilled_U
      INTEGER DAGMG_MUMPS_IXAMAX
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTRINSIC max
      DATA ZERO /0.0D0/
        NFRONT8 = int(NFRONT,8)
        INOPV   = 0
        XSIZE   = KEEP(IXSZ)
        NPIV    = IW(IOLDPS+1+XSIZE)
        NPIVP1  = NPIV + 1
        IF (KEEP(201).EQ.1 .AND. KEEP(50).NE.1) THEN
          CALL DAGMG_MUMPS_667(TYPEF_L, NBPANELS_L,                          &
     &       I_PIVRPTR_L, I_PIVR_L,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)                       &
     &              +KEEP(IXSZ),                                        &
     &       IW, LIW)
          CALL DAGMG_MUMPS_667(TYPEF_U, NBPANELS_U,                          &
     &       I_PIVRPTR_U, I_PIVR_U,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE,                &
     &       IW, LIW)
        ENDIF
          DO 460 IPIV=NPIVP1,NASS
            APOS = POSELT + NFRONT8*int(NPIV,8) + int(IPIV-1,8)
            JMAX = 1
            AMROW = ZERO
            J1 = APOS
            J3    = NASS -NPIV
            JMAX  = DAGMG_MUMPS_IXAMAX(J3,A(J1),NFRONT)
            JJ    = J1 + int(JMAX-1,8)*NFRONT8
            AMROW = abs(A(JJ))
            RMAX = AMROW
            J1 = APOS +  int(NASS-NPIV,8) * NFRONT8
            J3 = NFRONT - NASS
            IF (J3.EQ.0) GOTO 370
            DO 360 J=1,J3
              RMAX = max(abs(A(J1)),RMAX)
              J1 = J1 + NFRONT8
  360       CONTINUE
  370       IF (RMAX.EQ.ZERO) GO TO 460
            IDIAG = APOS + int(IPIV - NPIVP1,8)*NFRONT8
            IF (abs(A(IDIAG)).GE.max(UU*RMAX,SEUIL)) THEN
              JMAX = IPIV - NPIV
              GO TO 380
            ENDIF
            IF (AMROW.LT.max(UU*RMAX,SEUIL)) GO TO 460
            NOFFW = NOFFW + 1
  380       IF (IPIV.EQ.NPIVP1) GO TO 400
            J1   = POSELT + int(NPIV,8)
            J3_8 = POSELT + int(IPIV-1,8)
            DO 390 J= 1,NFRONT
              SWOP  = A(J1)
              A(J1) = A(J3_8)
              A(J3_8) = SWOP
              J1 = J1 + NFRONT8
              J3_8 = J3_8 + NFRONT8
  390       CONTINUE
            ISWPS1 = IOLDPS + 5 + NPIVP1 + NFRONT + XSIZE
            ISWPS2 = IOLDPS + 5 + IPIV + NFRONT + XSIZE
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
  400       IF (JMAX.EQ.1) GO TO 420
            J1 = POSELT + int(NPIV,8) * NFRONT8
            J2 = POSELT + int(NPIV + JMAX - 1,8) * NFRONT8
            DO 410 KSW=1,NFRONT
              SWOP = A(J1)
              A(J1) = A(J2)
              A(J2) = SWOP
              J1 = J1 + 1_8
              J2 = J2 + 1_8
  410       CONTINUE
            ISWPS1 = IOLDPS + 5 + NPIV + 1 + XSIZE
            ISWPS2 = IOLDPS + 5 + NPIV + JMAX + XSIZE
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
            GO TO 420
  460     CONTINUE
       INOPV = 1
       GOTO 430
  420 CONTINUE
              IF (KEEP(201).EQ.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_L),                       &
     &               NBPANELS_L,                                        &
     &               IW(I_PIVR_L), NASS, NPIVP1, NPIV+JMAX,             &
     &               PP_LastPanelonDisk_L,                              &
     &               PP_LastPIVRPTRFilled_L)
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_U),                       &
     &               NBPANELS_U,                                        &
     &               IW(I_PIVR_U), NASS, NPIVP1, IPIV,                  &
     &               PP_LastPanelonDisk_U,                              &
     &               PP_LastPIVRPTRFilled_U)
              ENDIF
  430 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_220
      SUBROUTINE DAGMG_MUMPS_225(IBEG_BLOCK,                                 &
     &     NFRONT,NASS,N,INODE,IW,LIW,A,LA,                             &
     &     IOLDPS,POSELT,IFINB,LKJIB,LKJIT,XSIZE)
      IMPLICIT NONE
      INTEGER NFRONT,NASS,N,LIW,INODE,IFINB,LKJIB,IBEG_BLOCK
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION    VALPIV
      INTEGER(8) :: APOS, POSELT, UUPOS, LPOS
      INTEGER(8) :: NFRONT8
      INTEGER IOLDPS
      INTEGER LKJIT, XSIZE
      DOUBLE PRECISION ONE, ALPHA
      INTEGER NPIV,JROW2
      INTEGER NEL2,NPIVP1,KROW,NEL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        NFRONT8= int(NFRONT,8)
        NPIV   = IW(IOLDPS+1+XSIZE)
        NPIVP1 = NPIV + 1
        NEL    = NFRONT - NPIVP1
        IFINB  = 0
        IF (IW(IOLDPS+3+XSIZE).LE.0) THEN
          IF (NASS.LT.LKJIT) THEN
           IW(IOLDPS+3+XSIZE) = NASS
          ELSE
           IW(IOLDPS+3+XSIZE) = min0(NASS,LKJIB)
          ENDIF
        ENDIF
        JROW2 = IW(IOLDPS+3+XSIZE)
        NEL2   = JROW2 - NPIVP1
        IF (NEL2.EQ.0) THEN
         IF (JROW2.EQ.NASS) THEN
          IFINB        = -1
         ELSE
          IFINB        = 1
          IW(IOLDPS+3+XSIZE) = min0(JROW2+LKJIB,NASS)
          IBEG_BLOCK = NPIVP1+1
         ENDIF
        ELSE
         APOS   = POSELT + int(NPIV,8)*(NFRONT8 + 1_8)
         VALPIV = ONE/A(APOS)
         LPOS   = APOS + NFRONT8
         DO 541 KROW = 1,NEL2
             A(LPOS) = A(LPOS)*VALPIV
             LPOS    = LPOS + NFRONT8
  541    CONTINUE
         LPOS   = APOS + NFRONT8
         UUPOS  = APOS + 1_8
         CALL DGER(NEL,NEL2,ALPHA,A(UUPOS),1,A(LPOS),NFRONT,            &
     &              A(LPOS+1_8),NFRONT)
        ENDIF
        RETURN
        END SUBROUTINE DAGMG_MUMPS_225
      SUBROUTINE DAGMG_MUMPS_229(NFRONT,N,INODE,IW,LIW,A,LA,IOLDPS,          &
     &          POSELT,XSIZE)
      IMPLICIT NONE
      INTEGER NFRONT,N,INODE,LIW,XSIZE
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION    ALPHA,VALPIV
      INTEGER(8) :: APOS, POSELT, UUPOS
      INTEGER(8) :: NFRONT8, LPOS, IRWPOS
      INTEGER IOLDPS,NPIV,NEL
      INTEGER JROW
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION, PARAMETER :: ONE = 1.0D0
        NFRONT8= int(NFRONT,8)
        NPIV   = IW(IOLDPS+1+XSIZE)
        NEL    = NFRONT - NPIV - 1
        APOS   = POSELT + int(NPIV,8) * NFRONT8 + int(NPIV,8)
        IF (NEL.EQ.0) GO TO 650
        VALPIV = ONE/A(APOS)
        LPOS   = APOS + NFRONT8
        DO 340 JROW = 1,NEL
            A(LPOS) = VALPIV*A(LPOS)
            LPOS    = LPOS + NFRONT8
  340   CONTINUE
        LPOS   = APOS + NFRONT8
        UUPOS  = APOS+1_8
        DO 440 JROW = 1,NEL
             IRWPOS  = LPOS + 1_8
             ALPHA   = -A(LPOS)
             CALL DAXPY(NEL,ALPHA,A(UUPOS),1,A(IRWPOS),1)
             LPOS    = LPOS + NFRONT8
  440   CONTINUE
  650   RETURN
        END SUBROUTINE DAGMG_MUMPS_229
      SUBROUTINE DAGMG_MUMPS_228(NFRONT,NASS,N,INODE,IW,LIW,A,LA,            &
     &       IOLDPS,POSELT,IFINB,XSIZE)
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER NFRONT,NASS,N,LIW,INODE,IFINB
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION    ALPHA,VALPIV
      INTEGER(8) :: APOS, POSELT, UUPOS, LPOS, IRWPOS
      INTEGER(8) :: NFRONT8
      INTEGER IOLDPS,NPIV,KROW, XSIZE
      INTEGER NEL,ICOL,NEL2
      INTEGER NPIVP1
      DOUBLE PRECISION, PARAMETER :: ONE = 1.0D0
        NFRONT8=int(NFRONT,8)
        NPIV   = IW(IOLDPS+1+XSIZE)
        NPIVP1 = NPIV + 1
        NEL    = NFRONT - NPIVP1
        NEL2   = NASS - NPIVP1
        IFINB  = 0
        IF (NPIVP1.EQ.NASS) IFINB = 1
        APOS   = POSELT + int(NPIV,8)*(NFRONT8 + 1_8)
        VALPIV = ONE/A(APOS)
        LPOS   = APOS + NFRONT8
        DO 541 KROW = 1,NEL
             A(LPOS) = A(LPOS)*VALPIV
             LPOS    = LPOS + NFRONT8
  541   CONTINUE
        LPOS   = APOS + NFRONT8
        UUPOS  = APOS + 1_8
        DO 440 ICOL = 1,NEL
             IRWPOS  = LPOS + 1_8
             ALPHA   = -A(LPOS)
             CALL DAXPY(NEL2,ALPHA,A(UUPOS),1,A(IRWPOS),1)
             LPOS    = LPOS + NFRONT8
  440   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_228
      SUBROUTINE DAGMG_MUMPS_231(A,LA,NFRONT,                                &
     &       NPIV,NASS,POSELT)
      IMPLICIT NONE
      INTEGER(8) :: LA,POSELT
      DOUBLE PRECISION    A(LA)
      INTEGER NFRONT, NPIV, NASS
      INTEGER(8) :: LPOS, LPOS1, LPOS2
      INTEGER NEL1,NEL11
      DOUBLE PRECISION ALPHA, ONE
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        NEL1   = NFRONT - NASS
        NEL11  = NFRONT - NPIV
        LPOS2  = POSELT + int(NASS,8)*int(NFRONT,8)
        CALL DTRSM('L','L','N','N',NPIV,NEL1,ONE,A(POSELT),NFRONT,      &
     &              A(LPOS2),NFRONT)
        LPOS   = LPOS2 + int(NPIV,8)
        LPOS1  = POSELT + int(NPIV,8)
        CALL DGEMM('N','N',NEL11,NEL1,NPIV,ALPHA,A(LPOS1),              &
     &          NFRONT,A(LPOS2),NFRONT,ONE,A(LPOS),NFRONT)
        RETURN
        END SUBROUTINE DAGMG_MUMPS_231
      SUBROUTINE DAGMG_MUMPS_642(A,LAFAC,NFRONT,                             &
     &      NPIV,NASS, IW, LIWFAC,                                      &
     &      MonBloc, TYPEFile, MYID, KEEP8,                             &
     &      STRAT, IFLAG_OOC,                                           &
     &      LNextPiv2beWritten, UNextPiv2beWritten)
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER NFRONT, NPIV, NASS
      INTEGER(8) :: LAFAC
      INTEGER  LIWFAC, TYPEFile, MYID, IFLAG_OOC,                       &
     &      LNextPiv2beWritten, UNextPiv2beWritten, STRAT
      DOUBLE PRECISION  A(LAFAC)
      INTEGER  IW(LIWFAC)
      INTEGER*8 KEEP8(150)
      TYPE(IO_BLOCK) :: MonBloc
      INTEGER(8) :: LPOS2,LPOS1,LPOS
      INTEGER NEL1,NEL11
      DOUBLE PRECISION ALPHA, ONE
      LOGICAL LAST_CALL
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        NEL1   = NFRONT - NASS
        NEL11  = NFRONT - NPIV
        LPOS2  = 1_8 + int(NASS,8) * int(NFRONT,8)
        CALL DTRSM('L','L','N','N',NPIV,NEL1,ONE,A(1),NFRONT,           &
     &              A(LPOS2),NFRONT)
        LAST_CALL=.FALSE.
           CALL DAGMG_MUMPS_688                                              &
     &          ( STRAT, TYPEFile,                                      &
     &           A, LAFAC, MonBloc,                                     &
     &           LNextPiv2beWritten, UNextPiv2beWritten,                &
     &           IW, LIWFAC,                                            &
     &           MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
        LPOS   = LPOS2 + int(NPIV,8)
        LPOS1  = int(1 + NPIV,8)
        CALL DGEMM('N','N',NEL11,NEL1,NPIV,ALPHA,A(LPOS1),              &
     &          NFRONT,A(LPOS2),NFRONT,ONE,A(LPOS),NFRONT)
        RETURN
        END SUBROUTINE DAGMG_MUMPS_642
      SUBROUTINE DAGMG_MUMPS_232(A,LA,NFRONT,NPIV,NASS,POSELT,LKJIB)
      INTEGER NFRONT, NPIV, NASS, LKJIB
      INTEGER (8) :: POSELT, LA
      DOUBLE PRECISION    A(LA)
      INTEGER(8) :: POSELT_LOCAL, LPOS, LPOS1, LPOS2
      INTEGER NEL1, NEL11, NPBEG
      DOUBLE PRECISION ALPHA, ONE
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        POSELT_LOCAL = POSELT
        NEL1   = NASS - NPIV
        NPBEG  = NPIV - LKJIB + 1
        NEL11  = NFRONT - NPIV
        LPOS2  = POSELT_LOCAL + int(NPIV,8)*int(NFRONT,8)               &
     &                        + int(NPBEG - 1,8)
        POSELT_LOCAL = POSELT_LOCAL + int(NPBEG-1,8)*int(NFRONT,8)      &
     &                              + int(NPBEG-1,8)
        CALL DTRSM('L','L','N','N',LKJIB,NEL1,ONE,A(POSELT_LOCAL),      &
     &               NFRONT,A(LPOS2),NFRONT)
        LPOS   = LPOS2 + int(LKJIB,8)
        LPOS1  = POSELT_LOCAL + int(LKJIB,8)
        CALL DGEMM('N','N',NEL11,NEL1,LKJIB,ALPHA,A(LPOS1),             &
     &       NFRONT,A(LPOS2),NFRONT,ONE,A(LPOS),NFRONT)
        RETURN
        END SUBROUTINE DAGMG_MUMPS_232
      SUBROUTINE DAGMG_MUMPS_233(IBEG_BLOCK,                                 &
     &    NFRONT,NASS,N,INODE,IW,LIW,A,LA,                              &
     &    IOLDPS,POSELT,LKJIB_ORIG,LKJIB,LKJIT,XSIZE )
      IMPLICIT NONE
      INTEGER NFRONT, NASS,N,LIW
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      INTEGER LKJIB_ORIG,LKJIB, INODE, IBEG_BLOCK
      INTEGER(8) :: POSELT, LPOS, LPOS1, LPOS2, POSLOCAL
      INTEGER(8) :: IPOS, KPOS
      INTEGER(8) :: NFRONT8
      INTEGER IOLDPS, NPIV, JROW2, NPBEG
      INTEGER NONEL, LKJIW, NEL1, NEL11
      INTEGER LBP, HF
      INTEGER LBPT,I1,K1,II,ISWOP,LBP1
      INTEGER LKJIT, XSIZE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION ALPHA, ONE
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        NFRONT8=int(NFRONT,8)
        NPIV   = IW(IOLDPS+1+XSIZE)
        JROW2  = iabs(IW(IOLDPS+3+XSIZE))
        NPBEG  = IBEG_BLOCK
        HF     = 6 + IW(IOLDPS+5+XSIZE) +XSIZE
        NONEL         = JROW2 - NPIV + 1
        IF ((NASS-NPIV).GE.LKJIT) THEN
         LKJIB       = LKJIB_ORIG + NONEL
         IW(IOLDPS+3+XSIZE)= min0(NPIV+LKJIB,NASS)
        ELSE
          IW(IOLDPS+3+XSIZE) = NASS
        ENDIF
        IBEG_BLOCK = NPIV + 1
        NEL1   = NASS - JROW2
        LKJIW  = NPIV - NPBEG + 1
        NEL11  = NFRONT - NPIV
        IF ((NEL1.NE.0).AND.(LKJIW.NE.0)) THEN
          LPOS2  = POSELT + int(JROW2,8)*NFRONT8 +                      &
     &             int(NPBEG - 1,8)
          POSLOCAL = POSELT + int(NPBEG-1,8)*NFRONT8 + int(NPBEG - 1,8)
          CALL DTRSM('L','L','N','N',LKJIW,NEL1,ONE,                    &
     &               A(POSLOCAL),NFRONT,                                &
     &               A(LPOS2),NFRONT)
          LPOS   = LPOS2 + int(LKJIW,8)
          LPOS1  = POSLOCAL + int(LKJIW,8)
          CALL DGEMM('N','N',NEL11,NEL1,LKJIW,ALPHA,A(LPOS1),           &
     &          NFRONT,A(LPOS2),NFRONT,ONE,A(LPOS),NFRONT)
        ENDIF
        RETURN
        END SUBROUTINE DAGMG_MUMPS_233
      SUBROUTINE DAGMG_MUMPS_236(A,LA,NPIVB,NFRONT,                          &
     &                             NPIV,NASS,POSELT)
      IMPLICIT NONE
      INTEGER NPIVB,NASS
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER(8) :: APOS, POSELT
      INTEGER NFRONT, NPIV, NASSL
      INTEGER(8) :: LPOS, LPOS1, LPOS2
      INTEGER NEL1, NEL11, NPIVE
      DOUBLE PRECISION    ALPHA, ONE
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
        NEL1   = NFRONT - NASS
        NEL11  = NFRONT - NPIV
        NPIVE  = NPIV - NPIVB
        NASSL  = NASS - NPIVB
        APOS   = POSELT + int(NPIVB,8)*int(NFRONT,8)                    &
     &                  + int(NPIVB,8)
        LPOS2  = APOS + int(NASSL,8)
        CALL DTRSM('R','U','N','U',NEL1,NPIVE,ONE,A(APOS),NFRONT,       &
     &              A(LPOS2),NFRONT)
        LPOS   = LPOS2 + int(NFRONT,8)*int(NPIVE,8)
        LPOS1  = APOS  + int(NFRONT,8)*int(NPIVE,8)
        CALL DGEMM('N','N',NEL1,NEL11,NPIVE,ALPHA,A(LPOS2),             &
     &          NFRONT,A(LPOS1),NFRONT,ONE,A(LPOS),NFRONT)
        RETURN
        END SUBROUTINE DAGMG_MUMPS_236
       SUBROUTINE DAGMG_MUMPS_217(N, NZ, NSCA,                               &
     &      ASPK, IRN, ICN, COLSCA, ROWSCA, WK, LWK, WK_REAL,           &
     &      LWK_REAL, ICNTL, INFO)
       IMPLICIT NONE
      INTEGER N, NZ, NSCA, MAXS
      INTEGER IRN(NZ), ICN(NZ)
      INTEGER ICNTL(40), INFO(40)
      DOUBLE PRECISION    ASPK(NZ)
      DOUBLE PRECISION COLSCA(*), ROWSCA(*)
      INTEGER LWK, LWK_REAL
      DOUBLE PRECISION    WK(LWK)
      DOUBLE PRECISION WK_REAL(LWK_REAL)
      INTEGER MPG,LP
      INTEGER IWNOR
      INTEGER I, K
      LOGICAL PROK
      DOUBLE PRECISION ONE
      PARAMETER( ONE = 1.0D0 )
      LP      = ICNTL(1)
      MPG     = ICNTL(2)
      MPG    = ICNTL(3)
      PROK   = (MPG.GT.0)
      IF (PROK) WRITE(MPG,101)
  101   FORMAT(/' ****** SCALING OF ORIGINAL MATRIX '/)
        IF (NSCA.EQ.1) THEN
         IF (PROK)                                                      &
     &    WRITE (MPG,*) ' DIAGONAL SCALING '
        ELSEIF (NSCA.EQ.2) THEN
         IF (PROK)                                                      &
     &   WRITE (MPG,*) ' SCALING BASED ON (MC29)'
        ELSEIF (NSCA.EQ.3) THEN
         IF (PROK)                                                      &
     &   WRITE (MPG,*) ' COLUMN SCALING'
        ELSEIF (NSCA.EQ.4) THEN
         IF (PROK)                                                      &
     &   WRITE (MPG,*) ' ROW AND COLUMN SCALING (1 Pass)'
        ELSEIF (NSCA.EQ.5) THEN
         IF (PROK)                                                      &
     &   WRITE (MPG,*) ' MC29 FOLLOWED BY ROW &COL SCALING'
        ELSEIF (NSCA.EQ.6) THEN
         IF (PROK)                                                      &
     &   WRITE (MPG,*) ' MC29 FOLLOWED BY COLUMN SCALING'
        ENDIF
        DO 10 I=1,N
            COLSCA(I) = ONE
            ROWSCA(I) = ONE
   10   CONTINUE
        IF ((NSCA.EQ.5).OR.                                             &
     &      (NSCA.EQ.6))                   THEN
          IF (NZ.GT.LWK) GOTO 400
          DO 15 K=1,NZ
           WK(K) = ASPK(K)
   15     CONTINUE
        ENDIF
        IF (5*N.GT.LWK_REAL) GOTO 410
        IWNOR = 1
          IF (NSCA.EQ.1) THEN
            CALL DAGMG_MUMPS_238(N,NZ,ASPK,IRN,ICN,                          &
     &        COLSCA,ROWSCA,MPG)
          ELSEIF (NSCA.EQ.2) THEN
            CALL DAGMG_MUMPS_239(N,NZ,ASPK,IRN,ICN,                          &
     &      ROWSCA,COLSCA,WK_REAL(IWNOR),MPG,MPG,NSCA)
          ELSEIF (NSCA.EQ.3) THEN
            CALL DAGMG_MUMPS_241(N,NZ,ASPK,IRN,ICN,WK_REAL(IWNOR),           &
     &      COLSCA, MPG)
          ELSEIF (NSCA.EQ.4) THEN
            CALL DAGMG_MUMPS_287(N,NZ,IRN,ICN,ASPK,                          &
     &      WK_REAL(IWNOR),WK_REAL(IWNOR+N),COLSCA,ROWSCA,MPG)
          ELSEIF (NSCA.EQ.5) THEN
            CALL DAGMG_MUMPS_239(N,NZ,WK,IRN,ICN,                            &
     &           ROWSCA,COLSCA,WK_REAL(IWNOR),MPG,MPG,NSCA)
            CALL DAGMG_MUMPS_241(N,NZ,WK,IRN,ICN,WK_REAL(IWNOR),             &
     &           COLSCA, MPG)
          ELSEIF (NSCA.EQ.6) THEN
            CALL DAGMG_MUMPS_239(N,NZ,WK,IRN,ICN,                            &
     &           ROWSCA,COLSCA,WK_REAL(IWNOR),MPG,MPG,NSCA)
            CALL DAGMG_MUMPS_240(NSCA,N,NZ,IRN,ICN,WK,                       &
     &           WK_REAL(IWNOR+N),ROWSCA,MPG)
            CALL DAGMG_MUMPS_241(N,NZ,WK,IRN,ICN,                            &
     &           WK_REAL(IWNOR), COLSCA, MPG)
          ENDIF
      GOTO 500
  400 INFO(1) = -5
      INFO(2) = NZ-LWK
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1))                                &
     & WRITE(LP,*) '*** ERROR: Not enough space to scale matrix'
      GOTO 500
  410 INFO(1) = -5
      INFO(2) = 5*N-LWK_REAL
      IF ((LP.GT.0).AND.(ICNTL(4).GE.1))                                &
     & WRITE(LP,*) '*** ERROR: Not enough space to scale matrix'
      GOTO 500
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_217
      SUBROUTINE DAGMG_MUMPS_287(N,NZ,IRN,ICN,VAL,                           &
     &    RNOR,CNOR,COLSCA,ROWSCA,MPRINT)
      INTEGER N, NZ
      DOUBLE PRECISION    VAL(NZ)
      DOUBLE PRECISION    RNOR(N),CNOR(N)
      DOUBLE PRECISION    COLSCA(N),ROWSCA(N)
      DOUBLE PRECISION    CMIN,CMAX,RMIN,ARNOR,ACNOR
      INTEGER IRN(NZ), ICN(NZ)
      DOUBLE PRECISION    VDIAG
      INTEGER MPRINT
      INTEGER I,J,K
      DOUBLE PRECISION ZERO, ONE
      PARAMETER(ZERO=0.0D0, ONE=1.0D0)
      DO 50 J=1,N
       CNOR(J)   = ZERO
       RNOR(J)   = ZERO
   50 END DO
      DO 100 K=1,NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I.LE.0).OR.(I.GT.N).OR.                                  &
     &        (J.LE.0).OR.(J.GT.N)) GOTO 100
            VDIAG = abs(VAL(K))
            IF (VDIAG.GT.CNOR(J)) THEN
              CNOR(J) =     VDIAG
            ENDIF
            IF (VDIAG.GT.RNOR(I)) THEN
              RNOR(I) =     VDIAG
            ENDIF
  100  CONTINUE
      IF (MPRINT.GT.0) THEN
       CMIN = CNOR(1)
       CMAX = CNOR(1)
       RMIN = RNOR(1)
       DO 111 I=1,N
        ARNOR = RNOR(I)
        ACNOR = CNOR(I)
        IF (ACNOR.GT.CMAX) CMAX=ACNOR
        IF (ACNOR.LT.CMIN) CMIN=ACNOR
        IF (ARNOR.LT.RMIN) RMIN=ARNOR
  111  CONTINUE
       WRITE(MPRINT,*) '**** STAT. OF MATRIX PRIOR ROW&COL SCALING'
       WRITE(MPRINT,*) ' MAXIMUM NORM-MAX OF COLUMNS:',CMAX
       WRITE(MPRINT,*) ' MINIMUM NORM-MAX OF COLUMNS:',CMIN
       WRITE(MPRINT,*) ' MINIMUM NORM-MAX OF ROWS   :',RMIN
      ENDIF
      DO 120 J=1,N
       IF (CNOR(J).LE.ZERO) THEN
         CNOR(J)   = ONE
       ELSE
         CNOR(J)   = ONE / CNOR(J)
       ENDIF
  120 END DO
      DO 130 J=1,N
       IF (RNOR(J).LE.ZERO) THEN
         RNOR(J)   = ONE
       ELSE
         RNOR(J)   = ONE / RNOR(J)
       ENDIF
  130 END DO
       DO 110 I=1,N
        ROWSCA(I) = ROWSCA(I) * RNOR(I)
        COLSCA(I) = COLSCA(I) * CNOR(I)
  110  CONTINUE
      IF (MPRINT.GT.0)                                                  &
     &  WRITE(MPRINT,*) ' END OF SCALING BY MAX IN ROW AND COL'
      RETURN
      END SUBROUTINE DAGMG_MUMPS_287
      SUBROUTINE DAGMG_MUMPS_239(N,NZ,VAL,ROWIND,COLIND,                     &
     &       RNOR,CNOR,WNOR,MPRINT,MP,                                  &
     &       NSCA)
      INTEGER N, NZ
      DOUBLE PRECISION    VAL(NZ)
      DOUBLE PRECISION WNOR(5*N)
      DOUBLE PRECISION RNOR(N), CNOR(N)
      INTEGER COLIND(NZ),ROWIND(NZ)
      INTEGER J,I,K
      INTEGER MPRINT,MP,NSCA
      INTEGER IFAIL9
      DOUBLE PRECISION ZERO, ONE
      PARAMETER( ZERO = 0.0D0, ONE = 1.0D0 )
      DO 15 I=1,N
       RNOR(I) = ZERO
       CNOR(I) = ZERO
   15 END DO
      CALL DAGMG_MUMPS_216(N,N,NZ,VAL,ROWIND,COLIND,                         &
     &     RNOR,CNOR,WNOR, MP,IFAIL9)
!CVD$ NODEPCHK
!CVD$ VECTOR
!CVD$ CONCUR
      DO 30 I=1,N
       CNOR(I) = exp(CNOR(I))
       RNOR(I) = exp(RNOR(I))
   30 END DO
      IF ((NSCA.EQ.5).OR.(NSCA.EQ.6)) THEN
        DO 100 K=1,NZ
          I   = ROWIND(K)
          J   = COLIND(K)
          IF (min(I,J).LT.1 .OR. I.GT.N .OR. J.GT.N) GOTO 100
          VAL(K) = VAL(K) * CNOR(J) * RNOR(I)
  100   CONTINUE
      ENDIF
      IF (MPRINT.GT.0)                                                  &
     &   WRITE(MPRINT,*) ' END OF SCALING USING MC29'
      RETURN
      END SUBROUTINE DAGMG_MUMPS_239
      SUBROUTINE DAGMG_MUMPS_241(N,NZ,VAL,IRN,ICN,                           &
     &       CNOR,COLSCA,MPRINT)
      INTEGER N,NZ
      DOUBLE PRECISION VAL(NZ)
      DOUBLE PRECISION CNOR(N)
      DOUBLE PRECISION COLSCA(N)
      INTEGER IRN(NZ), ICN(NZ)
      DOUBLE PRECISION VDIAG
      INTEGER MPRINT
      INTEGER I,J,K
      DOUBLE PRECISION ZERO, ONE
      PARAMETER (ZERO=0.0D0,ONE=1.0D0)
      DO 10 J=1,N
       CNOR(J)   = ZERO
   10 END DO
      DO 100 K=1,NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I.LE.0).OR.(I.GT.N).OR.                                    &
     &      (J.LE.0).OR.(J.GT.N)) GOTO 100
        VDIAG = abs(VAL(K))
        IF (VDIAG.GT.CNOR(J)) THEN
           CNOR(J) =     VDIAG
        ENDIF
  100 END DO
      DO 110 J=1,N
       IF (CNOR(J).LE.ZERO) THEN
         CNOR(J)   = ONE
       ELSE
         CNOR(J)   = ONE/CNOR(J)
       ENDIF
  110 END DO
       DO 215 I=1,N
        COLSCA(I) = COLSCA(I) * CNOR(I)
  215  CONTINUE
      IF (MPRINT.GT.0) WRITE(MPRINT,*) ' END OF COLUMN SCALING'
      RETURN
      END SUBROUTINE DAGMG_MUMPS_241
      SUBROUTINE DAGMG_MUMPS_238(N,NZ,VAL,IRN,ICN,                           &
     &      COLSCA,ROWSCA,MPRINT)
      INTEGER   N, NZ
      DOUBLE PRECISION  VAL(NZ)
      DOUBLE PRECISION ROWSCA(N),COLSCA(N)
      INTEGER   IRN(NZ),ICN(NZ)
      DOUBLE PRECISION      VDIAG
      INTEGER   MPRINT,I,J,K
      INTRINSIC sqrt
      DOUBLE PRECISION ZERO, ONE
      PARAMETER(ZERO=0.0D0, ONE=1.0D0)
      DO 10 I=1,N
       ROWSCA(I)   = ONE
   10 END DO
      DO 100 K=1,NZ
          I = IRN(K)
          IF ((I.GT.N).OR.(I.LE.0)) GOTO 100
          J = ICN(K)
          IF (I.EQ.J) THEN
            VDIAG = abs(VAL(K))
            IF (VDIAG.GT.ZERO) THEN
              ROWSCA(J) = ONE/(sqrt(VDIAG))
            ENDIF
          ENDIF
  100  CONTINUE
       DO 110 I=1,N
        COLSCA(I) = ROWSCA(I)
  110  CONTINUE
      IF (MPRINT.GT.0) WRITE(MPRINT,*) ' END OF DIAGONAL SCALING'
      RETURN
      END SUBROUTINE DAGMG_MUMPS_238
      SUBROUTINE DAGMG_MUMPS_240(NSCA,N,NZ,IRN,ICN,VAL,                      &
     &    RNOR,ROWSCA,MPRINT)
      INTEGER N, NZ, NSCA
      INTEGER IRN(NZ), ICN(NZ)
      DOUBLE PRECISION VAL(NZ)
      DOUBLE PRECISION RNOR(N)
      DOUBLE PRECISION ROWSCA(N)
      DOUBLE PRECISION VDIAG
      INTEGER MPRINT
      INTEGER I,J,K
      DOUBLE PRECISION ZERO,ONE
      PARAMETER (ZERO=0.0D0, ONE=1.0D0)
      DO 50 J=1,N
       RNOR(J)   = ZERO
   50 END DO
      DO 100 K=1,NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I.LE.0).OR.(I.GT.N).OR.                                  &
     &        (J.LE.0).OR.(J.GT.N)) GOTO 100
            VDIAG = abs(VAL(K))
            IF (VDIAG.GT.RNOR(I)) THEN
              RNOR(I) =  VDIAG
            ENDIF
  100  CONTINUE
      DO 130 J=1,N
       IF (RNOR(J).LE.ZERO) THEN
         RNOR(J)   = ONE
       ELSE
         RNOR(J)   = ONE/RNOR(J)
       ENDIF
  130 END DO
      DO 110 I=1,N
        ROWSCA(I) = ROWSCA(I)* RNOR(I)
  110 END DO
      IF ( (NSCA.EQ.4) .OR. (NSCA.EQ.6) ) THEN
        DO 150 K=1,NZ
          I   = IRN(K)
          J   = ICN(K)
          IF (min(I,J).LT.1 .OR. I.GT.N .OR. J.GT.N) GOTO 150
          VAL(K) = VAL(K) * RNOR(I)
  150   CONTINUE
      ENDIF
      IF (MPRINT.GT.0)                                                  &
     &  WRITE(MPRINT,'(A)') '  END OF ROW SCALING'
      RETURN
      END SUBROUTINE DAGMG_MUMPS_240
      SUBROUTINE DAGMG_MUMPS_216(M,N,NE,A,IRN,ICN,R,C,W,LP,IFAIL)
      INTEGER M,N,NE
      DOUBLE PRECISION A(NE)
      INTEGER IRN(NE),ICN(NE)
      DOUBLE PRECISION    R(M),C(N)
      DOUBLE PRECISION W(M*2+N*3)
      INTEGER LP,IFAIL
      INTRINSIC LOG,ABS,MIN
      INTEGER MAXIT
      PARAMETER (MAXIT=100)
      DOUBLE PRECISION ONE
      DOUBLE PRECISION SMIN,ZERO
      PARAMETER (ONE=1.0D0,SMIN=0.1D0,ZERO=0.0D0)
      INTEGER I,I1,I2,I3,I4,I5,ITER,J,K
      DOUBLE PRECISION E,E1,EM,Q,Q1,QM,S,S1,SM,U,V
      IFAIL = 0
      IF (M.LT.1 .OR. N.LT.1) THEN
         IFAIL = -1
         GO TO 220
      ELSE IF (NE.LE.0) THEN
         IFAIL = -2
         GO TO 220
      END IF
      I1 = 0
      I2 = M
      I3 = M + N
      I4 = M + N*2
      I5 = M + N*3
      DO 10 I = 1,M
         R(I) = ZERO
         W(I1+I) = ZERO
   10 END DO
      DO 20 J = 1,N
         C(J) = ZERO
         W(I2+J) = ZERO
         W(I3+J) = ZERO
         W(I4+J) = ZERO
   20 END DO
      DO 30 K = 1,NE
         U = abs(A(K))
         IF (U.EQ.ZERO) GO TO 30
         I = IRN(K)
         J = ICN(K)
         IF (min(I,J).LT.1 .OR. I.GT.M .OR. J.GT.N) GO TO 30
         U = log(U)
         W(I1+I) = W(I1+I) + ONE
         W(I2+J) = W(I2+J) + ONE
         R(I) = R(I) + U
         W(I3+J) = W(I3+J) + U
   30 END DO
      DO 40 I = 1,M
         IF (W(I1+I).EQ.ZERO) W(I1+I) = ONE
         R(I) = R(I)/W(I1+I)
         W(I5+I) = R(I)
   40 END DO
      DO 50 J = 1,N
         IF (W(I2+J).EQ.ZERO) W(I2+J) = ONE
         W(I3+J) = W(I3+J)/W(I2+J)
   50 END DO
      SM = SMIN*dble(NE)
      DO 60 K = 1,NE
         IF (abs(A(K)).EQ.ZERO) GO TO 60
         I = IRN(K)
         J = ICN(K)
         IF (min(I,J).LT.1 .OR. I.GT.M .OR. J.GT.N) GO TO 60
         R(I) = R(I) - W(I3+J)/W(I1+I)
   60 END DO
      E = ZERO
      Q = ONE
      S = ZERO
      DO 70 I = 1,M
         S = S + W(I1+I)*R(I)**2
   70 END DO
      IF (abs(S).LE.abs(SM)) GO TO 160
      DO 150 ITER = 1,MAXIT
         DO 80 K = 1,NE
            IF (abs(A(K)).EQ.ZERO) GO TO 80
            J = ICN(K)
            I = IRN(K)
            IF (min(I,J).LT.1 .OR. I.GT.M .OR. J.GT.N) GO TO 80
            C(J) = C(J) + R(I)
   80    CONTINUE
         S1 = S
         S = ZERO
         DO 90 J = 1,N
            V = -C(J)/Q
            C(J) = V/W(I2+J)
            S = S + V*C(J)
   90    CONTINUE
         E1 = E
         E = Q*S/S1
         Q = ONE - E
         IF (abs(S).LE.abs(SM)) E = ZERO
         DO 100 I = 1,M
            R(I) = R(I)*E*W(I1+I)
  100    CONTINUE
         IF (abs(S).LE.abs(SM)) GO TO 180
         EM = E*E1
         DO 110 K = 1,NE
            IF (abs(A(K)).EQ.ZERO) GO TO 110
            I = IRN(K)
            J = ICN(K)
            IF (min(I,J).LT.1 .OR. I.GT.M .OR. J.GT.N) GO TO 110
            R(I) = R(I) + C(J)
  110    CONTINUE
         S1 = S
         S = ZERO
         DO 120 I = 1,M
            V = -R(I)/Q
            R(I) = V/W(I1+I)
            S = S + V*R(I)
  120    CONTINUE
         E1 = E
         E = Q*S/S1
         Q1 = Q
         Q = ONE - E
         IF (abs(S).LE.abs(SM)) Q = ONE
         QM = Q*Q1
         DO 130 J = 1,N
            W(I4+J) = (EM*W(I4+J)+C(J))/QM
            W(I3+J) = W(I3+J) + W(I4+J)
  130    CONTINUE
         IF (abs(S).LE.abs(SM)) GO TO 160
         DO 140 J = 1,N
            C(J) = C(J)*E*W(I2+J)
  140    CONTINUE
  150 END DO
  160 DO 170 I = 1,M
         R(I) = R(I)*W(I1+I)
  170 END DO
  180 DO 190 K = 1,NE
         IF (abs(A(K)).EQ.ZERO) GO TO 190
         I = IRN(K)
         J = ICN(K)
         IF (min(I,J).LT.1 .OR. I.GT.M .OR. J.GT.N) GO TO 190
         R(I) = R(I) + W(I3+J)
  190 END DO
      DO 200 I = 1,M
         R(I) = R(I)/W(I1+I) - W(I5+I)
  200 END DO
      DO 210 J = 1,N
         C(J) = -W(I3+J)
  210 END DO
      RETURN
  220 IF (LP.GT.0) WRITE (LP,'(/A/A,I3)')                               &
     &    ' **** Error return from DMUMPS_216 ****',' IFAIL =',IFAIL
      END SUBROUTINE DAGMG_MUMPS_216
      SUBROUTINE DAGMG_MUMPS_27( id,  ANORMINF, LSCAL )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MASTER, IERR
      PARAMETER( MASTER = 0 )
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      DOUBLE PRECISION, INTENT(OUT) :: ANORMINF
      LOGICAL :: LSCAL
      INTEGER, DIMENSION (:), POINTER :: KEEP,INFO
      INTEGER*8, DIMENSION (:), POINTER :: KEEP8
      LOGICAL :: I_AM_SLAVE
      DOUBLE PRECISION DUMMY(1)
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0)
      DOUBLE PRECISION, ALLOCATABLE :: SUMR(:), SUMR_LOC(:)
      INTEGER :: allocok, MTYPE, I
      INFO =>id%INFO
      KEEP =>id%KEEP
      KEEP8 =>id%KEEP8
      I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR.                          &
     &             ( id%MYID .eq. MASTER .AND.                          &
     &               KEEP(46) .eq. 1 ) )
      IF (id%MYID .EQ. MASTER) THEN
       ALLOCATE( SUMR( id%N ), stat =allocok )
       IF (allocok .GT.0 ) THEN
        id%INFO(1)=-13
        id%INFO(2)=id%N
        RETURN
       ENDIF
      ENDIF
      IF ( KEEP(54) .eq. 0 ) THEN
          IF (id%MYID .EQ. MASTER) THEN
            IF (KEEP(55).EQ.0) THEN
             IF (.NOT.LSCAL) THEN
              CALL DAGMG_MUMPS_207(id%A(1),                                  &
     &          id%NZ, id%N,                                            &
     &          id%IRN(1), id%JCN(1),                                   &
     &          SUMR, KEEP,KEEP8 )
             ELSE
              CALL DAGMG_MUMPS_289(id%A(1),                                  &
     &          id%NZ, id%N,                                            &
     &          id%IRN(1), id%JCN(1),                                   &
     &          SUMR, KEEP, KEEP8,                                      &
     &          id%COLSCA(1))
             ENDIF
            ELSE
             MTYPE = 1
             IF (.NOT.LSCAL) THEN
              CALL DAGMG_MUMPS_119(MTYPE, id%N,                              &
     &           id%NELT, id%ELTPTR,                                    &
     &           id%LELTVAR, id%ELTVAR,                                 &
     &           id%NA_ELT, id%A_ELT(1),                                &
     &           SUMR, KEEP,KEEP8 )
             ELSE
              CALL DAGMG_MUMPS_135(MTYPE, id%N,                              &
     &           id%NELT, id%ELTPTR(1),                                 &
     &           id%LELTVAR, id%ELTVAR(1),                              &
     &           id%NA_ELT, id%A_ELT(1),                                &
     &           SUMR, KEEP,KEEP8, id%COLSCA(1))
             ENDIF
            ENDIF
          ENDIF
      ELSE
          ALLOCATE( SUMR_LOC( id%N ), stat =allocok )
          IF (allocok .GT.0 ) THEN
             id%INFO(1)=-13
             id%INFO(2)=id%N
             RETURN
          ENDIF
          IF ( I_AM_SLAVE .and.                                         &
     &           id%NZ_loc .NE. 0 ) THEN
           IF (.NOT.LSCAL) THEN
              CALL DAGMG_MUMPS_207(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%IRN_loc, id%JCN_loc,                                 &
     &          SUMR_LOC, id%KEEP,id%KEEP8 )
           ELSE
              CALL DAGMG_MUMPS_289(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%IRN_loc, id%JCN_loc,                                 &
     &          SUMR_LOC, id%KEEP,id%KEEP8,                             &
     &          id%COLSCA)
           ENDIF
          ELSE
           SUMR_LOC = ZERO
          ENDIF
          IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( SUMR_LOC, SUMR,                        id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
          ELSE
              CALL AGMG_COPY( SUMR_LOC, DUMMY,                       id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
          END IF
        DEALLOCATE (SUMR_LOC)
      ENDIF
      IF ( id%MYID .eq. MASTER ) THEN
       ANORMINF = dble(ZERO)
        IF (LSCAL) THEN
         DO I = 1, id%N
          ANORMINF = max(abs(id%ROWSCA(I) * SUMR(I)),                   &
     &                  ANORMINF)
         ENDDO
        ELSE
         DO I = 1, id%N
          ANORMINF = max(abs(SUMR(I)),                                  &
     &                  ANORMINF)
         ENDDO
        ENDIF
      ENDIF
      CALL AGMG_SETIERR( IERR )
      IF (id%MYID .eq. MASTER) DEALLOCATE (SUMR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_27
      SUBROUTINE DAGMG_MUMPS_693(IRN_loc, JCN_loc, A_loc, NZ_loc,            &
     &     M, N, NUMPROCS, MYID, COMM,                                  &
     &     RPARTVEC, CPARTVEC,                                          &
     &     RSNDRCVSZ, CSNDRCVSZ, REGISTRE,                              &
     &     IWRK, IWRKSZ,                                                &
     &     INTSZ, RESZ, OP,                                             &
     &     ROWSCA, COLSCA, WRKRC, ISZWRKRC,                             &
     &     SYM, NB1, NB2, NB3, EPS,                                     &
     &     ONENORMERR,INFNORMERR)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER NZ_loc, M, N, IWRKSZ, OP
      INTEGER NUMPROCS, MYID, COMM
      INTEGER INTSZ, RESZ
      INTEGER IRN_loc(NZ_loc)
      INTEGER JCN_loc(NZ_loc)
      DOUBLE PRECISION A_loc(NZ_loc)
      INTEGER RPARTVEC(M), RSNDRCVSZ(2*NUMPROCS)
      INTEGER CPARTVEC(N), CSNDRCVSZ(2*NUMPROCS)
      INTEGER IWRK(IWRKSZ)
      INTEGER REGISTRE(12)
      DOUBLE PRECISION ROWSCA(M)
      DOUBLE PRECISION COLSCA(M)
      INTEGER ISZWRKRC
      DOUBLE PRECISION WRKRC(ISZWRKRC)
      DOUBLE PRECISION ONENORMERR,INFNORMERR
      INTEGER IRSNDRCVNUM, ORSNDRCVNUM
      INTEGER IRSNDRCVVOL, ORSNDRCVVOL
      INTEGER ICSNDRCVNUM, OCSNDRCVNUM
      INTEGER ICSNDRCVVOL, OCSNDRCVVOL
      INTEGER  INUMMYR, INUMMYC
      INTEGER IMYRPTR,IMYCPTR
      INTEGER IRNGHBPRCS, IRSNDRCVIA,IRSNDRCVJA
      INTEGER ORNGHBPRCS, ORSNDRCVIA,ORSNDRCVJA
      INTEGER ICNGHBPRCS, ICSNDRCVIA,ICSNDRCVJA
      INTEGER OCNGHBPRCS, OCSNDRCVIA,OCSNDRCVJA
      INTEGER ISTATUS, REQUESTS, TMPWORK
      INTEGER ITDRPTR, ITDCPTR, ISRRPTR
      INTEGER OSRRPTR, ISRCPTR, OSRCPTR
      INTEGER SYM, NB1, NB2, NB3
      DOUBLE PRECISION EPS
      DOUBLE PRECISION RONE
      PARAMETER(RONE=1.0D0)
      EXTERNAL DAGMG_MUMPS_694,DAGMG_MUMPS_687,                                   &
     &     DAGMG_MUMPS_670
      INTEGER I
      IF(SYM.EQ.0) THEN
         CALL DAGMG_MUMPS_694(IRN_loc, JCN_loc, A_loc, NZ_loc,               &
     &        M, N, NUMPROCS, MYID, COMM,                               &
     &        RPARTVEC, CPARTVEC,                                       &
     &        RSNDRCVSZ, CSNDRCVSZ, REGISTRE,                           &
     &        IWRK, IWRKSZ,                                             &
     &        INTSZ, RESZ, OP,                                          &
     &        ROWSCA, COLSCA, WRKRC, ISZWRKRC,                          &
     &        NB1, NB2, NB3, EPS,                                       &
     &        ONENORMERR, INFNORMERR)
      ELSE
         CALL DAGMG_MUMPS_687(IRN_loc, JCN_loc, A_loc, NZ_loc,               &
     &        N, NUMPROCS, MYID, COMM,                                  &
     &        RPARTVEC,                                                 &
     &        RSNDRCVSZ, REGISTRE,                                      &
     &        IWRK, IWRKSZ,                                             &
     &        INTSZ, RESZ, OP,                                          &
     &        ROWSCA, WRKRC, ISZWRKRC,                                  &
     &        NB1, NB2, NB3, EPS,                                       &
     &        ONENORMERR, INFNORMERR)
         DO I=1,N
            COLSCA(I) = ROWSCA(I)
         ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_693
      SUBROUTINE DAGMG_MUMPS_694(IRN_loc, JCN_loc, A_loc, NZ_loc,            &
     &     M, N, NUMPROCS, MYID, COMM,                                  &
     &     RPARTVEC, CPARTVEC,                                          &
     &     RSNDRCVSZ, CSNDRCVSZ, REGISTRE,                              &
     &     IWRK, IWRKSZ,                                                &
     &     INTSZ, RESZ, OP,                                             &
     &     ROWSCA, COLSCA, WRKRC, ISZWRKRC,                             &
     &     NB1, NB2, NB3, EPS,                                          &
     &     ONENORMERR, INFNORMERR)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER NZ_loc, M, N, IWRKSZ, OP
      INTEGER NUMPROCS, MYID, COMM
      INTEGER INTSZ, RESZ
      INTEGER IRN_loc(NZ_loc)
      INTEGER JCN_loc(NZ_loc)
      DOUBLE PRECISION A_loc(NZ_loc)
      INTEGER RPARTVEC(M), RSNDRCVSZ(2*NUMPROCS)
      INTEGER CPARTVEC(N), CSNDRCVSZ(2*NUMPROCS)
      INTEGER IWRK(IWRKSZ)
      INTEGER REGISTRE(12)
      DOUBLE PRECISION ROWSCA(M)
      DOUBLE PRECISION COLSCA(M)
      INTEGER ISZWRKRC
      DOUBLE PRECISION WRKRC(ISZWRKRC)
      DOUBLE PRECISION ONENORMERR,INFNORMERR
      INTEGER IRSNDRCVNUM, ORSNDRCVNUM
      INTEGER IRSNDRCVVOL, ORSNDRCVVOL
      INTEGER ICSNDRCVNUM, OCSNDRCVNUM
      INTEGER ICSNDRCVVOL, OCSNDRCVVOL
      INTEGER  INUMMYR, INUMMYC
      INTEGER IMYRPTR,IMYCPTR
      INTEGER IRNGHBPRCS, IRSNDRCVIA,IRSNDRCVJA
      INTEGER ORNGHBPRCS, ORSNDRCVIA,ORSNDRCVJA
      INTEGER ICNGHBPRCS, ICSNDRCVIA,ICSNDRCVJA
      INTEGER OCNGHBPRCS, OCSNDRCVIA,OCSNDRCVJA
      INTEGER ISTATUS, REQUESTS, TMPWORK
      INTEGER ITDRPTR, ITDCPTR, ISRRPTR
      INTEGER OSRRPTR, ISRCPTR, OSRCPTR
      INTEGER NB1, NB2, NB3
      DOUBLE PRECISION EPS
      INTEGER ITER, NZIND, IR, IC, NUMCNVRG
      DOUBLE PRECISION ELM
      INTEGER TAG_COMM_COL
      PARAMETER(TAG_COMM_COL=100)
      INTEGER TAG_COMM_ROW
      PARAMETER(TAG_COMM_ROW=101)
      INTEGER TAG_ITERS
      PARAMETER(TAG_ITERS=102)
      EXTERNAL DAGMG_MUMPS_654,                                              &
     &     DAGMG_MUMPS_672,                                                  &
     &     DAGMG_MUMPS_674,                                                  &
     &     DAGMG_MUMPS_662,                                                  &
     &     DAGMG_MUMPS_743,                                                  &
     &     DAGMG_MUMPS_745,                                                  &
     &     DAGMG_MUMPS_660,                                                  &
     &     DAGMG_MUMPS_670,                                                  &
     &     DAGMG_MUMPS_671,                                                  &
     &     DAGMG_MUMPS_657,                                                  &
     &     DAGMG_MUMPS_656
      INTEGER DAGMG_MUMPS_743
      INTEGER DAGMG_MUMPS_745
      DOUBLE PRECISION DAGMG_MUMPS_737
      DOUBLE PRECISION DAGMG_MUMPS_738
      INTRINSIC abs
      DOUBLE PRECISION RONE, RZERO
      PARAMETER(RONE=1.0D0,RZERO=0.0D0)
      INTEGER RESZR, RESZC
      INTEGER INTSZR, INTSZC
      INTEGER MAXMN
      INTEGER I, IERROR
      DOUBLE PRECISION ONEERRROW, ONEERRCOL, ONEERRL, ONEERRG
      DOUBLE PRECISION INFERRROW, INFERRCOL, INFERRL, INFERRG
      INTEGER OORANGEIND
      INFERRG = -RONE
      ONEERRG = -RONE
      OORANGEIND = 0
      MAXMN = M
      IF(MAXMN < N) MAXMN = N
      IF(OP == 1) THEN
         IF(NUMPROCS > 1) THEN
            CALL DAGMG_MUMPS_654(MYID, NUMPROCS, COMM,                       &
     &           IRN_loc, JCN_loc, NZ_loc,                              &
     &           RPARTVEC, M, N,                                        &
     &           IWRK, IWRKSZ)
            CALL DAGMG_MUMPS_654(MYID, NUMPROCS, COMM,                       &
     &           JCN_loc, IRN_loc,  NZ_loc,                             &
     &           CPARTVEC, N, M,                                        &
     &           IWRK, IWRKSZ)
            CALL DAGMG_MUMPS_672(MYID, NUMPROCS, M, RPARTVEC,                &
     &           NZ_loc, IRN_loc, N, JCN_loc,                           &
     &           IRSNDRCVNUM,IRSNDRCVVOL,                               &
     &           ORSNDRCVNUM,ORSNDRCVVOL,                               &
     &           IWRK,IWRKSZ,                                           &
     &           RSNDRCVSZ(1), RSNDRCVSZ(1+NUMPROCS), COMM)
            CALL DAGMG_MUMPS_672(MYID, NUMPROCS, N, CPARTVEC,                &
     &           NZ_loc, JCN_loc, M, IRN_loc,                           &
     &           ICSNDRCVNUM,ICSNDRCVVOL,                               &
     &           OCSNDRCVNUM,OCSNDRCVVOL,                               &
     &           IWRK,IWRKSZ,                                           &
     &           CSNDRCVSZ(1), CSNDRCVSZ(1+NUMPROCS), COMM)
            CALL DAGMG_MUMPS_662(MYID, NUMPROCS, COMM,                       &
     &           IRN_loc, JCN_loc, NZ_loc,                              &
     &           RPARTVEC, CPARTVEC, M, N,                              &
     &           INUMMYR,                                               &
     &           INUMMYC,                                               &
     &           IWRK, IWRKSZ)
            INTSZR =  IRSNDRCVNUM + ORSNDRCVNUM +                       &
     &           IRSNDRCVVOL + ORSNDRCVVOL +                            &
     &           2*(NUMPROCS+1) + INUMMYR
            INTSZC = ICSNDRCVNUM + OCSNDRCVNUM +                        &
     &           ICSNDRCVVOL + OCSNDRCVVOL +                            &
     &           2*(NUMPROCS+1) + INUMMYC
            INTSZ = INTSZR + INTSZC + MAXMN +                           &
     &           (AGMG_MPF_STATUS_SIZE +1) *  NUMPROCS
         ELSE
             IRSNDRCVNUM = 0
             ORSNDRCVNUM = 0
             IRSNDRCVVOL = 0
             ORSNDRCVVOL = 0
             INUMMYR = 0
             ICSNDRCVNUM  = 0
             OCSNDRCVNUM  = 0
             ICSNDRCVVOL = 0
             OCSNDRCVVOL  = 0
             INUMMYC = 0
             INTSZ = 0
          ENDIF
          RESZR = M + IRSNDRCVVOL + ORSNDRCVVOL
          RESZC = N + ICSNDRCVVOL + OCSNDRCVVOL
          RESZ = RESZR  + RESZC
          REGISTRE(1) = IRSNDRCVNUM
          REGISTRE(2) = ORSNDRCVNUM
          REGISTRE(3) = IRSNDRCVVOL
          REGISTRE(4) = ORSNDRCVVOL
          REGISTRE(5) = ICSNDRCVNUM
          REGISTRE(6) = OCSNDRCVNUM
          REGISTRE(7) = ICSNDRCVVOL
          REGISTRE(8) = OCSNDRCVVOL
          REGISTRE(9) = INUMMYR
          REGISTRE(10) = INUMMYC
          REGISTRE(11) = INTSZ
          REGISTRE(12) = RESZ
       ELSE
          IRSNDRCVNUM = REGISTRE(1)
          ORSNDRCVNUM = REGISTRE(2)
          IRSNDRCVVOL = REGISTRE(3)
          ORSNDRCVVOL = REGISTRE(4)
          ICSNDRCVNUM = REGISTRE(5)
          OCSNDRCVNUM = REGISTRE(6)
          ICSNDRCVVOL = REGISTRE(7)
          OCSNDRCVVOL = REGISTRE(8)
          INUMMYR = REGISTRE(9)
          INUMMYC = REGISTRE(10)
          IF(NUMPROCS > 1) THEN
             CALL DAGMG_MUMPS_660(MYID, NUMPROCS,COMM,                       &
     &            IRN_loc, JCN_loc, NZ_loc,                             &
     &            RPARTVEC, CPARTVEC, M, N,                             &
     &            IWRK(1), INUMMYR,                                     &
     &            IWRK(1+INUMMYR), INUMMYC,                             &
     &            IWRK(1+INUMMYR+INUMMYC), IWRKSZ-INUMMYR-INUMMYC )
             IMYRPTR = 1
             IMYCPTR = IMYRPTR + INUMMYR
             IRNGHBPRCS = IMYCPTR+ INUMMYC
             IRSNDRCVIA = IRNGHBPRCS+IRSNDRCVNUM
             IRSNDRCVJA = IRSNDRCVIA + NUMPROCS+1
             ORNGHBPRCS = IRSNDRCVJA + IRSNDRCVVOL
             ORSNDRCVIA = ORNGHBPRCS + ORSNDRCVNUM
             ORSNDRCVJA = ORSNDRCVIA + NUMPROCS + 1
             ICNGHBPRCS = ORSNDRCVJA + ORSNDRCVVOL
             ICSNDRCVIA = ICNGHBPRCS + ICSNDRCVNUM
             ICSNDRCVJA = ICSNDRCVIA + NUMPROCS+1
             OCNGHBPRCS = ICSNDRCVJA + ICSNDRCVVOL
             OCSNDRCVIA = OCNGHBPRCS + OCSNDRCVNUM
             OCSNDRCVJA = OCSNDRCVIA +  NUMPROCS + 1
             REQUESTS = OCSNDRCVJA + OCSNDRCVVOL
             ISTATUS = REQUESTS + NUMPROCS
             TMPWORK = ISTATUS + AGMG_MPF_STATUS_SIZE *  NUMPROCS
             CALL DAGMG_MUMPS_674(MYID, NUMPROCS, M, RPARTVEC,               &
     &            NZ_loc, IRN_loc,N, JCN_loc,                           &
     &            IRSNDRCVNUM, IRSNDRCVVOL,                             &
     &            IWRK(IRNGHBPRCS),IWRK(IRSNDRCVIA),IWRK(IRSNDRCVJA),   &
     &            ORSNDRCVNUM, ORSNDRCVVOL,                             &
     &            IWRK(ORNGHBPRCS),IWRK(ORSNDRCVIA),IWRK(ORSNDRCVJA),   &
     &            RSNDRCVSZ(1), RSNDRCVSZ(1+NUMPROCS),                  &
     &            IWRK(TMPWORK),                                        &
     &            IWRK(ISTATUS), IWRK(REQUESTS),                        &
     &            TAG_COMM_ROW, COMM)
             CALL DAGMG_MUMPS_674(MYID, NUMPROCS, N, CPARTVEC,               &
     &            NZ_loc, JCN_loc, M, IRN_loc,                          &
     &            ICSNDRCVNUM, ICSNDRCVVOL,                             &
     &            IWRK(ICNGHBPRCS),                                     &
     &            IWRK(ICSNDRCVIA),                                     &
     &            IWRK(ICSNDRCVJA),                                     &
     &            OCSNDRCVNUM, OCSNDRCVVOL,                             &
     &            IWRK(OCNGHBPRCS),IWRK(OCSNDRCVIA),IWRK(OCSNDRCVJA),   &
     &            CSNDRCVSZ(1), CSNDRCVSZ(1+NUMPROCS),                  &
     &            IWRK(TMPWORK),                                        &
     &            IWRK(ISTATUS),  IWRK(REQUESTS),                       &
     &            TAG_COMM_COL, COMM)
             CALL DAGMG_MUMPS_670(ROWSCA, M, RZERO)
             CALL DAGMG_MUMPS_670(COLSCA, N, RZERO)
             CALL DAGMG_MUMPS_671(ROWSCA, M,                                 &
     &            IWRK(IMYRPTR),INUMMYR, RONE)
             CALL DAGMG_MUMPS_671(COLSCA, N,                                 &
     &            IWRK(IMYCPTR),INUMMYC, RONE)
          ELSE
             CALL DAGMG_MUMPS_670(ROWSCA, M, RONE)
             CALL DAGMG_MUMPS_670(COLSCA, N, RONE)
          ENDIF
          ITDRPTR = 1
          ITDCPTR = ITDRPTR + M
          ISRRPTR = ITDCPTR + N
          OSRRPTR = ISRRPTR + IRSNDRCVVOL
          ISRCPTR = OSRRPTR + ORSNDRCVVOL
          OSRCPTR = ISRCPTR + ICSNDRCVVOL
          IF(NUMPROCS == 1)THEN
             OSRCPTR = OSRCPTR - 1
             ISRCPTR = ISRCPTR - 1
             OSRRPTR = OSRRPTR - 1
             ISRRPTR = ISRRPTR - 1
          ELSE
             IF(IRSNDRCVVOL == 0) ISRRPTR = ISRRPTR - 1
             IF(ORSNDRCVVOL == 0) OSRRPTR = OSRRPTR - 1
             IF(ICSNDRCVVOL == 0) ISRCPTR = ISRCPTR - 1
             IF(OCSNDRCVVOL == 0) OSRCPTR = OSRCPTR - 1
          ENDIF
          ITER = 1
          DO WHILE (ITER.LE.NB1+NB2+NB3)
             IF(NUMPROCS > 1) THEN
                CALL DAGMG_MUMPS_650(WRKRC(ITDRPTR),M,                       &
     &               IWRK(IMYRPTR),INUMMYR)
                CALL DAGMG_MUMPS_650(WRKRC(ITDCPTR),N,                       &
     &               IWRK(IMYCPTR),INUMMYC)
             ELSE
                CALL DAGMG_MUMPS_670(WRKRC(ITDRPTR),M, RZERO)
                CALL DAGMG_MUMPS_670(WRKRC(ITDCPTR),N, RZERO)
             ENDIF
             IF((ITER.LE.NB1).OR.(ITER > NB1+NB2)) THEN
                IF((ITER.EQ.1).OR.(OORANGEIND.EQ.1)) THEN
                   DO NZIND=1,NZ_loc
                      IR = IRN_loc(NZIND)
                      IC = JCN_loc(NZIND)
                      IF((IR.GE.1).AND.(IR.LE.M).AND.                   &
     &                     (IC.GE.1).AND.(IC.LE.N)) THEN
                         ELM = abs(A_loc(NZIND))*ROWSCA(IR)*COLSCA(IC)
                         IF(WRKRC(ITDRPTR-1+IR)<ELM) THEN
                            WRKRC(ITDRPTR-1+IR)= ELM
                         ENDIF
                         IF(WRKRC(ITDCPTR-1+IC)<ELM) THEN
                            WRKRC(ITDCPTR-1+IC)= ELM
                         ENDIF
                      ELSE
                         OORANGEIND = 1
                      ENDIF
                   ENDDO
                ELSEIF(OORANGEIND.EQ.0) THEN
                   DO NZIND=1,NZ_loc
                      IR = IRN_loc(NZIND)
                      IC = JCN_loc(NZIND)
                      ELM = abs(A_loc(NZIND))*ROWSCA(IR)*COLSCA(IC)
                      IF(WRKRC(ITDRPTR-1+IR)<ELM) THEN
                         WRKRC(ITDRPTR-1+IR)= ELM
                      ENDIF
                      IF(WRKRC(ITDCPTR-1+IC)<ELM) THEN
                         WRKRC(ITDCPTR-1+IC)= ELM
                      ENDIF
                   ENDDO
                ENDIF
                IF(NUMPROCS > 1) THEN
                   CALL DAGMG_MUMPS_657(MYID, NUMPROCS,                      &
     &                  WRKRC(ITDCPTR), N, TAG_ITERS+ITER,              &
     &                  ICSNDRCVNUM,IWRK(ICNGHBPRCS),                   &
     &                  ICSNDRCVVOL,IWRK(ICSNDRCVIA), IWRK(ICSNDRCVJA), &
     &                  WRKRC(ISRCPTR),                                 &
     &                  OCSNDRCVNUM,IWRK(OCNGHBPRCS),                   &
     &                  OCSNDRCVVOL,IWRK(OCSNDRCVIA), IWRK(OCSNDRCVJA), &
     &                  WRKRC( OSRCPTR),                                &
     &                  IWRK(ISTATUS),IWRK(REQUESTS),                   &
     &                  COMM)
                  CALL DAGMG_MUMPS_657(MYID, NUMPROCS,                       &
     &                  WRKRC(ITDRPTR), M, TAG_ITERS+2+ITER,            &
     &                  IRSNDRCVNUM,IWRK(IRNGHBPRCS),                   &
     &                  IRSNDRCVVOL,IWRK(IRSNDRCVIA), IWRK(IRSNDRCVJA), &
     &                  WRKRC(ISRRPTR),                                 &
     &                  ORSNDRCVNUM,IWRK(ORNGHBPRCS),                   &
     &                  ORSNDRCVVOL,IWRK(ORSNDRCVIA), IWRK(ORSNDRCVJA), &
     &                  WRKRC( OSRRPTR),                                &
     &                  IWRK(ISTATUS),IWRK(REQUESTS),                   &
     &                  COMM)
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 (ITER.EQ.NB1).OR.                                &
     &                 ((ITER.EQ.NB1+NB2+NB3).AND.                      &
     &                 (NB1+NB3.GT.0))) THEN
                     INFERRROW = DAGMG_MUMPS_737(ROWSCA,                     &
     &                    WRKRC(ITDRPTR), M,                            &
     &                    IWRK(IMYRPTR),INUMMYR)
                     INFERRCOL = DAGMG_MUMPS_737(COLSCA,                     &
     &                    WRKRC(ITDCPTR), N,                            &
     &                    IWRK(IMYCPTR),INUMMYC)
                     INFERRL = INFERRCOL
                     IF(INFERRROW > INFERRL ) THEN
                        INFERRL = INFERRROW
                     ENDIF
   CALL AGMG_COPY(INFERRL, INFERRG,                         1, AGMG_MPF_DOUBLE_PRECISION, IERROR)
                     IF(INFERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_665(COLSCA,  WRKRC(ITDCPTR),        &
     &                       N,                                         &
     &                       IWRK(IMYCPTR),INUMMYC)
                        CALL DAGMG_MUMPS_665(ROWSCA,  WRKRC(ITDRPTR),        &
     &                       M,                                         &
     &                       IWRK(IMYRPTR),INUMMYR)
                        IF(ITER .LE. NB1) THEN
                           ITER = NB1+1
                           CYCLE
                        ELSE
                           EXIT
                        ENDIF
                     ENDIF
                  ENDIF
               ELSE
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 (ITER.EQ.NB1).OR.                                &
     &                 ((ITER.EQ.NB1+NB2+NB3).AND.                      &
     &                 (NB1+NB3.GT.0))) THEN
                     INFERRROW = DAGMG_MUMPS_738(ROWSCA,                     &
     &                    WRKRC(ITDRPTR), M)
                     INFERRCOL = DAGMG_MUMPS_738(COLSCA,                     &
     &                    WRKRC(ITDCPTR), N)
                     INFERRL = INFERRCOL
                     IF(INFERRROW > INFERRL) THEN
                        INFERRL = INFERRROW
                     ENDIF
                     INFERRG = INFERRL
                     IF(INFERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_666(COLSCA,  WRKRC(ITDCPTR), N)
                        CALL DAGMG_MUMPS_666(ROWSCA,  WRKRC(ITDRPTR), M)
                        IF(ITER .LE. NB1) THEN
                           ITER = NB1+1
                           CYCLE
                        ELSE
                           EXIT
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ELSE
               IF((ITER .EQ.1).OR.(OORANGEIND.EQ.1))THEN
                  DO NZIND=1,NZ_loc
                     IR = IRN_loc(NZIND)
                     IC = JCN_loc(NZIND)
                     IF((IR.GE.1).AND.(IR.LE.M).AND.                    &
     &                    (IC.GE.1).AND.(IC.LE.N)) THEN
                        ELM = abs(A_loc(NZIND))*ROWSCA(IR)*COLSCA(IC)
                        WRKRC(ITDRPTR-1+IR) = WRKRC(ITDRPTR-1+IR) + ELM
                        WRKRC(ITDCPTR-1+IC) = WRKRC(ITDCPTR-1+IC) + ELM
                     ELSE
                        OORANGEIND = 1
                     ENDIF
                  ENDDO
               ELSEIF(OORANGEIND.EQ.0) THEN
                  DO NZIND=1,NZ_loc
                     IR = IRN_loc(NZIND)
                     IC = JCN_loc(NZIND)
                     ELM = abs(A_loc(NZIND))*ROWSCA(IR)*COLSCA(IC)
                     WRKRC(ITDRPTR-1+IR) = WRKRC(ITDRPTR-1+IR) + ELM
                     WRKRC(ITDCPTR-1+IC) = WRKRC(ITDCPTR-1+IC) + ELM
                  ENDDO
               ENDIF
               IF(NUMPROCS > 1) THEN
                  CALL DAGMG_MUMPS_656(MYID, NUMPROCS,                       &
     &                 WRKRC(ITDCPTR), N, TAG_ITERS+ITER,               &
     &                 ICSNDRCVNUM, IWRK(ICNGHBPRCS),                   &
     &                 ICSNDRCVVOL, IWRK(ICSNDRCVIA), IWRK(ICSNDRCVJA), &
     &                 WRKRC(ISRCPTR),                                  &
     &                 OCSNDRCVNUM, IWRK(OCNGHBPRCS),                   &
     &                 OCSNDRCVVOL, IWRK(OCSNDRCVIA), IWRK(OCSNDRCVJA), &
     &                 WRKRC( OSRCPTR),                                 &
     &                 IWRK(ISTATUS), IWRK(REQUESTS),                   &
     &                 COMM)
                  CALL DAGMG_MUMPS_656(MYID, NUMPROCS,                       &
     &                 WRKRC(ITDRPTR), M, TAG_ITERS+2+ITER,             &
     &                 IRSNDRCVNUM, IWRK(IRNGHBPRCS),                   &
     &                 IRSNDRCVVOL, IWRK(IRSNDRCVIA), IWRK(IRSNDRCVJA), &
     &                 WRKRC(ISRRPTR),                                  &
     &                 ORSNDRCVNUM, IWRK(ORNGHBPRCS),                   &
     &                 ORSNDRCVVOL, IWRK(ORSNDRCVIA), IWRK(ORSNDRCVJA), &
     &                 WRKRC( OSRRPTR),                                 &
     &                 IWRK(ISTATUS), IWRK(REQUESTS),                   &
     &                 COMM)
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 ((ITER.EQ.NB1+NB2).AND.                          &
     &                 (NB2.GT.0))) THEN
                     ONEERRROW = DAGMG_MUMPS_737(ROWSCA,                     &
     &                    WRKRC(ITDRPTR), M,                            &
     &                    IWRK(IMYRPTR),INUMMYR)
                     ONEERRCOL = DAGMG_MUMPS_737(COLSCA,                     &
     &                    WRKRC(ITDCPTR), N,                            &
     &                    IWRK(IMYCPTR),INUMMYC)
                     ONEERRL = ONEERRCOL
                     IF(ONEERRROW > ONEERRL ) THEN
                        ONEERRL = ONEERRROW
                     ENDIF
   CALL AGMG_COPY(ONEERRL, ONEERRG,                         1, AGMG_MPF_DOUBLE_PRECISION, IERROR)
                     IF(ONEERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_665(COLSCA,  WRKRC(ITDCPTR),        &
     &                       N,                                         &
     &                       IWRK(IMYCPTR),INUMMYC)
                        CALL DAGMG_MUMPS_665(ROWSCA,  WRKRC(ITDRPTR),        &
     &                       M,                                         &
     &                       IWRK(IMYRPTR),INUMMYR)
                        ITER = NB1+NB2+1
                        CYCLE
                     ENDIF
                  ENDIF
               ELSE
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 ((ITER.EQ.NB1+NB2).AND.                          &
     &                 (NB2.GT.0))) THEN
                     ONEERRROW = DAGMG_MUMPS_738(ROWSCA,                     &
     &                    WRKRC(ITDRPTR), M)
                     ONEERRCOL = DAGMG_MUMPS_738(COLSCA,                     &
     &                    WRKRC(ITDCPTR), N)
                     ONEERRL = ONEERRCOL
                     IF(ONEERRROW > ONEERRL) THEN
                        ONEERRL = ONEERRROW
                     ENDIF
                     ONEERRG = ONEERRL
                     IF(ONEERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_666(COLSCA,  WRKRC(ITDCPTR), N)
                        CALL DAGMG_MUMPS_666(ROWSCA,  WRKRC(ITDRPTR), M)
                        ITER = NB1+NB2+1
                        CYCLE
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(NUMPROCS > 1) THEN
               CALL DAGMG_MUMPS_665(COLSCA,  WRKRC(ITDCPTR), N,              &
     &              IWRK(IMYCPTR),INUMMYC)
               CALL DAGMG_MUMPS_665(ROWSCA,  WRKRC(ITDRPTR), M,              &
     &              IWRK(IMYRPTR),INUMMYR)
            ELSE
               CALL DAGMG_MUMPS_666(COLSCA,  WRKRC(ITDCPTR), N)
               CALL DAGMG_MUMPS_666(ROWSCA,  WRKRC(ITDRPTR), M)
            ENDIF
            ITER = ITER + 1
         ENDDO
         ONENORMERR = ONEERRG
         INFNORMERR = INFERRG
         IF(NUMPROCS > 1) THEN
            CALL AGMG_COPY(ROWSCA, WRKRC, M, AGMG_MPF_DOUBLE_PRECISION, IERROR)
            IF(MYID.EQ.0) THEN
               DO I=1, M
                  ROWSCA(I) = WRKRC(I)
               ENDDO
            ENDIF
            CALL AGMG_COPY(COLSCA, WRKRC(1+M:M+N), N,                                     AGMG_MPF_DOUBLE_PRECISION, IERROR)
            If(MYID.EQ.0) THEN
               DO I=1, N
                  COLSCA(I) = WRKRC(I+M)
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_694
      SUBROUTINE DAGMG_MUMPS_687(IRN_loc, JCN_loc, A_loc, NZ_loc,            &
     &     N, NUMPROCS, MYID, COMM,                                     &
     &     PARTVEC,                                                     &
     &     RSNDRCVSZ,                                                   &
     &     REGISTRE,                                                    &
     &     IWRK, IWRKSZ,                                                &
     &     INTSZ, RESZ, OP,                                             &
     &     SCA, WRKRC, ISZWRKRC,                                        &
     &     NB1, NB2, NB3, EPS,                                          &
     &     ONENORMERR, INFNORMERR)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER NZ_loc, N, IWRKSZ, OP
      INTEGER NUMPROCS, MYID, COMM
      INTEGER INTSZ, RESZ
      INTEGER IRN_loc(NZ_loc)
      INTEGER JCN_loc(NZ_loc)
      DOUBLE PRECISION A_loc(NZ_loc)
      INTEGER PARTVEC(N), RSNDRCVSZ(2*NUMPROCS)
      INTEGER IWRK(IWRKSZ)
      INTEGER REGISTRE(12)
      DOUBLE PRECISION SCA(N)
      INTEGER ISZWRKRC
      DOUBLE PRECISION WRKRC(ISZWRKRC)
      INTEGER IRSNDRCVNUM, ORSNDRCVNUM
      INTEGER IRSNDRCVVOL, ORSNDRCVVOL
      INTEGER  INUMMYR
      INTEGER IMYRPTR,IMYCPTR
      INTEGER IRNGHBPRCS, IRSNDRCVIA,IRSNDRCVJA
      INTEGER ORNGHBPRCS, ORSNDRCVIA,ORSNDRCVJA
      INTEGER ISTATUS, REQUESTS, TMPWORK
      INTEGER ITDRPTR, ISRRPTR, OSRRPTR
      DOUBLE PRECISION ONENORMERR,INFNORMERR
      INTEGER NB1, NB2, NB3
      DOUBLE PRECISION EPS
      INTEGER ITER, NZIND, IR, IC, NUMCNVRG
      DOUBLE PRECISION ELM
      INTEGER TAG_COMM_COL
      PARAMETER(TAG_COMM_COL=100)
      INTEGER TAG_COMM_ROW
      PARAMETER(TAG_COMM_ROW=101)
      INTEGER TAG_ITERS
      PARAMETER(TAG_ITERS=102)
      EXTERNAL DAGMG_MUMPS_655,                                              &
     &     DAGMG_MUMPS_673,                                                  &
     &     DAGMG_MUMPS_692,                                                  &
     &     DAGMG_MUMPS_663,                                                  &
     &     DAGMG_MUMPS_742,                                                  &
     &     DAGMG_MUMPS_745,                                                  &
     &     DAGMG_MUMPS_661,                                                  &
     &     DAGMG_MUMPS_657,                                                  &
     &     DAGMG_MUMPS_656,                                                  &
     &     DAGMG_MUMPS_670,                                                  &
     &     DAGMG_MUMPS_671
      INTEGER DAGMG_MUMPS_742
      INTEGER DAGMG_MUMPS_745
      DOUBLE PRECISION DAGMG_MUMPS_737
      DOUBLE PRECISION DAGMG_MUMPS_738
      INTRINSIC abs
      DOUBLE PRECISION RONE, RZERO
      PARAMETER(RONE=1.0D0,RZERO=0.0D0)
      INTEGER RESZR, RESZC
      INTEGER INTSZR, INTSZC
      INTEGER MAXMN
      INTEGER I, IERROR
      DOUBLE PRECISION ONEERRL, ONEERRG
      DOUBLE PRECISION INFERRL, INFERRG
      INTEGER OORANGEIND
      OORANGEIND = 0
      INFERRG = -RONE
      ONEERRG = -RONE
      MAXMN = N
      IF(OP == 1) THEN
         IF(NUMPROCS > 1) THEN
            CALL DAGMG_MUMPS_655(MYID, NUMPROCS, COMM,                       &
     &           IRN_loc, JCN_loc, NZ_loc,                              &
     &           PARTVEC, N,                                            &
     &           IWRK, IWRKSZ)
            CALL DAGMG_MUMPS_673(MYID, NUMPROCS, N, PARTVEC,                 &
     &           NZ_loc, IRN_loc,JCN_loc, IRSNDRCVNUM,IRSNDRCVVOL,      &
     &           ORSNDRCVNUM, ORSNDRCVVOL,                              &
     &           IWRK,IWRKSZ,                                           &
     &           RSNDRCVSZ(1), RSNDRCVSZ(1+NUMPROCS), COMM)
            CALL DAGMG_MUMPS_663(MYID, NUMPROCS, COMM,                       &
     &           IRN_loc, JCN_loc, NZ_loc,                              &
     &           PARTVEC, N,                                            &
     &           INUMMYR,                                               &
     &           IWRK, IWRKSZ)
            INTSZR =  IRSNDRCVNUM + ORSNDRCVNUM +                       &
     &           IRSNDRCVVOL + ORSNDRCVVOL +                            &
     &           2*(NUMPROCS+1) + INUMMYR
            INTSZ = INTSZR + N +                                        &
     &           (AGMG_MPF_STATUS_SIZE +1) *  NUMPROCS
         ELSE
            IRSNDRCVNUM = 0
            ORSNDRCVNUM = 0
            IRSNDRCVVOL = 0
            ORSNDRCVVOL = 0
            INUMMYR = 0
            INTSZ = 0
         ENDIF
         RESZ = N + IRSNDRCVVOL + ORSNDRCVVOL
         REGISTRE(1) = IRSNDRCVNUM
         REGISTRE(2) = ORSNDRCVNUM
         REGISTRE(3) = IRSNDRCVVOL
         REGISTRE(4) = ORSNDRCVVOL
         REGISTRE(9) = INUMMYR
         REGISTRE(11) = INTSZ
         REGISTRE(12) = RESZ
      ELSE
         IRSNDRCVNUM = REGISTRE(1)
         ORSNDRCVNUM = REGISTRE(2)
         IRSNDRCVVOL = REGISTRE(3)
         ORSNDRCVVOL = REGISTRE(4)
         INUMMYR = REGISTRE(9)
          IF(NUMPROCS > 1) THEN
             CALL DAGMG_MUMPS_661(MYID, NUMPROCS,COMM,                       &
     &            IRN_loc, JCN_loc, NZ_loc,                             &
     &            PARTVEC, N,                                           &
     &            IWRK(1), INUMMYR,                                     &
     &            IWRK(1+INUMMYR), IWRKSZ-INUMMYR)
             IMYRPTR = 1
             IMYCPTR = IMYRPTR + INUMMYR
             IRNGHBPRCS = IMYCPTR
             IRSNDRCVIA = IRNGHBPRCS+IRSNDRCVNUM
             IRSNDRCVJA = IRSNDRCVIA + NUMPROCS+1
             ORNGHBPRCS = IRSNDRCVJA + IRSNDRCVVOL
             ORSNDRCVIA = ORNGHBPRCS + ORSNDRCVNUM
             ORSNDRCVJA = ORSNDRCVIA + NUMPROCS + 1
             REQUESTS = ORSNDRCVJA + ORSNDRCVVOL
             ISTATUS = REQUESTS + NUMPROCS
             TMPWORK = ISTATUS + AGMG_MPF_STATUS_SIZE *  NUMPROCS
             CALL DAGMG_MUMPS_692(MYID, NUMPROCS, N, PARTVEC,                &
     &            NZ_loc, IRN_loc, JCN_loc,                             &
     &            IRSNDRCVNUM, IRSNDRCVVOL,                             &
     &            IWRK(IRNGHBPRCS),IWRK(IRSNDRCVIA),IWRK(IRSNDRCVJA),   &
     &            ORSNDRCVNUM, ORSNDRCVVOL,                             &
     &            IWRK(ORNGHBPRCS),IWRK(ORSNDRCVIA),IWRK(ORSNDRCVJA),   &
     &            RSNDRCVSZ(1), RSNDRCVSZ(1+NUMPROCS),                  &
     &            IWRK(TMPWORK),                                        &
     &            IWRK(ISTATUS), IWRK(REQUESTS),                        &
     &            TAG_COMM_ROW, COMM)
             CALL DAGMG_MUMPS_670(SCA, N, RZERO)
             CALL DAGMG_MUMPS_671(SCA, N,                                    &
     &            IWRK(IMYRPTR),INUMMYR, RONE)
          ELSE
             CALL DAGMG_MUMPS_670(SCA, N, RONE)
          ENDIF
          ITDRPTR = 1
          ISRRPTR = ITDRPTR + N
          OSRRPTR = ISRRPTR + IRSNDRCVVOL
          IF(NUMPROCS == 1)THEN
             OSRRPTR = OSRRPTR - 1
             ISRRPTR = ISRRPTR - 1
          ELSE
             IF(IRSNDRCVVOL == 0) ISRRPTR = ISRRPTR - 1
             IF(ORSNDRCVVOL == 0) OSRRPTR = OSRRPTR - 1
          ENDIF
          ITER = 1
          DO WHILE(ITER.LE.NB1+NB2+NB3)
             IF(NUMPROCS > 1) THEN
                CALL DAGMG_MUMPS_650(WRKRC(ITDRPTR),N,                       &
     &               IWRK(IMYRPTR),INUMMYR)
             ELSE
                CALL DAGMG_MUMPS_670(WRKRC(ITDRPTR),N, RZERO)
             ENDIF
             IF((ITER.LE.NB1).OR.(ITER > NB1+NB2)) THEN
                IF((ITER.EQ.1).OR.(OORANGEIND.EQ.1)) THEN
                   DO NZIND=1,NZ_loc
                      IR = IRN_loc(NZIND)
                      IC = JCN_loc(NZIND)
                      IF((IR.GE.1).AND.(IR.LE.N).AND.                   &
     &                     (IC.GE.1).AND.(IC.LE.N)) THEN
                         ELM = abs(A_loc(NZIND))*SCA(IR)*SCA(IC)
                         IF(WRKRC(ITDRPTR-1+IR)<ELM) THEN
                            WRKRC(ITDRPTR-1+IR)= ELM
                         ENDIF
                         IF(WRKRC(ITDRPTR-1+IC)<ELM) THEN
                            WRKRC(ITDRPTR-1+IC)= ELM
                         ENDIF
                      ELSE
                         OORANGEIND = 1
                      ENDIF
                   ENDDO
                ELSEIF(OORANGEIND.EQ.0) THEN
                   DO NZIND=1,NZ_loc
                      IR = IRN_loc(NZIND)
                      IC = JCN_loc(NZIND)
                      ELM = abs(A_loc(NZIND))*SCA(IR)*SCA(IC)
                      IF(WRKRC(ITDRPTR-1+IR)<ELM) THEN
                         WRKRC(ITDRPTR-1+IR)= ELM
                      ENDIF
                      IF(WRKRC(ITDRPTR-1+IC)<ELM) THEN
                         WRKRC(ITDRPTR-1+IC)= ELM
                      ENDIF
                   ENDDO
                ENDIF
                IF(NUMPROCS > 1) THEN
                  CALL DAGMG_MUMPS_657(MYID, NUMPROCS,                       &
     &                  WRKRC(ITDRPTR), N, TAG_ITERS+2+ITER,            &
     &                  IRSNDRCVNUM,IWRK(IRNGHBPRCS),                   &
     &                  IRSNDRCVVOL,IWRK(IRSNDRCVIA), IWRK(IRSNDRCVJA), &
     &                  WRKRC(ISRRPTR),                                 &
     &                  ORSNDRCVNUM,IWRK(ORNGHBPRCS),                   &
     &                  ORSNDRCVVOL,IWRK(ORSNDRCVIA), IWRK(ORSNDRCVJA), &
     &                  WRKRC( OSRRPTR),                                &
     &                  IWRK(ISTATUS),IWRK(REQUESTS),                   &
     &                  COMM)
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 (ITER.EQ.NB1).OR.                                &
     &                 ((ITER.EQ.NB1+NB2+NB3).AND.                      &
     &                 (NB1+NB3.GT.0))) THEN
                     INFERRL = DAGMG_MUMPS_737(SCA,                          &
     &                    WRKRC(ITDRPTR), N,                            &
     &                    IWRK(IMYRPTR),INUMMYR)
   CALL AGMG_COPY(INFERRL, INFERRG,                         1, AGMG_MPF_DOUBLE_PRECISION, IERROR)
                     IF(INFERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_665(SCA,  WRKRC(ITDRPTR), N,        &
     &                       IWRK(IMYRPTR),INUMMYR)
                        IF(ITER .LE. NB1) THEN
                           ITER = NB1+1
                           CYCLE
                        ELSE
                           EXIT
                        ENDIF
                     ENDIF
                  ENDIF
               ELSE
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 (ITER.EQ.NB1).OR.                                &
     &                 ((ITER.EQ.NB1+NB2+NB3).AND.                      &
     &                 (NB1+NB3.GT.0))) THEN
                     INFERRL = DAGMG_MUMPS_738(SCA,                          &
     &                    WRKRC(ITDRPTR), N)
                     INFERRG = INFERRL
                     IF(INFERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_666(SCA,  WRKRC(ITDRPTR), N)
                        IF(ITER .LE. NB1) THEN
                           ITER = NB1+1
                           CYCLE
                        ELSE
                           EXIT
                        ENDIF
                     ENDIF
                  ENDIF
               ENDIF
            ELSE
               IF((ITER.EQ.1).OR.(OORANGEIND.EQ.1))THEN
                  DO NZIND=1,NZ_loc
                     IR = IRN_loc(NZIND)
                     IC = JCN_loc(NZIND)
                     IF((IR.GE.1).AND.(IR.LE.N).AND.                    &
     &                    (IC.GE.1).AND.(IC.LE.N)) THEN
                        ELM = abs(A_loc(NZIND))*SCA(IR)*SCA(IC)
                        WRKRC(ITDRPTR-1+IR) = WRKRC(ITDRPTR-1+IR) + ELM
                        IF(IR.NE.IC) THEN
                           WRKRC(ITDRPTR-1+IC) =                        &
     &                          WRKRC(ITDRPTR-1+IC) + ELM
                        ENDIF
                     ELSE
                        OORANGEIND = 1
                     ENDIF
                  ENDDO
               ELSEIF(OORANGEIND.EQ.0)THEN
                  DO NZIND=1,NZ_loc
                     IR = IRN_loc(NZIND)
                     IC = JCN_loc(NZIND)
                     ELM = abs(A_loc(NZIND))*SCA(IR)*SCA(IC)
                     WRKRC(ITDRPTR-1+IR) = WRKRC(ITDRPTR-1+IR) + ELM
                     IF(IR.NE.IC) THEN
                        WRKRC(ITDRPTR-1+IC) = WRKRC(ITDRPTR-1+IC) + ELM
                     ENDIF
                  ENDDO
               ENDIF
               IF(NUMPROCS > 1) THEN
                  CALL DAGMG_MUMPS_656(MYID, NUMPROCS,                       &
     &                 WRKRC(ITDRPTR), N, TAG_ITERS+2+ITER,             &
     &                 IRSNDRCVNUM, IWRK(IRNGHBPRCS),                   &
     &                 IRSNDRCVVOL, IWRK(IRSNDRCVIA), IWRK(IRSNDRCVJA), &
     &                 WRKRC(ISRRPTR),                                  &
     &                 ORSNDRCVNUM, IWRK(ORNGHBPRCS),                   &
     &                 ORSNDRCVVOL, IWRK(ORSNDRCVIA), IWRK(ORSNDRCVJA), &
     &                 WRKRC( OSRRPTR),                                 &
     &                 IWRK(ISTATUS), IWRK(REQUESTS),                   &
     &                 COMM)
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 ((ITER.EQ.NB1+NB2).AND.                          &
     &                 (NB2.GT.0))) THEN
                     ONEERRL = DAGMG_MUMPS_737(SCA,                          &
     &                    WRKRC(ITDRPTR), N,                            &
     &                    IWRK(IMYRPTR),INUMMYR)
   CALL AGMG_COPY(ONEERRL, ONEERRG,                         1, AGMG_MPF_DOUBLE_PRECISION, IERROR)
                     IF(ONEERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_665(SCA,  WRKRC(ITDRPTR), N,        &
     &                       IWRK(IMYRPTR),INUMMYR)
                        ITER = NB1+NB2+1
                        CYCLE
                     ENDIF
                  ENDIF
               ELSE
                  IF((EPS .GT. RZERO) .OR.                              &
     &                 ((ITER.EQ.NB1+NB2).AND.                          &
     &                 (NB2.GT.0))) THEN
                     ONEERRL = DAGMG_MUMPS_738(SCA,                          &
     &                    WRKRC(ITDRPTR), N)
                     ONEERRG = ONEERRL
                     IF(ONEERRG.LE.EPS) THEN
                        CALL DAGMG_MUMPS_666(SCA,  WRKRC(ITDRPTR), N)
                        ITER = NB1+NB2+1
                        CYCLE
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF
            IF(NUMPROCS > 1) THEN
               CALL DAGMG_MUMPS_665(SCA,  WRKRC(ITDRPTR), N,                 &
     &              IWRK(IMYRPTR),INUMMYR)
            ELSE
               CALL DAGMG_MUMPS_666(SCA,  WRKRC(ITDRPTR), N)
            ENDIF
            ITER = ITER + 1
         ENDDO
         ONENORMERR = ONEERRG
         INFNORMERR = INFERRG
         IF(NUMPROCS > 1) THEN
            CALL AGMG_COPY(SCA, WRKRC, N, AGMG_MPF_DOUBLE_PRECISION, IERROR)
            IF(MYID.EQ.0) THEN
               DO I=1, N
                  SCA(I) = WRKRC(I)
               ENDDO
            ENDIF
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_687
      SUBROUTINE DAGMG_MUMPS_654(MYID, NUMPROCS, COMM,                       &
     & IRN_loc, JCN_loc, NZ_loc,                                        &
     & IPARTVEC, ISZ, OSZ,                                              &
     & IWRK, IWSZ)
      IMPLICIT NONE
      EXTERNAL DAGMG_MUMPS_703
      INTEGER MYID, NUMPROCS, COMM
      INTEGER NZ_loc, ISZ, IWSZ, OSZ
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER IWRK(IWSZ)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I
      INTEGER OP, IERROR
      INTEGER IDIST, IR, IC
      IF(NUMPROCS.NE.1) THEN
         CALL AGMG_SETIERR( OP)
         CALL DAGMG_MUMPS_668(IWRK, 4*ISZ, ISZ)
         DO I=1,ISZ
            IWRK(2*I-1) = 0
            IWRK(2*I) = MYID
         ENDDO
         DO I=1,NZ_loc
            IR = IRN_loc(I)
            IC = JCN_loc(I)
            IF((IR.GE.1).AND.(IR.LE.ISZ).AND.                           &
     &           (IC.GE.1).AND.(IC.LE.OSZ)) THEN
               IWRK(2*IR-1) = IWRK(2*IR-1) + 1
            ENDIF
         ENDDO
         CALL AGMG_COPY(IWRK(1), IWRK(1+2*ISZ), ISZ,                                AGMG_MPF_2INTEGER, IERROR)
         DO I=1,ISZ
            IPARTVEC(I) = IWRK(2*i+2*ISZ)
         ENDDO
         CALL AGMG_SETIERR( IERROR)
      ELSE
         DO I=1,ISZ
            IPARTVEC(I) = 0
         ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_654
      SUBROUTINE DAGMG_MUMPS_662(MYID, NUMPROCS, COMM,                       &
     &     IRN_loc, JCN_loc, NZ_loc,                                    &
     &     ROWPARTVEC, COLPARTVEC, M, N,                                &
     &     INUMMYR,                                                     &
     &     INUMMYC,                                                     &
     &     IWRK, IWSZ)
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, M, N
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER ROWPARTVEC(M)
      INTEGER COLPARTVEC(N)
      INTEGER INUMMYR, INUMMYC
      INTEGER IWSZ
      INTEGER IWRK(IWSZ)
      INTEGER COMM
      INTEGER I, IR, IC
      INUMMYR = 0
      INUMMYC = 0
      DO I=1,M
         IWRK(I) = 0
         IF(ROWPARTVEC(I).EQ.MYID) THEN
            IWRK(I)=1
            INUMMYR = INUMMYR + 1
         ENDIF
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N)) ) THEN
            IF(IWRK(IR) .EQ. 0) THEN
               IWRK(IR)= 1
               INUMMYR = INUMMYR + 1
            ENDIF
         ENDIF
      ENDDO
      DO I=1,N
         IWRK(I) = 0
         IF(COLPARTVEC(I).EQ.MYID) THEN
            IWRK(I)= 1
            INUMMYC = INUMMYC + 1
         ENDIF
      ENDDO
      DO I=1,NZ_loc
         IC = JCN_loc(I)
         IR = IRN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N)) ) THEN
            IF(IWRK(IC) .EQ. 0) THEN
               IWRK(IC)= 1
               INUMMYC = INUMMYC + 1
            ENDIF
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_662
      SUBROUTINE DAGMG_MUMPS_660(MYID, NUMPROCS,COMM,                        &
     &     IRN_loc, JCN_loc, NZ_loc,                                    &
     &     ROWPARTVEC, COLPARTVEC, M, N,                                &
     &     MYROWINDICES, INUMMYR,                                       &
     &     MYCOLINDICES, INUMMYC,                                       &
     &     IWRK, IWSZ  )
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, M, N
      INTEGER INUMMYR, INUMMYC, IWSZ
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER ROWPARTVEC(M)
      INTEGER COLPARTVEC(N)
      INTEGER MYROWINDICES(INUMMYR)
      INTEGER MYCOLINDICES(INUMMYC)
      INTEGER IWRK(IWSZ)
      INTEGER COMM
      INTEGER I, IR, IC, ITMP, MAXMN
      MAXMN = M
      IF(N > MAXMN) MAXMN = N
      DO I=1,M
         IWRK(I) = 0
         IF(ROWPARTVEC(I).EQ.MYID) IWRK(I)=1
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &      ((IC.GE.1).AND.(IC.LE.N))  ) THEN
            IF(IWRK(IR) .EQ. 0) IWRK(IR)= 1
         ENDIF
      ENDDO
      ITMP = 1
      DO I=1,M
         IF(IWRK(I).EQ.1) THEN
            MYROWINDICES(ITMP) = I
            ITMP  = ITMP + 1
         ENDIF
      ENDDO
      DO I=1,N
         IWRK(I) = 0
         IF(COLPARTVEC(I).EQ.MYID) IWRK(I)= 1
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &      ((IC.GE.1).AND.(IC.LE.N))  ) THEN
            IF(IWRK(IC) .EQ. 0) IWRK(IC)= 1
         ENDIF
      ENDDO
      ITMP = 1
      DO I=1,N
         IF(IWRK(I).EQ.1) THEN
            MYCOLINDICES(ITMP) = I
            ITMP  = ITMP + 1
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_660
      INTEGER FUNCTION DAGMG_MUMPS_744(D, DSZ, INDX, INDXSZ, EPS)
      IMPLICIT NONE
      INTEGER DSZ, INDXSZ
      DOUBLE PRECISION D(DSZ)
      INTEGER INDX(INDXSZ)
      DOUBLE PRECISION EPS
      INTEGER I, IID
      DOUBLE PRECISION RONE
      PARAMETER(RONE=1.0D0)
      DAGMG_MUMPS_744 = 1
      DO I=1, INDXSZ
         IID = INDX(I)
         IF (.NOT.( (D(IID).LE.(RONE+EPS)).AND.                         &
     &        ((RONE-EPS).LE.D(IID)) )) THEN
            DAGMG_MUMPS_744 = 0
         ENDIF
      ENDDO
      RETURN
      END FUNCTION DAGMG_MUMPS_744
      INTEGER FUNCTION DAGMG_MUMPS_745(D, DSZ, EPS)
      IMPLICIT NONE
      INTEGER DSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION EPS
      INTEGER I
      DOUBLE PRECISION RONE
      PARAMETER(RONE=1.0D0)
      DAGMG_MUMPS_745 = 1
      DO I=1, DSZ
         IF (.NOT.( (D(I).LE.(RONE+EPS)).AND.                           &
     &        ((RONE-EPS).LE.D(I)) )) THEN
            DAGMG_MUMPS_745 = 0
         ENDIF
      ENDDO
      RETURN
      END FUNCTION DAGMG_MUMPS_745
      INTEGER FUNCTION DAGMG_MUMPS_743(DR, M, INDXR, INDXRSZ,                &
     &     DC, N, INDXC, INDXCSZ, EPS, COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER M, N, INDXRSZ, INDXCSZ
      DOUBLE PRECISION DR(M), DC(N)
      INTEGER INDXR(INDXRSZ), INDXC(INDXCSZ)
      DOUBLE PRECISION EPS
      INTEGER COMM
      EXTERNAL DAGMG_MUMPS_744
      INTEGER  DAGMG_MUMPS_744
      INTEGER GLORES, MYRESR, MYRESC, MYRES
      INTEGER IERR
      MYRESR =  DAGMG_MUMPS_744(DR, M, INDXR, INDXRSZ, EPS)
      MYRESC =  DAGMG_MUMPS_744(DC, N, INDXC, INDXCSZ, EPS)
      MYRES = MYRESR + MYRESC
      CALL AGMG_COPY(MYRES, GLORES, 1, AGMG_MPF_INTEGER, IERR)
      DAGMG_MUMPS_743 = GLORES
      RETURN
      END FUNCTION DAGMG_MUMPS_743
      DOUBLE PRECISION FUNCTION DAGMG_MUMPS_737(D, TMPD, DSZ,                &
     &     INDX, INDXSZ)
      IMPLICIT NONE
      INTEGER DSZ, INDXSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION TMPD(DSZ)
      INTEGER INDX(INDXSZ)
      DOUBLE PRECISION RONE
      PARAMETER(RONE=1.0D0)
      INTEGER I, IIND
      DOUBLE PRECISION ERRMAX
      INTRINSIC abs
      ERRMAX = -RONE
      DO I=1,INDXSZ
         IIND = INDX(I)
         IF(abs(RONE-TMPD(IIND)).GT.ERRMAX) THEN
            ERRMAX = abs(RONE-TMPD(IIND))
         ENDIF
      ENDDO
      DAGMG_MUMPS_737 = ERRMAX
      RETURN
      END FUNCTION DAGMG_MUMPS_737
      DOUBLE PRECISION FUNCTION DAGMG_MUMPS_738(D, TMPD, DSZ)
      IMPLICIT NONE
      INTEGER DSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION TMPD(DSZ)
      DOUBLE PRECISION RONE
      PARAMETER(RONE=1.0D0)
      INTEGER I, IIND
      DOUBLE PRECISION ERRMAX1
      INTRINSIC abs
      ERRMAX1 = -RONE
      DO I=1,DSZ
         IF(abs(RONE-TMPD(I)).GT.ERRMAX1) THEN
            ERRMAX1 = abs(RONE-TMPD(I))
         ENDIF
      ENDDO
      DAGMG_MUMPS_738 = ERRMAX1
      RETURN
      END FUNCTION DAGMG_MUMPS_738
      SUBROUTINE DAGMG_MUMPS_665(D,  TMPD, DSZ,                              &
     &        INDX, INDXSZ)
      IMPLICIT NONE
      INTEGER DSZ, INDXSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION TMPD(DSZ)
      INTEGER INDX(INDXSZ)
      INTRINSIC sqrt
      INTEGER I, IIND
      DO I=1,INDXSZ
         IIND = INDX(I)
         D(IIND) = D(IIND)/sqrt(TMPD(IIND))
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_665
      SUBROUTINE DAGMG_MUMPS_666(D,  TMPD, DSZ)
      IMPLICIT NONE
      INTEGER DSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION TMPD(DSZ)
      INTRINSIC sqrt
      INTEGER I
      DO I=1,DSZ
         D(I) = D(I)/sqrt(TMPD(I))
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_666
      SUBROUTINE DAGMG_MUMPS_671(D, DSZ, INDX, INDXSZ, VAL)
      IMPLICIT NONE
      INTEGER DSZ, INDXSZ
      DOUBLE PRECISION D(DSZ)
      INTEGER INDX(INDXSZ)
      DOUBLE PRECISION VAL
      INTEGER I, IIND
      DO I=1,INDXSZ
         IIND = INDX(I)
         D(IIND) = VAL
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_671
      SUBROUTINE DAGMG_MUMPS_702(D, DSZ, INDX, INDXSZ)
      IMPLICIT NONE
      INTEGER DSZ, INDXSZ
      DOUBLE PRECISION D(DSZ)
      INTEGER INDX(INDXSZ)
      INTEGER I, IIND
      DO I=1,INDXSZ
         IIND  = INDX(I)
         D(IIND) = 1.0D0/D(IIND)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_702
      SUBROUTINE DAGMG_MUMPS_670(D, DSZ, VAL)
      IMPLICIT NONE
      INTEGER DSZ
      DOUBLE PRECISION D(DSZ)
      DOUBLE PRECISION VAL
      INTEGER I
      DO I=1,DSZ
         D(I) = VAL
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_670
      SUBROUTINE DAGMG_MUMPS_650(TMPD, TMPSZ, INDX, INDXSZ)
      IMPLICIT NONE
      INTEGER TMPSZ,INDXSZ
      DOUBLE PRECISION TMPD(TMPSZ)
      INTEGER INDX(INDXSZ)
      INTEGER I
      DOUBLE PRECISION DZERO
      PARAMETER(DZERO=0.0D0)
      DO I=1,INDXSZ
         TMPD(INDX(I)) = DZERO
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_650
      SUBROUTINE DAGMG_MUMPS_703(INV, INOUTV, LEN, DTYPE)
      IMPLICIT NONE
      INTEGER LEN
      INTEGER INV(2*LEN)
      INTEGER INOUTV(2*LEN)
      INTEGER DTYPE
      INTEGER I
      INTEGER DIN, DINOUT, PIN, PINOUT
      DO I=1,2*LEN-1,2
         DIN = INV(I)
         PIN = INV(I+1)
         DINOUT = INOUTV(I)
         PINOUT = INOUTV(I+1)
         IF (DINOUT < DIN) THEN
            INOUTV(I) = DIN
            INOUTV(I+1) = PIN
         ELSE IF (DINOUT == DIN) THEN
            IF ((MOD(DINOUT,2).EQ.0).AND.(PIN<PINOUT)) THEN
              INOUTV(I+1) = PIN
            ELSE IF ((MOD(DINOUT,2).EQ.1).AND.(PIN>PINOUT)) THEN
              INOUTV(I+1) = PIN
            ENDIF
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_703
      SUBROUTINE DAGMG_MUMPS_668(IW, IWSZ, IVAL)
      IMPLICIT NONE
      INTEGER IWSZ
      INTEGER IW(IWSZ)
      INTEGER IVAL
      INTEGER I
      DO I=1,IWSZ
         IW(I)=IVAL
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_668
      SUBROUTINE DAGMG_MUMPS_704(MYID, NUMPROCS,                             &
     & IRN_loc, JCN_loc, NZ_loc,                                        &
     & ROWPARTVEC, COLPARTVEC, M, N,                                    &
     & MYROWINDICES, INUMMYR,                                           &
     & MYCOLINDICES, INUMMYC,                                           &
     & IWRKROW, IWRKCOL, IWSZR, IWSZC, COMM    )
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, M, N
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER ROWPARTVEC(M)
      INTEGER COLPARTVEC(N)
      INTEGER MYROWINDICES(M)
      INTEGER MYCOLINDICES(N)
      INTEGER INUMMYR, INUMMYC
      INTEGER IWSZR, IWSZC
      INTEGER IWRKROW(IWSZR)
      INTEGER IWRKCOL(IWSZC)
      INTEGER COMM
      INTEGER I, IR, IC, ITMP
      INUMMYR = 0
      INUMMYC = 0
      DO I=1,M
         IWRKROW(I) = 0
         IF(ROWPARTVEC(I).EQ.MYID) THEN
            IWRKROW(I)=1
            INUMMYR = INUMMYR + 1
         ENDIF
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRKROW(IR) .EQ. 0) THEN
               IWRKROW(IR)= 1
               INUMMYR = INUMMYR + 1
            ENDIF
         ENDIF
      ENDDO
      ITMP = 1
      DO I=1,M
         IF(IWRKROW(I).EQ.1) THEN
            MYROWINDICES(ITMP) = I
            ITMP  = ITMP + 1
         ENDIF
      ENDDO
      DO I=1,N
         IWRKCOL(I) = 0
         IF(COLPARTVEC(I).EQ.MYID) THEN
            IWRKCOL(I)= 1
            INUMMYC = INUMMYC + 1
         ENDIF
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.M).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRKCOL(IC) .EQ. 0) THEN
               IWRKCOL(IC)= 1
               INUMMYC = INUMMYC + 1
            ENDIF
         ENDIF
      ENDDO
      ITMP = 1
      DO I=1,N
         IF(IWRKCOL(I).EQ.1) THEN
            MYCOLINDICES(ITMP) = I
            ITMP  = ITMP + 1
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_704
      SUBROUTINE DAGMG_MUMPS_672(MYID, NUMPROCS, ISZ, IPARTVEC,              &
     &     NZ_loc, INDX, OSZ, OINDX,ISNDRCVNUM,ISNDRCVVOL,              &
     &     OSNDRCVNUM,OSNDRCVVOL,                                       &
     &     IWRK,IWRKSZ, SNDSZ, RCVSZ, COMM)
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, ISZ, IWRKSZ, OSZ
      INTEGER ISNDRCVNUM, ISNDRCVVOL
      INTEGER OSNDRCVNUM, OSNDRCVVOL
      INTEGER COMM
      INTEGER INDX(NZ_loc)
      INTEGER OINDX(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER IWRK(IWRKSZ)
      INTEGER SNDSZ(NUMPROCS)
      INTEGER RCVSZ(NUMPROCS)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I
      INTEGER IIND, IIND2, PIND
      INTEGER IERROR
      DO I=1,NUMPROCS
         SNDSZ(I) = 0
         RCVSZ(I) = 0
      ENDDO
      DO I=1,IWRKSZ
         IWRK(I) = 0
      ENDDO
      DO I=1,NZ_loc
         IIND = INDX(I)
         IIND2 = OINDX(I)
         IF((IIND.GE.1).AND.(IIND.LE.ISZ).AND.                          &
     &        (IIND2.GE.1).AND.(IIND2.LE.OSZ))THEN
            PIND = IPARTVEC(IIND)
            IF(PIND .NE. MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWRK(IIND) = 1
                  SNDSZ(PIND+1) = SNDSZ(PIND+1)+1
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      CALL AGMG_MPF_ALLTOALL(SNDSZ, 1, AGMG_MPF_INTEGER,                          &
     & RCVSZ, 1, AGMG_MPF_INTEGER, COMM, IERROR)
      ISNDRCVNUM = 0
      ISNDRCVVOL = 0
      OSNDRCVNUM = 0
      OSNDRCVVOL = 0
      DO I=1, NUMPROCS
         IF(SNDSZ(I) > 0) OSNDRCVNUM = OSNDRCVNUM + 1
         OSNDRCVVOL = OSNDRCVVOL + SNDSZ(I)
         IF(RCVSZ(I) > 0) ISNDRCVNUM = ISNDRCVNUM + 1
         ISNDRCVVOL = ISNDRCVVOL + RCVSZ(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_672
      SUBROUTINE DAGMG_MUMPS_674(MYID, NUMPROCS, ISZ, IPARTVEC,              &
     &     NZ_loc, INDX, OSZ, OINDX,                                    &
     &     ISNDRCVNUM, ISNDVOL, INGHBPRCS, ISNDRCVIA, ISNDRCVJA,        &
     &     OSNDRCVNUM, OSNDVOL, ONGHBPRCS, OSNDRCVIA, OSNDRCVJA,        &
     &     SNDSZ, RCVSZ, IWRK,                                          &
     &     ISTATUS, REQUESTS,                                           &
     &     ITAGCOMM, COMM )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MYID, NUMPROCS, NZ_loc, ISZ, ISNDVOL, OSNDVOL, OSZ
      INTEGER INDX(NZ_loc)
      INTEGER OINDX(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER ISNDRCVNUM, INGHBPRCS(ISNDRCVNUM)
      INTEGER ISNDRCVIA(NUMPROCS+1)
      INTEGER ISNDRCVJA(ISNDVOL)
      INTEGER OSNDRCVNUM, ONGHBPRCS(OSNDRCVNUM)
      INTEGER OSNDRCVIA(NUMPROCS+1)
      INTEGER OSNDRCVJA(OSNDVOL)
      INTEGER SNDSZ(NUMPROCS)
      INTEGER RCVSZ(NUMPROCS)
      INTEGER IWRK(ISZ)
      INTEGER ISTATUS(AGMG_MPF_STATUS_SIZE, ISNDRCVNUM)
      INTEGER REQUESTS(ISNDRCVNUM)
      INTEGER ITAGCOMM, COMM
      INTEGER I, IIND, IIND2, IPID, OFFS
      INTEGER IWHERETO, POFFS, ITMP, IERROR
      DO I=1,ISZ
         IWRK(I) = 0
      ENDDO
      OFFS = 1
      POFFS = 1
      DO I=1,NUMPROCS
         OSNDRCVIA(I) = OFFS + SNDSZ(I)
         IF(SNDSZ(I) > 0) THEN
            ONGHBPRCS(POFFS)=I
            POFFS = POFFS + 1
         ENDIF
         OFFS  = OFFS +  SNDSZ(I)
      ENDDO
      OSNDRCVIA(NUMPROCS+1) = OFFS
      DO I=1,NZ_loc
         IIND=INDX(I)
         IIND2 = OINDX(I)
         IF((IIND.GE.1).AND.(IIND.LE.ISZ).AND.                          &
     &        (IIND2.GE.1).AND.(IIND2.LE.OSZ) ) THEN
            IPID=IPARTVEC(IIND)
            IF(IPID.NE.MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWHERETO = OSNDRCVIA(IPID+1)-1
                  OSNDRCVIA(IPID+1) = OSNDRCVIA(IPID+1)-1
                  OSNDRCVJA(IWHERETO) = IIND
                  IWRK(IIND) = 1
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      CALL AGMG_SETIERR(IERROR)
      OFFS = 1
      POFFS = 1
      ISNDRCVIA(1) = 1
      DO I=2,NUMPROCS+1
         ISNDRCVIA(I) = OFFS + RCVSZ(I-1)
         IF(RCVSZ(I-1) > 0) THEN
            INGHBPRCS(POFFS)=I-1
            POFFS = POFFS + 1
         ENDIF
         OFFS  = OFFS +  RCVSZ(I-1)
      ENDDO
      CALL AGMG_SETIERR(IERROR)
      DO I=1, ISNDRCVNUM
         IPID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(IPID)
         ITMP = ISNDRCVIA(IPID+1) - ISNDRCVIA(IPID)
         CALL AGMG_SETIERR(IERROR)
      ENDDO
      DO I=1,OSNDRCVNUM
         IPID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(IPID)
         ITMP = OSNDRCVIA(IPID+1)-OSNDRCVIA(IPID)
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(ISNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      CALL AGMG_SETIERR(IERROR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_674
      SUBROUTINE DAGMG_MUMPS_657(MYID, NUMPROCS,TMPD, IDSZ, ITAGCOMM,        &
     &     ISNDRCVNUM, INGHBPRCS,                                       &
     &     ISNDRCVVOL, ISNDRCVIA, ISNDRCVJA, ISNDRCVA,                  &
     &     OSNDRCVNUM, ONGHBPRCS,                                       &
     &     OSNDRCVVOL, OSNDRCVIA, OSNDRCVJA, OSNDRCVA,                  &
     &     ISTATUS, REQUESTS,                                           &
     &     COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MYID, NUMPROCS, IDSZ, ITAGCOMM
      INTEGER ISNDRCVNUM,OSNDRCVNUM, ISNDRCVVOL, OSNDRCVVOL
      DOUBLE PRECISION TMPD(IDSZ)
      INTEGER INGHBPRCS(ISNDRCVNUM), ONGHBPRCS(OSNDRCVNUM)
      INTEGER ISNDRCVIA(NUMPROCS+1), ISNDRCVJA(ISNDRCVVOL)
      DOUBLE PRECISION ISNDRCVA(ISNDRCVVOL)
      INTEGER OSNDRCVIA(NUMPROCS+1), OSNDRCVJA(OSNDRCVVOL)
      DOUBLE PRECISION OSNDRCVA(OSNDRCVVOL)
      INTEGER ISTATUS(AGMG_MPF_STATUS_SIZE, max(ISNDRCVNUM,OSNDRCVNUM))
      INTEGER REQUESTS(max(ISNDRCVNUM,OSNDRCVNUM))
      INTEGER COMM, IERROR
      INTEGER I, PID, OFFS, SZ, J, JS, JE, IID
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(PID)
         SZ = ISNDRCVIA(PID+1) -  ISNDRCVIA(PID)
         CALL AGMG_SETIERR( IERROR)
      ENDDO
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(PID)
         SZ = OSNDRCVIA(PID+1) - OSNDRCVIA(PID)
         JS = OSNDRCVIA(PID)
         JE =  OSNDRCVIA(PID+1) - 1
         DO J=JS, JE
            IID = OSNDRCVJA(J)
            OSNDRCVA(j) = TMPD(IID)
         ENDDO
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(ISNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         JS = ISNDRCVIA(PID)
         JE = ISNDRCVIA(PID+1)-1
         DO J=JS,JE
            IID = ISNDRCVJA(J)
            IF(TMPD(IID) < ISNDRCVA(J)) TMPD(IID)= ISNDRCVA(J)
         ENDDO
      ENDDO
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(PID)
         SZ = OSNDRCVIA(PID+1) -  OSNDRCVIA(PID)
         CALL AGMG_SETIERR( IERROR)
      ENDDO
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(PID)
         SZ = ISNDRCVIA(PID+1)-ISNDRCVIA(PID)
         JS = ISNDRCVIA(PID)
         JE = ISNDRCVIA(PID+1) -1
         DO J=JS, JE
            IID = ISNDRCVJA(J)
            ISNDRCVA(J) = TMPD(IID)
         ENDDO
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(OSNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         JS = OSNDRCVIA(PID)
         JE = OSNDRCVIA(PID+1) - 1
         DO J=JS,JE
            IID = OSNDRCVJA(J)
            TMPD(IID)=OSNDRCVA(J)
         ENDDO
      ENDDO
      RETURN
      END  SUBROUTINE DAGMG_MUMPS_657
      SUBROUTINE DAGMG_MUMPS_656(MYID, NUMPROCS,TMPD, IDSZ, ITAGCOMM,        &
     &     ISNDRCVNUM, INGHBPRCS,                                       &
     &     ISNDRCVVOL, ISNDRCVIA, ISNDRCVJA, ISNDRCVA,                  &
     &     OSNDRCVNUM, ONGHBPRCS,                                       &
     &     OSNDRCVVOL, OSNDRCVIA, OSNDRCVJA, OSNDRCVA,                  &
     &     ISTATUS, REQUESTS,                                           &
     &     COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MYID, NUMPROCS, IDSZ, ITAGCOMM
      INTEGER ISNDRCVNUM,OSNDRCVNUM, ISNDRCVVOL, OSNDRCVVOL
      DOUBLE PRECISION TMPD(IDSZ)
      INTEGER INGHBPRCS(ISNDRCVNUM), ONGHBPRCS(OSNDRCVNUM)
      INTEGER ISNDRCVIA(NUMPROCS+1), ISNDRCVJA(ISNDRCVVOL)
      DOUBLE PRECISION ISNDRCVA(ISNDRCVVOL)
      INTEGER OSNDRCVIA(NUMPROCS+1), OSNDRCVJA(OSNDRCVVOL)
      DOUBLE PRECISION OSNDRCVA(OSNDRCVVOL)
      INTEGER ISTATUS(AGMG_MPF_STATUS_SIZE, max(ISNDRCVNUM,OSNDRCVNUM))
      INTEGER REQUESTS(max(ISNDRCVNUM,OSNDRCVNUM))
      INTEGER COMM, IERROR
      INTEGER I, PID, OFFS, SZ, J, JS, JE, IID
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(PID)
         SZ = ISNDRCVIA(PID+1) -  ISNDRCVIA(PID)
         CALL AGMG_SETIERR( IERROR)
      ENDDO
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(PID)
         SZ = OSNDRCVIA(PID+1) - OSNDRCVIA(PID)
         JS = OSNDRCVIA(PID)
         JE =  OSNDRCVIA(PID+1) - 1
         DO J=JS, JE
            IID = OSNDRCVJA(J)
            OSNDRCVA(j) = TMPD(IID)
         ENDDO
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(ISNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         JS = ISNDRCVIA(PID)
         JE = ISNDRCVIA(PID+1)-1
         DO J=JS,JE
            IID = ISNDRCVJA(J)
            TMPD(IID)  = TMPD(IID)+ ISNDRCVA(J)
         ENDDO
      ENDDO
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(PID)
         SZ = OSNDRCVIA(PID+1) -  OSNDRCVIA(PID)
         CALL AGMG_SETIERR( IERROR)
      ENDDO
      DO I=1,ISNDRCVNUM
         PID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(PID)
         SZ = ISNDRCVIA(PID+1)-ISNDRCVIA(PID)
         JS = ISNDRCVIA(PID)
         JE = ISNDRCVIA(PID+1) -1
         DO J=JS, JE
            IID = ISNDRCVJA(J)
            ISNDRCVA(J) = TMPD(IID)
         ENDDO
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(OSNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      DO I=1,OSNDRCVNUM
         PID = ONGHBPRCS(I)
         JS = OSNDRCVIA(PID)
         JE = OSNDRCVIA(PID+1) - 1
         DO J=JS,JE
            IID = OSNDRCVJA(J)
            TMPD(IID)=OSNDRCVA(J)
         ENDDO
      ENDDO
      RETURN
      END  SUBROUTINE DAGMG_MUMPS_656
      SUBROUTINE DAGMG_MUMPS_655(MYID, NUMPROCS, COMM,                       &
     & IRN_loc, JCN_loc, NZ_loc,                                        &
     & IPARTVEC, ISZ,                                                   &
     & IWRK, IWSZ)
      IMPLICIT NONE
      EXTERNAL DAGMG_MUMPS_703
      INTEGER MYID, NUMPROCS, COMM
      INTEGER NZ_loc, ISZ, IWSZ
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER IWRK(IWSZ)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I
      INTEGER OP, IERROR
      INTEGER IDIST, IR, IC
      IF(NUMPROCS.NE.1) THEN
         CALL AGMG_SETIERR( OP)
         CALL DAGMG_MUMPS_668(IWRK, 4*ISZ, ISZ)
         DO I=1,ISZ
            IWRK(2*I-1) = 0
            IWRK(2*I) = MYID
         ENDDO
         DO I=1,NZ_loc
            IR = IRN_loc(I)
            IC = JCN_loc(I)
            IF((IR.GE.1).AND.(IR.LE.ISZ).AND.                           &
     &           (IC.GE.1).AND.(IC.LE.ISZ)) THEN
               IWRK(2*IR-1) = IWRK(2*IR-1) + 1
               IWRK(2*IC-1) = IWRK(2*IC-1) + 1
            ENDIF
         ENDDO
         CALL AGMG_COPY(IWRK(1), IWRK(1+2*ISZ), ISZ,                                AGMG_MPF_2INTEGER, IERROR)
         DO I=1,ISZ
            IPARTVEC(I) = IWRK(2*i+2*ISZ)
         ENDDO
         CALL AGMG_SETIERR( IERROR)
      ELSE
         DO I=1,ISZ
            IPARTVEC(I) = 0
         ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_655
      SUBROUTINE DAGMG_MUMPS_673(MYID, NUMPROCS, ISZ, IPARTVEC,              &
     & NZ_loc, INDX,OINDX,ISNDRCVNUM,ISNDRCVVOL,OSNDRCVNUM,OSNDRCVVOL,  &
     & IWRK,IWRKSZ, SNDSZ, RCVSZ, COMM)
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, ISZ, IWRKSZ
      INTEGER ISNDRCVNUM, ISNDRCVVOL
      INTEGER OSNDRCVNUM, OSNDRCVVOL
      INTEGER COMM
      INTEGER INDX(NZ_loc), OINDX(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER IWRK(IWRKSZ)
      INTEGER SNDSZ(NUMPROCS)
      INTEGER RCVSZ(NUMPROCS)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I
      INTEGER IIND, IIND2, PIND
      INTEGER IERROR
      DO I=1,NUMPROCS
         SNDSZ(I) = 0
         RCVSZ(I) = 0
      ENDDO
      DO I=1,IWRKSZ
         IWRK(I) = 0
      ENDDO
      DO I=1,NZ_loc
         IIND = INDX(I)
         IIND2 = OINDX(I)
         IF((IIND.GE.1).AND.(IIND.LE.ISZ).AND.(IIND2.GE.1)              &
     &        .AND.(IIND2.LE.ISZ)) THEN
            PIND = IPARTVEC(IIND)
            IF(PIND .NE. MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWRK(IIND) = 1
                  SNDSZ(PIND+1) = SNDSZ(PIND+1)+1
               ENDIF
            ENDIF
            IIND = OINDX(I)
            PIND = IPARTVEC(IIND)
            IF(PIND .NE. MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWRK(IIND) = 1
                  SNDSZ(PIND+1) = SNDSZ(PIND+1)+1
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      CALL AGMG_MPF_ALLTOALL(SNDSZ, 1, AGMG_MPF_INTEGER,                          &
     &     RCVSZ, 1, AGMG_MPF_INTEGER, COMM, IERROR)
      ISNDRCVNUM = 0
      ISNDRCVVOL = 0
      OSNDRCVNUM = 0
      OSNDRCVVOL = 0
      DO I=1, NUMPROCS
         IF(SNDSZ(I) > 0) OSNDRCVNUM = OSNDRCVNUM + 1
         OSNDRCVVOL = OSNDRCVVOL + SNDSZ(I)
         IF(RCVSZ(I) > 0) ISNDRCVNUM = ISNDRCVNUM + 1
         ISNDRCVVOL = ISNDRCVVOL + RCVSZ(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_673
      SUBROUTINE DAGMG_MUMPS_663(MYID, NUMPROCS, COMM,                       &
     &     IRN_loc, JCN_loc, NZ_loc,                                    &
     &     PARTVEC, N,                                                  &
     &     INUMMYR,                                                     &
     &     IWRK, IWSZ)
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, N
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER PARTVEC(N)
      INTEGER INUMMYR
      INTEGER IWSZ
      INTEGER IWRK(IWSZ)
      INTEGER COMM
      INTEGER I, IR, IC
      INUMMYR = 0
      DO I=1,N
         IWRK(I) = 0
         IF(PARTVEC(I).EQ.MYID) THEN
            IWRK(I)=1
            INUMMYR = INUMMYR + 1
         ENDIF
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.N).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRK(IR) .EQ. 0) THEN
               IWRK(IR)= 1
               INUMMYR = INUMMYR + 1
            ENDIF
         ENDIF
         IF((IR.GE.1).AND.(IR.LE.N).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRK(IC).EQ.0) THEN
               IWRK(IC)= 1
               INUMMYR = INUMMYR + 1
            ENDIF
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_663
      INTEGER FUNCTION DAGMG_MUMPS_742(D, N, INDXR, INDXRSZ,                 &
     &     EPS, COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER N, INDXRSZ
      DOUBLE PRECISION D(N)
      INTEGER INDXR(INDXRSZ)
      DOUBLE PRECISION EPS
      INTEGER COMM
      EXTERNAL DAGMG_MUMPS_744
      INTEGER  DAGMG_MUMPS_744
      INTEGER GLORES, MYRESR, MYRESC, MYRES
      INTEGER IERR
      MYRESR =  DAGMG_MUMPS_744(D, N, INDXR, INDXRSZ, EPS)
      MYRES = 2*MYRESR
      CALL AGMG_COPY(MYRES, GLORES, 1, AGMG_MPF_INTEGER, IERR)
      DAGMG_MUMPS_742 = GLORES
      RETURN
      END FUNCTION DAGMG_MUMPS_742
      SUBROUTINE DAGMG_MUMPS_661(MYID, NUMPROCS,COMM,                        &
     &     IRN_loc, JCN_loc, NZ_loc,                                    &
     &     PARTVEC, N,                                                  &
     &     MYROWINDICES, INUMMYR,                                       &
     &     IWRK, IWSZ  )
      IMPLICIT NONE
      INTEGER MYID, NUMPROCS, NZ_loc, N
      INTEGER INUMMYR, IWSZ
      INTEGER IRN_loc(NZ_loc), JCN_loc(NZ_loc)
      INTEGER PARTVEC(N)
      INTEGER MYROWINDICES(INUMMYR)
      INTEGER IWRK(IWSZ)
      INTEGER COMM
      INTEGER I, IR, IC, ITMP, MAXMN
      MAXMN = N
      DO I=1,N
         IWRK(I) = 0
         IF(PARTVEC(I).EQ.MYID) IWRK(I)=1
      ENDDO
      DO I=1,NZ_loc
         IR = IRN_loc(I)
         IC = JCN_loc(I)
         IF((IR.GE.1).AND.(IR.LE.N).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRK(IR) .EQ. 0) IWRK(IR)= 1
         ENDIF
         IF((IR.GE.1).AND.(IR.LE.N).AND.                                &
     &        ((IC.GE.1).AND.(IC.LE.N))) THEN
            IF(IWRK(IC) .EQ.0) IWRK(IC)=1
         ENDIF
      ENDDO
      ITMP = 1
      DO I=1,N
         IF(IWRK(I).EQ.1) THEN
            MYROWINDICES(ITMP) = I
            ITMP  = ITMP + 1
         ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_661
      SUBROUTINE DAGMG_MUMPS_692(MYID, NUMPROCS, ISZ, IPARTVEC,              &
     & NZ_loc, INDX, OINDX,                                             &
     & ISNDRCVNUM, ISNDVOL, INGHBPRCS, ISNDRCVIA, ISNDRCVJA,            &
     & OSNDRCVNUM, OSNDVOL, ONGHBPRCS, OSNDRCVIA, OSNDRCVJA,            &
     & SNDSZ, RCVSZ, IWRK,                                              &
     & ISTATUS, REQUESTS,                                               &
     &  ITAGCOMM, COMM )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER MYID, NUMPROCS, NZ_loc, ISZ, ISNDVOL, OSNDVOL
      INTEGER INDX(NZ_loc), OINDX(NZ_loc)
      INTEGER IPARTVEC(ISZ)
      INTEGER ISNDRCVNUM, INGHBPRCS(ISNDRCVNUM)
      INTEGER ISNDRCVIA(NUMPROCS+1)
      INTEGER ISNDRCVJA(ISNDVOL)
      INTEGER OSNDRCVNUM, ONGHBPRCS(OSNDRCVNUM)
      INTEGER OSNDRCVIA(NUMPROCS+1)
      INTEGER OSNDRCVJA(OSNDVOL)
      INTEGER SNDSZ(NUMPROCS)
      INTEGER RCVSZ(NUMPROCS)
      INTEGER IWRK(ISZ)
      INTEGER ISTATUS(AGMG_MPF_STATUS_SIZE, ISNDRCVNUM)
      INTEGER REQUESTS(ISNDRCVNUM)
      INTEGER ITAGCOMM, COMM
      INTEGER I, IIND,IIND2,IPID,OFFS,IWHERETO,POFFS, ITMP, IERROR
      DO I=1,ISZ
         IWRK(I) = 0
      ENDDO
      OFFS = 1
      POFFS = 1
      DO I=1,NUMPROCS
         OSNDRCVIA(I) = OFFS + SNDSZ(I)
         IF(SNDSZ(I) > 0) THEN
            ONGHBPRCS(POFFS)=I
            POFFS = POFFS + 1
         ENDIF
         OFFS  = OFFS +  SNDSZ(I)
      ENDDO
      OSNDRCVIA(NUMPROCS+1) = OFFS
      DO I=1,NZ_loc
         IIND=INDX(I)
         IIND2 = OINDX(I)
         IF((IIND.GE.1).AND.(IIND.LE.ISZ).AND.(IIND2.GE.1)              &
     &        .AND.(IIND2.LE.ISZ)) THEN
            IPID=IPARTVEC(IIND)
            IF(IPID.NE.MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWHERETO = OSNDRCVIA(IPID+1)-1
                  OSNDRCVIA(IPID+1) = OSNDRCVIA(IPID+1)-1
                  OSNDRCVJA(IWHERETO) = IIND
                  IWRK(IIND) = 1
               ENDIF
            ENDIF
            IIND = OINDX(I)
            IPID=IPARTVEC(IIND)
            IF(IPID.NE.MYID) THEN
               IF(IWRK(IIND).EQ.0) THEN
                  IWHERETO = OSNDRCVIA(IPID+1)-1
                  OSNDRCVIA(IPID+1) = OSNDRCVIA(IPID+1)-1
                  OSNDRCVJA(IWHERETO) = IIND
                  IWRK(IIND) = 1
               ENDIF
            ENDIF
         ENDIF
      ENDDO
      CALL AGMG_SETIERR(IERROR)
      OFFS = 1
      POFFS = 1
      ISNDRCVIA(1) = 1
      DO I=2,NUMPROCS+1
         ISNDRCVIA(I) = OFFS + RCVSZ(I-1)
         IF(RCVSZ(I-1) > 0) THEN
            INGHBPRCS(POFFS)=I-1
            POFFS = POFFS + 1
         ENDIF
         OFFS  = OFFS +  RCVSZ(I-1)
      ENDDO
      CALL AGMG_SETIERR(IERROR)
      DO I=1, ISNDRCVNUM
         IPID = INGHBPRCS(I)
         OFFS = ISNDRCVIA(IPID)
         ITMP = ISNDRCVIA(IPID+1) - ISNDRCVIA(IPID)
         CALL AGMG_SETIERR(IERROR)
      ENDDO
      DO I=1,OSNDRCVNUM
         IPID = ONGHBPRCS(I)
         OFFS = OSNDRCVIA(IPID)
         ITMP = OSNDRCVIA(IPID+1)-OSNDRCVIA(IPID)
         CALL AGMG_NOCALL('MPI_SEND')
      ENDDO
      IF(ISNDRCVNUM > 0) THEN
         CALL AGMG_NOCALL('MPI_WAITALL')
      ENDIF
      CALL AGMG_SETIERR(IERROR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_692
      SUBROUTINE DAGMG_MUMPS_628(IW,LREC,SIZE_FREE,XSIZE)
      INTEGER, intent(in) :: LREC, XSIZE
      INTEGER, intent(in) :: IW(LREC)
      INTEGER(8), intent(out):: SIZE_FREE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IF (IW(1+XXS).EQ.S_NOLCBCONTIG .OR.                               &
     &    IW(1+XXS).EQ.S_NOLCBNOCONTIG) THEN
        SIZE_FREE=int(IW(1+XSIZE+2),8)*int(IW(1+XSIZE+3),8)
      ELSE IF (IW(1+XXS).EQ.S_NOLCBCONTIG38 .OR.                        &
     &         IW(1+XXS).EQ.S_NOLCBNOCONTIG38) THEN
        SIZE_FREE=int(IW(1+XSIZE+2),8)*int(IW(1+XSIZE)+                 &
     &            IW(1+XSIZE + 3) -                                     &
     &          ( IW(1+XSIZE + 4)                                       &
     &          - IW(1+XSIZE + 3) ), 8)
      ELSE
        SIZE_FREE=0_8
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_628
      SUBROUTINE DAGMG_MUMPS_629                                             &
     &(IW,LIW,IXXP,ICURRENT,NEXT, RCURRENT,ISIZE2SHIFT)
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER(8) :: RCURRENT
      INTEGER LIW,IXXP,ICURRENT,NEXT,ISIZE2SHIFT
      INTEGER IW(LIW)
      INTEGER(8) :: RSIZE
      ICURRENT=NEXT
      CALL AGMG_MUMPS_729( RSIZE, IW(ICURRENT + XXR) )
      RCURRENT = RCURRENT - RSIZE
      NEXT=IW(ICURRENT+XXP)
      IW(IXXP)=ICURRENT+ISIZE2SHIFT
      IXXP=ICURRENT+XXP
      RETURN
      END SUBROUTINE DAGMG_MUMPS_629
      SUBROUTINE DAGMG_MUMPS_630(IW,LIW,BEG2SHIFT,END2SHIFT,ISIZE2SHIFT)
      IMPLICIT NONE
      INTEGER LIW, BEG2SHIFT, END2SHIFT, ISIZE2SHIFT
      INTEGER IW(LIW)
      INTEGER I
      IF (ISIZE2SHIFT.GT.0) THEN
        DO I=END2SHIFT,BEG2SHIFT,-1
          IW(I+ISIZE2SHIFT)=IW(I)
        ENDDO
      ELSE IF (ISIZE2SHIFT.LT.0) THEN
        DO I=BEG2SHIFT,END2SHIFT
          IW(I+ISIZE2SHIFT)=IW(I)
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_630
      SUBROUTINE DAGMG_MUMPS_631(A, LA, BEG2SHIFT, END2SHIFT, RSIZE2SHIFT)
      IMPLICIT NONE
      INTEGER(8) :: LA, BEG2SHIFT, END2SHIFT, RSIZE2SHIFT
      DOUBLE PRECISION A(LA)
      INTEGER(8) :: I
      IF (RSIZE2SHIFT.GT.0_8) THEN
        DO I=END2SHIFT,BEG2SHIFT,-1_8
          A(I+RSIZE2SHIFT)=A(I)
        ENDDO
      ELSE IF (RSIZE2SHIFT.LT.0_8) THEN
        DO I=BEG2SHIFT,END2SHIFT
          A(I+RSIZE2SHIFT)=A(I)
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_631
      SUBROUTINE DAGMG_MUMPS_94(N,KEEP28,IW,LIW,A,LA,                        &
     &       LRLU,IPTRLU,IWPOS,                                         &
     &       IWPOSCB,PTRIST,PTRAST,STEP,PIMASTER,PAMASTER, ITLOC,       &
     &       KEEP216,LRLUS,XSIZE)
      IMPLICIT NONE
      INTEGER(8) :: LA, LRLU, IPTRLU, LRLUS
      INTEGER N,LIW,KEEP28,                                             &
     &        IWPOS,IWPOSCB,KEEP216,XSIZE
      INTEGER(8) :: PTRAST(KEEP28), PAMASTER(KEEP28)
      INTEGER IW(LIW),PTRIST(KEEP28),                                   &
     &        STEP(N),                                                  &
     & PIMASTER(KEEP28),                                                &
     & ITLOC(N)
      DOUBLE PRECISION A(LA)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER ICURRENT, NEXT, STATE_NEXT
      INTEGER(8) :: RCURRENT
      INTEGER ISIZE2SHIFT
      INTEGER(8) :: RSIZE2SHIFT
      INTEGER IBEGCONTIG
      INTEGER(8) :: RBEGCONTIG
      INTEGER(8) :: RBEG2SHIFT, REND2SHIFT
      INTEGER INODE
      INTEGER(8) :: FREE_IN_REC
      INTEGER(8) :: RCURRENT_SIZE
      INTEGER IXXP
      ISIZE2SHIFT=0
      RSIZE2SHIFT=0_8
      ICURRENT  = LIW-XSIZE+1
      RCURRENT = LA+1_8
      IBEGCONTIG = -999999
      RBEGCONTIG = -999999_8
      NEXT = IW(ICURRENT+XXP)
      IF (NEXT.EQ.TOP_OF_STACK) RETURN
      STATE_NEXT = IW(NEXT+XXS)
      IXXP = ICURRENT+XXP
   10    CONTINUE
         IF ( STATE_NEXT .NE. S_FREE .AND.                              &
     &        (KEEP216.EQ.3.OR.                                         &
     &         (STATE_NEXT .NE. S_NOLCBNOCONTIG .AND.                   &
     &          STATE_NEXT .NE. S_NOLCBCONTIG .AND.                     &
     &          STATE_NEXT .NE. S_NOLCBNOCONTIG38 .AND.                 &
     &          STATE_NEXT .NE. S_NOLCBCONTIG38))) THEN
            CALL DAGMG_MUMPS_629(IW,LIW,                                     &
     &           IXXP, ICURRENT, NEXT, RCURRENT, ISIZE2SHIFT)
            CALL AGMG_MUMPS_729(RCURRENT_SIZE, IW(ICURRENT+XXR))
            IF (IBEGCONTIG < 0) THEN
              IBEGCONTIG=ICURRENT+IW(ICURRENT+XXI)-1
            ENDIF
            IF (RBEGCONTIG < 0_8) THEN
              RBEGCONTIG=RCURRENT+RCURRENT_SIZE-1_8
            ENDIF
            INODE=IW(ICURRENT+XXN)
            IF (RSIZE2SHIFT .NE. 0_8) THEN
                IF (PTRAST(STEP(INODE)).EQ.RCURRENT)                    &
     &            PTRAST(STEP(INODE))=                                  &
     &            PTRAST(STEP(INODE))+RSIZE2SHIFT
                IF (PAMASTER(STEP(INODE)).EQ.RCURRENT)                  &
     &            PAMASTER(STEP(INODE))=                                &
     &            PAMASTER(STEP(INODE))+RSIZE2SHIFT
            ENDIF
            IF (ISIZE2SHIFT .NE. 0) THEN
                IF (PTRIST(STEP(INODE)).EQ.ICURRENT)                    &
     &            PTRIST(STEP(INODE))=                                  &
     &            PTRIST(STEP(INODE))+ISIZE2SHIFT
                IF (PIMASTER(STEP(INODE)).EQ.ICURRENT)                  &
     &            PIMASTER(STEP(INODE))=                                &
     &            PIMASTER(STEP(INODE))+ISIZE2SHIFT
            ENDIF
            IF (NEXT .NE. TOP_OF_STACK) THEN
              STATE_NEXT=IW(NEXT+XXS)
              GOTO 10
            ENDIF
         ENDIF
   20    CONTINUE
         IF (IBEGCONTIG.NE.0 .AND. ISIZE2SHIFT .NE. 0) THEN
           CALL DAGMG_MUMPS_630(IW,LIW,ICURRENT,IBEGCONTIG,ISIZE2SHIFT)
           IF (IXXP .LE.IBEGCONTIG) THEN
           IXXP=IXXP+ISIZE2SHIFT
           ENDIF
         ENDIF
         IBEGCONTIG=-9999
   25    CONTINUE
         IF (RBEGCONTIG .GT.0_8 .AND. RSIZE2SHIFT .NE. 0_8) THEN
           CALL DAGMG_MUMPS_631(A,LA,RCURRENT,RBEGCONTIG,RSIZE2SHIFT)
         ENDIF
         RBEGCONTIG=-99999_8
   30    CONTINUE
         IF (NEXT.EQ. TOP_OF_STACK) GOTO 100
         IF (STATE_NEXT .EQ. S_NOLCBCONTIG .OR.                         &
     &       STATE_NEXT .EQ. S_NOLCBNOCONTIG .OR.                       &
     &       STATE_NEXT .EQ. S_NOLCBCONTIG38 .OR.                       &
     &       STATE_NEXT .EQ. S_NOLCBNOCONTIG38) THEN
           IF ( KEEP216.eq.3) THEN
             WRITE(*,*) "Internal error 2 in DAGMG_MUMPS_94"
           ENDIF
           IF (RBEGCONTIG > 0_8) GOTO 25
           CALL DAGMG_MUMPS_629                                              &
     &       (IW,LIW,IXXP,ICURRENT,NEXT, RCURRENT,ISIZE2SHIFT)
           IF (IBEGCONTIG < 0 ) THEN
             IBEGCONTIG=ICURRENT+IW(ICURRENT+XXI)-1
           ENDIF
           CALL DAGMG_MUMPS_628(IW(ICURRENT),                                &
     &                              LIW-ICURRENT+1,                     &
     &                              FREE_IN_REC,                        &
     &                              XSIZE)
           IF (STATE_NEXT .EQ. S_NOLCBNOCONTIG) THEN
             CALL DAGMG_MUMPS_627(A,LA,RCURRENT,                             &
     &            IW(ICURRENT+XSIZE+2),                                 &
     &            IW(ICURRENT+XSIZE),                                   &
     &            IW(ICURRENT+XSIZE)+IW(ICURRENT+XSIZE+3), 0,           &
     &            IW(ICURRENT+XXS),RSIZE2SHIFT)
           ELSE IF (STATE_NEXT .EQ. S_NOLCBNOCONTIG38) THEN
             CALL DAGMG_MUMPS_627(A,LA,RCURRENT,                             &
     &            IW(ICURRENT+XSIZE+2),                                 &
     &            IW(ICURRENT+XSIZE),                                   &
     &            IW(ICURRENT+XSIZE)+IW(ICURRENT+XSIZE+3),              &
     &            IW(ICURRENT+XSIZE+4)-IW(ICURRENT+XSIZE+3),            &
     &            IW(ICURRENT+XXS),RSIZE2SHIFT)
           ELSE IF (RSIZE2SHIFT .GT.0_8) THEN
             RBEG2SHIFT = RCURRENT + FREE_IN_REC
             CALL AGMG_MUMPS_729(RCURRENT_SIZE, IW(ICURRENT+XXR))
             REND2SHIFT = RCURRENT + RCURRENT_SIZE - 1_8
             CALL DAGMG_MUMPS_631(A, LA,                                     &
     &                          RBEG2SHIFT, REND2SHIFT,                 &
     &                          RSIZE2SHIFT)
           ENDIF
           INODE=IW(ICURRENT+XXN)
           IF (ISIZE2SHIFT.NE.0) THEN
             PTRIST(STEP(INODE))=PTRIST(STEP(INODE))+ISIZE2SHIFT
           ENDIF
           PTRAST(STEP(INODE))=PTRAST(STEP(INODE))+RSIZE2SHIFT+         &
     &                         FREE_IN_REC
           CALL AGMG_MUMPS_724(IW(ICURRENT+XXR),FREE_IN_REC)
           IF (STATE_NEXT.EQ.S_NOLCBCONTIG.OR.                          &
     &         STATE_NEXT.EQ.S_NOLCBNOCONTIG) THEN
             IW(ICURRENT+XXS)=S_NOLCLEANED
           ELSE
             IW(ICURRENT+XXS)=S_NOLCLEANED38
           ENDIF
           RSIZE2SHIFT=RSIZE2SHIFT+FREE_IN_REC
           RBEGCONTIG=-9999_8
           IF (NEXT.EQ.TOP_OF_STACK) THEN
             GOTO 20
           ELSE
             STATE_NEXT=IW(NEXT+XXS)
           ENDIF
           GOTO 30
         ENDIF
         IF (IBEGCONTIG.GT.0) THEN
           GOTO 20
         ENDIF
   40    CONTINUE
         IF (STATE_NEXT == S_FREE) THEN
            ICURRENT = NEXT
            CALL AGMG_MUMPS_729( RCURRENT_SIZE, IW(ICURRENT + XXR) )
            ISIZE2SHIFT = ISIZE2SHIFT + IW(ICURRENT+XXI)
            RSIZE2SHIFT = RSIZE2SHIFT + RCURRENT_SIZE
            RCURRENT    = RCURRENT    - RCURRENT_SIZE
            NEXT=IW(ICURRENT+XXP)
            IF (NEXT.EQ.TOP_OF_STACK) THEN
              WRITE(*,*) "Internal error 1 in DAGMG_MUMPS_94"
              CALL AGMG_MUMPS_ABORT()
            ENDIF
            STATE_NEXT  = IW(NEXT+XXS)
            GOTO 40
         ENDIF
      GOTO 10
  100 CONTINUE
      IWPOSCB = IWPOSCB + ISIZE2SHIFT
      LRLU    = LRLU    + RSIZE2SHIFT
      IPTRLU  = IPTRLU  + RSIZE2SHIFT
      RETURN
      END SUBROUTINE DAGMG_MUMPS_94
      SUBROUTINE DAGMG_MUMPS_632(IREC, IW, LIW,                              &
     &            ISIZEHOLE, RSIZEHOLE)
      IMPLICIT NONE
      INTEGER, intent(in) :: IREC, LIW
      INTEGER, intent(in) :: IW(LIW)
      INTEGER, intent(out):: ISIZEHOLE
      INTEGER(8), intent(out) :: RSIZEHOLE
      INTEGER IRECLOC
      INTEGER(8) :: RECLOC_SIZE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      ISIZEHOLE=0
      RSIZEHOLE=0_8
      IRECLOC = IREC + IW( IREC+XXI )
   10 CONTINUE
      CALL AGMG_MUMPS_729(RECLOC_SIZE, IW(IRECLOC+XXR))
      IF (IW(IRECLOC+XXS).EQ.S_FREE) THEN
        ISIZEHOLE=ISIZEHOLE+IW(IRECLOC+XXI)
        RSIZEHOLE=RSIZEHOLE+RECLOC_SIZE
        IRECLOC=IRECLOC+IW(IRECLOC+XXI)
        GOTO 10
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_632
      SUBROUTINE DAGMG_MUMPS_627(A, LA, RCURRENT,                            &
     &           NROW, NCB, LD, NELIM, NODESTATE, ISHIFT)
      IMPLICIT NONE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER LD, NROW, NCB, NELIM, NODESTATE
      INTEGER(8) :: ISHIFT
      INTEGER(8) :: LA, RCURRENT
      DOUBLE PRECISION A(LA)
      INTEGER I,J
      INTEGER(8) :: IOLD,INEW
      LOGICAL NELIM_ROOT
      NELIM_ROOT=.TRUE.
      IF (NODESTATE.EQ. S_NOLCBNOCONTIG) THEN
         NELIM_ROOT=.FALSE.
         IF (NELIM.NE.0)  THEN
           WRITE(*,*) "Internal error 1 IN DAGMG_MUMPS_627"
           CALL AGMG_MUMPS_ABORT()
         ENDIF
      ELSE IF (NODESTATE .NE. S_NOLCBNOCONTIG38) THEN
           WRITE(*,*) "Internal error 2 in DAGMG_MUMPS_627"                  &
     &                ,NODESTATE
           CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (ISHIFT .LT.0_8) THEN
        WRITE(*,*) "Internal error 3 in DAGMG_MUMPS_627",ISHIFT
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (NELIM_ROOT) THEN
        IOLD=RCURRENT+int(LD,8)*int(NROW,8)+int(NELIM-1-NCB,8)
      ELSE
        IOLD = RCURRENT+int(LD,8)*int(NROW,8)-1_8
      ENDIF
      INEW = RCURRENT+int(LD,8)*int(NROW,8)+ISHIFT-1_8
      DO I = NROW, 1, -1
        IF (I.EQ.NROW .AND. ISHIFT.EQ.0_8.AND.                          &
     &    .NOT. NELIM_ROOT) THEN
          IOLD=IOLD-int(LD,8)
          INEW=INEW-int(NCB,8)
          CYCLE
        ENDIF
        IF (NELIM_ROOT) THEN
          DO J=1,NELIM
            A( INEW ) = A( IOLD + int(- J + 1,8))
            INEW = INEW - 1_8
          ENDDO
        ELSE
          DO J=1, NCB
            A( INEW ) = A( IOLD + int(- J + 1, 8))
            INEW = INEW - 1_8
          ENDDO
        ENDIF
        IOLD = IOLD - int(LD,8)
      ENDDO
      IF (NELIM_ROOT) THEN
        NODESTATE=S_NOLCBCONTIG38
      ELSE
        NODESTATE=S_NOLCBCONTIG
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_627
      SUBROUTINE DAGMG_MUMPS_700(BUFR,LBUFR,                                 &
     &     LBUFR_BYTES,                                                 &
     &     root, N, IW, LIW, A, LA,                                     &
     &     NBPROCFILS, LRLU, IPTRLU, IWPOS, IWPOSCB,                    &
     &     PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP, PIMASTER, PAMASTER,  &
     &     COMP, LRLUS, IPOOL, LPOOL, LEAF,                             &
     &     FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,                  &
     &     KEEP,KEEP8, IFLAG, IERROR, COMM, COMM_LOAD, ITLOC,           &
     &     ND,PROCNODE_STEPS,SLAVEF )
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC ) :: root
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA, LRLU, IPTRLU, LRLUS
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER LBUFR, LBUFR_BYTES, N, LIW,                               &
     &        IWPOS, IWPOSCB, COMP, COMM, COMM_LOAD, IFLAG,             &
     &        IERROR
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LEAF )
      INTEGER PTRIST(KEEP(28))
      INTEGER PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28)), ITLOC( N )
      INTEGER BUFR( LBUFR_BYTES ), NBPROCFILS( KEEP(28) )
      INTEGER IW( LIW )
      INTEGER ND(KEEP(28)), PROCNODE_STEPS(KEEP(28)),SLAVEF
      DOUBLE PRECISION A( LA )
      INTEGER   MYID
      INTEGER FILS( N ), PTRAIW(N), PTRARW( N )
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
        INTEGER IERR
        INTEGER POSITION, LOCAL_M, LOCAL_N, LREQI
        INTEGER(8) :: LREQA, POS_ROOT
        INTEGER NROW_SON, NCOL_SON, IROOT, ISON
        INTEGER NBROWS_ALREADY_SENT, NBROWS_PACKET
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
        POSITION = 0
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        IROOT = KEEP( 38 )
        IF ( PTRIST( STEP(IROOT) ) .NE. 0 .OR.                          &
     &       PTLUST_S( STEP(IROOT)) .NE. 0 ) THEN
          IF (NBROWS_ALREADY_SENT + NBROWS_PACKET .EQ. NROW_SON .OR.    &
     &        NROW_SON.EQ.0 .OR. NCOL_SON .EQ. 0)THEN
            NBPROCFILS(STEP(IROOT)) = NBPROCFILS(STEP(IROOT))-1
            IF ( NBPROCFILS( STEP(IROOT) ) .eq. 0 ) THEN
              IF (KEEP(201).EQ.1) THEN
                 CALL DAGMG_MUMPS_681(IERR)
              ELSEIF (KEEP(201).EQ.2) THEN
                 CALL DAGMG_MUMPS_580(IERR)
              ENDIF
              CALL DAGMG_MUMPS_507( N, IPOOL, LPOOL,                         &
     &             PROCNODE_STEPS, SLAVEF, KEEP(28), KEEP(76),          &
     &             KEEP(80), KEEP(47),                                  &
     &             STEP, IROOT + N)
              IF (KEEP(47) .GE. 3) THEN
                 CALL DAGMG_MUMPS_500(                                       &
     &                IPOOL, LPOOL,                                     &
     &                PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,    &
     &                MYID, STEP, N, ND, FILS )
              ENDIF
            ENDIF
          ENDIF
        ELSE
           IF (NBROWS_ALREADY_SENT + NBROWS_PACKET .EQ. NROW_SON        &
     &       .OR.                                                       &
     &        NROW_SON*NCOL_SON .EQ. 0)THEN
             NBPROCFILS(STEP( IROOT ) ) = -1
           ENDIF
           IF (KEEP(60) == 0) THEN
            CALL DAGMG_MUMPS_284( root, IROOT, N,                            &
     &                     IW, LIW, A, LA,                              &
     &                     FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,  &
     &                     LRLU, IPTRLU,                                &
     &                     IWPOS, IWPOSCB, PTRIST, PTRAST,              &
     &                     STEP, PIMASTER, PAMASTER, ITLOC,             &
     &                     COMP, LRLUS, IFLAG, KEEP,KEEP8, IERROR )
            IF ( IFLAG .LT. 0 ) RETURN
           ELSE
             PTRIST(STEP(IROOT)) = -55555
           ENDIF
        END IF
        LREQI = NBROWS_PACKET + NCOL_SON
        LREQA = int(NBROWS_PACKET,8) * int(NCOL_SON,8)
        IF ( (LREQA.NE.0_8) .AND.                                       &
     &       (PTRIST(STEP(IROOT)).LT.0).AND.                            &
     &       KEEP(60)==0) THEN
         WRITE(*,*) ' Error in DMUMPS_700'
         CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF (LREQA.NE.0_8) THEN
          CALL DAGMG_MUMPS_22(.FALSE.,0_8,.FALSE.,.FALSE.,                   &
     &     MYID,N,KEEP,KEEP8,IW,LIW,A, LA,                              &
     &     LRLU, IPTRLU, IWPOS, IWPOSCB, PTRIST,                        &
     &     PTRAST, STEP, PIMASTER, PAMASTER, ITLOC,                     &
     &     LREQI, LREQA, -1234, S_NOTFREE, .FALSE.,                     &
     &     COMP, LRLUS, IFLAG, IERROR                                   &
     &          )
          IF ( IFLAG .LT. 0 ) RETURN
          CALL AGMG_NOCALL('MPI_UNPACK')
          CALL AGMG_NOCALL('MPI_UNPACK')
          IF (KEEP(60) .EQ.0) THEN
          IF ( PTRIST(STEP(IROOT)) .NE. 0 ) THEN
               LOCAL_N  = -IW( PTRIST(STEP( IROOT )) + KEEP(IXSZ)    )
               LOCAL_M  =  IW( PTRIST(STEP( IROOT )) + 1 + KEEP(IXSZ))
               POS_ROOT = PAMASTER(STEP( IROOT ))
          ELSE
               LOCAL_N = IW( PTLUST_S(STEP( IROOT ) ) + 1 + KEEP(IXSZ))
               LOCAL_M = IW( PTLUST_S(STEP( IROOT ) ) + 2 + KEEP(IXSZ))
               POS_ROOT = PTRFAC(IW(PTLUST_S(STEP(IROOT))+4+            &
     &                    KEEP(IXSZ)))
          END IF
          CALL DAGMG_MUMPS_38( NBROWS_PACKET, NCOL_SON,                      &
     &                     IW( IWPOSCB + 1 ),                           &
     &                     IW( IWPOSCB + NBROWS_PACKET + 1 ),           &
     &                     A( IPTRLU + 1_8 ),                           &
     &                     A( POS_ROOT ), LOCAL_M, LOCAL_N )
          ELSE
          CALL DAGMG_MUMPS_38( NBROWS_PACKET, NCOL_SON,                      &
     &                     IW( IWPOSCB + 1 ),                           &
     &                     IW( IWPOSCB + NBROWS_PACKET + 1 ),           &
     &                     A( IPTRLU + 1_8 ),                           &
     &                     root%SCHUR_POINTER(1),                       &
     &                     root%SCHUR_LLD , root%SCHUR_NLOC)
          ENDIF
          IWPOSCB = IWPOSCB + LREQI
          IPTRLU  = IPTRLU  + LREQA
          LRLU    = LRLU    + LREQA
          LRLUS   = LRLUS   + LREQA
          CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                              &
     &                    LA-LRLUS,0_8,-LREQA,KEEP,KEEP8,LRLU)
        ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_700
      SUBROUTINE DAGMG_MUMPS_224(NFRONT,NASS,IBEGKJI, LPIV, TIPIV,           &
     &    N,INODE,IW,LIW,A,LA,                                          &
     &    INOPV,NOFFW,IFLAG,IOLDPS,POSELT,UU,SEUIL,KEEP,KEEP8,          &
     &     DKEEP,PIVNUL_LIST,LPN_LIST,                                  &
     &     PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                       &
     &     PP_LastPIVRPTRFilled_L,                                      &
     &     PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                       &
     &     PP_LastPIVRPTRFilled_U)
      IMPLICIT NONE
      INTEGER IBEGKJI, LPIV
      INTEGER TIPIV(LPIV)
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      INTEGER NFRONT,NASS,N,LIW,INODE,IFLAG,INOPV,NOFFW
      DOUBLE PRECISION UU, SEUIL
      INTEGER IW(LIW)
      INTEGER IOLDPS
      INTEGER(8) :: POSELT
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER PP_FIRST2SWAP_L, PP_LastPanelonDisk_L,                    &
     &        PP_LastPIVRPTRFilled_L,                                   &
     &        PP_FIRST2SWAP_U, PP_LastPanelonDisk_U,                    &
     &        PP_LastPIVRPTRFilled_U
      DOUBLE PRECISION SWOP
      INTEGER(8) :: APOS, IDIAG
      INTEGER(8) :: J1, J2, JJ, J3_8
      INTEGER(8) :: NFRONT8
      INTEGER ILOC
      DOUBLE PRECISION ZERO, RMAX, AMROW, ONE
      INTEGER NPIV,NASSW,IPIV
      INTEGER NPIVP1,JMAX,J3,ISW,ISWPS1
      INTEGER ISWPS2,KSW, HF
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER DAGMG_MUMPS_IXAMAX
      INTRINSIC max
      DATA ZERO /0.0D0/
      DATA ONE /1.0D0/
      INTEGER TYPEF_L, I_PIVRPTR_L, I_PIVR_L, NBPANELS_L
      INTEGER TYPEF_U, I_PIVRPTR_U, I_PIVR_U, NBPANELS_U
      INTEGER XSIZE
      PARAMETER (TYPEF_L=1, TYPEF_U=2)
        NFRONT8=int(NFRONT,8)
        XSIZE   = KEEP(IXSZ)
        NPIV    = IW(IOLDPS+1+XSIZE)
        HF = 6 + IW(IOLDPS+5+XSIZE)+XSIZE
        NPIVP1  = NPIV + 1
        IF (KEEP(201).EQ.1) THEN
          CALL DAGMG_MUMPS_667(TYPEF_L, NBPANELS_L,                          &
     &       I_PIVRPTR_L, I_PIVR_L,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE,                &
     &       IW, LIW)
          CALL DAGMG_MUMPS_667(TYPEF_U, NBPANELS_U,                          &
     &       I_PIVRPTR_U, I_PIVR_U,                                     &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+XSIZE)+XSIZE,                &
     &       IW, LIW)
        ENDIF
        ILOC    = NPIVP1 - IBEGKJI + 1
        TIPIV(ILOC) = ILOC
        NASSW   = iabs(IW(IOLDPS+3+XSIZE))
        IF(INOPV .EQ. -1) THEN
           APOS = POSELT + NFRONT8*int(NPIVP1-1,8) + int(NPIV,8)
           IDIAG = APOS
           IF(abs(A(APOS)).LT.SEUIL) THEN
              IF(dble(A(APOS)) .GE. ZERO) THEN
                 A(APOS) = dble(SEUIL)
              ELSE
                 A(APOS) = dble(-SEUIL)
              ENDIF
              KEEP(98) = KEEP(98)+1
           ENDIF
           IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
             CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_L),                          &
     &               NBPANELS_L,                                        &
     &               IW(I_PIVR_L), NASS, NPIVP1, NPIVP1,                &
     &               PP_LastPanelonDisk_L,                              &
     &               PP_LastPIVRPTRFilled_L)
             CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_U),                          &
     &               NBPANELS_U,                                        &
     &               IW(I_PIVR_U), NASS, NPIVP1, NPIVP1,                &
     &               PP_LastPanelonDisk_U,                              &
     &               PP_LastPIVRPTRFilled_U)
           ENDIF
           GO TO 420
        ENDIF
        INOPV   = 0
          DO 460 IPIV=NPIVP1,NASSW
            APOS = POSELT + NFRONT8*int(IPIV-1,8) + int(NPIV,8)
            JMAX = 1
            IF (UU.GT.ZERO) GO TO 340
            IF (A(APOS).EQ.dble(ZERO)) GO TO 630
            GO TO 380
  340       AMROW = ZERO
            J1 = APOS
            J2 = APOS +int(- NPIV + NASS - 1,8)
             J3    = NASS -NPIV
             JMAX  = DAGMG_MUMPS_IXAMAX(J3,A(J1),1)
             JJ    = int(JMAX,8) + J1 - 1_8
             AMROW = abs(A(JJ))
            RMAX = AMROW
            J1 = J2 + 1_8
            J2 = APOS +int(- NPIV + NFRONT - 1,8)
            IF (J2.LT.J1) GO TO 370
            DO 360 JJ=J1,J2
              RMAX = max(abs(A(JJ)),RMAX)
  360       CONTINUE
  370       IDIAG = APOS + int(IPIV - NPIVP1,8)
            IF (RMAX.LE.DKEEP(1)) THEN
               KEEP(109) = KEEP(109)+1
               ISW = IOLDPS+IW(IOLDPS+1+KEEP(IXSZ))+6+KEEP(IXSZ)+       &
     &                      IW(IOLDPS+5+KEEP(IXSZ))+IPIV-NPIVP1
               PIVNUL_LIST(KEEP(109)) = IW(ISW)
               IF(DKEEP(2).GT.ZERO) THEN
                  IF(dble(A(IDIAG)) .GE. ZERO) THEN
                     A(IDIAG) = dble(DKEEP(2))
                  ELSE
                     A(IDIAG) = dble(-DKEEP(2))
                  ENDIF
               ELSE
                 J1 = APOS
                 J2 = APOS +int(- NPIV + NFRONT - 1,8)
                 DO JJ=J1,J2
                   A(JJ)= dble(ZERO)
                 ENDDO
                 A(IDIAG) = dble(ONE)
               ENDIF
               JMAX = IPIV - NPIV
               GOTO 380
            ENDIF
            IF (abs(A(IDIAG)).GT.max(UU*RMAX,SEUIL)) THEN
               JMAX = IPIV - NPIV
               GO TO 380
            ENDIF
            IF (AMROW.LE.max(UU*RMAX,SEUIL)) GO TO 460
            NOFFW = NOFFW + 1
  380       IF (IPIV.EQ.NPIVP1) GO TO 400
            J1 = POSELT + int(NPIV,8)*NFRONT8
            J2 = J1 + NFRONT8 - 1_8
            J3_8 = POSELT + int(IPIV-1,8)*NFRONT8
            DO 390 JJ=J1,J2
              SWOP = A(JJ)
              A(JJ) = A(J3_8)
              A(J3_8) = SWOP
              J3_8 = J3_8 + 1_8
  390       CONTINUE
            ISWPS1 = IOLDPS + HF - 1 + NPIVP1
            ISWPS2 = IOLDPS + HF - 1 + IPIV
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
  400       IF (JMAX.EQ.1) GO TO 420
            TIPIV(ILOC) = ILOC + JMAX - 1
            J1 = POSELT + int(NPIV,8)
            J2 = POSELT + int(NPIV + JMAX - 1,8)
            DO 410 KSW=1,NASS
              SWOP = A(J1)
              A(J1) = A(J2)
              A(J2) = SWOP
              J1 = J1 + NFRONT8
              J2 = J2 + NFRONT8
  410       CONTINUE
            ISWPS1 = IOLDPS + HF - 1 + NFRONT + NPIV + 1
            ISWPS2 = IOLDPS + HF - 1 + NFRONT + NPIV + JMAX
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
            GO TO 420
  460     CONTINUE
      IF (NASSW.EQ.NASS) THEN
       INOPV = 1
      ELSE
       INOPV = 2
      ENDIF
      GO TO 430
  630 CONTINUE
      IFLAG = -10
      WRITE(*,*) 'NIV2:Detected 0 pivot, INODE,NPIV=',INODE,NPIV
      GOTO 430
  420 CONTINUE
              IF (KEEP(201).EQ.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_L),                       &
     &               NBPANELS_L,                                        &
     &               IW(I_PIVR_L), NASS, NPIVP1, IPIV,                  &
     &               PP_LastPanelonDisk_L,                              &
     &               PP_LastPIVRPTRFilled_L)
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR_U),                       &
     &               NBPANELS_U,                                        &
     &               IW(I_PIVR_U), NASS, NPIVP1, NPIV+JMAX,             &
     &               PP_LastPanelonDisk_U,                              &
     &               PP_LastPIVRPTRFilled_U)
              ENDIF
  430 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_224
      SUBROUTINE  DAGMG_MUMPS_294( COMM_LOAD, ASS_IRECV,                     &
     &             N, INODE, FPERE,                                     &
     &             IW, LIW,                                             &
     &             IOLDPS, POSELT, A, LA, LDA_FS,                       &
     &             IBEGKJI, IEND, TIPIV, LPIV, LASTBL, NB_BLOC_FAC,     &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC,                    &
     &             STEP, PIMASTER, PAMASTER,                            &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N, INODE, FPERE, LIW, IBEGKJI, IEND, LPIV,                &
     &        IOLDPS, LDA_FS, NB_BLOC_FAC
      INTEGER(8) :: POSELT, LA
      INTEGER IW(LIW), TIPIV(LPIV)
      LOGICAL LASTBL
      DOUBLE PRECISION A(LA)
      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL,                        &
     &        SLAVEF, ICNTL(40)
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER IWPOS, IWPOSCB, COMP
      INTEGER BUFR( LBUFR ), IPOOL(LPOOL),                              &
     &        ITLOC(N), FILS(N),                                        &
     &        PTRARW(LPTRAR), PTRAIW(LPTRAR),                           &
     &        ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER(8) :: PTRAST  (KEEP(28))
      INTEGER(8) :: PTRFAC  (KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28)),                     &
     &        STEP(N), PIMASTER(KEEP(28)),                              &
     &        NSTK_S(KEEP(28)),                                         &
     &        NBPROCFILS(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      EXTERNAL  DAGMG_MUMPS_329
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER(8) :: APOS, LREQA
      INTEGER NPIV, NCOL, PDEST, NSLAVES
      INTEGER IERR, IERR_MPI, LREQI
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      DOUBLE PRECISION FLOP1,FLOP2
      NSLAVES= IW(IOLDPS+5+KEEP(IXSZ))
          IF (NSLAVES.EQ.0) THEN
           WRITE(6,*) ' ERROR 1 in DMUMPS_294 '
           CALL AGMG_MUMPS_ABORT()
          ENDIF
      NPIV   = IEND - IBEGKJI + 1
      NCOL   = LDA_FS - IBEGKJI + 1
      APOS   = POSELT + int(LDA_FS,8)*int(IBEGKJI-1,8) +                &
     &                  int(IBEGKJI - 1,8)
      IF (IBEGKJI > 0) THEN
       CALL AGMG_MUMPS_511( LDA_FS, IBEGKJI-1, LPIV,                         &
     &                            KEEP(50),2,FLOP1)
      ELSE
        FLOP1=0.0D0
      ENDIF
      CALL AGMG_MUMPS_511( LDA_FS, IEND, LPIV,                               &
     &                           KEEP(50),2,FLOP2)
      FLOP2 = FLOP1 - FLOP2
      CALL DAGMG_MUMPS_190(1, .FALSE., FLOP2, KEEP,KEEP8)
      IF ((NPIV.GT.0) .OR.                                              &
     &    ((NPIV.EQ.0).AND.(LASTBL)) ) THEN
        PDEST  = IOLDPS + 6 + KEEP(IXSZ)
        IERR = -1
        IF ( NPIV .NE. 0 ) THEN
          NB_BLOC_FAC = NB_BLOC_FAC + 1
        END IF
        DO WHILE (IERR .EQ.-1)
          CALL DAGMG_MUMPS_65( INODE, LDA_FS, NCOL,                          &
     &               NPIV, FPERE, LASTBL, TIPIV, A(APOS),               &
     &               IW(PDEST), NSLAVES, KEEP(50), NB_BLOC_FAC,         &
     &               COMM, IERR )
        IF (IERR.EQ.-1) THEN
           BLOCKING  = .FALSE.
           SET_IRECV = .TRUE.
           MESSAGE_RECEIVED = .FALSE.
           CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                       &
     &      BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                      &
     &      AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                &
     &      STATUS, BUFR, LBUFR,                                        &
     &      LBUFR_BYTES,                                                &
     &      PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB, IPTRLU,             &
     &      LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                     &
     &      PTLUST_S, PTRFAC,                                           &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP, IFLAG,      &
     &      IERROR, COMM,                                               &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF, NBFIN, MYID, SLAVEF,                    &
     &      root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,          &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,               &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
           IF (MESSAGE_RECEIVED) POSELT = PTRAST(STEP(INODE))
           IF ( IFLAG .LT. 0 ) GOTO 500
         ENDIF
        ENDDO
        IF (IERR .EQ. -2 .OR. IERR.EQ.-3 ) THEN
          IF (IERR.EQ.-2) IFLAG = -17
          IF (IERR.EQ.-3) IFLAG = -20
          LREQA = int(NCOL,8)*int(NPIV,8)
          LREQI = NPIV + 6 + 2*NSLAVES
          CALL AGMG_MUMPS_731(                                               &
     &    int(LREQI,8) * int(KEEP(34),8) + LREQA * int(KEEP(35),8),     &
     &    IERROR)
          GOTO 300
        ENDIF
      ENDIF
      GOTO 500
  300 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 RETURN
      END SUBROUTINE  DAGMG_MUMPS_294
      SUBROUTINE DAGMG_MUMPS_273( ROOT,                                      &
     &    INODE, NELIM, NSLAVES, ROW_LIST,                              &
     &    COL_LIST, SLAVE_LIST,                                         &
     &    PROCNODE_STEPS, IWPOS, IWPOSCB, IPTRLU,                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, ITLOC, COMP,        &
     &    IFLAG, IERROR,                                                &
     &    IPOOL, LPOOL, LEAF, MYID, SLAVEF, KEEP,KEEP8,                 &
     &    COMM,COMM_LOAD,FILS,ND )
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: ROOT
      INTEGER INODE, NELIM, NSLAVES
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER ROW_LIST(*), COL_LIST(*),                                 &
     &        SLAVE_LIST(*)
      INTEGER(8) :: IPTRLU, LRLU, LRLUS, LA
      INTEGER IWPOS, IWPOSCB
      INTEGER N, LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER PTRIST( KEEP(28) ), PTLUST_S(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28))
      INTEGER COMP
      INTEGER NSTK_S(KEEP(28)), ITLOC( N ), PROCNODE_STEPS( KEEP(28) )
      INTEGER IFLAG, IERROR
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER MYID, SLAVEF
      INTEGER COMM,COMM_LOAD,ND(KEEP(28)),FILS(N)
      INTEGER IROOT, TYPE_INODE, DEB_ROW, DEB_COL,                      &
     &        NOINT
      INTEGER(8) :: NOREAL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_330
      IROOT        = KEEP(38)
      NSTK_S(STEP(IROOT))= NSTK_S(STEP(IROOT)) - 1
      KEEP(42) = KEEP(42) + NELIM
      TYPE_INODE= AGMG_MUMPS_330(STEP(INODE), PROCNODE_STEPS, SLAVEF)
      IF (TYPE_INODE.EQ.1) THEN
        IF (NELIM.EQ.0) THEN
         KEEP(41) = KEEP(41) + 1
        ELSE
         KEEP(41) = KEEP(41) + 3
        ENDIF
      ELSE
        IF (NELIM.EQ.0) THEN
         KEEP(41) = KEEP(41) + NSLAVES
        ELSE
         KEEP(41) = KEEP(41) + 2*NSLAVES + 1
        ENDIF
      ENDIF
      IF  (NELIM.EQ.0) THEN
        PIMASTER(STEP(INODE)) = 0
      ELSE
       NOINT = 6 + NSLAVES + NELIM  + NELIM + KEEP(IXSZ)
       NOREAL= 0_8
       CALL DAGMG_MUMPS_22(.FALSE.,0_8,.FALSE.,.FALSE.,                      &
     &   MYID,N,KEEP,KEEP8,IW,LIW, A, LA,                               &
     &   LRLU, IPTRLU,IWPOS,IWPOSCB,                                    &
     &   PTRIST,PTRAST,STEP, PIMASTER, PAMASTER, ITLOC,                 &
     &   NOINT, NOREAL, INODE, S_NOTFREE, .TRUE.,                       &
     &   COMP, LRLUS, IFLAG, IERROR                                     &
     &      )
       IF ( IFLAG .LT. 0 ) THEN
         WRITE(*,*) ' Failure in int space allocation in CB area ',     &
     &    ' during assembly of root : DMUMPS_273',                      &
     &    ' size required was :', NOINT,                                &
     &    'INODE=',INODE,' NELIM=',NELIM, ' NSLAVES=', NSLAVES
         RETURN
        ENDIF
        PIMASTER(STEP( INODE )) = IWPOSCB + 1
        PAMASTER(STEP( INODE )) = IPTRLU  + 1_8
        IW( IWPOSCB + 1+KEEP(IXSZ) ) = 2*NELIM
        IW( IWPOSCB + 2+KEEP(IXSZ) ) = NELIM
        IW( IWPOSCB + 3+KEEP(IXSZ) ) = 0
        IW( IWPOSCB + 4+KEEP(IXSZ) ) = 0
        IW( IWPOSCB + 5+KEEP(IXSZ) ) = 1
        IW( IWPOSCB + 6+KEEP(IXSZ) ) = NSLAVES
        IF (NSLAVES.GT.0) THEN
         IW( IWPOSCB+7+KEEP(IXSZ):IWPOSCB+7+KEEP(IXSZ)+NSLAVES-1) =     &
     &                   SLAVE_LIST(1:NSLAVES)
        ENDIF
        DEB_ROW = IWPOSCB+7+NSLAVES+KEEP(IXSZ)
        IW(DEB_ROW : DEB_ROW+NELIM -1) = ROW_LIST(1:NELIM)
        DEB_COL = DEB_ROW + NELIM
        IW(DEB_COL : DEB_COL+NELIM -1) = COL_LIST(1:NELIM)
      ENDIF
      IF (NSTK_S(STEP(IROOT)) .EQ. 0 ) THEN
          CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL, PROCNODE_STEPS,              &
     &         SLAVEF, KEEP(28), KEEP(76), KEEP(80), KEEP(47),          &
     &         STEP, IROOT )
          IF (KEEP(47) .GE. 3) THEN
             CALL DAGMG_MUMPS_500(                                           &
     &            IPOOL, LPOOL,                                         &
     &            PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,        &
     &            MYID, STEP, N, ND, FILS )
          ENDIF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_273
      SUBROUTINE DAGMG_MUMPS_534( N,FRERE, FILS,                             &
     &     NA,NE,ND,PERM,SYM,INFO,LP,K47,K81,K215,K234,K55,             &
     &     PROCNODE,SLAVEF,PEAK                                         &
     &     )
      IMPLICIT NONE
      INTEGER N,PERM,SYM, LP, SIZE_MEM_SBTR
      INTEGER FRERE(N), FILS(N)
      INTEGER NA(N), NE(N), ND(N),K47,K81,K215,K234,K55
      INTEGER INFO(40)
      INTEGER SLAVEF,PROCNODE(N)
      DOUBLE PRECISION PEAK
      INTEGER NBROOT, NBLEAF, LNA, allocok, LEAF, I, NSTEPS,            &
     &        K47_LOC, K81_LOC
      INTEGER, ALLOCATABLE, DIMENSION (:) :: NEW_NA, STEP
      INTEGER TEMP_MEM(1),SBTR_WHICH_M
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) :: MEM_SUBTREE
      INTEGER, ALLOCATABLE, DIMENSION (:,:) :: MY_ROOT,                 &
     &     MY_SIZE,MY_LEAF
      INTEGER, ALLOCATABLE, DIMENSION (:) ::      DEPTH_FIRST
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION (:) :: COST_TRAV
      INTEGER DUMMY_DAD(1), DUMMY_DAD_LENGTH
      PARAMETER (DUMMY_DAD_LENGTH=1)
      LOGICAL USE_DAD
      PARAMETER (USE_DAD=.FALSE.)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IF (N.EQ.1) THEN
        NBROOT = 1
        NBLEAF = 1
      ELSEIF (NA(N).LT.0) THEN
        NBLEAF = N
        NBROOT = N
      ELSEIF (NA(N-1).LT.0) THEN
        NBLEAF = N-1
        NBROOT = NA(N)
      ELSE
        NBLEAF = NA(N-1)
        NBROOT = NA(N)
      ENDIF
      LNA = NBROOT + NBLEAF + 2
      ALLOCATE (NEW_NA (LNA), STEP(N), stat=allocok)
      IF (allocok > 0 ) THEN
        INFO(1) = -7
        INFO(2) = LNA + N
        RETURN
      ENDIF
      NEW_NA(1)=NBLEAF
      NEW_NA(2)=NBROOT
      LEAF = 3
      IF ( N == 1 ) THEN
          NEW_NA(LEAF) = 1
          LEAF = LEAF + 1
      ELSE IF (NA(N) < 0) THEN
          NEW_NA(LEAF) = - NA(N)-1
          LEAF = LEAF + 1
          DO I = 1, NBLEAF - 1
            NEW_NA(LEAF) = NA(I)
            LEAF = LEAF + 1
          ENDDO
      ELSE IF (NA(N-1) < 0 ) THEN
          NEW_NA(LEAF) = - NA(N-1) - 1
          LEAF =LEAF + 1
          IF ( NBLEAF > 1 ) THEN
            DO I = 1, NBLEAF - 1
              NEW_NA(LEAF) = NA(I)
              LEAF = LEAF + 1
            ENDDO
          ENDIF
      ELSE
          DO I = 1, NBLEAF
            NEW_NA(LEAF) = NA(I)
            LEAF = LEAF + 1
          ENDDO
      END IF
      SIZE_MEM_SBTR=NEW_NA(2)
      ALLOCATE(MEM_SUBTREE(SIZE_MEM_SBTR,SLAVEF),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= SIZE_MEM_SBTR*SLAVEF
         RETURN
      ENDIF
      ALLOCATE(MY_ROOT(SIZE_MEM_SBTR,SLAVEF),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= SIZE_MEM_SBTR*SLAVEF
         RETURN
      ENDIF
      ALLOCATE(MY_LEAF(SIZE_MEM_SBTR,SLAVEF),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= SIZE_MEM_SBTR*SLAVEF
         RETURN
      ENDIF
      ALLOCATE(MY_SIZE(SIZE_MEM_SBTR,SLAVEF),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= SIZE_MEM_SBTR*SLAVEF
         RETURN
      ENDIF
      DO I = 1, N
        STEP(I)=I
        IF ( FRERE(I) .EQ. 0 ) THEN
          NEW_NA(LEAF) = I
          LEAF = LEAF + 1
        END IF
      END DO
      NSTEPS = N
      K47_LOC = 0
      K81_LOC = 0
      SBTR_WHICH_M=0
      ALLOCATE(DEPTH_FIRST(1),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= 1
         RETURN
      ENDIF
      ALLOCATE(COST_TRAV(1),stat=allocok)
      IF (allocok .ne.0) THEN
         INFO(1)= -7
         INFO(2)= 1
         RETURN
      ENDIF
      CALL DAGMG_MUMPS_363(N,FRERE, STEP, FILS,                              &
     &     NEW_NA,LNA,NE,ND,                                            &
     &     DUMMY_DAD, DUMMY_DAD_LENGTH, USE_DAD,                        &
     &     NSTEPS,PERM,SYM,INFO,LP,K47_LOC,K81_LOC,0,K215,K234,K55,     &
     &     PROCNODE,MEM_SUBTREE,SLAVEF, SIZE_MEM_SBTR, PEAK,SBTR_WHICH_M&
     &     ,1,1,DEPTH_FIRST,COST_TRAV,MY_LEAF,MY_SIZE,MY_ROOT           &
     &)
      NA(1:NBLEAF)=NEW_NA(3:2+NBLEAF)
      NA(N)=NBROOT
      IF (N.GT.1) THEN
       IF (NBLEAF.GT.N-2) THEN
        IF (NBLEAF.EQ.N-1) THEN
         NA(N-1) = -NA(N-1)-1
         NA(N)   = NBROOT
        ELSE
         NA(N) = -NA(N)-1
        ENDIF
       ELSE
        NA(N-1) = NBLEAF
        NA(N)   = NBROOT
       ENDIF
      ENDIF
      DEALLOCATE(MEM_SUBTREE)
      DEALLOCATE(NEW_NA,STEP)
      DEALLOCATE(DEPTH_FIRST,COST_TRAV)
      DEALLOCATE(MY_LEAF,MY_SIZE,MY_ROOT)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_534
      SUBROUTINE DAGMG_MUMPS_363(N,FRERE, STEP, FILS,                        &
     &     NA,LNA,NE,ND, DAD, LDAD, USE_DAD,                            &
     &     NSTEPS,PERM,SYM,INFO,LP,K47,K81,K76,K215,K234,K55,           &
     &     PROCNODE,MEM_SUBTREE,SLAVEF, SIZE_MEM_SBTR, PEAK             &
     &     ,SBTR_WHICH_M,SIZE_DEPTH_FIRST,SIZE_COST_TRAV,               &
     &     DEPTH_FIRST_TRAV,COST_TRAV,MY_FIRST_LEAF,                    &
     &     MY_NB_LEAF,MY_ROOT_SBTR                                      &
     &     )
      IMPLICIT NONE
      INTEGER N,PERM,SYM, NSTEPS, LNA, LP, SIZE_MEM_SBTR,LDAD
      INTEGER FRERE(NSTEPS), FILS(N), STEP(N)
      INTEGER NA(LNA), NE(NSTEPS), ND(NSTEPS)
      INTEGER K47,K81,K76,K215,K234,K55
      INTEGER DAD(LDAD)
      LOGICAL USE_DAD
      INTEGER INFO(40)
      INTEGER SLAVEF,PROCNODE(NSTEPS)
      DOUBLE PRECISION, intent(out) :: MEM_SUBTREE(SIZE_MEM_SBTR,SLAVEF)
      INTEGER :: SBTR_WHICH_M
      INTEGER MY_FIRST_LEAF(SIZE_MEM_SBTR,SLAVEF),                      &
     &     MY_ROOT_SBTR(SIZE_MEM_SBTR,SLAVEF),                          &
     &     MY_NB_LEAF(SIZE_MEM_SBTR,SLAVEF)
      EXTERNAL AGMG_MUMPS_283,AGMG_MUMPS_275
      LOGICAL AGMG_MUMPS_283
      INTEGER AGMG_MUMPS_275
      DOUBLE PRECISION PEAK
      INTEGER SIZE_DEPTH_FIRST,DEPTH_FIRST_TRAV(SIZE_DEPTH_FIRST)
      INTEGER SIZE_COST_TRAV
      DOUBLE PRECISION COST_TRAV(SIZE_COST_TRAV)
      INTEGER, DIMENSION (:), ALLOCATABLE :: DEPTH
      INTEGER ITOP,IFATH,IN,LSTK,NSTK,INODE,K,I,allocok,LOCAL_PERM
      INTEGER*8 NCB
      INTEGER*8 NELIM,NFR
      INTEGER NFR4,NELIM4
      INTEGER LEAF,NBLEAF,NBROOT, SIZE_TAB
      INTEGER, DIMENSION (:), ALLOCATABLE :: ROOT,IPOOL,TNSTK
      INTEGER, DIMENSION (:), ALLOCATABLE,TARGET :: SON,TEMP
      INTEGER*8, DIMENSION (:), ALLOCATABLE :: M,M_TOTAL, fact
      INTEGER*8, DIMENSION (:), ALLOCATABLE :: TAB1,TAB2
      INTEGER, DIMENSION (:), POINTER :: TAB
      INTEGER J,x,y,z,dernier,fin,RANK_TRAV
      INTEGER cour,t,II,temporary
      INTEGER actuel,CB_current,CB_MAX,ROOT_OF_CUR_SBTR
      INTEGER*8, DIMENSION (:), ALLOCATABLE :: T1,T2
      INTEGER, DIMENSION (:), ALLOCATABLE :: RESULT
      INTEGER*8 MEM_SIZE,FACT_SIZE,SUM,MEM_SEC_PERM,FACT_SIZE_T,        &
     &     MEM_SIZE_T,TOTAL_MEM_SIZE,TMP_TOTAL_MEM_SIZE,TMP_SUM,        &
     &     SIZECB, SIZECB_LASTSON
      INTEGER*8 TMP8
      LOGICAL   SBTR_M
      INTEGER INDICE(SLAVEF),ID,FIRST_LEAF,SIZE_SBTR
      EXTERNAL AGMG_MUMPS_170,AGMG_MUMPS_167
      LOGICAL AGMG_MUMPS_170,AGMG_MUMPS_167
      DOUBLE PRECISION COST_NODE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      TOTAL_MEM_SIZE=0_8
      ROOT_OF_CUR_SBTR=0
      IF((PERM.EQ.0).OR.(PERM.EQ.1).OR.                                 &
     &     (PERM.EQ.2).OR.(PERM.EQ.3).OR.(PERM.EQ.4).OR.                &
     &     (PERM.EQ.5).OR.(PERM.EQ.6))THEN
         LOCAL_PERM=0
      ENDIF
      IF (K47 == 4 .OR. ((K47.GE.2).AND.(K81.GE. 1))) THEN
        DO I=1,SLAVEF
          INDICE(I)=1
        ENDDO
        DO I=1,SLAVEF
          DO x=1,SIZE_MEM_SBTR
            MEM_SUBTREE(x,I)=-1.0D0
          ENDDO
        ENDDO
      ENDIF
      SBTR_M=((K47 == 4 .OR. ((K47.GE.2).AND.(K81 .GE. 1))))
      MEM_SIZE=0_8
      FACT_SIZE=0_8
      IF ((PERM.GT.7).AND.                                              &
     & (.NOT.(K47 == 4 .OR. ((K47.GE.2).AND.(K81 .GE. 1))))) THEN
         WRITE(*,*) "Internal Error in DAGMG_MUMPS_363",PERM
         CALL AGMG_MUMPS_ABORT()
      END IF
      NBLEAF = NA(1)
      NBROOT = NA(2)
      IF((PERM.EQ.0).AND.(NBROOT.EQ.NBLEAF)) RETURN
      IF (SBTR_M.OR.(PERM.EQ.2))  THEN
         IF((SBTR_WHICH_M.EQ.1).AND.(PERM.NE.1))THEN
            ALLOCATE(M_TOTAL(NSTEPS), stat=allocok )
            IF (allocok > 0) THEN
               IF ( LP .GT. 0 )                                         &
     &              WRITE(LP,*)'Memory allocation error in              &
     &              DAGMG_MUMPS_363'
               INFO(1)=-7
               INFO(2)=NSTEPS
               RETURN
            ENDIF
         ENDIF
      ENDIF
      ALLOCATE( IPOOL(NBLEAF), M(NSTEPS), fact(NSTEPS),                 &
     &          TNSTK(NSTEPS), stat=allocok )
      IF (allocok > 0) THEN
        IF ( LP .GT. 0 )                                                &
     &    WRITE(LP,*)'Memory allocation error in DMUMPS_363'
        INFO(1)=-7
        INFO(2)=NSTEPS
        RETURN
      ENDIF
      II=0
      DO I=1,NSTEPS
         TNSTK(I) = NE(I)
         IF(NE(I).GE.II) II=NE(I)
      ENDDO
      SIZE_TAB=max(II,NBROOT)
      ALLOCATE(SON(II), TEMP(II),                                       &
     &         TAB1(SIZE_TAB), TAB2(SIZE_TAB), stat=allocok )
      IF (allocok > 0) THEN
        IF ( LP .GT. 0 )                                                &
     &    WRITE(LP,*)'Memory allocation error in DMUMPS_363'
        INFO(1)=-7
        INFO(2)=NSTEPS
        RETURN
      ENDIF
      ALLOCATE(T1(SIZE_TAB),T2(SIZE_TAB),                               &
     &         RESULT(SIZE_TAB),stat=allocok)
      IF (allocok > 0) THEN
        IF ( LP .GT. 0 )                                                &
     &    WRITE(LP,*)'Memory allocation error in DMUMPS_363'
        INFO(1)=-7
        INFO(2)=SIZE_TAB
        RETURN
      ENDIF
      IF(NBROOT.EQ.NBLEAF)THEN
        IF((PERM.NE.1).OR.(PERM.EQ.4).OR.(PERM.EQ.6))THEN
          WRITE(*,*)'Internal Error in reordertree:'
          WRITE(*,*)'  problem with perm parameter in reordertree'
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        DO I=1,NBROOT
          TAB1(I)=int(ND(STEP(NA(I+2+NBLEAF))),8)
          IPOOL(I)=NA(I+2+NBLEAF)
          M(STEP(IPOOL(I)))=TAB1(I)*TAB1(I)
        ENDDO
        CALL DAGMG_MUMPS_462(NA(2+NBLEAF+1),NBROOT,TAB1,TAB2,4,              &
     &    RESULT,T1,T2)
        GOTO 789
      ENDIF
      IF((PERM.EQ.3).OR.(PERM.EQ.4))THEN
         ALLOCATE(DEPTH(NSTEPS),stat=allocok)
         IF (allocok > 0) THEN
            IF ( LP .GT. 0 )                                            &
     &           WRITE(LP,*)'Memory allocation error in                 &
     &           DAGMG_MUMPS_363'
            INFO(1)=-7
            INFO(2)=NSTEPS
            RETURN
         ENDIF
         DEPTH=0
         NBROOT = NA(2)
         IPOOL(1:NBROOT) = NA(3+NBLEAF:2+NBLEAF+NBROOT)
         fin=NBROOT
         LEAF=NA(1)
  499    CONTINUE
         INODE=IPOOL(fin)
         IF(INODE.LT.0)THEN
            WRITE(*,*)'Internal Error in reordertree INODE < 0 !'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         IN=INODE
 4602    IN = FILS(IN)
         IF (IN .GT. 0 ) THEN
            GOTO 4602
         ENDIF
         IN=-IN
         DO I=1,NE(STEP(INODE))
            SON(I)=IN
            IN=FRERE(STEP(IN))
         ENDDO
         DO I=1,NE(STEP(INODE))
            IPOOL(fin)=SON(I)
            DEPTH(STEP(SON(I)))=DEPTH(STEP(INODE))+1
            SON(I)=0
            fin=fin+1
         ENDDO
         IF(NE(STEP(INODE)).EQ.0)THEN
            LEAF=LEAF-1
         ELSE
            fin=fin-1
            GOTO 499
         ENDIF
         fin=fin-1
         IF(fin.EQ.0) GOTO 489
         GOTO 499
  489    CONTINUE
      ENDIF
      IF(K76.EQ.4)THEN
         RANK_TRAV=NSTEPS
         DEPTH_FIRST_TRAV=0
      ENDIF
      IF((K76.EQ.5).OR.(PERM.EQ.5).OR.(PERM.EQ.6))THEN
         COST_TRAV=0.0D0
         COST_NODE=0.0D0
      ENDIF
      DO I=1,NSTEPS
         M(I)=0_8
         IF (SBTR_M.OR.(PERM.EQ.2))  THEN
            IF((SBTR_WHICH_M.EQ.1).AND.(PERM.NE.1))THEN
               M_TOTAL(I)=0_8
            ENDIF
         ENDIF
      ENDDO
      DO I=1,NSTEPS
         fact(I)=0_8
      ENDDO
      IPOOL(1:NBLEAF)=NA(3:2+NBLEAF)
      LEAF = NBLEAF + 1
   91 CONTINUE
        IF (LEAF.NE.1) THEN
           LEAF = LEAF -1
           INODE = IPOOL(LEAF)
        ENDIF
   96   CONTINUE
        NFR    = int(ND(STEP(INODE)),8)
        NSTK   = NE(STEP(INODE))
        NELIM4 = 0
        IN = INODE
  101   NELIM4 = NELIM4 + 1
        IN = FILS(IN)
        IF (IN .GT. 0 ) GOTO 101
        NELIM=int(NELIM4,8)
        IF(NE(STEP(INODE)).EQ.0) THEN
           M(STEP(INODE))=NFR*NFR
           IF (SBTR_M.OR.(PERM.EQ.2))  THEN
                 M_TOTAL(STEP(INODE))=NFR*NFR
           ENDIF
        ENDIF
        IF((PERM.EQ.4).OR.(PERM.EQ.3))THEN
           IF(AGMG_MUMPS_170(STEP(INODE),                                    &
     &PROCNODE,SLAVEF))THEN
              DEPTH(STEP(INODE))=0
           ENDIF
        ENDIF
        IF ( SYM .eq. 0 ) THEN
          fact(STEP(INODE))=fact(STEP(INODE))+                          &
     &      (2_8*NFR*NELIM)-(NELIM*NELIM)
        ELSE
          fact(STEP(INODE))=fact(STEP(INODE))+NFR*NELIM
        ENDIF
        IF (USE_DAD) THEN
          IFATH = DAD( STEP(INODE) )
        ELSE
          IN = INODE
  113     IN = FRERE(IN)
          IF (IN.GT.0) GO TO 113
          IFATH = -IN
        ENDIF
        IF (IFATH.EQ.0) THEN
           NBROOT = NBROOT - 1
           IF (NBROOT.EQ.0) GOTO 116
           GOTO 91
        ELSE
           fact(STEP(IFATH))=fact(STEP(IFATH))+fact(STEP(INODE))
           IF((PERM.EQ.3).OR.(PERM.EQ.4))THEN
              DEPTH(STEP(IFATH))=max(DEPTH(STEP(INODE)),                &
     &             DEPTH(STEP(IFATH)))
           ENDIF
        ENDIF
        TNSTK(STEP(IFATH)) = TNSTK(STEP(IFATH)) - 1
        IF ( TNSTK(STEP(IFATH)) .EQ. 0 ) THEN
           INODE = IFATH
           IN=INODE
           dernier=IN
           I=1
 5700      IN = FILS(IN)
           IF (IN .GT. 0 ) THEN
             dernier=IN
             I=I+1
             GOTO 5700
           ENDIF
           NCB=int(ND(STEP(INODE))-I,8)
           IN=-IN
           IF(PERM.NE.7)THEN
              DO I=1,NE(STEP(INODE))
                 SON(I)=IN
                 TEMP(I)=IN
                 IF(IN.GT.0) IN=FRERE(STEP(IN))
              ENDDO
           ELSE
              DO I=NE(STEP(INODE)),1,-1
                 SON(I)=IN
                 TEMP(I)=IN
                 IF(IN.GT.0) IN=FRERE(STEP(IN))
              ENDDO
           ENDIF
           IF(PERM.EQ.7) GOTO 213
           NFR = int(ND(STEP(INODE)),8)
           DO II=1,NE(STEP(INODE))
             TAB1(II)=0_8
             TAB2(II)=0_8
             cour=SON(II)
             NELIM4=1
  151        cour=FILS(cour)
             IF(cour.GT.0) THEN
                NELIM4=NELIM4+1
                GOTO 151
             ENDIF
             NELIM=int(NELIM4,8)
             IF((SYM.EQ.0).OR.(K215.NE.0)) THEN
                SIZECB=(int(ND(STEP(SON(II))),8)-NELIM)                 &
     &                *(int(ND(STEP(SON(II))),8)-NELIM)
             ELSE
                SIZECB=(int(ND(STEP(SON(II))),8)-NELIM)                 &
     &                *(int(ND(STEP(SON(II))),8)-                       &
     &               NELIM+1_8)/2_8
             ENDIF
             IF((PERM.EQ.0).OR.(PERM.EQ.5))THEN
                IF (K234 .NE. 0 .AND. K55.EQ.0 ) THEN
                   TMP8=NFR
                   TMP8=TMP8*TMP8
                   TAB1(II)=MAX(TMP8, M(STEP(SON(II)))) - SIZECB
                   TAB2(II)=SIZECB
                ELSE
                   TAB1(II)=M(STEP(SON(II)))- SIZECB
                   TAB2(II)=SIZECB
                ENDIF
             ENDIF
             IF((PERM.EQ.1).OR.(PERM.EQ.6)) THEN
                TAB1(II)=M(STEP(SON(II)))-SIZECB
                TAB1(II)=TAB1(II)-fact(STEP(SON(II)))
                TAB2(II)=SIZECB+fact(STEP(SON(II)))
             ENDIF
             IF(PERM.EQ.2)THEN
                IF (AGMG_MUMPS_170(STEP(INODE),                              &
     &               PROCNODE,SLAVEF))THEN
                   TAB1(II)=M_TOTAL(STEP(SON(II)))-SIZECB               &
     &                  -fact(STEP(SON(II)))
                   TAB2(II)=SIZECB
                ELSE
                   TAB1(II)=M(STEP(SON(II)))-SIZECB
                   TAB2(II)=SIZECB
                ENDIF
             ENDIF
             IF(PERM.EQ.3)THEN
                IF (AGMG_MUMPS_170(STEP(INODE),                              &
     &               PROCNODE,SLAVEF))THEN
                   TAB1(II)=M(STEP(SON(II)))-SIZECB
                   TAB2(II)=SIZECB
                ELSE
                   TAB1(II)=int(DEPTH(STEP(SON(II))),8)
                   TAB2(II)=M(STEP(SON(II)))
                ENDIF
             ENDIF
             IF(PERM.EQ.4)THEN
                IF (AGMG_MUMPS_170(STEP(INODE),                              &
     &               PROCNODE,SLAVEF))THEN
                   TAB1(II)=M(STEP(SON(II)))-                           &
     &                  SIZECB-fact(STEP(SON(II)))
                   TAB2(II)=SIZECB
                ELSE
                   TAB1(II)=int(DEPTH(STEP(SON(II))),8)
                   TAB2(II)=M(STEP(SON(II)))
                ENDIF
             ENDIF
          ENDDO
          CALL DAGMG_MUMPS_462(SON,NE(STEP(INODE)),TAB1,TAB2,                &
     &         LOCAL_PERM                                               &
     &           ,RESULT,T1,T2)
          IF(PERM.EQ.0) THEN
             DO II=1,NE(STEP(INODE))
               cour=TEMP(II)
               NELIM4=1
  153          cour=FILS(cour)
               IF(cour.GT.0) THEN
                  NELIM4=NELIM4+1
                  GOTO 153
               ENDIF
               NELIM=int(NELIM4,8)
               IF((SYM.EQ.0).OR.(K215.NE.0))THEN
                  SIZECB=(int(ND(STEP(TEMP(II))),8)-NELIM)*             &
     &                 (int(ND(STEP(TEMP(II))),8)-NELIM)
               ELSE
                  SIZECB=(int(ND(STEP(TEMP(II))),8)-NELIM)*             &
     &                    (int(ND(STEP(TEMP(II))),8)-NELIM+1_8)/2_8
               ENDIF
               TAB1(II)=SIZECB
             ENDDO
             CALL DAGMG_MUMPS_462(TEMP,NE(STEP(INODE)),TAB1,TAB2,3,          &
     &         RESULT,T1,T2)
           ENDIF
           IF(PERM.EQ.1) THEN
              DO II=1,NE(STEP(INODE))
                cour=TEMP(II)
                NELIM4=1
  187           cour=FILS(cour)
                IF(cour.GT.0) THEN
                   NELIM4=NELIM4+1
                   GOTO 187
                ENDIF
                NELIM=int(NELIM4,8)
                IF((SYM.EQ.0).OR.(K215.NE.0))THEN
                   SIZECB=(int(ND(STEP(TEMP(II))),8)-NELIM)*            &
     &                    (int(ND(STEP(TEMP(II))),8)-NELIM)
                ELSE
                   SIZECB=(int(ND(STEP(TEMP(II))),8)-NELIM)*            &
     &                    (int(ND(STEP(TEMP(II))),8)-NELIM+1_8)/2_8
                ENDIF
                TAB1(II)=SIZECB+fact(STEP(TEMP(II)))
             ENDDO
             CALL DAGMG_MUMPS_462(TEMP,NE(STEP(INODE)),TAB1,TAB2,3,          &
     &         RESULT,T1,T2)
           ENDIF
  213      CONTINUE
           IFATH=INODE
           DO II=1,2
              SUM=0_8
              FACT_SIZE=0_8
              FACT_SIZE_T=0_8
              MEM_SIZE=0_8
              MEM_SIZE_T=0_8
              CB_MAX=0
              CB_current=0
              TMP_SUM=0_8
              IF(II.EQ.1) TAB=>SON
              IF(II.EQ.2) TAB=>TEMP
              DO I=1,NE(STEP(INODE))
                 cour=TAB(I)
                 NELIM4=1
  149            cour=FILS(cour)
                 IF(cour.GT.0) THEN
                    NELIM4=NELIM4+1
                    GOTO 149
                 ENDIF
                 NELIM=int(NELIM4, 8)
                 NFR=int(ND(STEP(TAB(I))),8)
                 IF((SYM.EQ.0).OR.(K215.NE.0))THEN
                    SIZECB=(NFR-NELIM)*(NFR-NELIM)
                 ELSE
                    SIZECB=(NFR-NELIM)*(NFR-NELIM+1_8)/2_8
                 ENDIF
                 MEM_SIZE=max(MEM_SIZE,(M(STEP(TAB(I)))+SUM+FACT_SIZE))
                 IF (SBTR_M.OR.(PERM.EQ.2)) THEN
                       MEM_SIZE_T=max(MEM_SIZE_T,(M_TOTAL(STEP(TAB(I)))+&
     &                      SUM+                                        &
     &                      FACT_SIZE_T))
                       FACT_SIZE_T=FACT_SIZE_T+fact(STEP(TAB(I)))
                 ENDIF
                 TOTAL_MEM_SIZE=max(TOTAL_MEM_SIZE,                     &
     &                (M(STEP(TAB(I)))+SUM+FACT_SIZE))
                 TMP_SUM=TMP_SUM+fact(STEP(TAB(I)))
                 SUM=SUM+SIZECB
                 SIZECB_LASTSON = SIZECB
                 IF((PERM.EQ.1).OR.(PERM.EQ.4))THEN
                    FACT_SIZE=FACT_SIZE+fact(STEP(TAB(I)))
                 ENDIF
              ENDDO
              IF((SYM.EQ.0).OR.(K215.NE.0))THEN
                 SIZECB=NCB*NCB
              ELSE
                 SIZECB=(NCB*(NCB+1_8))/2_8
              ENDIF
              IF (K234.NE.0 .AND. K55.EQ.0) THEN
                 TOTAL_MEM_SIZE=max(TOTAL_MEM_SIZE,                     &
     &                ( (   int(ND(STEP(IFATH)),8)                      &
     &                    * int(ND(STEP(IFATH)),8) )                    &
     &                  + SUM-SIZECB_LASTSON+TMP_SUM )                  &
     &           )
              ELSE IF (K234.NE.0 .AND. K55.NE.0) THEN
                 TOTAL_MEM_SIZE=max(TOTAL_MEM_SIZE,                     &
     &                ( ( int(ND(STEP(IFATH)),8)                        &
     &                  * int(ND(STEP(IFATH)),8) )                      &
     &                  + SUM + TMP_SUM )                               &
     &           )
              ELSE
                 TOTAL_MEM_SIZE=max(TOTAL_MEM_SIZE,                     &
     &                ( ( int(ND(STEP(IFATH)),8)                        &
     &                  * int(ND(STEP(IFATH)),8))                       &
     &                  + max(SUM,SIZECB) + TMP_SUM )                   &
     &                )
              ENDIF
              IF(II.EQ.1)THEN
                 TMP_TOTAL_MEM_SIZE=TOTAL_MEM_SIZE
              ENDIF
              IF((II.EQ.1).OR.(PERM.EQ.7)) THEN
                 IF (K234.NE.0 .AND. K55.EQ.0) THEN
                   M(STEP(IFATH))=max(MEM_SIZE,((int(ND(STEP(IFATH)),8) &
     &             *int(ND(STEP(IFATH)),8))+SUM-SIZECB_LASTSON+         &
     &             FACT_SIZE))
                 ELSE IF (K234.NE.0 .AND. K55.NE.0) THEN
                   M(STEP(IFATH))=max(MEM_SIZE,((int(ND(STEP(IFATH)),8) &
     &             *int(ND(STEP(IFATH)),8))+SUM+FACT_SIZE))
                 ELSE
                   M(STEP(IFATH))=max(MEM_SIZE,((int(ND(STEP(IFATH)),8) &
     &             *int(ND(STEP(IFATH)),8))+max(SUM,SIZECB)+FACT_SIZE))
                 ENDIF
                 IF (SBTR_M.OR.(PERM.EQ.2))  THEN
                       M_TOTAL(STEP(IFATH))=max(MEM_SIZE_T,             &
     &                      ((int(ND(STEP(IFATH)),8)                    &
     &                      *int(ND(STEP(IFATH)),8))+max(SUM,SIZECB)+   &
     &                      FACT_SIZE_T))
                 ENDIF
              ENDIF
              IF((II.EQ.2).AND.(PERM.EQ.1).OR.(PERM.EQ.0).OR.           &
     &             (PERM.EQ.5).OR.(PERM.EQ.6).OR.                       &
     &             (.NOT.SBTR_M.OR.(SBTR_WHICH_M.NE.1)))THEN
                 MEM_SEC_PERM=max(MEM_SIZE,((int(ND(STEP(IFATH)),8)     &
     &             *int(ND(STEP(IFATH)),8))+max(SUM,SIZECB)+FACT_SIZE))
              ENDIF
              IF((PERM.EQ.2).OR.(PERM.EQ.3).OR.(PERM.EQ.4))THEN
                 MEM_SEC_PERM=huge(MEM_SEC_PERM)
              ENDIF
           ENDDO
           IF(PERM.EQ.7) GOTO 96
           IF(MEM_SEC_PERM.EQ.M(STEP(IFATH))) THEN
              TAB=>TEMP
           ELSE IF (MEM_SEC_PERM.LT.M(STEP(IFATH))) THEN
              WRITE(*,*)'Probleme dans reorder!!!!'
              CALL AGMG_MUMPS_ABORT()
           ELSE
              TOTAL_MEM_SIZE=TMP_TOTAL_MEM_SIZE
              TAB=>SON
           ENDIF
           DO I=NE(STEP(INODE)),1,-1
              IF(I.EQ.NE(STEP(INODE))) THEN
                 FILS(dernier)=-TAB(I)
                 dernier=TAB(I)
                 GOTO 222
              ENDIF
              IF(I.EQ.1) THEN
                 FRERE(STEP(dernier))=TAB(I)
                 FRERE(STEP(TAB(I)))=-INODE
                 GOTO 222
              ENDIF
              IF(I.GT.1) THEN
                 FRERE(STEP(dernier))=TAB(I)
                 dernier=TAB(I)
                 GOTO 222
              ENDIF
  222         CONTINUE
           ENDDO
           GOTO 96
        ELSE
           GOTO 91
        ENDIF
  116   CONTINUE
        NBROOT = NA(2)
        IPOOL(1:NBROOT) = NA(3+NBLEAF:2+NBLEAF+NBROOT)
        IF(PERM.EQ.7) GOTO 001
        IF (PERM.eq.1) THEN
          DO I=1,NBROOT
            TAB1(I)=M(STEP(NA(I+2+NBLEAF)))-fact(STEP(NA(I+2+NBLEAF)))
            TAB1(I)=-TAB1(I)
          ENDDO
          CALL DAGMG_MUMPS_462(NA(2+NBLEAF+1),NBROOT,TAB1,TAB2,4,            &
     &      RESULT,T1,T2)
          IPOOL(1:NBROOT) = NA(3+NBLEAF:2+NBLEAF+NBROOT)
        ENDIF
    1   CONTINUE
        fin=NBROOT
        LEAF=NA(1)
        FIRST_LEAF=-9999
        SIZE_SBTR=0
  999   CONTINUE
        INODE=IPOOL(fin)
        IF(INODE.LT.0)THEN
           WRITE(*,*)'Internal Error in reordertree INODE < 0 !'
           CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF(SIZE_SBTR.NE.0)THEN
           IF(.NOT.AGMG_MUMPS_167(STEP(INODE),PROCNODE,SLAVEF))THEN
              IF ( K47 == 4 .OR. ((K81.GE.1).AND.(K47.GE.2))) THEN
                 IF((SLAVEF.NE.1))THEN
                    MY_FIRST_LEAF(INDICE(ID+1)-1,ID+1)=FIRST_LEAF
                    MY_NB_LEAF(INDICE(ID+1)-1,ID+1)=SIZE_SBTR
                    FIRST_LEAF=-9999
                    SIZE_SBTR=0
                 ENDIF
              ENDIF
           ENDIF
        ENDIF
        IF(AGMG_MUMPS_283(STEP(INODE),PROCNODE,SLAVEF))THEN
           ROOT_OF_CUR_SBTR=INODE
        ENDIF
        IF (K76.EQ.4)THEN
           IF(SLAVEF.NE.1)THEN
              WRITE(*,*)'INODE=',INODE,'RANK',RANK_TRAV
              IF(AGMG_MUMPS_167(STEP(INODE),PROCNODE,SLAVEF))THEN
                 DEPTH_FIRST_TRAV(STEP(INODE))=DEPTH_FIRST_TRAV(STEP(   &
     &                ROOT_OF_CUR_SBTR))
              ELSE
                 DEPTH_FIRST_TRAV(STEP(INODE))=RANK_TRAV
              ENDIF
              RANK_TRAV=RANK_TRAV-1
           ENDIF
        ENDIF
        IF (K76.EQ.5)THEN
           IF(SLAVEF.NE.1)THEN
              IF (USE_DAD) THEN
                IFATH=DAD(INODE)
              ELSE
                IN = INODE
  395           IN = FRERE(IN)
                IF (IN.GT.0) GO TO 395
                IFATH = -IN
              ENDIF
              NFR4   = ND(STEP(INODE))
              NFR    = int(NFR4,8)
              NELIM4 = 0
              IN = INODE
  396         NELIM4 = NELIM4 + 1
              IN = FILS(IN)
              IF (IN .GT. 0 ) GOTO 396
              NELIM=int(NELIM4,8)
              IF((SYM.EQ.0).OR.(K215.NE.0))THEN
                 SIZECB=(NFR-NELIM)*(NFR-NELIM)
              ELSE
                 SIZECB=(NFR-NELIM)*(NFR-NELIM+1_8)/2_8
              ENDIF
              CALL AGMG_MUMPS_511(NFR4,NELIM4,NELIM4,                        &
     &             SYM,1,COST_NODE)
              IF(IFATH.NE.0)THEN
                 IF(AGMG_MUMPS_167(STEP(INODE),PROCNODE,SLAVEF))THEN
                    COST_TRAV(STEP(INODE))=COST_TRAV(STEP(              &
     &                   ROOT_OF_CUR_SBTR))
                 ELSE
                    COST_TRAV(STEP(INODE))=COST_NODE+                   &
     &                   COST_TRAV(STEP(IFATH))+                        &
     &                   dble(SIZECB*18_8)
                 ENDIF
              ELSE
                 COST_TRAV(STEP(INODE))=COST_NODE
              ENDIF
              IF(K76.EQ.5)THEN
                 WRITE(*,*)'INODE=',INODE,'COST=',COST_TRAV(STEP(INODE))
              ENDIF
           ENDIF
        ENDIF
        IF ( K47 == 4 .OR. ((K81.GE.1).AND.(K47.GE.2))) THEN
              IF((SLAVEF.NE.1).AND.                                     &
     &          AGMG_MUMPS_283(STEP(INODE),PROCNODE,SLAVEF))THEN
                IF (NE(STEP(INODE)).NE.0) THEN
                   ID=AGMG_MUMPS_275(STEP(INODE),PROCNODE,SLAVEF)
                   IF((SBTR_WHICH_M.EQ.1).AND.(PERM.NE.1))THEN
                      MEM_SUBTREE(INDICE(ID+1),ID+1)=                   &
     &                     dble(M_TOTAL(STEP(INODE)))
                   ELSE
                      MEM_SUBTREE(INDICE(ID+1),ID+1)=                   &
     &                     dble(M(STEP(INODE)))
                   ENDIF
                   MY_ROOT_SBTR(INDICE(ID+1),ID+1)=INODE
                  INDICE(ID+1)=INDICE(ID+1)+1
                ENDIF
              ENDIF
              IF((SLAVEF.EQ.1).AND.FRERE(STEP(INODE)).EQ.0)THEN
                 ID=AGMG_MUMPS_275(STEP(INODE),PROCNODE,SLAVEF)
                 IF((SBTR_WHICH_M.EQ.1).AND.(PERM.NE.1))THEN
                    MEM_SUBTREE(INDICE(ID+1),ID+1)=                     &
     &                   dble(M_TOTAL(STEP(INODE)))
                 ELSE
                    MEM_SUBTREE(INDICE(ID+1),ID+1)=                     &
     &                   dble(M(STEP(INODE)))
                 ENDIF
                 INDICE(ID+1)=INDICE(ID+1)+1
              ENDIF
        ENDIF
        IN=INODE
 5602   IN = FILS(IN)
        IF (IN .GT. 0 ) THEN
           dernier=IN
           GOTO 5602
        ENDIF
        IN=-IN
        DO I=1,NE(STEP(INODE))
           TEMP(I)=IN
           IF((PERM.EQ.5).OR.(PERM.EQ.6))THEN
              IF((SLAVEF.NE.1).AND.(.NOT.AGMG_MUMPS_170(                     &
     &             STEP(INODE),PROCNODE,SLAVEF)))THEN
                 NFR4   = ND(STEP(INODE))
                 NFR    = int(NFR4,8)
                 NELIM4 = 0
                 II = TEMP(I)
  845            NELIM4 = NELIM4 + 1
                 II = FILS(II)
                 IF (II .GT. 0 ) GOTO 845
                 NELIM=int(NELIM4,8)
                 CALL AGMG_MUMPS_511(NFR4,NELIM4,NELIM4,                     &
     &                SYM,1,COST_NODE)
                 TAB1(I)=int(COST_NODE+                                 &
     &                COST_TRAV(STEP(INODE)),8)
                 TAB2(I)=0_8
              ELSE
                 SON(I)=IN
              ENDIF
           ELSE
              SON(I)=IN
           ENDIF
           IN=FRERE(STEP(IN))
        ENDDO
        IF((PERM.EQ.5).OR.(PERM.EQ.6))THEN
           IF((SLAVEF.NE.1).AND.(.NOT.AGMG_MUMPS_170(                        &
     &          STEP(INODE),PROCNODE,SLAVEF)))THEN
              CALL DAGMG_MUMPS_462(TEMP,NE(STEP(INODE)),TAB1,TAB2,           &
     &             LOCAL_PERM                                           &
     &             ,RESULT,T1,T2)
              TAB=>TEMP
              DO I=NE(STEP(INODE)),1,-1
                 IF(I.EQ.NE(STEP(INODE))) THEN
                    FILS(dernier)=-TAB(I)
                    dernier=TAB(I)
                    GOTO 221
                 ENDIF
                 IF(I.EQ.1) THEN
                    FRERE(STEP(dernier))=TAB(I)
                    FRERE(STEP(TAB(I)))=-INODE
                    GOTO 221
                 ENDIF
                 IF(I.GT.1) THEN
                    FRERE(STEP(dernier))=TAB(I)
                    dernier=TAB(I)
                    GOTO 221
                 ENDIF
  221            CONTINUE
                 SON(NE(STEP(INODE))-I+1)=TAB(I)
              ENDDO
           ENDIF
        ENDIF
        DO I=1,NE(STEP(INODE))
           IPOOL(fin)=SON(I)
           SON(I)=0
           fin=fin+1
        ENDDO
        IF(NE(STEP(INODE)).EQ.0)THEN
           IF ( K47 == 4 .OR. ((K81.GE.1).AND.(K47.GE.2))) THEN
              IF(SLAVEF.NE.1)THEN
                 IF(AGMG_MUMPS_167(STEP(INODE),PROCNODE,SLAVEF))THEN
                    IF(FIRST_LEAF.EQ.-9999)THEN
                       FIRST_LEAF=INODE
                    ENDIF
                    SIZE_SBTR=SIZE_SBTR+1
                 ENDIF
              ENDIF
           ENDIF
           IF(PERM.NE.7)THEN
              NA(LEAF+2)=INODE
           ENDIF
           LEAF=LEAF-1
        ELSE
           fin=fin-1
           GOTO 999
        ENDIF
        fin=fin-1
        IF(fin.EQ.0) THEN
           IF(SIZE_SBTR.NE.0)THEN
              IF ( K47 == 4 .OR. ((K81.GE.1).AND.(K47.GE.2))) THEN
                 IF((SLAVEF.NE.1))THEN
                    MY_FIRST_LEAF(INDICE(ID+1)-1,ID+1)=FIRST_LEAF
                    MY_NB_LEAF(INDICE(ID+1)-1,ID+1)=SIZE_SBTR
                    FIRST_LEAF=-9999
                    SIZE_SBTR=0
                 ENDIF
              ENDIF
           ENDIF
           GOTO 789
        ENDIF
        GOTO 999
  789   CONTINUE
        NBROOT=NA(2)
        NBLEAF=NA(1)
        PEAK=0.0D0
        FACT_SIZE=0_8
        DO I=1,NBROOT
           PEAK=max(PEAK,dble(M(STEP(NA(2+NBLEAF+I)))))
           FACT_SIZE=FACT_SIZE+fact(STEP(NA(2+NBLEAF+I)))
        ENDDO
 5483   CONTINUE
        DEALLOCATE(IPOOL)
        DEALLOCATE(M)
        DEALLOCATE(fact)
        DEALLOCATE(TNSTK)
        DEALLOCATE(SON)
        DEALLOCATE(TAB2)
        DEALLOCATE(TAB1)
        DEALLOCATE(T1)
        DEALLOCATE(T2)
        DEALLOCATE(RESULT)
        DEALLOCATE(TEMP)
        IF((PERM.EQ.3).OR.(PERM.EQ.4))THEN
           DEALLOCATE(DEPTH)
        ENDIF
        IF (SBTR_M.OR.(PERM.EQ.2))  THEN
           IF((SBTR_WHICH_M.EQ.1).AND.(PERM.NE.1).OR.(PERM.EQ.2))THEN
              DEALLOCATE(M_TOTAL)
           ENDIF
        ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_363
      RECURSIVE SUBROUTINE DAGMG_MUMPS_462(TAB,DIM,TAB1,TAB2,PERM,           &
     &  RESULT,TEMP1,TEMP2)
      IMPLICIT NONE
      INTEGER DIM
      INTEGER*8 TAB1(DIM),TAB2(DIM)
      INTEGER*8 TEMP1(DIM),TEMP2(DIM)
      INTEGER TAB(DIM), PERM,RESULT(DIM)
      INTEGER I,J,K,C,I1,I2,COR1,COR2
      IF(DIM.EQ.1) THEN
        RESULT(1)=TAB(1)
        TEMP1(1)=TAB1(1)
        TEMP2(1)=TAB2(1)
        RETURN
      ENDIF
      I=DIM/2
      CALL DAGMG_MUMPS_462(TAB(1),I,TAB1(1),TAB2(1),PERM,                    &
     &  RESULT(1),TEMP1(1),TEMP2(1))
      CALL DAGMG_MUMPS_462(TAB(I+1),DIM-I,TAB1(I+1),TAB2(I+1),               &
     &  PERM,RESULT(I+1),TEMP1(I+1),TEMP2(I+1))
      I1=1
      I2=I+1
      J=1
      DO WHILE ((I1.LE.I).AND.(I2.LE.DIM))
        IF((PERM.EQ.3))THEN
          IF(TEMP1(I1).LE.TEMP1(I2))THEN
            TAB(J)=RESULT(I1)
            TAB1(J)=TEMP1(I1)
            J=J+1
            I1=I1+1
          ELSE
            TAB(J)=RESULT(I2)
            TAB1(J)=TEMP1(I2)
            J=J+1
            I2=I2+1
          ENDIF
          GOTO 3
        ENDIF
        IF((PERM.EQ.4).OR.(PERM.EQ.5))THEN
          IF (TEMP1(I1).GE.TEMP1(I2))THEN
            TAB(J)=RESULT(I1)
            TAB1(J)=TEMP1(I1)
            J=J+1
            I1=I1+1
          ELSE
            TAB(J)=RESULT(I2)
            TAB1(J)=TEMP1(I2)
            J=J+1
            I2=I2+1
          ENDIF
          GOTO 3
        ENDIF
        IF((PERM.EQ.0).OR.(PERM.EQ.1).OR.(PERM.EQ.2)) THEN
          IF(TEMP1(I1).GT.TEMP1(I2))THEN
            TAB1(J)=TEMP1(I1)
            TAB2(J)=TEMP2(I1)
            TAB(J)=RESULT(I1)
            J=J+1
            I1=I1+1
            GOTO 3
          ENDIF
          IF(TEMP1(I1).LT.TEMP1(I2))THEN
            TAB1(J)=TEMP1(I2)
            TAB2(J)=TEMP2(I2)
            TAB(J)=RESULT(I2)
            J=J+1
            I2=I2+1
            GOTO 3
          ENDIF
          IF((TEMP1(I1).EQ.TEMP1(I2)))THEN
            IF(TEMP2(I1).LE.TEMP2(I2))THEN
              TAB1(J)=TEMP1(I1)
              TAB2(J)=TEMP2(I1)
              TAB(J)=RESULT(I1)
              J=J+1
              I1=I1+1
            ELSE
              TAB1(J)=TEMP1(I2)
              TAB2(J)=TEMP2(I2)
              TAB(J)=RESULT(I2)
              J=J+1
              I2=I2+1
            ENDIF
          ENDIF
        ENDIF
    3 CONTINUE
      ENDDO
      IF(I1.GT.I)THEN
        DO WHILE(I2.LE.DIM)
          TAB(J)=RESULT(I2)
          TAB1(J)=TEMP1(I2)
          TAB2(J)=TEMP2(I2)
          J=J+1
          I2=I2+1
        ENDDO
      ELSE
        IF(I2.GT.DIM)THEN
          DO WHILE(I1.LE.I)
            TAB1(J)=TEMP1(I1)
            TAB2(J)=TEMP2(I1)
            TAB(J)=RESULT(I1)
            J=J+1
            I1=I1+1
          ENDDO
        ENDIF
      ENDIF
      DO I=1,DIM
        TEMP1(I)=TAB1(I)
        TEMP2(I)=TAB2(I)
        RESULT(I)=TAB(I)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_462
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_26(id)
      USE DAGMG_MUMPS_LOAD
      USE AGMG_MUMPS_STATIC_MAPPING
      USE DAGMG_MUMPS_STRUC_DEF
      USE TOOLS_COMMON
      USE DAGMG_MUMPS_PARALLEL_ANALYSIS
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      !start pavel ferkl
      interface
      subroutine DAGMG_MUMPS_746( ID, PTRAR )
      use DAGMG_MUMPS_STRUC_DEF
      implicit none
      TYPE(DAGMG_MUMPS_STRUC), INTENT(IN), TARGET :: ID
      INTEGER, TARGET          :: PTRAR(ID%N,2)
      end subroutine DAGMG_MUMPS_746
      end interface
      !end pavel ferkl
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER ierr, MASTER
      PARAMETER( MASTER = 0 )
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER LIW, IKEEP, FILS, FRERE, PTRAR, NFSIZ
      INTEGER NE, NA
      INTEGER I, allocok
      INTEGER MAXIS1_CHECK
      INTEGER INDX, NRECV, NB_NIV2, LAST_ALLOWED, IDEST
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER LOCAL_M, LOCAL_N, K44MAX
      INTEGER NUMROC_FOOL
      EXTERNAL NUMROC_FOOL
      INTEGER IRANK
      INTEGER MP, LP, MPG
      LOGICAL PROK, PROKG, LISTVAR_SCHUR_2BE_FREED
      INTEGER SIZE_SCHUR_PASSED
      INTEGER SBUF_SEND, SBUF_REC, TOTAL_MBYTES
      INTEGER*8 SBUF_RECOLD8, MIN_BUF_SIZE8
      INTEGER MIN_BUF_SIZE
      INTEGER*8 MAX_SIZE_FACTOR_TMP
      INTEGER NSLAVES_SAVE
      INTEGER LEAF, INODE, ISTEP, INN, LPTRAR
      INTEGER NBLEAF, NBROOT, MYROW_CHECK, INIV2
      INTEGER*8 K13TMP8, K14TMP8
      INTEGER MM_WRITE
      INTEGER MM_WRITE_CHECK
      CHARACTER(LEN=20) MM_IDSTR
      DOUBLE PRECISION PEAK
      INTEGER PERM
      INTEGER, ALLOCATABLE, DIMENSION(:,:) :: REQPTR
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PAR2_NODES
      INTEGER, DIMENSION(:), POINTER :: IWtemp
      INTEGER, DIMENSION(:), POINTER :: XNODEL, NODEL, SSARBR
      INTEGER, POINTER ::  NELT, LELTVAR
      INTEGER, DIMENSION(:), POINTER :: KEEP,INFO, INFOG
      INTEGER*8, DIMENSION(:), POINTER :: KEEP8
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RINFO
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RINFOG
      INTEGER, DIMENSION(:), POINTER :: ICNTL
      LOGICAL I_AM_SLAVE, OOC_STAT, PERLU_ON, COND
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      INTEGER K,J, IORD, IFS
      INTEGER SIZE_TEMP_MEM,SIZE_DEPTH_FIRST,SIZE_COST_TRAV
      LOGICAL IS_REORDERTREE_CALLED
      DOUBLE PRECISION, DIMENSION (:,:), ALLOCATABLE :: TEMP_MEM
      INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_ROOT
      INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_LEAF
      INTEGER, DIMENSION (:,:), ALLOCATABLE :: TEMP_SIZE
      INTEGER, DIMENSION (:), ALLOCATABLE :: DEPTH_FIRST
      DOUBLE PRECISION, DIMENSION (:), ALLOCATABLE :: COST_TRAV_TMP
      INTEGER*8 :: TOTAL_BYTES
      INTEGER, POINTER, DIMENSION(:) ::  WORK1PTR, WORK2PTR,            &
     &     NFSIZPTR,                                                    &
     &     FILSPTR,                                                     &
     &     FREREPTR
      IS_REORDERTREE_CALLED=.FALSE.
      KEEP   => id%KEEP
      KEEP8  => id%KEEP8
      INFO   => id%INFO
      RINFO  => id%RINFO
      INFOG  => id%INFOG
      RINFOG => id%RINFOG
      ICNTL  => id%ICNTL
      NELT    => id%NELT
      LELTVAR => id%LELTVAR
      KEEP8(24) = 0_8
      I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR.                          &
     &     ( id%MYID .eq. MASTER .AND.                                  &
     &     id%KEEP(46) .eq. 1 ) )
      LP  = ICNTL( 1 )
      MP  = ICNTL( 2 )
      MPG = ICNTL( 3 )
      PROK  = ( MP  .GT. 0 )
      PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
      IF (PROK) WRITE( MP, 220 )
      IF (PROKG.AND.(MPG .NE. MP)) WRITE( MPG, 220 ) id%VERSION_NUMBER
  220 FORMAT( /' DMUMPS ',A )
      IF ( PROK ) THEN
         IF ( KEEP(50) .eq. 0 ) THEN
            WRITE(MP, '(A)') 'L U Solver for unsymmetric matrices'
         ELSE IF ( KEEP(50) .eq. 1 ) THEN
            WRITE(MP, '(A)')                                            &
     & 'L D L^T Solver for symmetric positive definite matrices'
         ELSE
            WRITE(MP, '(A)')                                            &
     &           'L D L^T Solver for general symmetric matrices'
         END IF
         IF ( KEEP(46) .eq. 1 ) THEN
            WRITE(MP, '(A)') 'Type of parallelism: Working host'
         ELSE
            WRITE(MP, '(A)') 'Type of parallelism: Host not working'
         END IF
      END IF
      IF ( PROKG .AND. (MP.NE.MPG)) THEN
         IF ( KEEP(50) .eq. 0 ) THEN
            WRITE(MPG, '(A)') 'L U Solver for unsymmetric matrices'
         ELSE IF ( KEEP(50) .eq. 1 ) THEN
            WRITE(MPG, '(A)')                                           &
     & 'L D L^T Solver for symmetric positive definite matrices'
         ELSE
            WRITE(MPG, '(A)')                                           &
     &           'L D L^T Solver for general symmetric matrices'
         END IF
         IF ( KEEP(46) .eq. 1 ) THEN
            WRITE(MPG, '(A)') 'Type of parallelism: Working host'
         ELSE
            WRITE(MPG, '(A)') 'Type of parallelism: Host not working'
         END IF
      END IF
      IF (PROK) WRITE( MP, 110 )
      IF (PROKG .AND. (MPG.NE.MP)) WRITE( MPG, 110 )
      CALL DAGMG_MUMPS_647(id)
      IORD = ICNTL(7)
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      CALL AGMG_SETIERR( ierr )
      IF (id%KEEP(60) .EQ. 2 .or. id%KEEP(60) .EQ. 3) THEN
         CALL AGMG_SETIERR( ierr )
         CALL AGMG_SETIERR( ierr )
         CALL AGMG_SETIERR( ierr )
         CALL AGMG_SETIERR( ierr )
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      IF ( id%KEEP(55) .EQ. 0) THEN
         IF ( KEEP(54) .eq. 3 ) THEN
          CALL AGMG_COPY( id%NZ_LOC, id%NZ, 1, AGMG_MPF_INTEGER, IERR )
         ELSE
            CALL AGMG_SETIERR( ierr )
         END IF
      ELSE
         CALL AGMG_SETIERR( ierr )
      ENDIF
      IF ( associated(id%MEM_DIST) ) deallocate( id%MEM_DIST )
      allocate( id%MEM_DIST( 0:id%NSLAVES-1 ), STAT=ierr )
      IF ( ierr .GT. 0 ) THEN
         INFO(1) = -7
         INFO(2) = id%NSLAVES
         IF ( LP .GT. 0 ) THEN
            WRITE(LP, 150) 'MEM_DIST'
         END IF
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      id%MEM_DIST(0:id%NSLAVES-1) = 0
      CALL AGMG_MUMPS_427(                                                   &
     &     id%COMM,id%COMM_NODES,KEEP(69),KEEP(46),                     &
     &     id%NSLAVES,id%MEM_DIST,INFO)
      CALL DAGMG_MUMPS_658(id)
      IF (KEEP(244) .EQ. 1) THEN
         IF ( KEEP(54) .eq. 3 ) THEN
            CALL DAGMG_MUMPS_664(id)
         END IF
         IF ( id%MYID .eq. MASTER ) THEN
 1234       CONTINUE
            IF ( ( (KEEP(23) .NE. 0) .AND.                              &
     &           ( (KEEP(23).NE.7) .OR. KEEP(50).EQ. 2 ) )              &
     &           .OR.                                                   &
     &           ( associated(id%A) .AND. KEEP(52) .EQ. 77 .AND.        &
     &           (KEEP(50).EQ.2))                                       &
     &        .OR.                                                      &
     &           KEEP(52) .EQ. -2 ) THEN
               IF (.not.associated(id%A)) THEN
                  IF (KEEP(23).GT.2) KEEP(23) = 1
               ENDIF
               CALL DAGMG_MUMPS_203(id%N, id%NZ, KEEP(23), id%IS1(1), id,    &
     &              ICNTL, INFO)
               IF (INFO(1) .LT. 0) THEN
                  KEEP(23) = 0
                  GOTO 10
               END IF
            END IF
            IF (KEEP(55) .EQ. 0) THEN
               IF ( IORD .EQ. 1 ) THEN
                  LIW = 2 * id%NZ + 3 * id%N + 2
               ELSE
                  LIW = 2 * id%NZ + 3 * id%N + 2
               ENDIF
               IF (LIW.LT.3*id%N) LIW = 3*id%N
            ELSE
               COND = (KEEP(60) .NE. 0)
               IF( COND ) THEN
                  LIW = id%N + id%N + 1
               ELSE
                  LIW =  id%N + id%N + id%N+3 + id%N+1
               ENDIF
            ENDIF
            IF (LIW.LT.3*id%N) LIW = 3*id%N
            IF (KEEP(23) .NE. 0) THEN
               IKEEP = id%N + 1
            ELSE
               IKEEP = 1
            END IF
            NA      = IKEEP +     id%N
            NE      = IKEEP + 2 * id%N
            FILS    = IKEEP + 3 * id%N
            FRERE   = FILS  +     id%N
            PTRAR   = FRERE +     id%N
            IF (KEEP(55) .EQ. 0) THEN
               NFSIZ  = PTRAR + 4 * id%N
               MAXIS1_CHECK = NFSIZ + id%N - 1
            ELSE
               NFSIZ  = PTRAR + 2 * (NELT + 1)
               MAXIS1_CHECK = NFSIZ + id%N -1
            ENDIF
            IF ( id%MAXIS1 .LT. MAXIS1_CHECK ) THEN
               IF (LP.GE.0) THEN
                  WRITE(LP,*) '***********************************'
                  WRITE(LP,*) 'MAXIS1 and MAXIS1_CHECK are different !!'
                  WRITE(LP,*) 'MAXIS1, MAXIS1_CHECK=',id%MAXIS1,        &
     &                 MAXIS1_CHECK
                  WRITE(LP,*) 'This might cause problems ...'
                  WRITE(LP,*) '***********************************'
               ENDIF
            END IF
            IF ( IORD .EQ. 1 ) THEN
               DO I = 1, id%N
                  id%IS1( IKEEP + I - 1 ) = id%PERM_IN( I )
               END DO
            END IF
            INFOG(1) = 0
            INFOG(2) = 0
            INFOG(8) = -1
            IF ( .NOT. associated( id%LISTVAR_SCHUR ) ) THEN
               SIZE_SCHUR_PASSED = 1
               LISTVAR_SCHUR_2BE_FREED=.TRUE.
               allocate( id%LISTVAR_SCHUR( 1 ), STAT=ALLOCOK )
               IF ( ALLOCOK .GT. 0 ) THEN
                  WRITE(*,*)                                            &
     &                 'PB allocating an array of size 1 in Schur '
                  CALL AGMG_MUMPS_ABORT()
               END IF
            ELSE
               SIZE_SCHUR_PASSED=id%SIZE_SCHUR
               LISTVAR_SCHUR_2BE_FREED = .FALSE.
            END IF
            IF (KEEP(55) .EQ. 0) THEN
               CALL DAGMG_MUMPS_195(id%N, id%NZ, id%IRN(1), id%JCN(1),       &
     &              LIW, id%IS1(IKEEP),                                 &
     &              id%IS1(PTRAR), IORD, id%IS1(NFSIZ),                 &
     &              id%IS1(FILS), id%IS1(FRERE),                        &
     &              id%LISTVAR_SCHUR(1), SIZE_SCHUR_PASSED,             &
     &              ICNTL(1), INFOG(1), KEEP(1),KEEP8(1),id%NSLAVES,    &
     &              id%SYM,id%IS1(1),id)
               IF ( (KEEP(23).LE.-1).AND.(KEEP(23).GE.-6) ) THEN
                  KEEP(23) = -KEEP(23)
                  IF (.NOT. associated(id%A)) KEEP(23) = 1
                  GOTO 1234
               ENDIF
               INFOG(7)=IORD
            ELSE
               allocate( IWtemp ( 3*id%N ), stat = ierr )
               IF ( ierr .GT. 0 ) THEN
                  INFO( 1 ) = -7
                  INFO( 2 ) = 3*id%N
                  IF ( LP .GT. 0 ) THEN
                     WRITE(LP, 150) 'IWtemp'
                  END IF
                  GOTO 10
               ENDIF
               allocate( XNODEL ( id%N+1 ), stat = ierr )
               IF ( ierr .GT. 0 ) THEN
                  INFO( 1 ) = -7
                  INFO( 2 ) = id%N + 1
                  IF ( LP .GT. 0 ) THEN
                     WRITE(LP, 150) 'XNODEL'
                  END IF
                  GOTO 10
               ENDIF
               IF (LELTVAR.ne.id%ELTPTR(NELT+1)-1)  THEN
                  INFO(1) = -2002
                  INFO(2) = id%ELTPTR(NELT+1)-1
                  GOTO 10
               ENDIF
               allocate( NODEL ( LELTVAR ), stat = ierr )
               IF ( ierr .GT. 0 ) THEN
                  INFO( 1 ) = -7
                  INFO( 2 ) = LELTVAR
                  IF ( LP .GT. 0 ) THEN
                     WRITE(LP, 150) 'NODEL'
                  END IF
                  GOTO 10
               ENDIF
               CALL DAGMG_MUMPS_128(id%N, NELT,                              &
     &              id%ELTPTR(1), id%ELTVAR(1), LIW,                    &
     &              id%IS1(IKEEP),                                      &
     &              IWtemp, IORD, id%IS1(NFSIZ), id%IS1(FILS),          &
     &              id%IS1(FRERE), id%LISTVAR_SCHUR, SIZE_SCHUR_PASSED, &
     &              ICNTL(1), INFOG(1), KEEP(1),KEEP8(1),               &
     &              id%ELTPROC(1), id%NSLAVES,                          &
     &              XNODEL(1), NODEL(1))
               DEALLOCATE(IWtemp)
               INFOG(7)=IORD
            ENDIF
            IF ( LISTVAR_SCHUR_2BE_FREED ) THEN
               deallocate( id%LISTVAR_SCHUR )
               NULLIFY   ( id%LISTVAR_SCHUR )
            ENDIF
            INFO(1)=INFOG(1)
            INFO(2)=INFOG(2)
            KEEP(28) = INFOG(6)
            IF ( INFO(1) .LT. 0 ) THEN
               GO TO 10
            ENDIF
         ENDIF
      ELSE
         IKEEP   = 1
         NA      = IKEEP +     id%N
         NE      = IKEEP + 2 * id%N
         FILS    = IKEEP + 3 * id%N
         FRERE   = FILS  +     id%N
         PTRAR   = FRERE +     id%N
         NFSIZ   = PTRAR + 4 * id%N
         IF(id%MYID .EQ. MASTER) THEN
            WORK1PTR => id%IS1(IKEEP : IKEEP + 3*id%N-1)
            WORK2PTR => id%IS1(PTRAR : PTRAR + 4*id%N-1)
            NFSIZPTR => id%IS1(NFSIZ : NFSIZ + id%N-1)
            FILSPTR  => id%IS1(FILS  : FILS  + id%N-1)
            FREREPTR => id%IS1(FRERE : FRERE + id%N-1)
         ELSE
            ALLOCATE(WORK1PTR(3*id%N))
            ALLOCATE(WORK2PTR(4*id%N))
         END IF
         CALL DAGMG_MUMPS_715(id,                                            &
     &        WORK1PTR,                                                 &
     &        WORK2PTR,                                                 &
     &        NFSIZPTR,                                                 &
     &        FILSPTR,                                                  &
     &        FREREPTR)
         IF(id%MYID .EQ. 0) THEN
            NULLIFY(WORK1PTR, WORK2PTR, NFSIZPTR)
            NULLIFY(FILSPTR, FREREPTR)
         ELSE
            DEALLOCATE(WORK1PTR, WORK2PTR)
         END IF
         KEEP(28) = INFOG(6)
      END IF
   10 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO, id%COMM, id%MYID )
      IF ( INFO(1) < 0 ) RETURN
      IF(id%MYID .EQ. MASTER) THEN
         CALL AGMG_MUMPS_633(KEEP(12),ICNTL(14),                             &
     &        KEEP(50),KEEP(54),ICNTL(6),KEEP(52))
         CALL DAGMG_MUMPS_348(id%N, id%IS1(FILS), id%IS1(FRERE),             &
     &        id%IS1(IKEEP+2*id%N), id%IS1(IKEEP+id%N))
         IF (id%NSLAVES .EQ. 1) THEN
            id%NBSA = 0
            IF ( (id%KEEP(60).EQ.0).AND.(id%KEEP(53).EQ.0))  THEN
               id%KEEP(20)=0
               id%KEEP(38)=0
            ENDIF
            id%KEEP(56)=0
            id%PROCNODE = 0
            IF (id%KEEP(60) .EQ. 2 .OR. id%KEEP(60).EQ.3) THEN
               CALL DAGMG_MUMPS_564(id%KEEP(38), id%PROCNODE(1),             &
     &              1+2*id%NSLAVES, id%IS1(FILS),id%N)
            ENDIF
         ELSE
       PEAK = dble(id%INFOG(5))*dble(id%INFOG(5)) +                     &
     &        dble(id%KEEP(2))*dble(id%KEEP(2))
            SSARBR => id%IS1(IKEEP:IKEEP+id%N-1)
            call DAGMG_MUMPS_537(id%N,id%NSLAVES,ICNTL,                      &
     &           INFOG,                                                 &
     &           id%IS1(NE),                                            &
     &           id%IS1(NFSIZ),                                         &
     &           id%IS1(FRERE),                                         &
     &           id%IS1(FILS),                                          &
     &           KEEP,KEEP8,id%PROCNODE(1),                             &
     &           SSARBR(1),id%NBSA,PEAK,ierr                            &
     &           )
            NULLIFY(SSARBR)
            if(ierr.eq.-999) then
               write(6,*) ' Internal error in MUMPS_369'
               INFO(1) = ierr
               GOTO 11
            ENDIF
            IF(IERR.NE.0) THEN
               INFO(1) = -135
               INFO(2) = ierr
               GOTO 11
            ENDIF
            CALL DAGMG_MUMPS_348(id%N, id%IS1(FILS),                         &
     &           id%IS1(FRERE), id%IS1(IKEEP+2*id%N),                   &
     &           id%IS1(IKEEP+id%N))
         ENDIF
   11    CONTINUE
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO, id%COMM, id%MYID )
      IF ( INFO(1) < 0 ) RETURN
      CALL AGMG_SETIERR( ierr )
      IF (KEEP(55) .EQ. 0) THEN
         if (associated(id%FRTPTR)) DEALLOCATE(id%FRTPTR)
         if (associated(id%FRTELT)) DEALLOCATE(id%FRTELT)
         allocate( id%FRTPTR(1), id%FRTELT(1) )
      ELSE
         LPTRAR = id%NELT+id%NELT+2
         CALL AGMG_MUMPS_733(id%PTRAR, LPTRAR, id%INFO, LP,                  &
     &        FORCE=.TRUE., STRING='id%PTRAR (Analysis)', ERRCODE=-7)
         CALL AGMG_MUMPS_733(id%FRTPTR, id%N+1, id%INFO, LP,                 &
     &        FORCE=.TRUE., STRING='id%FRTPTR (Analysis)', ERRCODE=-7)
         CALL AGMG_MUMPS_733(id%FRTELT, id%NELT, id%INFO, LP,                &
     &        FORCE=.TRUE., STRING='id%FRTELT (Analysis)', ERRCODE=-7)
         CALL AGMG_MUMPS_276( ICNTL, INFO, id%COMM, id%MYID )
         IF ( INFO(1) < 0 ) RETURN
         IF(id%MYID .EQ. MASTER) THEN
            CALL DAGMG_MUMPS_153(                                            &
     &           id%N, NELT, id%ELTPTR(NELT+1)-1, id%IS1(FRERE),        &
     &           id%IS1(FILS),                                          &
     &           id%IS1(IKEEP+id%N), id%IS1(IKEEP+2*id%N), XNODEL,      &
     &           NODEL, id%FRTPTR(1), id%FRTELT(1), id%ELTPROC(1))
            DO I=1, id%NELT+1
               id%PTRAR(id%NELT+I+1)=id%ELTPTR(I)
            ENDDO
            deallocate(XNODEL)
            deallocate(NODEL)
         END IF
         CALL AGMG_SETIERR( ierr )
         CALL AGMG_SETIERR( ierr )
         CALL AGMG_SETIERR( ierr )
      ENDIF
      IF(id%MYID .EQ. MASTER) THEN
         IF ( INFO( 1 ) .LT. 0 ) GOTO 12
         IF ( KEEP(55) .ne. 0 ) THEN
            CALL DAGMG_MUMPS_120(id%N, NELT, id%ELTPROC(1),id%NSLAVES,       &
     &           id%PROCNODE)
         END IF
         NB_NIV2 = KEEP(56)
         IF ( NB_NIV2.GT.0 ) THEN
            allocate(PAR2_NODES(NB_NIV2),                               &
     &           STAT=ALLOCOK)
            IF (ALLOCOK .GT.0) then
               INFO(1)= -7
               INFO(2)= NB_NIV2
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'PAR2_NODES'
               END IF
               GOTO 12
            END IF
         ENDIF
         IF ((NB_NIV2.GT.0) .AND. (KEEP(24).EQ.0)) THEN
            INIV2 = 0
            DO 777 INODE = 1, id%N
               IF ( ( id%IS1(FRERE+INODE-1) .NE. id%N+1 ) .AND.         &
     &              ( AGMG_MUMPS_330(INODE,id%PROCNODE(1),id%NSLAVES)        &
     &              .eq. 2) ) THEN
                  INIV2 = INIV2 + 1
                  PAR2_NODES(INIV2) = INODE
               END IF
  777       CONTINUE
            IF ( INIV2 .NE. NB_NIV2 ) THEN
               WRITE(*,*) "Internal Error 2 in DAGMG_MUMPS_26",              &
     &              INIV2, NB_NIV2
               CALL AGMG_MUMPS_ABORT()
            ENDIF
         ENDIF
         IF ( (KEEP(24) .NE. 0) .AND. (NB_NIV2.GT.0) ) THEN
            IF ( associated(id%CANDIDATES)) deallocate(id%CANDIDATES)
            allocate( id%CANDIDATES(id%NSLAVES+1,NB_NIV2),              &
     &           stat=allocok)
            if (allocok .gt.0) then
               INFO(1)= -7
               INFO(2)= NB_NIV2*(id%NSLAVES+1)
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'CANDIDATES'
               END IF
               GOTO 12
            END IF
            CALL AGMG_MUMPS_393                                              &
     &           (PAR2_NODES,id%CANDIDATES,ierr)
            IF(IERR.NE.0)  THEN
               INFO(1) = -2002
               GOTO 12
            ENDIF
            CALL AGMG_MUMPS_494()
            IF(IERR.NE.0)  THEN
               INFO(1) = -2002
               GOTO 12
            ENDIF
         ELSE
            allocate(id%CANDIDATES(1,1), stat=allocok)
            IF (allocok .NE. 0) THEN
               INFO(1)= -7
               INFO(2)= 1
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'CANDIDATES'
               END IF
               GOTO 12
            ENDIF
         ENDIF
   12    CONTINUE
         KEEP(84) = ICNTL(27)
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO, id%COMM, id%MYID )
      IF ( INFO(1) < 0 ) RETURN
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_MUMPS_749( id%KEEP8(21), MASTER,                             &
     &                     id%MYID, id%COMM, IERR)
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      IF (id%MYID==MASTER) KEEP(127)=INFOG(5)
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_MUMPS_733(id%STEP, id%N, id%INFO, LP, FORCE=.TRUE.,          &
     &     STRING='id%STEP (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%PROCNODE_STEPS, id%KEEP(28), id%INFO, LP,       &
     &     FORCE=.TRUE.,                                                &
     &     STRING='id%PROCNODE_STEPS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%NE_STEPS, id%KEEP(28), id%INFO, LP,             &
     &     FORCE=.TRUE.,                                                &
     &     STRING='id%NE_STEPS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%ND_STEPS, id%KEEP(28), id%INFO, LP,             &
     &     FORCE=.TRUE.,                                                &
     &     STRING='id%ND_STEPS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%FRERE_STEPS, id%KEEP(28), id%INFO, LP,          &
     &     FORCE=.TRUE.,                                                &
     &     STRING='id%FRERE_STEPS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%DAD_STEPS, id%KEEP(28), id%INFO, LP,            &
     &     FORCE=.TRUE.,                                                &
     &     STRING='id%DAD_STEPS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%FILS, id%N, id%INFO, LP, FORCE=.TRUE.,          &
     &     STRING='id%FILS (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      CALL AGMG_MUMPS_733(id%SYM_PERM, id%N, id%INFO, LP, FORCE=.TRUE.,      &
     &     STRING='id%SYM_PERM (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 94
      IF (KEEP(55) .EQ. 0) THEN
        LPTRAR = id%N+id%N
        CALL AGMG_MUMPS_733(id%PTRAR, LPTRAR, id%INFO, LP, FORCE=.TRUE.,     &
     &       STRING='id%PTRAR (Analysis)', ERRCODE=-7)
        IF(INFO(1).LT.0) GOTO 94
      ENDIF
      IF ( associated( id%UNS_PERM ) ) deallocate(id%UNS_PERM)
      IF ( id%MYID == MASTER .AND. id%KEEP(23) .NE. 0 ) THEN
         allocate(id%UNS_PERM(id%N),stat=allocok)
         IF ( allocok .ne. 0) THEN
            INFO(1) = -7
            INFO(2) = id%N
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%UNS_PERM'
            END IF
            GOTO 94
         ENDIF
         DO I=1,id%N
            id%UNS_PERM(I) = id%IS1(I)
         END DO
      ENDIF
   94 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( id%MYID .EQ. MASTER ) THEN
         DO I=1,id%N
            id%FILS(I) = id%IS1(FILS+I-1)
         ENDDO
      END IF
      IF (id%MYID .EQ. MASTER ) THEN
         IF (id%N.eq.1) THEN
            NBROOT = 1
            NBLEAF = 1
         ELSE IF (id%IS1(NA+id%N-1) .LT.0) THEN
            NBLEAF = id%N
            NBROOT = id%N
         ELSE IF (id%IS1(NA+id%N-2) .LT.0) THEN
            NBLEAF = id%N-1
            NBROOT = id%IS1(NA+id%N-1)
         ELSE
            NBLEAF = id%IS1(NA+id%N-2)
            NBROOT = id%IS1(NA+id%N-1)
         ENDIF
         id%LNA = 2+NBLEAF+NBROOT
      ENDIF
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_MUMPS_733(id%NA, id%LNA, id%INFO, LP, FORCE=.TRUE.,          &
     &     STRING='id%NA (Analysis)', ERRCODE=-7)
      IF(INFO(1).LT.0) GOTO 96
      IF (id%MYID .EQ.MASTER ) THEN
         id%NA(1) = NBLEAF
         id%NA(2) = NBROOT
         LEAF = 3
         IF ( id%N == 1 ) THEN
            id%NA(LEAF) = 1
            LEAF = LEAF + 1
         ELSE IF (id%IS1(NA+id%N-1) < 0) THEN
            id%NA(LEAF) = - id%IS1(NA+id%N-1)-1
            LEAF = LEAF + 1
            DO I = 1, NBLEAF - 1
               id%NA(LEAF) = id%IS1(NA+I-1)
               LEAF = LEAF + 1
            ENDDO
         ELSE IF (id%IS1(NA+id%N-2) < 0 ) THEN
            INODE = - id%IS1(NA+id%N-2) - 1
            id%NA(LEAF) = INODE
            LEAF =LEAF + 1
            IF ( NBLEAF > 1 ) THEN
               DO I = 1, NBLEAF - 1
                  id%NA(LEAF) = id%IS1(NA+I-1)
                  LEAF = LEAF + 1
               ENDDO
            ENDIF
         ELSE
            DO I = 1, NBLEAF
               id%NA(LEAF) = id%IS1(NA+I-1)
               LEAF = LEAF + 1
            ENDDO
         END IF
      END IF
   96 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) RETURN
      IF ( id%MYID .EQ. MASTER ) THEN
         ISTEP = 0
         DO I = 1, id%N
            IF ( id%IS1(FRERE+I-1) .ne. id%N + 1 ) THEN
               ISTEP = ISTEP + 1
               id%STEP(I)=ISTEP
               INN = id%IS1(FILS+I-1)
               DO WHILE ( INN .GT. 0 )
                  id%STEP(INN) = - ISTEP
                  INN = id%IS1(FILS + INN -1)
               END DO
               IF (id%IS1(FRERE+I-1) .eq. 0) THEN
                  id%NA(LEAF) = I
                  LEAF = LEAF + 1
               ENDIF
            ENDIF
         END DO
         IF ( LEAF - 1 .NE. 2+NBROOT + NBLEAF ) THEN
            WRITE(*,*) 'Internal error 2 in DMUMPS_26'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         IF ( ISTEP .NE. id%KEEP(28) ) THEN
            write(*,*) 'Internal error 3 in DMUMPS_26'
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         DO I = 1, id%N
            IF (id%IS1(FRERE+I-1) .NE. id%N+1) THEN
               id%PROCNODE_STEPS(id%STEP(I)) = id%PROCNODE( I )
               id%FRERE_STEPS(id%STEP(I))    = id%IS1(FRERE+I-1)
               id%NE_STEPS(id%STEP(I))    = id%IS1(NE+I-1)
               id%ND_STEPS(id%STEP(I))    = id%IS1(NFSIZ+I-1)
            ENDIF
         ENDDO
         DO I = 1, id%N
            IF ( id%STEP(I) .LE. 0) CYCLE
            IF (id%IS1(FRERE+I-1) .eq. 0) THEN
               id%DAD_STEPS(id%STEP(I)) = 0
            ENDIF
            IFS = id%IS1(FILS+I-1)
            DO WHILE ( IFS .GT. 0 )
               IFS= id%IS1(FILS + IFS -1)
            END DO
            IFS = -IFS
            DO WHILE (IFS.GT.0)
               id%DAD_STEPS(id%STEP(IFS)) = I
               IFS   = id%IS1(FRERE+IFS-1)
            ENDDO
         END DO
         CALL DAGMG_MUMPS_181(id%N, id%IS1(NA),                              &
     &        id%IS1(NE), id%SYM_PERM(1),                               &
     &        id%IS1(FILS), id%DAD_STEPS,                               &
     &        id%STEP, id%KEEP(28) )
         deallocate(id%PROCNODE)
         NULLIFY(id%PROCNODE)
         deallocate(id%IS1)
         NULLIFY(id%IS1)
         IF (( id%KEEP(70) .NE. -1 ).OR.(id%KEEP(47).EQ.4).OR.          &
     &        (( id%KEEP(81) .GT. 0).AND.(id%KEEP(47).GE.2)))           &
     &        THEN
            IS_REORDERTREE_CALLED=.TRUE.
            IF ((id%KEEP(47) .EQ. 4).OR.                                &
     &           (( id%KEEP(81) .GT. 0).AND.(id%KEEP(47).GE.2))) THEN
               IF(id%NSLAVES.GT.1) THEN
                  SIZE_TEMP_MEM = id%NBSA
               ELSE
                  SIZE_TEMP_MEM = id%NA(2)
               ENDIF
            ELSE
               SIZE_TEMP_MEM = 1
            ENDIF
            IF(id%KEEP(76).EQ.4)THEN
               SIZE_DEPTH_FIRST=id%KEEP(28)
            ELSE
               SIZE_DEPTH_FIRST=1
            ENDIF
            allocate(TEMP_MEM(SIZE_TEMP_MEM,id%NSLAVES),STAT=ALLOCOK)
            IF (ALLOCOK .NE.0) THEN
               INFO(1)= -7
               INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'TEMP_MEM'
               END IF
               GOTO 80
            END IF
            allocate(TEMP_LEAF(SIZE_TEMP_MEM,id%NSLAVES),               &
     &           stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'TEMP_LEAF'
               END IF
               INFO(1)= -7
               INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
               GOTO 80
            end if
            allocate(TEMP_SIZE(SIZE_TEMP_MEM,id%NSLAVES),               &
     &           stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'TEMP_SIZE'
               END IF
               INFO(1)= -7
               INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
               GOTO 80
            end if
            allocate(TEMP_ROOT(SIZE_TEMP_MEM,id%NSLAVES),               &
     &           stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'TEMP_ROOT'
               END IF
               INFO(1)= -7
               INFO(2)= SIZE_TEMP_MEM*id%NSLAVES
               GOTO 80
            end if
            allocate(DEPTH_FIRST(SIZE_DEPTH_FIRST),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'DEPTH_FIRST'
               END IF
               INFO(1)= -7
               INFO(2)= SIZE_DEPTH_FIRST
               GOTO 80
            end if
            IF(id%KEEP(76).EQ.5)THEN
               SIZE_COST_TRAV=id%KEEP(28)
            ELSE
               SIZE_COST_TRAV=1
            ENDIF
            allocate(COST_TRAV_TMP(SIZE_COST_TRAV),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'COST_TRAV_TMP'
               END IF
               INFO(1)= -7
               INFO(2)= SIZE_COST_TRAV
               GOTO 80
            END IF
            IF(id%KEEP(76).EQ.5)THEN
               IF(id%KEEP(70).EQ.0)THEN
                  id%KEEP(70)=5
               ENDIF
               IF(id%KEEP(70).EQ.1)THEN
                  id%KEEP(70)=6
               ENDIF
            ENDIF
            IF(id%KEEP(76).EQ.4)THEN
               IF(id%KEEP(70).EQ.0)THEN
                  id%KEEP(70)=3
               ENDIF
               IF(id%KEEP(70).EQ.1)THEN
                  id%KEEP(70)=4
               ENDIF
            ENDIF
               CALL DAGMG_MUMPS_363(id%N, id%FRERE_STEPS(1),                 &
     &              id%STEP(1),id%FILS(1), id%NA(1), id%LNA,            &
     &              id%NE_STEPS(1), id%ND_STEPS(1), id%DAD_STEPS,       &
     &              id%KEEP(28), .TRUE., id%KEEP(28), id%KEEP(70),      &
     &              id%KEEP(50), id%INFO(1), id%ICNTL(1),id%KEEP(47),   &
     &              id%KEEP(81),id%KEEP(76),id%KEEP(215),               &
     &              id%KEEP(234), id%KEEP(55),                          &
     &              id%PROCNODE_STEPS(1),TEMP_MEM,id%NSLAVES,           &
     &              SIZE_TEMP_MEM, PEAK,id%KEEP(90),SIZE_DEPTH_FIRST,   &
     &              SIZE_COST_TRAV,DEPTH_FIRST(1),COST_TRAV_TMP(1),     &
     &              TEMP_LEAF,TEMP_SIZE,TEMP_ROOT                       &
     &              )
         END IF
      ENDIF
   80 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) RETURN
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr)
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      CALL AGMG_SETIERR( ierr )
      IF (KEEP(55) .EQ. 0) THEN
         CALL DAGMG_MUMPS_746(id, id%PTRAR)
         IF(id%MYID .EQ. MASTER) THEN
            IF ( (KEEP(244) .EQ. 1) .AND. (KEEP(54) .EQ. 3) ) THEN
               DEALLOCATE( id%IRN )
               DEALLOCATE( id%JCN )
            END IF
         END IF
      ENDIF
      IF(id%KEEP(76).EQ.4)THEN
         IF(associated(id%DEPTH_FIRST))                                 &
     &        deallocate(id%DEPTH_FIRST)
         allocate(id%DEPTH_FIRST(id%KEEP(28)),stat=allocok)
         IF (allocok .ne.0) then
            INFO(1)= -7
            INFO(2)= id%KEEP(28)
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%DEPTH_FIRST'
            END IF
            GOTO 87
         END IF
         IF(id%MYID.EQ.MASTER)THEN
            id%DEPTH_FIRST(1:id%KEEP(28))=DEPTH_FIRST(1:id%KEEP(28))
         ENDIF
         CALL AGMG_SETIERR( ierr )
      ELSE
         IF(associated(id%DEPTH_FIRST))                                 &
     &        deallocate(id%DEPTH_FIRST)
         allocate(id%DEPTH_FIRST(1),stat=allocok)
         IF (allocok .ne.0) then
            INFO(1)= -7
            INFO(2)= 1
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%DEPTH_FIRST'
            END IF
            GOTO 87
         END IF
         id%DEPTH_FIRST(1)=0
      ENDIF
      IF(id%KEEP(76).EQ.5)THEN
         IF(associated(id%COST_TRAV))                                   &
     &        deallocate(id%COST_TRAV)
         allocate(id%COST_TRAV(id%KEEP(28)),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%COST_TRAV'
            END IF
            INFO(1)= -7
            INFO(2)= id%KEEP(28)
            GOTO 87
         END IF
         IF(id%MYID.EQ.MASTER)THEN
            id%COST_TRAV(1:id%KEEP(28))=COST_TRAV_TMP(1:id%KEEP(28))
         ENDIF
         CALL AGMG_SETIERR( ierr )
      ELSE
         IF(associated(id%COST_TRAV))                                   &
     &        deallocate(id%COST_TRAV)
         allocate(id%COST_TRAV(1),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%COST_TRAV(1)'
            END IF
            INFO(1)= -7
            INFO(2)= 1
            GOTO 87
         END IF
         id%COST_TRAV(1)=0.0d0
      ENDIF
      IF (id%KEEP(47) .EQ. 4 .OR.                                       &
     &     ((id%KEEP(81) .GT. 0).AND.(id%KEEP(47).GE.2))) THEN
         IF(id%MYID .EQ. MASTER)THEN
            DO K=1,id%NSLAVES
               DO J=1,SIZE_TEMP_MEM
                  IF(TEMP_MEM(J,K) < 0.0D0) GOTO 666
               ENDDO
  666          CONTINUE
               J=J-1
               IF (id%KEEP(46) == 1) THEN
                  IDEST = K - 1
               ELSE
                  IDEST = K
               ENDIF
               IF (IDEST .NE. MASTER) THEN
                  CALL AGMG_NOCALL('MPI_SEND')
                  CALL AGMG_NOCALL('MPI_SEND')
                  CALL AGMG_NOCALL('MPI_SEND')
                  CALL AGMG_NOCALL('MPI_SEND')
                  CALL AGMG_NOCALL('MPI_SEND')
               ELSE
                  IF(associated(id%MEM_SUBTREE))                        &
     &                 deallocate(id%MEM_SUBTREE)
                  allocate(id%MEM_SUBTREE(J),stat=allocok)
                  IF (allocok .ne.0) then
                     IF ( LP .GT. 0 ) THEN
                        WRITE(LP, 150) 'id%MEM_SUBTREE'
                     END IF
                     INFO(1)= -7
                     INFO(2)= J
                     GOTO 87
                  END IF
                  id%NBSA_LOCAL = J
                  id%MEM_SUBTREE(1:J)=TEMP_MEM(1:J,1)
                  IF(associated(id%MY_ROOT_SBTR))                       &
     &                 deallocate(id%MY_ROOT_SBTR)
                  allocate(id%MY_ROOT_SBTR(J),stat=allocok)
                  IF (allocok .ne.0) then
                     IF ( LP .GT. 0 ) THEN
                        WRITE(LP, 150) 'id%MY_ROOT_SBTR'
                     END IF
                     INFO(1)= -7
                     INFO(2)= J
                     GOTO 87
                  END IF
                  id%MY_ROOT_SBTR(1:J)=TEMP_ROOT(1:J,1)
                  IF(associated(id%MY_FIRST_LEAF))                      &
     &                 deallocate(id%MY_FIRST_LEAF)
                  allocate(id%MY_FIRST_LEAF(J),stat=allocok)
                  IF (allocok .ne.0) then
                     IF ( LP .GT. 0 ) THEN
                        WRITE(LP, 150) 'id%MY_FIRST_LEAF'
                     END IF
                     INFO(1)= -7
                     INFO(2)= J
                     GOTO 87
                  END IF
                  id%MY_FIRST_LEAF(1:J)=TEMP_LEAF(1:J,1)
                  IF(associated(id%MY_NB_LEAF))                         &
     &                 deallocate(id%MY_NB_LEAF)
                  allocate(id%MY_NB_LEAF(J),stat=allocok)
                  IF (allocok .ne.0) then
                     IF ( LP .GT. 0 ) THEN
                        WRITE(LP, 150) 'id%MY_NB_LEAF'
                     END IF
                     INFO(1)= -7
                     INFO(2)= J
                     GOTO 87
                  END IF
                  id%MY_NB_LEAF(1:J)=TEMP_SIZE(1:J,1)
               ENDIF
            ENDDO
         ELSE
            CALL AGMG_NOCALL('MPI_RECV')
            IF(associated(id%MEM_SUBTREE))                              &
     &           deallocate(id%MEM_SUBTREE)
            allocate(id%MEM_SUBTREE(id%NBSA_LOCAL),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'id%MEM_SUBTREE'
               END IF
               INFO(1)= -7
               INFO(2)= id%NBSA_LOCAL
               GOTO 87
            END IF
            IF(associated(id%MY_ROOT_SBTR))                             &
     &           deallocate(id%MY_ROOT_SBTR)
            allocate(id%MY_ROOT_SBTR(id%NBSA_LOCAL),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'id%MY_ROOT_SBTR'
               END IF
               INFO(1)= -7
               INFO(2)= id%NBSA_LOCAL
               GOTO 87
            END IF
            IF(associated(id%MY_FIRST_LEAF))                            &
     &           deallocate(id%MY_FIRST_LEAF)
            allocate(id%MY_FIRST_LEAF(id%NBSA_LOCAL),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'MY_FIRST_LEAF'
               END IF
               INFO(1)= -7
               INFO(2)= id%NBSA_LOCAL
               GOTO 87
            END IF
            IF(associated(id%MY_NB_LEAF))                               &
     &           deallocate(id%MY_NB_LEAF)
            allocate(id%MY_NB_LEAF(id%NBSA_LOCAL),stat=allocok)
            IF (allocok .ne.0) then
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'MY_NB_LEAF'
               END IF
               INFO(1)= -7
               INFO(2)= id%NBSA_LOCAL
               GOTO 87
            END IF
            CALL AGMG_NOCALL('MPI_RECV')
            CALL AGMG_NOCALL('MPI_RECV')
            CALL AGMG_NOCALL('MPI_RECV')
            CALL AGMG_NOCALL('MPI_RECV')
         ENDIF
      ELSE
         id%NBSA_LOCAL = -999999
         IF(associated(id%MEM_SUBTREE))                                 &
     &        deallocate(id%MEM_SUBTREE)
         allocate(id%MEM_SUBTREE(1),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%MEM_SUBTREE(1)'
            END IF
            INFO(1)= -7
            INFO(2)= 1
            GOTO 87
         END IF
         IF(associated(id%MY_ROOT_SBTR))                                &
     &        deallocate(id%MY_ROOT_SBTR)
         allocate(id%MY_ROOT_SBTR(1),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%MY_ROOT_SBTR(1)'
            END IF
            INFO(1)= -7
            INFO(2)= 1
            GOTO 87
         END IF
         IF(associated(id%MY_FIRST_LEAF))                               &
     &        deallocate(id%MY_FIRST_LEAF)
         allocate(id%MY_FIRST_LEAF(1),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%MY_FIRST_LEAF(1)'
            END IF
            INFO(1)= -7
            INFO(2)= 1
            GOTO 87
         END IF
         IF(associated(id%MY_NB_LEAF))                                  &
     &        deallocate(id%MY_NB_LEAF)
         allocate(id%MY_NB_LEAF(1),stat=allocok)
         IF (allocok .ne.0) then
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%MY_NB_LEAF(1)'
            END IF
            INFO(1)= -7
            INFO(2)= 1
            GOTO 87
         END IF
      ENDIF
      IF(id%MYID.EQ.MASTER)THEN
         IF(IS_REORDERTREE_CALLED)THEN
            deallocate(TEMP_MEM)
            deallocate(TEMP_SIZE)
            deallocate(TEMP_ROOT)
            deallocate(TEMP_LEAF)
            deallocate(COST_TRAV_TMP)
            deallocate(DEPTH_FIRST)
         ENDIF
      ENDIF
   87 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) RETURN
      NB_NIV2 = KEEP(56)
      IF (  NB_NIV2.GT.0  ) THEN
         if (id%MYID.ne.MASTER) then
            IF (associated(id%CANDIDATES)) deallocate(id%CANDIDATES)
            allocate(PAR2_NODES(NB_NIV2),                               &
     &           id%CANDIDATES(id%NSLAVES+1,NB_NIV2),                   &
     &           STAT=allocok)
            IF (allocok .ne.0) then
               INFO(1)= -7
               INFO(2)= NB_NIV2*(id%NSLAVES+1)
               IF ( LP .GT. 0 ) THEN
                  WRITE(LP, 150) 'PAR2_NODES/id%CANDIDATES'
               END IF
            end if
         end if
         CALL AGMG_MUMPS_276( ICNTL, INFO,                                   &
     &        id%COMM, id%MYID )
         IF ( INFO(1).LT.0 ) RETURN
         CALL AGMG_SETIERR( ierr )
         IF (KEEP(24) .NE.0 ) THEN
            CALL AGMG_SETIERR( ierr )
         ENDIF
      ENDIF
      IF ( associated(id%ISTEP_TO_INIV2)) THEN
         deallocate(id%ISTEP_TO_INIV2)
         NULLIFY(id%ISTEP_TO_INIV2)
      ENDIF
      IF ( associated(id%I_AM_CAND)) THEN
         deallocate(id%I_AM_CAND)
         NULLIFY(id%I_AM_CAND)
      ENDIF
      IF (NB_NIV2.EQ.0) THEN
         id%KEEP(71) = 1
      ELSE
         id%KEEP(71) = id%KEEP(28)
      ENDIF
      allocate(id%ISTEP_TO_INIV2(id%KEEP(71)),                          &
     &     id%I_AM_CAND(max(NB_NIV2,1)),                                &
     &     stat=allocok)
      IF (allocok .gt.0) THEN
         IF ( LP .GT. 0 ) THEN
            WRITE(LP, 150) 'id%ISTEP_TO_INIV2'
            WRITE(LP, 150) 'id%TAB_POS_IN_PERE'
         END IF
         INFO(1)= -7
         IF (NB_NIV2.EQ.0) THEN
            INFO(2)= 2
         ELSE
            INFO(2)= id%KEEP(28)+NB_NIV2*(id%NSLAVES+2)
         END IF
         GOTO 321
      ENDIF
      IF ( NB_NIV2 .GT.0 ) THEN
         DO INIV2 = 1, NB_NIV2
            INN = PAR2_NODES(INIV2)
            id%ISTEP_TO_INIV2(id%STEP(INN)) = INIV2
         END DO
         CALL DAGMG_MUMPS_649( id%NSLAVES,                                   &
     &        NB_NIV2, id%MYID_NODES,                                   &
     &        id%CANDIDATES(1,1), id%I_AM_CAND(1) )
      ENDIF
      IF (associated(id%FUTURE_NIV2)) THEN
         deallocate(id%FUTURE_NIV2)
         NULLIFY(id%FUTURE_NIV2)
      ENDIF
      allocate(id%FUTURE_NIV2(id%NSLAVES), stat=allocok)
      IF (allocok .gt.0) THEN
         IF ( LP .GT. 0 ) THEN
            WRITE(LP, 150) 'FUTURE_NIV2'
         END IF
         INFO(1)= -7
         INFO(2)= id%NSLAVES
         GOTO 321
      ENDIF
      id%FUTURE_NIV2=0
      DO INIV2 = 1, NB_NIV2
         IDEST = AGMG_MUMPS_275(id%STEP(PAR2_NODES(INIV2)),                  &
     &        id%PROCNODE_STEPS,                                        &
     &        id%NSLAVES)
         id%FUTURE_NIV2(IDEST+1)=id%FUTURE_NIV2(IDEST+1)+1
      ENDDO
      IF ( I_AM_SLAVE ) THEN
         IF ( associated(id%TAB_POS_IN_PERE)) THEN
            deallocate(id%TAB_POS_IN_PERE)
            NULLIFY(id%TAB_POS_IN_PERE)
         ENDIF
         allocate(id%TAB_POS_IN_PERE(id%NSLAVES+2,max(NB_NIV2,1)),      &
     &        stat=allocok)
         IF (allocok .gt.0) THEN
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%ISTEP_TO_INIV2'
               WRITE(LP, 150) 'id%TAB_POS_IN_PERE'
            END IF
            INFO(1)= -7
            IF (NB_NIV2.EQ.0) THEN
               INFO(2)= 2
            ELSE
               INFO(2)= id%KEEP(28)+NB_NIV2*(id%NSLAVES+2)
            END IF
            GOTO 321
         ENDIF
      END IF
      IF (NB_NIV2.GT.0) deallocate (PAR2_NODES)
  321 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) RETURN
      IF ( KEEP(23).NE.0 .and. id%MYID .EQ. MASTER ) THEN
         IKEEP = id%N + 1
      ELSE
         IKEEP = 1
      END IF
      FILS   = IKEEP + 3 * id%N
      NE     = IKEEP + 2 * id%N
      NA     = IKEEP +     id%N
      FRERE  = FILS  + id%N
      PTRAR  = FRERE + id%N
      IF (KEEP(55) .EQ. 0) THEN
         IF ( id%MYID.EQ.MASTER ) THEN
            NFSIZ   = PTRAR  + 4 * id%N
         ELSE
            NFSIZ   = PTRAR  + 2 * id%N
         ENDIF
      ELSE
         NFSIZ   = PTRAR  + 2 * (NELT + 1)
      END IF
      IF ( KEEP(38) .NE. 0 ) THEN
         CALL DAGMG_MUMPS_164( id%MYID,                                      &
     &        id%NSLAVES, id%N, id%root,                                &
     &        id%COMM_NODES, KEEP( 38 ), id%FILS(1),                    &
     &        id%KEEP(50), id%KEEP(46),                                 &
     &        id%KEEP(51)                                               &
     &        , id%KEEP(60), id%NPROW, id%NPCOL, id%MBLOCK, id%NBLOCK   &
     &        )
      ELSE
         id%root%yes = .FALSE.
      END IF
      IF ( KEEP(38) .NE. 0 .and. I_AM_SLAVE ) THEN
         CALL AGMG_COPY(id%root%MYROW, MYROW_CHECK, 1,                              AGMG_MPF_INTEGER, ierr)
         IF ( MYROW_CHECK .eq. -1) THEN
            INFO(1) = -25
            INFO(2) = 0
         END IF
         IF ( id%root%MYROW .LT. -1 .OR.                                &
     &        id%root%MYCOL .LT. -1 ) THEN
            INFO(1) = -25
            INFO(2) = 0
         END IF
         IF ( LP > 0 .AND. INFO(1) == -25 ) THEN
            WRITE(LP, '(A)')                                            &
     &           'Problem with your version of the BLACS.'
            WRITE(LP, '(A)') 'Try using a BLACS version from netlib.'
         ENDIF
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) RETURN
      IF ( I_AM_SLAVE ) THEN
         IF (KEEP(55) .EQ. 0) THEN
            CALL DAGMG_MUMPS_24( id%MYID,                                    &
     &           id%NSLAVES, id%N, id%PROCNODE_STEPS(1),                &
     &           id%STEP(1), id%PTRAR(1),                               &
     &           id%PTRAR(id%N +1),                                     &
     &           id%ISTEP_TO_INIV2(1), id%I_AM_CAND(1),                 &
     &           KEEP(1),KEEP8(1), ICNTL, id )
         ELSE
            CALL DAGMG_MUMPS_25( id%MYID,                                    &
     &           id%NSLAVES, id%N, id%PROCNODE_STEPS(1),                &
     &           id%STEP(1),                                            &
     &           id%PTRAR(1),                                           &
     &           id%PTRAR(id%NELT+2 ),                                  &
     &           id%NELT,                                               &
     &           id%FRTPTR(1), id%FRTELT(1),                            &
     &           KEEP(1), KEEP8(1), ICNTL, id%SYM )
         ENDIF
      ENDIF
      IF ( I_AM_SLAVE ) THEN
            IF ( id%root%yes ) THEN
               LOCAL_M = NUMROC_FOOL( id%ND_STEPS(id%STEP(KEEP(38))),        &
     &              id%root%MBLOCK, id%root%MYROW, 0,                   &
     &              id%root%NPROW )
               LOCAL_M = max(1, LOCAL_M)
               LOCAL_N = NUMROC_FOOL( id%ND_STEPS(id%STEP(KEEP(38))),        &
     &              id%root%NBLOCK, id%root%MYCOL, 0,                   &
     &              id%root%NPCOL )
            ELSE
               LOCAL_M = 0
               LOCAL_N = 0
            END IF
            IF  ( KEEP(60) .EQ. 2 .OR. KEEP(60) .EQ. 3 ) THEN
               id%SCHUR_MLOC=LOCAL_M
               id%SCHUR_NLOC=LOCAL_N
               id%root%SCHUR_MLOC=LOCAL_M
               id%root%SCHUR_NLOC=LOCAL_N
            ENDIF
               IF ( .NOT. associated(id%CANDIDATES)) THEN
                  ALLOCATE(id%CANDIDATES(id%NSLAVES+1,1))
               ENDIF
               CALL DAGMG_MUMPS_246( id%MYID_NODES, id%N,                    &
     &              id%STEP(1), id%FRERE_STEPS(1), id%FILS(1),          &
     &              id%NA, id%LNA, id%NE_STEPS(1), id%DAD_STEPS(1),     &
     &              id%ND_STEPS(1), id%PROCNODE_STEPS(1),               &
     &              id%NSLAVES,                                         &
     &              KEEP8(11), KEEP(26), KEEP(15),                      &
     &              KEEP8(12),                                          &
     &              KEEP8(14),                                          &
     &              KEEP(224), KEEP(225),                               &
     &              KEEP(27), RINFO(1),                                 &
     &              KEEP(1), KEEP8(1), LOCAL_M, LOCAL_N, SBUF_RECOLD8,  &
     &              SBUF_SEND, SBUF_REC, id%COST_SUBTREES, KEEP(28),    &
     &              id%I_AM_CAND(1), max(KEEP(56),1), id%ISTEP_TO_INIV2,&
     &              id%CANDIDATES,                                      &
     &              INFO(1), INFO(2)                                    &
     &              ,KEEP8(15)                                          &
     &              ,MAX_SIZE_FACTOR_TMP, KEEP8(9), KEEP8(109)          &
     &           )
            id%MAX_SURF_MASTER = KEEP8(15)
            KEEP8(19)=MAX_SIZE_FACTOR_TMP
            KEEP( 29 ) = KEEP(15) + 2* max(KEEP(12),10)                 &
     &           * ( KEEP(15) / 100 + 1)
            INFO( 19 ) = KEEP(225) + 2* max(KEEP(12),10)                &
     &           * ( KEEP(225) / 100 + 1)
            KEEP8(13)  = KEEP8(12) + int(KEEP(12),8) *                  &
     &           ( KEEP8(12) / 100_8 + 1_8 )
            KEEP8(17)  = KEEP8(14) + int(KEEP(12),8) *                  &
     &           ( KEEP8(14) /100_8 +1_8)
         CALL AGMG_MUMPS_736 ( SBUF_RECOLD8, KEEP8(22), AGMG_MPF_MAX,             &
     &                            id%COMM_NODES )
         SBUF_SEND = max(SBUF_SEND,KEEP(27))
         SBUF_REC  = max(SBUF_REC ,KEEP(27))
         CALL AGMG_COPY(SBUF_REC, KEEP(44), 1,                   AGMG_MPF_INTEGER, ierr)
         IF (KEEP(48)==5) THEN
            KEEP(43)=KEEP(44)
         ELSE
            KEEP(43)=SBUF_SEND
         ENDIF
         MIN_BUF_SIZE8 = KEEP8(22) / int(KEEP(238),8)
         MIN_BUF_SIZE8 = min( MIN_BUF_SIZE8, int(huge (KEEP(43)),8))
         MIN_BUF_SIZE  = int( MIN_BUF_SIZE8 )
         KEEP(44) = max(KEEP(44), MIN_BUF_SIZE)
         KEEP(43) = max(KEEP(43), MIN_BUF_SIZE)
            IF ( MP .GT. 0 ) THEN
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated INTEGER space for factors         :',   &
     &              KEEP(26)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' INFO(3), est. real space to store factors   :',   &
     &              KEEP8(11)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated number of entries in factors      :',   &
     &              KEEP8(9)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Current value of space relaxation parameter :',   &
     &              KEEP(12)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated size of IS (In Core factorization):',   &
     &              KEEP(29)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated size of S  (In Core factorization):',   &
     &              KEEP8(13)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated size of S  (OOC factorization)    :',   &
     &              KEEP8(17)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated maximum SENT message size (bytes) :',   &
     &              KEEP(43) * KEEP(35)
               WRITE(MP,'(A,I10) ')                                     &
     &              ' Estimated maximum RECV message size (bytes) :',   &
     &              KEEP(44) * KEEP(35)
            END IF
      ELSE
         KEEP8(13) = 0_8
         KEEP(29) = 0
         KEEP8(17)= 0_8
         INFO(19) = 0
         KEEP8(11) = 0_8
         KEEP(26) = 0
         KEEP(27) = 0
         RINFO(1) = 0.0D0
      END IF
      CALL AGMG_MUMPS_736( KEEP8(19), KEEP8(119),                            &
     &     AGMG_MPF_MAX, id%COMM)
      CALL AGMG_COPY( KEEP(27), KEEP(127), 1,                                    AGMG_MPF_INTEGER, ierr)
      CALL AGMG_COPY( KEEP(26), KEEP(126), 1,                                    AGMG_MPF_INTEGER, ierr)
      CALL AGMG_MUMPS_646( KEEP8(11), KEEP8(111), AGMG_MPF_SUM,                   &
     &     MASTER, id%COMM )
      CALL AGMG_MUMPS_735( KEEP8(111), INFOG(3) )
      CALL AGMG_COPY( RINFO(1), RINFOG(1), 1,                  AGMG_MPF_DOUBLE_PRECISION, ierr)
      CALL AGMG_MUMPS_735( KEEP8(11), INFO(3) )
      INFO ( 4 ) = KEEP(  26 )
      INFO ( 5 ) = KEEP(  27 )
      INFO ( 7 ) = KEEP(  29 )
      CALL AGMG_MUMPS_735( KEEP8(13), INFO(8) )
      CALL AGMG_MUMPS_735( KEEP8(17), INFO(20) )
      CALL AGMG_MUMPS_735( KEEP8(9), INFO(24) )
      INFOG( 4 ) = KEEP( 126 )
      INFOG( 5 ) = KEEP( 127 )
      CALL AGMG_MUMPS_735( KEEP8(109), INFOG(20) )
      CALL DAGMG_MUMPS_100(id%MYID, id%COMM, KEEP, KEEP8,                    &
     &     INFO, INFOG, RINFO, RINFOG, ICNTL)
         OOC_STAT = .FALSE.
         PERLU_ON = .FALSE.
         CALL DAGMG_MUMPS_214( KEEP(1), KEEP8(1),                            &
     &        id%MYID, id%N, id%NELT, id%LNA, id%NZ,                    &
     &        id%NA_ELT,                                                &
     &        id%NSLAVES, TOTAL_MBYTES, .FALSE.,                        &
     &        OOC_STAT, PERLU_ON, TOTAL_BYTES)
         KEEP8(2) = TOTAL_BYTES
         PERLU_ON  = .TRUE.
         CALL DAGMG_MUMPS_214( KEEP(1), KEEP8(1),                            &
     &        id%MYID, id%N, id%NELT, id%LNA, id%NZ,                    &
     &        id%NA_ELT,                                                &
     &        id%NSLAVES, TOTAL_MBYTES, .FALSE.,                        &
     &        OOC_STAT, PERLU_ON, TOTAL_BYTES)
         IF ( MP .gt. 0 ) THEN
            WRITE(MP,'(A,I10) ')                                        &
     & ' Estimated space in MBYTES for IC factorization            :',  &
     &           TOTAL_MBYTES
         END IF
         id%INFO(15) = TOTAL_MBYTES
      CALL AGMG_MUMPS_243( id%MYID, id%COMM,                                 &
     &     id%INFO(15), id%INFOG(16), IRANK )
      IF ( PROKG ) THEN
         WRITE( MPG,'(A,I10) ')                                         &
     & ' ** Rank of proc needing largest memory in IC facto        :',  &
     &        IRANK
         WRITE( MPG,'(A,I10) ')                                         &
     & ' ** Estimated corresponding MBYTES for IC facto            :',  &
     &        id%INFOG(16)
         IF ( KEEP(46) .eq. 0 ) THEN
            WRITE( MPG,'(A,I10) ')                                      &
     & ' ** Estimated avg. MBYTES per work. proc at facto (IC)     :'   &
     &           ,(id%INFOG(17)-id%INFO(15))/id%NSLAVES
         ELSE
            WRITE( MPG,'(A,I10) ')                                      &
     & ' ** Estimated avg. MBYTES per work. proc at facto (IC)     :'   &
     &           ,id%INFOG(17)/id%NSLAVES
         END IF
         WRITE(MPG,'(A,I10) ')                                          &
     & ' ** TOTAL     space in MBYTES for IC factorization         :'   &
     &        ,id%INFOG(17)
      END IF
         OOC_STAT = .TRUE.
         PERLU_ON = .FALSE.
         CALL DAGMG_MUMPS_214( KEEP(1), KEEP8(1),                            &
     &        id%MYID, id%N, id%NELT, id%LNA, id%NZ,                    &
     &        id%NA_ELT,                                                &
     &        id%NSLAVES, TOTAL_MBYTES, .FALSE.,                        &
     &        OOC_STAT, PERLU_ON, TOTAL_BYTES)
         KEEP8(3) = TOTAL_BYTES
         PERLU_ON  = .TRUE.
         CALL DAGMG_MUMPS_214( id%KEEP(1), id%KEEP8(1),                      &
     &        id%MYID, id%N, id%NELT, id%LNA, id%NZ,                    &
     &        id%NA_ELT,                                                &
     &        id%NSLAVES, TOTAL_MBYTES, .FALSE.,                        &
     &        OOC_STAT, PERLU_ON, TOTAL_BYTES)
         id%INFO(17) = TOTAL_MBYTES
      CALL AGMG_MUMPS_243( id%MYID, id%COMM,                                 &
     &     id%INFO(17), id%INFOG(26), IRANK )
      IF ( PROKG  ) THEN
         WRITE( MPG,'(A,I10) ')                                         &
     & ' ** Rank of proc needing largest memory for OOC facto      :',  &
     &        IRANK
         WRITE( MPG,'(A,I10) ')                                         &
     & ' ** Estimated corresponding MBYTES for OOC facto           :',  &
     &        id%INFOG(26)
         IF ( KEEP(46) .eq. 0 ) THEN
            WRITE( MPG,'(A,I10) ')                                      &
     & ' ** Estimated avg. MBYTES per work. proc at facto (OOC)    :'   &
     &           ,(id%INFOG(27)-id%INFO(15))/id%NSLAVES
         ELSE
            WRITE( MPG,'(A,I10) ')                                      &
     & ' ** Estimated avg. MBYTES per work. proc at facto (OOC)    :'   &
     &           ,id%INFOG(27)/id%NSLAVES
         END IF
         WRITE(MPG,'(A,I10) ')                                          &
     & ' ** TOTAL     space in MBYTES for OOC factorization        :'   &
     &        ,id%INFOG(27)
      END IF
      IF ( id%MYID .EQ. MASTER .AND. KEEP(54) .eq. 1 ) THEN
         IF (associated( id%MAPPING))                                   &
     &        deallocate( id%MAPPING)
         allocate( id%MAPPING(id%NZ), stat=allocok)
         IF ( allocok .GT. 0 ) THEN
            INFO(1) = -7
            INFO(2) = id%NZ
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'id%MAPPING'
            END IF
            GOTO 92
         END IF
         allocate(IWtemp( id%N ), stat=allocok)
         IF ( allocok .GT. 0 ) THEN
            INFO(1)=-7
            INFO(2)=id%N
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'IWtemp(N)'
            END IF
            GOTO 92
         END IF
         CALL DAGMG_MUMPS_83(                                                &
     &        id%N, id%MAPPING(1),                                      &
     &        id%NZ, id%IRN(1),id%JCN(1), id%PROCNODE_STEPS(1),         &
     &        id%STEP(1),                                               &
     &        id%NSLAVES, id%SYM_PERM(1),                               &
     &        id%FILS, IWtemp, id%KEEP(1),id%KEEP8(1),                  &
     &        id%root%MBLOCK, id%root%NBLOCK,                           &
     &        id%root%NPROW, id%root%NPCOL )
         deallocate( IWtemp )
   92    CONTINUE
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      RETURN
  110 FORMAT(/' ****** ANALYSIS STEP ********'/)
  150 FORMAT(                                                           &
     & /' ** FAILURE DURING DMUMPS_26, DYNAMIC ALLOCATION OF',          &
     &     A30)
      END SUBROUTINE DAGMG_MUMPS_26
      SUBROUTINE DAGMG_MUMPS_537(N,NSLAVES,                                  &
     &     ICNTL,INFOG, NE, NFSIZ,                                      &
     &     FRERE, FILS,                                                 &
     &     KEEP,KEEP8,PROCNODE,                                         &
     &     SSARBR,NBSA,PEAK,ierr                                        &
     &     )
      USE AGMG_MUMPS_STATIC_MAPPING
      IMPLICIT NONE
      INTEGER N, NSLAVES, NBSA, ierr
      INTEGER ICNTL(40),INFOG(40),KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER NE(N),NFSIZ(N),FRERE(N),FILS(N),PROCNODE(N)
      INTEGER SSARBR(N)
      DOUBLE PRECISION PEAK
      CALL AGMG_MUMPS_369(N,NSLAVES,                                         &
     &     ICNTL,INFOG, NE, NFSIZ,                                      &
     &     FRERE, FILS,                                                 &
     &     KEEP,KEEP8,PROCNODE,                                         &
     &     SSARBR,NBSA,dble(PEAK),ierr                                  &
     &     )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_537
      SUBROUTINE DAGMG_MUMPS_564(INODE, PROCNODE, VALUE, FILS, N)
      INTEGER, intent(in) :: INODE, N, VALUE
      INTEGER, intent(in) :: FILS(N)
      INTEGER, intent(inout) :: PROCNODE(N)
      INTEGER IN
      IN=INODE
      DO WHILE ( IN > 0 )
         PROCNODE( IN ) = VALUE
         IN=FILS( IN )
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_564
      SUBROUTINE DAGMG_MUMPS_647(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE(DAGMG_MUMPS_STRUC)  :: id
      INTEGER   :: LP, MP, MPG, I
      INTEGER   :: MASTER
      LOGICAL   :: PROK, PROKG
      PARAMETER( MASTER = 0 )
      LP  = id%ICNTL( 1 )
      MP  = id%ICNTL( 2 )
      MPG = id%ICNTL( 3 )
      PROK  = ( MP  .GT. 0 )
      PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
      IF ( (id%KEEP(24).NE.0) .AND.                                     &
     &     id%NSLAVES.eq.1 ) THEN
         id%KEEP(24) = 0
         IF ( PROKG ) THEN
            WRITE(MPG, '(A)')                                           &
     &           ' Resetting candidate strategy to 0 because NSLAVES=1'
            WRITE(MPG, '(A)') ' '
         END IF
      END IF
      IF ( (id%KEEP(24).EQ.0) .AND.                                     &
     &     id%NSLAVES.GT.1 ) THEN
         id%KEEP(24) = 8
      ENDIF
      IF ( (id%KEEP(24).NE.0)  .AND. (id%KEEP(24).NE.1)  .AND.          &
     &     (id%KEEP(24).NE.8)  .AND. (id%KEEP(24).NE.10) .AND.          &
     &     (id%KEEP(24).NE.12) .AND. (id%KEEP(24).NE.14) .AND.          &
     &     (id%KEEP(24).NE.16) .AND. (id%KEEP(24).NE.18)) THEN
         id%KEEP(24) = 8
         IF ( PROKG ) THEN
            WRITE(MPG, '(A)')                                           &
     &           ' Resetting candidate strategy to 8 '
            WRITE(MPG, '(A)') ' '
         END IF
      END IF
      id%KEEP8(21) = int(id%KEEP(85),8)
      IF ( id%MYID .EQ. MASTER ) THEN
         id%KEEP(201)=id%ICNTL(22)
         IF (id%KEEP(201) .NE. 0) THEN
            id%KEEP(201)=1
         ENDIF
         id%KEEP(54) = id%ICNTL(18)
         IF ( id%KEEP(54) .LT. 0 .or. id%KEEP(54).GT.3 ) THEN
            IF ( PROKG ) THEN
               WRITE(MPG, *) ' Out-of-range value for id%ICNTL(18).'
               WRITE(MPG, *) ' Used 0 ie matrix not distributed'
            END IF
            id%KEEP(54) = 0
         END IF
         id%KEEP(55) = id%ICNTL(5)
         IF ( id%KEEP(55) .LT. 0 .OR. id%KEEP(55) .GT. 1 ) THEN
            IF ( PROKG ) THEN
               WRITE(MPG, *) ' Out-of-range value for id%ICNTL(5).'
               WRITE(MPG, *) ' Used 0 ie matrix is assembled'
            END IF
            id%KEEP(55) = 0
         END IF
         id%KEEP(60) = id%ICNTL(19)
         IF ( id%KEEP( 60 ) .LE. 0 ) id%KEEP( 60 ) = 0
         IF ( id%KEEP( 60 ) .GT. 3 ) id%KEEP( 60 ) = 0
         IF (id%KEEP(60) .NE. 0 .AND. id%SIZE_SCHUR == 0 ) THEN
            WRITE(MPG,'(A)')                                            &
     &           ' ** Schur option ignored because SIZE_SCHUR=0'
            id%KEEP(60)=0
         END IF
         IF ( id%KEEP(60) .NE.0 ) THEN
            IF ( .NOT. associated( id%LISTVAR_SCHUR ) ) THEN
               id%INFO(1) = -22
               id%INFO(2) = 8
               RETURN
            ELSE IF (size(id%LISTVAR_SCHUR)<id%SIZE_SCHUR) THEN
               id%INFO(1) = -22
               id%INFO(2) = 8
               RETURN
            END IF
         ENDIF
         IF (id%KEEP(60) .EQ. 3 .AND. id%KEEP(50).NE.0) THEN
            IF (id%MBLOCK > 0 .AND. id%NBLOCK > 0 .AND.                 &
     &           id%NPROW > 0 .AND. id%NPCOL > 0 ) THEN
               IF (id%NPROW *id%NPCOL .LE. id%NSLAVES) THEN
                  IF (id%MBLOCK .NE. id%NBLOCK ) THEN
                     id%INFO(1)=-31
                     id%INFO(2)=id%MBLOCK - id%NBLOCK
                     RETURN
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
         id%KEEP(244) = id%ICNTL(28)
         id%KEEP(245) = id%ICNTL(29)
         IF ((id%KEEP(244) .EQ. 2) .AND. (id%KEEP(245) .EQ. 2)) THEN
            id%INFOG(1) = -38
            id%INFO(1)  = -38
            IF(id%MYID .EQ.0 ) THEN
               WRITE(LP,'("ParMETIS not available.")')
               WRITE(LP,'("Aborting.")')
               RETURN
            END IF
         END IF
         IF ((id%KEEP(244) .EQ. 2) .AND. (id%KEEP(245) .EQ. 1)) THEN
            id%INFOG(1) = -38
            id%INFO(1)  = -38
            IF(id%MYID .EQ.0 ) THEN
               WRITE(LP,'("PT-SCOTCH not available.")')
               WRITE(LP,'("Aborting.")')
               RETURN
            END IF
         END IF
         IF((id%KEEP(244) .GT. 2) .OR.                                  &
     &        (id%KEEP(244) .LT. 0)) id%KEEP(244)=0
         IF(id%KEEP(244) .EQ. 0) THEN
            id%KEEP(244) = 1
         ELSE IF (id%KEEP(244) .EQ. 2) THEN
            IF(id%KEEP(55) .NE. 0) THEN
               id%INFO(1)  = -39
               id%INFOG(1) = -39
               WRITE(LP,                                                &
     &              '("Incompatible values for ICNTL(5), ICNTL(28)")')
               WRITE(LP,                                                &
     &              '("Parallel analysis is not possible if the")')
               WRITE(LP,                                                &
     &              '("matrix is not assembled")')
               RETURN
            ELSE IF(id%KEEP(60) .NE. 0) THEN
               id%INFO(1)  = -39
               id%INFOG(1) = -39
               WRITE(LP,                                                &
     &              '("Incompatible values for ICNTL(19), ICNTL(28)")')
               WRITE(LP,                                                &
     &              '("Parallel analysis is not possible if SCHUR")')
               WRITE(LP,                                                &
     &              '("complement must be returned")')
               RETURN
            END IF
            IF(id%NSLAVES .LT. 2) THEN
               id%KEEP(244) = 1
               IF(PROKG) WRITE(MPG,                                     &
     &              '("Too few processes.                               &
     & Reverting to sequential analysis")',advance='no')
               IF(id%KEEP(245) .EQ. 1) THEN
                  IF(PROKG) WRITE(MPG, '(" with SCOTCH")')
                  id%ICNTL(7) = 3
               ELSE IF(id%KEEP(245) .EQ. 2) THEN
                  IF(PROKG) WRITE(MPG, '(" with Metis")')
                  id%ICNTL(7) = 5
               ELSE
                  IF(PROKG) WRITE(MPG, '(".")')
                  id%ICNTL(7) = 0
               END IF
            END IF
         END IF
         id%INFOG(32) = id%KEEP(244)
         IF ( (id%KEEP(244) .EQ. 1) .AND.                               &
     &        (id%ICNTL(7) .EQ. 1) ) THEN
            IF ( .NOT. associated( id%PERM_IN ) ) THEN
               id%INFO(1) = -22
               id%INFO(2) = 3
               RETURN
            ELSE IF ( size( id%PERM_IN ) < id%N ) THEN
               id%INFO(1) = -22
               id%INFO(2) = 3
               RETURN
            END IF
         ENDIF
         IF (id%KEEP(9) .LE. 1 ) id%KEEP(9) = 500
         IF ( id%KEEP8(21) .GT. 0_8 ) THEN
            IF ((id%KEEP8(21).LE.1_8) .OR.                              &
     &          (id%KEEP8(21).GT.int(id%KEEP(9),8)))                    &
     &         id%KEEP8(21) = int(min(id%KEEP(9),100),8)
         ENDIF
         IF (id%KEEP(48) .EQ. 1 ) id%KEEP(48) = -12345
         IF ( (id%KEEP(48).LT.0) .OR. (id%KEEP(48).GT.5) ) THEN
            id%KEEP(48)=5
         ENDIF
         IF ( (id%KEEP(60) .NE. 0) .AND. (id%ICNTL(7) .EQ. 1) ) THEN
            DO I = 1, id%SIZE_SCHUR
               IF (id%PERM_IN(id%LISTVAR_SCHUR(I))                      &
     &              .EQ. id%N-id%SIZE_SCHUR+I)                          &
     &              CYCLE
               id%INFO(1) = -22
               id%INFO(2) = 8
               RETURN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Ignoring user-ordering, because incompatible with Schur.'
                  WRITE(MPG,'(A)') ' ** id%ICNTL(7) treated as 0.'
               END IF
               EXIT
            ENDDO
         END IF
         id%KEEP(95) = id%ICNTL(12)
         IF (id%KEEP(50).NE.2) id%KEEP(95) = 1
         IF ((id%KEEP(95).GT.3).OR.(id%KEEP(95).LT.0)) id%KEEP(95) = 0
         id%KEEP(23) = id%ICNTL(6)
         IF (id%KEEP(23).LT.0.OR.id%KEEP(23).GT.7) id%KEEP(23) = 7
         IF ( id%KEEP(50) .EQ. 1 ) THEN
            IF (id%KEEP(23) .NE. 0) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Max-trans not compatible with LLT factorization'
               END IF
               id%KEEP(23) = 0
            ENDIF
            IF (id%KEEP(95) .GT. 1) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** ICNTL(12) ignored: not compatible with LLT factorization'
               END IF
            ENDIF
            id%KEEP(95) = 1
         END IF
         IF  (id%KEEP(60) .GT. 0) THEN
            IF (id%KEEP(23) .NE. 0) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     &                 ' ** Max-trans not allowed because of Schur'
               END IF
               id%KEEP(23) = 0
            ENDIF
            IF (id%KEEP(52).NE.0) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Scaling during analysis not allowed because of Schur'
               ENDIF
               id%KEEP(52) = 0
            ENDIF
            IF (id%KEEP(95) .GT. 1) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** ICNTL(12) option not allowed because of Schur'
               END IF
            ENDIF
            id%KEEP(95) = 1
         END IF
         IF ( (id%KEEP(23) .NE. 0) .AND. (id%ICNTL(7) .EQ. 1) ) THEN
            id%KEEP(23) = 0
            id%KEEP(95) = 1
            IF (MPG.GT.0) THEN
               WRITE(MPG,'(A)')                                         &
     & ' ** Max-trans not allowed because ordering is given'
            END IF
         END IF
         IF ( id%ICNTL(7) .EQ. 1 ) THEN
            IF (id%KEEP(95) > 1 .AND. MPG.GT.0) THEN
               WRITE(MPG,'(A)')                                         &
     & ' ** ICNTL(12) option incompatible with given ordering'
            END IF
            id%KEEP(95) = 1
         END IF
         IF (id%KEEP(54) .NE. 0) THEN
            IF( id%KEEP(23) .NE. 0 ) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Max-trans not allowed because matrix is distributed'
               END IF
               id%KEEP(23) = 0
            ENDIF
            IF (id%KEEP(52).EQ.-2) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Scaling during analysis not allowed (matrix is distributed)'
               ENDIF
            ENDIF
            id%KEEP(52) = 0
            IF (id%KEEP(95) .GT. 1 .AND. MPG.GT.0) THEN
               WRITE(MPG,'(A)')                                         &
     & ' ** ICNTL(12) option not allowed because matrix is              &
     &distributed'
            ENDIF
            id%KEEP(95) = 1
         END IF
         IF ( id%KEEP(55) .NE. 0 ) THEN
            IF( id%KEEP(23) .NE. 0 ) THEN
               IF (MPG.GT.0) THEN
                  WRITE(MPG,'(A)')                                      &
     & ' ** Max-trans not allowed for element matrix'
               END IF
               id%KEEP(23) = 0
            ENDIF
            IF (MPG.GT.0 .AND. id%KEEP(52).EQ.-2) THEN
               WRITE(MPG,'(A)')                                         &
     & ' ** Scaling not allowed at analysis for element matrix'
            ENDIF
            id%KEEP(52) = 0
            id%KEEP(95) = 1
         ENDIF
         IF(id%KEEP(244) .EQ. 2) THEN
            IF(id%KEEP(23) .EQ. 7) THEN
               id%KEEP(23) = 0
            ELSE IF (id%KEEP(23) .GT. 0) THEN
               id%INFO(1)  = -39
               id%INFOG(1) = -39
               id%KEEP(23) = 0
               WRITE(LP,                                                &
     &              '("Incompatible values for ICNTL(6), ICNTL(28)")')
               WRITE(LP,                                                &
     &              '("Maximum transversal not allowed                  &
     &                 in parallel analysis")')
               RETURN
            END IF
         END IF
         IF ( id%KEEP(54) .NE. 0 .AND. id%KEEP(55) .NE. 0 ) THEN
            id%KEEP(54) = 0
            IF (MPG.GT.0) THEN
               WRITE(MPG,'(A)')                                         &
     & ' ** Distributed entry not available for element matrix'
            END IF
         ENDIF
         IF (id%ICNTL(39).NE.1 .and. id%ICNTL(39).NE.2) THEN
            id%KEEP(106)=1
         ELSE
            id%KEEP(106)=id%ICNTL(39)
         ENDIF
         IF(id%KEEP(50) .EQ. 2) THEN
            IF( .NOT. associated(id%A) ) THEN
               IF(id%KEEP(95) .EQ. 3) THEN
                  id%KEEP(95) = 2
               ENDIF
            ENDIF
            IF(id%KEEP(95) .EQ. 3 .AND. id%ICNTL(7) .NE. 2) THEN
               IF (PROK) WRITE(MP,*)                                    &
     &              'WARNING: DMUMPS_203 constrained ordering not ',    &
     &              'available with selected ordering'
               id%KEEP(95) = 2
            ENDIF
            IF(id%KEEP(95) .EQ. 3) THEN
               id%KEEP(23) = 5
               id%KEEP(52) = -2
            ELSE IF(id%KEEP(95) .EQ. 2 .AND.                            &
     &              (id%KEEP(23) .EQ. 0 .OR. id%KEEP(23) .EQ. 7) ) THEN
               IF( associated(id%A) ) THEN
                  id%KEEP(23) = 5
               ELSE
                  id%KEEP(23) = 1
               ENDIF
            ELSE IF(id%KEEP(95) .EQ. 1) THEN
               id%KEEP(23) = 0
            ELSE IF(id%KEEP(95) .EQ. 0 .AND. id%KEEP(23) .EQ. 0) THEN
               id%KEEP(95) = 1
            ENDIF
         ELSE
            id%KEEP(95) = 1
         ENDIF
         id%KEEP(53)=0
         IF(id%KEEP(86).EQ.1)THEN
            IF(id%KEEP(47).LT.2) id%KEEP(47)=2
         ENDIF
         IF(id%KEEP(48).EQ.5)THEN
            IF(id%KEEP(50).EQ.0)THEN
               id%KEEP(87)=50
               id%KEEP(88)=50
            ELSE
               id%KEEP(87)=70
               id%KEEP(88)=70
            ENDIF
         ENDIF
         IF((id%NSLAVES.EQ.1).AND.(id%KEEP(76).GT.3))THEN
            id%KEEP(76)=2
         ENDIF
         IF(id%KEEP(81).GT.0)THEN
            IF(id%KEEP(47).LT.2) id%KEEP(47)=2
         ENDIF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_647
      SUBROUTINE DAGMG_MUMPS_664(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      TYPE(DAGMG_MUMPS_STRUC)  :: id
      INTEGER, ALLOCATABLE :: REQPTR(:,:)
      INTEGER              :: MASTER, IERR, INDX, NRECV
      INTEGER              :: STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER              :: LP, MP, MPG, I
      LOGICAL              :: PROK, PROKG
      PARAMETER( MASTER = 0 )
      LP  = id%ICNTL( 1 )
      MP  = id%ICNTL( 2 )
      MPG = id%ICNTL( 3 )
      PROK  = ( MP  .GT. 0 )
      PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
      IF ( id%KEEP(46) .EQ. 0 .AND. id%MYID .EQ. MASTER ) THEN
         id%NZ_LOC = 0
      END IF
      IF ( id%MYID .eq. MASTER ) THEN
         allocate( REQPTR( id%NPROCS, 3 ), STAT = IERR )
         IF ( IERR .GT. 0 ) THEN
            id%INFO(1) = -7
            id%INFO(2) = 3 * id%NPROCS
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'REQPTR'
            END IF
            GOTO 13
         END IF
         allocate( id%IRN( id%NZ ), STAT = IERR )
         IF ( IERR .GT. 0 ) THEN
            id%INFO(1) = -7
            id%INFO(2) = id%NZ
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'IRN'
            END IF
            GOTO 13
         END IF
         allocate( id%JCN( id%NZ ), STAT = IERR )
         IF ( IERR .GT. 0 ) THEN
            id%INFO(1) = -7
            id%INFO(2) = id%NZ
            IF ( LP .GT. 0 ) THEN
               WRITE(LP, 150) 'JCN'
            END IF
            GOTO 13
         END IF
      END IF
   13 CONTINUE
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &     id%COMM, id%MYID )
      IF ( id%INFO(1) < 0 ) RETURN
      IF ( id%MYID .EQ. MASTER ) THEN
         DO I = 1, id%NPROCS - 1
            CALL AGMG_NOCALL('MPI_RECV')
         END DO
         IF ( id%KEEP(46) .eq. 0 ) THEN
            REQPTR( 1, 1 ) = 1
         ELSE
            REQPTR( 1, 1 ) = id%NZ_LOC + 1
         END IF
         DO I = 2, id%NPROCS
            REQPTR( I, 1 ) = REQPTR( I, 1 ) + REQPTR( I-1, 1 )
         END DO
      ELSE
         CALL AGMG_NOCALL('MPI_SEND')
      END IF
      IF ( id%MYID .eq. MASTER ) THEN
         NRECV = 0
         DO I = 1, id%NPROCS - 1
            IF ( REQPTR( I + 1, 1 ) - REQPTR( I, 1 ) .NE. 0 ) THEN
               NRECV = NRECV + 2
               CALL AGMG_SETIERR( IERR )
               CALL AGMG_SETIERR( IERR )
            ELSE
               REQPTR(I, 2) = AGMG_MPF_REQUEST_NULL
               REQPTR(I, 3) = AGMG_MPF_REQUEST_NULL
            END IF
         END DO
      ELSE
         IF ( id%NZ_LOC .NE. 0 ) THEN
            CALL AGMG_NOCALL('MPI_SEND')
            CALL AGMG_NOCALL('MPI_SEND')
         END IF
      END IF
      IF ( id%MYID .eq. MASTER ) THEN
         IF ( id%NZ_LOC .NE. 0 ) THEN
            DO I=1,id%NZ_LOC
               id%IRN(I) = id%IRN_LOC(I)
               id%JCN(I) = id%JCN_LOC(I)
            ENDDO
         END IF
         REQPTR( id%NPROCS, 2 ) = AGMG_MPF_REQUEST_NULL
         REQPTR( id%NPROCS, 3 ) = AGMG_MPF_REQUEST_NULL
         DO I = 1, NRECV
            CALL AGMG_NOCALL('MPI_WAITANY')
         END DO
         deallocate( REQPTR )
      END IF
      RETURN
  150 FORMAT(                                                           &
     &/' ** FAILURE DURING DMUMPS_664, DYNAMIC ALLOCATION OF',          &
     &     A30)
      END SUBROUTINE DAGMG_MUMPS_664
      SUBROUTINE DAGMG_MUMPS_658(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE(DAGMG_MUMPS_STRUC)  :: id
      INTEGER              :: MASTER, IERR
      INTEGER              :: LP, MP, MPG,  I
      CHARACTER (LEN=10)   :: SYMM
      CHARACTER (LEN=8)    :: ARITH
      INTEGER              :: MM_WRITE
      INTEGER              :: MM_WRITE_CHECK
      CHARACTER(LEN=20)    :: MM_IDSTR
      LOGICAL              :: I_AM_SLAVE,PROK, PROKG
      PARAMETER( MASTER = 0 )
      I_AM_SLAVE = ( id%MYID .NE. MASTER  .OR.                          &
     &     ( id%MYID .EQ. MASTER .AND.                                  &
     &     id%KEEP(46) .EQ. 1 ) )
      IF ( id%MYID .eq. MASTER .AND. id%KEEP(54).NE.3) THEN
         IF (id%WRITE_PROBLEM(1:20) .NE. "NAME_NOT_INITIALIZED")THEN
            IF (associated(id%A)) THEN
               ARITH='real'
            ELSE
               ARITH='pattern '
            ENDIF
            IF (id%SYM .eq. 0) THEN
               SYMM="general"
            ELSE
               SYMM="symmetric"
            END IF
            OPEN(69,FILE=TRIM(id%WRITE_PROBLEM))
            WRITE(69,FMT=*)'%%MatrixMarket matrix coordinate ',         &
     &           TRIM(ARITH)," ",TRIM(SYMM)
            WRITE(69,*) id%N, id%N, id%NZ
            IF (associated(id%A)) THEN
               DO I=1,id%NZ
                  IF (id%SYM.NE.0 .AND. id%IRN(I).LT.id%JCN(I)) THEN
                     WRITE(69,*) id%JCN(I), id%IRN(I), id%A(I)
                  ELSE
                     WRITE(69,*) id%IRN(I), id%JCN(I), id%A(I)
                  ENDIF
               ENDDO
            ELSE
               DO I=1,id%NZ
                  IF (id%SYM.NE.0 .AND. id%IRN(I).LT.id%JCN(I)) THEN
                     WRITE(69,*) id%JCN(I), id%IRN(I)
                  ELSE
                     WRITE(69,*) id%IRN(I), id%JCN(I)
                  ENDIF
               ENDDO
            ENDIF
            CLOSE(69)
            OPEN(69,FILE=TRIM(id%WRITE_PROBLEM) //".rhs")
            WRITE(69,FMT=*)'%%MatrixMarket matrix array ',TRIM(ARITH),  &
     &           ' general'
            WRITE(69,*) id%N, 1
            IF (associated(id%RHS)) THEN
               DO I=1,id%N
                  WRITE(69,*) id%RHS(I)
               ENDDO
            ENDIF
            CLOSE(69)
         END IF
      ELSE IF ( id%KEEP(54).EQ.3) THEN
         IF (id%WRITE_PROBLEM(1:20) .EQ. "NAME_NOT_INITIALIZED"         &
     &        .OR. .NOT. I_AM_SLAVE )THEN
            MM_WRITE = 0
         ELSE
            MM_WRITE = 1
         ENDIF
         CALL AGMG_COPY(MM_WRITE, MM_WRITE_CHECK, 1,                                AGMG_MPF_INTEGER, ierr)
         IF (MM_WRITE_CHECK.EQ.id%NSLAVES .AND. I_AM_SLAVE) THEN
            IF (associated(id%A_LOC)) THEN
               ARITH='real'
            ELSE
               ARITH='pattern '
            ENDIF
            IF (id%SYM .eq. 0) THEN
               SYMM="general"
            ELSE
               SYMM="symmetric"
            END IF
            WRITE(MM_IDSTR,'(I7)') id%MYID
            OPEN(69,                                                    &
     &           FILE=TRIM(id%WRITE_PROBLEM)//TRIM(ADJUSTL(MM_IDSTR)))
            WRITE(69,FMT=*)'%%MatrixMarket matrix coordinate ',         &
     &           TRIM(ARITH)," ",TRIM(SYMM)
            WRITE(69,*) id%N, id%N, id%NZ_LOC
            IF (associated(id%A_LOC)) THEN
               DO I=1,id%NZ_LOC
                  IF (id%SYM.NE.0 .AND.                                 &
     &                 id%IRN_LOC(I).LT.id%JCN_LOC(I)) THEN
                     WRITE(69,*) id%JCN_LOC(I), id%IRN_LOC(I),          &
     &                    id%A_LOC(I)
                  ELSE
                     WRITE(69,*) id%IRN_LOC(I), id%JCN_LOC(I),          &
     &                    id%A_LOC(I)
                  ENDIF
               ENDDO
            ELSE
               DO I=1,id%NZ_LOC
                  IF (id%SYM.NE.0 .AND.                                 &
     &                 id%IRN_LOC(I).LT.id%JCN_LOC(I)) THEN
                     WRITE(69,*) id%JCN_LOC(I), id%IRN_LOC(I)
                  ELSE
                     WRITE(69,*) id%IRN_LOC(I), id%JCN_LOC(I)
                  ENDIF
               ENDDO
            ENDIF
            CLOSE(69)
         ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_658
      SUBROUTINE DAGMG_MUMPS_649( NSLAVES, NB_NIV2, MYID_NODES,              &
     &     CANDIDATES, I_AM_CAND )
      IMPLICIT NONE
      INTEGER, intent(in) :: NSLAVES, NB_NIV2, MYID_NODES
      INTEGER, intent(in) :: CANDIDATES( NSLAVES+1, NB_NIV2 )
      LOGICAL, intent(out):: I_AM_CAND( NB_NIV2 )
      INTEGER I, INIV2, NCAND
      DO INIV2=1, NB_NIV2
         I_AM_CAND(INIV2)=.FALSE.
         NCAND = CANDIDATES(NSLAVES+1,INIV2)
         DO I=1, NCAND
            IF (CANDIDATES(I,INIV2).EQ.MYID_NODES) THEN
               I_AM_CAND(INIV2)=.TRUE.
               EXIT
            ENDIF
         ENDDO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_649
      SUBROUTINE DAGMG_MUMPS_251(N,IW,LIW,A,LA,                              &
     &             NSTK_STEPS, NBPROCFILS,IFLAG,ND,FILS,STEP,           &
     &             FRERE, DAD, CAND,                                    &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE,                     &
     &             MAXFRT, NTOTPV, NMAXNPIV, PTRIST, PTRAST,            &
     &             PIMASTER, PAMASTER, PTRARW,PTRAIW,                   &
     &             ITLOC, IERROR,IPOOL, LPOOL,                          &
     &             RINFO, POSFAC ,IWPOS, LRLU, IPTRLU,                  &
     &             LRLUS, LEAF, NBROOT, NBRTOT,                         &
     &             UU, ICNTL, PTLUST_S, PTRFAC, NSTEPS, INFO,           &
     &             KEEP,KEEP8,                                          &
     &             PROCNODE_STEPS,SLAVEF,MYID, COMM_NODES,              &
     &             MYID_NODES,                                          &
     &             BUFR,LBUFR,LBUFR_BYTES,INTARR,DBLARR,root,           &
     &             PERM, NELT, FRTPTR, FRTELT, LPTRAR,                  &
     &             COMM_LOAD, ASS_IRECV, SEUIL, SEUIL_LDLT_NIV2,        &
     &             MEM_DISTRIB, NE,                                     &
     &     DKEEP,PIVNUL_LIST,LPN_LIST)
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER N,IFLAG,NTOTPV,MAXFRT,LIW, LPTRAR, NMAXNPIV,              &
     &        IERROR, NSTEPS, INFO(40)
      INTEGER(8) :: LA
      DOUBLE PRECISION, TARGET :: A(LA)
      INTEGER SLAVEF, COMM_NODES, MYID, MYID_NODES
      INTEGER, DIMENSION(0: SLAVEF - 1) :: MEM_DISTRIB
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      INTEGER LPOOL
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER ITLOC(N)
      INTEGER IW(LIW), NSTK_STEPS(KEEP(28)), NBPROCFILS(KEEP(28))
      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND(KEEP(28))
      INTEGER FILS(N),PTRIST(KEEP(28))
      INTEGER STEP(N), FRERE(KEEP(28)), DAD(KEEP(28))
      INTEGER PIMASTER(KEEP(28))
      INTEGER PTLUST_S(KEEP(28)), PERM(N)
      INTEGER CAND(SLAVEF+1,max(1,KEEP(56)))
      INTEGER   ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER IPOOL(LPOOL)
      INTEGER NE(KEEP(28))
      DOUBLE PRECISION RINFO(20)
      INTEGER(8) :: PAMASTER(KEEP(28)), PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: POSFAC, LRLU, LRLUS, IPTRLU
      INTEGER IWPOS, LEAF, NBROOT
      INTEGER COMM_LOAD, ASS_IRECV
      DOUBLE PRECISION UU, SEUIL, SEUIL_LDLT_NIV2
      INTEGER NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER        INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      LOGICAL IS_ISOLATED_NODE
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER  LIWK_RR, LWK_RR, LOCAL_M, LOCAL_N, PHASE,                &
     &         MBLOCK, NBLOCK
      LOGICAL ROOT_OWNER
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      !start pavel ferkl
      interface
      subroutine DAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
     &           UU, NOFFW,                                             &
     &           NPVW,                                                  &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
     &             PIMASTER, PAMASTER,                                  &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
     &            DKEEP,PIVNUL_LIST,LPN_LIST )
      USE DAGMG_MUMPS_OOC
      implicit none
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
      END TYPE DAGMG_MUMPS_ROOT_STRUC

      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
      INTEGER(8) :: LA
      DOUBLE PRECISION A( LA )
      DOUBLE PRECISION UU, SEUIL
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
      INTEGER LPTRAR, NELT
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
     &        IWPOS, IWPOSCB, COMP
      INTEGER NB_BLOC_FAC
      INTEGER ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER, TARGET :: IW( LIW )
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
      INTEGER FRERE(KEEP(28)), FILS(N)
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)),                                         &
     & PTLUST_S(KEEP(28)),                                              &
     & PIMASTER(KEEP(28)),                                              &
     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION  DBLARR(max(1,KEEP(13)))
      LOGICAL AVOID_DELAYED
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      end subroutine DAGMG_MUMPS_141
      SUBROUTINE DAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
     &                           IOLDPS, POSELT, IFLAG,                 &
     &                           UU, NNEG, NPVW,                        &
     &                           KEEP,KEEP8,                            &
     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER(8) :: LA, POSELT
      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
      INTEGER MYID, SLAVEF, IOLDPS
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION UU, SEUIL
      DOUBLE PRECISION A( LA )
      INTEGER, TARGET :: IW( LIW )
      LOGICAL AVOID_DELAYED
      INTEGER ETATASS, IWPOS
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      end subroutine DAGMG_MUMPS_140
      end interface
      !end pavel ferkl
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR
      LOGICAL FLAG
      DOUBLE PRECISION, PARAMETER :: DZERO = 0.0D0, DONE = 1.0D0
      INTEGER INODE
      INTEGER IWPOSCB
      INTEGER FPERE, TYPEF
      INTEGER MP, LP, DUMMY(1)
      INTEGER NBFIN, NBRTOT, NBROOT_TRAITEES
      INTEGER NFRONT, IOLDPS
      INTEGER*8 NFRONT8
      INTEGER(8) :: POSELT
      INTEGER IPOSROOT, IPOSROOTROWINDICES
      INTEGER GLOBK109
      INTEGER(8) :: LBUFRX
      DOUBLE PRECISION, POINTER, DIMENSION(:) :: BUFRX
      LOGICAL :: IS_BUFRX_ALLOCATED
      DOUBLE PRECISION FLOP1
      INTEGER TYPE
      LOGICAL SON_LEVEL2, SET_IRECV, BLOCKING,                          &
     &        MESSAGE_RECEIVED
      LOGICAL AVOID_DELAYED
      LOGICAL LAST_CALL
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      LOGICAL AGMG_MUMPS_167,AGMG_MUMPS_283
      EXTERNAL AGMG_MUMPS_167,AGMG_MUMPS_283
      LOGICAL DAGMG_MUMPS_508
      EXTERNAL DAGMG_MUMPS_508, DAGMG_MUMPS_509
      LOGICAL STACK_RIGHT_AUTHORIZED
      INTEGER MAXFRW, NPVW, NOFFW, NELVAW, COMP,                        &
     &        JOBASS, ETATASS
      LOGICAL CONCERNED
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, TYPEFile, NextPiv2beWritten,               &
     &        IDUMMY
      INTEGER(8) :: ITMP8
      TYPE(IO_BLOCK) :: MonBloc
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      DOUBLE PRECISION    OPASSW, OPELIW
       ASS_IRECV = AGMG_MPF_REQUEST_NULL
       ITLOC(1:N) =0
       PTRIST  (1:KEEP(28))=0
       PTLUST_S(1:KEEP(28))=0
       PTRAST(1:KEEP(28))=0_8
       PTRFAC(1:KEEP(28))=-99999_8
      MP = ICNTL(2)
      LP = ICNTL(1)
      MAXFRW = 0
      NPVW   = 0
      NOFFW  = 0
      NELVAW = 0
      COMP  = 0
      OPASSW = DZERO
      OPELIW = DZERO
      IWPOSCB = LIW
      STACK_RIGHT_AUTHORIZED = .TRUE.
      CALL DAGMG_MUMPS_22( .FALSE., 0_8,                                     &
     &     .FALSE., .FALSE., MYID_NODES, N, KEEP, KEEP8,                &
     &     IW, LIW, A, LA, LRLU, IPTRLU, IWPOS, IWPOSCB,                &
     &     PTRIST, PTRAST, STEP, PIMASTER,                              &
     &     PAMASTER, ITLOC, KEEP(IXSZ), 0_8, -444, -444, .true.,        &
     &     COMP, LRLUS,                                                 &
     &     IFLAG, IERROR                                                &
     &     )
      JOBASS  = 0
      ETATASS = 0
      NBFIN = NBRTOT
      NBROOT_TRAITEES = 0
      NBPROCFILS(1:KEEP(28)) = 0
      IF ( KEEP(38).NE.0 ) THEN
        IF (root%yes) THEN
          IF (KEEP(60).eq.0) THEN
            CALL DAGMG_MUMPS_284(                                            &
     &        root, KEEP(38), N, IW, LIW,                               &
     &        A, LA,                                                    &
     &        FILS, MYID_NODES, PTRAIW, PTRARW,                         &
     &        INTARR, DBLARR,                                           &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,                          &
     &        COMP, LRLUS, IFLAG, KEEP,KEEP8, IERROR )
          ELSE
             PTRIST(STEP(KEEP(38)))=-77777
          ENDIF
        ENDIF
        IF ( IFLAG .LT. 0 ) GOTO 635
      END IF
   20 CONTINUE
      NIV1_FLAG=0
      SET_IRECV = .TRUE.
      BLOCKING = .FALSE.
      MESSAGE_RECEIVED = .FALSE.
      CALL DAGMG_MUMPS_329(                                                  &
     &      COMM_LOAD, ASS_IRECV, BLOCKING, SET_IRECV,                  &
     &      MESSAGE_RECEIVED,                                           &
     &      AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                &
     &      STATUS, BUFR, LBUFR,                                        &
     &      LBUFR_BYTES,                                                &
     &      PROCNODE_STEPS, POSFAC,                                     &
     &      IWPOS, IWPOSCB, IPTRLU,                                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA,                             &
     &      PTRIST, PTLUST_S, PTRFAC,                                   &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_STEPS,               &
     &      COMP, IFLAG,                                                &
     &      IERROR, COMM_NODES,                                         &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF, NBFIN, MYID_NODES, SLAVEF,              &
     &      root, OPASSW, OPELIW, ITLOC, FILS,                          &
     &      PTRARW, PTRAIW,                                             &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,               &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE,                            &
     &      STACK_RIGHT_AUTHORIZED )
      CALL DAGMG_MUMPS_467(COMM_LOAD, KEEP)
      IF (MESSAGE_RECEIVED) THEN
          IF ( IFLAG .LT. 0 ) GO TO 640
          IF ( NBFIN .eq. 0 ) GOTO 640
      ELSE
          IF ( .NOT. DAGMG_MUMPS_508( IPOOL, LPOOL) )THEN
            CALL DAGMG_MUMPS_509( N, IPOOL, LPOOL,                           &
     &      PROCNODE_STEPS,                                             &
     &      SLAVEF, STEP, INODE, KEEP,KEEP8, MYID_NODES, ND,            &
     &      (.NOT. STACK_RIGHT_AUTHORIZED) )
            STACK_RIGHT_AUTHORIZED = .TRUE.
            IF (KEEP(47) .GE. 3) THEN
              CALL DAGMG_MUMPS_500(                                          &
     &              IPOOL, LPOOL,                                       &
     &              PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,      &
     &              MYID_NODES, STEP, N, ND, FILS )
            ENDIF
            IF (KEEP(47).EQ.4) THEN
               IF(INODE.GT.0.AND.INODE.LE.N)THEN
                  IF((NE(STEP(INODE)).EQ.0).AND.                        &
     &                 (FRERE(STEP(INODE)).EQ.0))THEN
                     IS_ISOLATED_NODE=.TRUE.
                  ELSE
                     IS_ISOLATED_NODE=.FALSE.
                  ENDIF
               ENDIF
               CALL DAGMG_MUMPS_501(                                         &
     &              IS_ISOLATED_NODE,INODE,IPOOL,LPOOL,                 &
     &              MYID_NODES,SLAVEF,COMM_LOAD,KEEP,KEEP8)
            ENDIF
            IF ((( KEEP(80) == 2 .OR. KEEP(80)==3 ) .AND.               &
     &           ( KEEP(47) == 4 )).OR.                                 &
     &           (KEEP(80) == 1 .AND. KEEP(47) .GE. 1)) THEN
               CALL DAGMG_MUMPS_512(INODE,STEP,KEEP(28),                     &
     &         PROCNODE_STEPS,FRERE,ND,COMM_LOAD,SLAVEF,                &
     &         MYID_NODES,KEEP,KEEP8,N)
            END IF
            GOTO 30
          ENDIF
      ENDIF
      GO TO 20
   30 CONTINUE
      IF ( INODE .LT. 0 ) THEN
        INODE = -INODE
        FPERE = DAD(STEP(INODE))
        GOTO 130
      ELSE IF (INODE.GT.N) THEN
       INODE = INODE - N
       IF (INODE.EQ.KEEP(38)) THEN
         NBROOT_TRAITEES = NBROOT_TRAITEES + 1
         IF ( NBROOT_TRAITEES .EQ. NBROOT ) THEN
            NBFIN = NBFIN - NBROOT
            IF (SLAVEF.GT.1) THEN
                DUMMY(1) = NBROOT
                CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID_NODES,      &
     &          COMM_NODES, RACINE, SLAVEF)
            END IF
         ENDIF
         IF (NBFIN.EQ.0) GOTO 640
         GOTO 20
       ENDIF
       TYPE = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
       IF (TYPE.EQ.1) GOTO 100
       FPERE = DAD(STEP(INODE))
       AVOID_DELAYED = ( (FPERE .eq. KEEP(20) .OR. FPERE .eq. KEEP(38)) &
     &                   .AND. KEEP(60).ne.0 )
       IF ( KEEP(50) .eq. 0 ) THEN
         CALL  DAGMG_MUMPS_144( COMM_LOAD, ASS_IRECV,                        &
     &             N, INODE, FPERE, IW, LIW, A, LA,                     &
     &             UU, NOFFW,                                           &
     &             NPVW,                                                &
     &             COMM_NODES, MYID_NODES, BUFR, LBUFR,LBUFR_BYTES,     &
     &             NBFIN,LEAF,                                          &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC,                    &
     &             STEP, PIMASTER, PAMASTER,                            &
     &             NSTK_STEPS,NBPROCFILS,PROCNODE_STEPS,                &
     &             root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,   &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
     &              DKEEP(1),PIVNUL_LIST(1),LPN_LIST)
          IF ( IFLAG .LT. 0 ) GOTO 640
       ELSE
         CALL  DAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                        &
     &             N, INODE, FPERE, IW, LIW, A, LA,                     &
     &             UU, NOFFW,                                           &
     &             NPVW,                                                &
     &             COMM_NODES, MYID_NODES, BUFR, LBUFR,LBUFR_BYTES,     &
     &             NBFIN,LEAF,                                          &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC,                    &
     &             STEP, PIMASTER, PAMASTER,                            &
     &             NSTK_STEPS,NBPROCFILS,PROCNODE_STEPS,                &
     &             root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,   &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL_LDLT_NIV2,       &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
     &              DKEEP(1),PIVNUL_LIST(1),LPN_LIST)
        IF ( IFLAG .LT. 0 ) GOTO 640
        IF ( IW( PTLUST_S(STEP(INODE)) + KEEP(IXSZ) + 5 ) .GT. 1 ) THEN
             GOTO 20
        END IF
       END IF
       GOTO 130
      ENDIF
      IF (INODE.EQ.KEEP(38)) THEN
         CALL  DAGMG_MUMPS_176( COMM_LOAD, ASS_IRECV,                        &
     &    root, FRERE,                                                  &
     &    INODE,                                                        &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_STEPS, COMP,           &
     &    IFLAG, IERROR, COMM_NODES,                                    &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID_NODES, SLAVEF,                                    &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND,                        &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
         IF ( IFLAG .LT. 0 ) GOTO 640
        GOTO 20
      ENDIF
      TYPE = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      IF (TYPE.EQ.1) THEN
        IF (KEEP(55).NE.0) THEN
         CALL DAGMG_MUMPS_36( COMM_LOAD, ASS_IRECV,                          &
     &        NELT, FRTPTR, FRTELT,                                     &
     &        N,INODE,IW,LIW,A,LA,                                      &
     &        IFLAG,IERROR,ND,                                          &
     &        FILS,FRERE,MAXFRW,root,OPASSW, OPELIW,                    &
     &     PTRIST,PTLUST_S,PTRFAC,PTRAST,STEP, PIMASTER,PAMASTER,       &
     &        PTRARW,PTRAIW,                                            &
     &        ITLOC, NSTEPS, SON_LEVEL2,                                &
     &        COMP, LRLU, IPTRLU,                                       &
     &        IWPOS,IWPOSCB, POSFAC, LRLUS,                             &
     &        ICNTL, KEEP,KEEP8, INTARR, DBLARR,                        &
     &    NSTK_STEPS,NBPROCFILS, PROCNODE_STEPS, SLAVEF,                &
     &    COMM_NODES, MYID_NODES,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM, ISTEP_TO_INIV2, TAB_POS_IN_PERE )
        ELSE
         JOBASS = 0
         CALL DAGMG_MUMPS_252(COMM_LOAD, ASS_IRECV,                          &
     &        N,INODE,IW,LIW,A,LA,                                      &
     &        IFLAG,IERROR,ND,                                          &
     &        FILS,FRERE,DAD,MAXFRW,root,OPASSW, OPELIW,                &
     &      PTRIST,PTLUST_S,PTRFAC,PTRAST,STEP, PIMASTER,PAMASTER,      &
     &        PTRARW,PTRAIW,                                            &
     &        ITLOC, NSTEPS, SON_LEVEL2,                                &
     &        COMP, LRLU, IPTRLU,                                       &
     &        IWPOS,IWPOSCB, POSFAC, LRLUS,                             &
     &        ICNTL, KEEP,KEEP8, INTARR, DBLARR,                        &
     &    NSTK_STEPS,NBPROCFILS, PROCNODE_STEPS, SLAVEF,                &
     &    COMM_NODES, MYID_NODES,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    JOBASS,ETATASS )
        ENDIF
       IF ( IFLAG .LT. 0 ) GOTO 640
        IF ((NBPROCFILS(STEP(INODE)).GT.0).OR.(SON_LEVEL2)) GOTO 20
      ELSE
        IF ( KEEP(55) .eq. 0 ) THEN
          CALL DAGMG_MUMPS_253(COMM_LOAD, ASS_IRECV,                         &
     &    N, INODE, IW, LIW, A, LA,                                     &
     &    IFLAG, IERROR,                                                &
     &    ND, FILS, FRERE, CAND,                                        &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    MAXFRW,                                                       &
     &    root, OPASSW, OPELIW, PTRIST, PTLUST_S, PTRFAC,               &
     &    PTRAST, STEP, PIMASTER, PAMASTER, PTRARW, NSTK_STEPS,         &
     &    PTRAIW, ITLOC, NSTEPS,                                        &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP,KEEP8,INTARR,DBLARR,                              &
     &    NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM_NODES,               &
     &    MYID_NODES,                                                   &
     &    BUFR, LBUFR, LBUFR_BYTES,                                     &
     &    NBFIN, LEAF, IPOOL, LPOOL, PERM,                              &
     &    MEM_DISTRIB(0)                                                &
     &    )
        ELSE
          CALL DAGMG_MUMPS_37( COMM_LOAD, ASS_IRECV,                         &
     &    NELT, FRTPTR, FRTELT,                                         &
     &    N, INODE, IW, LIW, A, LA, IFLAG, IERROR,                      &
     &    ND, FILS, FRERE, CAND,                                        &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    MAXFRW,                                                       &
     &    root, OPASSW, OPELIW, PTRIST, PTLUST_S, PTRFAC,               &
     &    PTRAST, STEP, PIMASTER, PAMASTER, PTRARW, NSTK_STEPS,         &
     &    PTRAIW, ITLOC, NSTEPS,                                        &
     &    COMP, LRLU, IPTRLU, IWPOS, IWPOSCB, POSFAC, LRLUS,            &
     &    ICNTL, KEEP,KEEP8,INTARR,DBLARR,                              &
     &    NBPROCFILS, PROCNODE_STEPS, SLAVEF, COMM_NODES,               &
     &    MYID_NODES,                                                   &
     &    BUFR, LBUFR, LBUFR_BYTES,                                     &
     &    NBFIN, LEAF, IPOOL, LPOOL, PERM,                              &
     &    MEM_DISTRIB(0))
        END IF
        IF (IFLAG.LT.0) GOTO 640
        GOTO 20
      ENDIF
  100 CONTINUE
       FPERE = DAD(STEP(INODE))
      IF ( INODE .eq. KEEP(20) ) THEN
        POSELT = PTRAST(STEP(INODE))
        IF (PTRFAC(STEP(INODE)).NE.POSELT) THEN
          WRITE(*,*) "ERROR 2 in DAGMG_MUMPS_251", POSELT
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        CALL DAGMG_MUMPS_87                                                  &
     &       ( IW(PTLUST_S(STEP(INODE))+KEEP(IXSZ)) )
        GOTO 200
      END IF
      POSELT = PTRAST(STEP(INODE))
      IOLDPS = PTLUST_S(STEP(INODE))
      AVOID_DELAYED = ( (FPERE .eq. KEEP(20) .OR. FPERE .eq. KEEP(38))  &
     &                   .AND. KEEP(60).ne.0 )
      IF (KEEP(50).EQ.0) THEN
         CALL DAGMG_MUMPS_143( N, INODE, IW, LIW, A, LA,                     &
     &               IOLDPS, POSELT,                                    &
     &               IFLAG, UU, NOFFW, NPVW,                            &
     &               KEEP,KEEP8,                                        &
     &               STEP, PROCNODE_STEPS, MYID_NODES, SLAVEF,          &
     &               SEUIL, AVOID_DELAYED, ETATASS,                     &
     &              DKEEP(1),PIVNUL_LIST(1),LPN_LIST, IWPOS)
         JOBASS = ETATASS
         IF (JOBASS.EQ.1) THEN
           CALL DAGMG_MUMPS_252(COMM_LOAD, ASS_IRECV,                        &
     &        N,INODE,IW,LIW,A,LA,                                      &
     &        IFLAG,IERROR,ND,                                          &
     &        FILS,FRERE,DAD,MAXFRW,root,OPASSW, OPELIW,                &
     &      PTRIST,PTLUST_S,PTRFAC,PTRAST,STEP,PIMASTER,PAMASTER,       &
     &        PTRARW,PTRAIW,                                            &
     &        ITLOC, NSTEPS, SON_LEVEL2,                                &
     &        COMP, LRLU, IPTRLU,                                       &
     &        IWPOS,IWPOSCB, POSFAC, LRLUS,                             &
     &        ICNTL, KEEP,KEEP8, INTARR, DBLARR,                        &
     &    NSTK_STEPS,NBPROCFILS, PROCNODE_STEPS, SLAVEF,                &
     &    COMM_NODES, MYID_NODES,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    JOBASS,ETATASS )
         ENDIF
      ELSE
         IW( IOLDPS+4+KEEP(IXSZ) ) = 1
         CALL DAGMG_MUMPS_140( N, INODE,                                     &
     &           IW, LIW, A, LA,                                        &
     &           IOLDPS, POSELT,                                        &
     &           IFLAG, UU, NOFFW, NPVW,                                &
     &           KEEP,KEEP8, MYID_NODES, SEUIL, AVOID_DELAYED,          &
     &           ETATASS,                                               &
     &           DKEEP(1),PIVNUL_LIST(1),LPN_LIST, IWPOS)
         IW( IOLDPS+4+KEEP(IXSZ) ) = STEP(INODE)
         JOBASS = ETATASS
         IF (JOBASS.EQ.1) THEN
           CALL DAGMG_MUMPS_252(COMM_LOAD, ASS_IRECV,                        &
     &        N,INODE,IW,LIW,A,LA,                                      &
     &        IFLAG,IERROR,ND,                                          &
     &        FILS,FRERE,DAD,MAXFRW,root,OPASSW, OPELIW,                &
     &      PTRIST,PTLUST_S,PTRFAC,PTRAST,STEP,PIMASTER,PAMASTER,       &
     &        PTRARW,PTRAIW,                                            &
     &        ITLOC, NSTEPS, SON_LEVEL2,                                &
     &        COMP, LRLU, IPTRLU,                                       &
     &        IWPOS,IWPOSCB, POSFAC, LRLUS,                             &
     &        ICNTL, KEEP,KEEP8, INTARR, DBLARR,                        &
     &    NSTK_STEPS,NBPROCFILS, PROCNODE_STEPS, SLAVEF,                &
     &    COMM_NODES, MYID_NODES,                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, IPOOL, LPOOL, LEAF,          &
     &    PERM,                                                         &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE,                              &
     &    JOBASS,ETATASS )
         ENDIF
      ENDIF
      IF (IFLAG.LT.0) GOTO 635
  130 CONTINUE
      TYPE  = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      IF ( FPERE .NE. 0 ) THEN
        TYPEF = AGMG_MUMPS_330(STEP(FPERE),PROCNODE_STEPS,SLAVEF)
      ELSE
        TYPEF = -9999
      END IF
      CALL DAGMG_MUMPS_254( COMM_LOAD, ASS_IRECV,                            &
     &       N,INODE,TYPE,TYPEF,LA,IW,LIW,A,                            &
     &       IFLAG,IERROR,OPELIW,NELVAW,NMAXNPIV,                       &
     &       PTRIST,PTLUST_S,PTRFAC,                                    &
     &       PTRAST, STEP, PIMASTER, PAMASTER,                          &
     &       NE, POSFAC,LRLU,                                           &
     &       LRLUS,IPTRLU,ICNTL,KEEP,KEEP8,COMP,IWPOS,IWPOSCB,          &
     &       PROCNODE_STEPS,SLAVEF,FPERE,COMM_NODES,MYID_NODES,         &
     &       IPOOL, LPOOL, LEAF,                                        &
     &       NSTK_STEPS, NBPROCFILS, BUFR, LBUFR, LBUFR_BYTES, NBFIN,   &
     & root, OPASSW, ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,       &
     & ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,                         &
     & ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      IF (IFLAG.LT.0) GOTO 640
  200 CONTINUE
      IF ( INODE .eq. KEEP(38) ) THEN
        WRITE(*,*) 'Error .. in DMUMPS_251: ',                          &
     &             ' INODE == KEEP(38)'
        Stop
      END IF
      IF ( FPERE.EQ.0 ) THEN
        NBROOT_TRAITEES = NBROOT_TRAITEES + 1
        IF ( NBROOT_TRAITEES .EQ. NBROOT ) THEN
           IF (KEEP(201).EQ.1) THEN
              CALL DAGMG_MUMPS_681(IERR)
           ELSE IF ( KEEP(201).EQ.2) THEN
              CALL DAGMG_MUMPS_580(IERR)
           ENDIF
            NBFIN = NBFIN - NBROOT
            IF ( NBFIN .LT. 0 ) THEN
              WRITE(*,*) ' ERROR 1 in DMUMPS_251: ',                    &
     &                   ' NBFIN=', NBFIN
              CALL AGMG_MUMPS_ABORT()
            END IF
            IF ( NBROOT .LT. 0 ) THEN
              WRITE(*,*) ' ERROR 1 in DMUMPS_251: ',                    &
     &                   ' NBROOT=', NBROOT
              CALL AGMG_MUMPS_ABORT()
            END IF
            IF (SLAVEF.GT.1) THEN
                DUMMY(1) = NBROOT
                CALL DAGMG_MUMPS_242( DUMMY(1), 1, AGMG_MPF_INTEGER,              &
     &          MYID_NODES, COMM_NODES, RACINE, SLAVEF)
            END IF
        ENDIF
        IF (NBFIN.EQ.0)THEN
           GOTO 640
        ENDIF
      ELSEIF ( FPERE.NE.KEEP(38) .AND.                                  &
     &         AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,SLAVEF).EQ.         &
     &         MYID_NODES ) THEN
        NSTK_STEPS(STEP(FPERE)) = NSTK_STEPS(STEP(FPERE))-1
        IF ( NSTK_STEPS( STEP( FPERE )).EQ.0) THEN
          IF (KEEP(234).NE.0 .AND.                                      &
     &      AGMG_MUMPS_167(STEP(INODE),PROCNODE_STEPS,SLAVEF))               &
     &      THEN
            STACK_RIGHT_AUTHORIZED = .FALSE.
          ENDIF
          CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL,                              &
     &         PROCNODE_STEPS, SLAVEF, KEEP(28), KEEP(76),              &
     &         KEEP(80), KEEP(47), STEP, FPERE )
          IF (KEEP(47) .GE. 3) THEN
             CALL DAGMG_MUMPS_500(                                           &
     &            IPOOL, LPOOL,                                         &
     &            PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,        &
     &            MYID_NODES, STEP, N, ND, FILS )
          ENDIF
          CALL AGMG_MUMPS_137( FPERE, N, PROCNODE_STEPS,SLAVEF,              &
     &           ND, FILS, FRERE, STEP, PIMASTER, KEEP(28),             &
     &           KEEP(50), FLOP1,                                       &
     &           IW, LIW, KEEP(IXSZ) )
          IF (FPERE.NE.KEEP(20))                                        &
     &    CALL DAGMG_MUMPS_190(1,.FALSE.,FLOP1,KEEP,KEEP8)
        ENDIF
      ENDIF
      GO TO 20
  635 CONTINUE
      CALL DAGMG_MUMPS_44( MYID_NODES, SLAVEF, COMM_NODES )
  640 CONTINUE
        CALL DAGMG_MUMPS_255( INFO(1),                                       &
     &       ASS_IRECV, BUFR, LBUFR,                                    &
     &       LBUFR_BYTES,                                               &
     &       COMM_NODES,                                                &
     &       MYID_NODES, SLAVEF)
       CALL DAGMG_MUMPS_180( INFO(1),                                        &
     &      BUFR, LBUFR,                                                &
     &      LBUFR_BYTES,                                                &
     &      COMM_NODES, COMM_LOAD, SLAVEF, MP)
      CALL AGMG_SETIERR( IERR )
       IF ( INFO(1) .GE. 0 ) THEN
          IF( KEEP(38) .NE. 0 .OR. KEEP(20).NE.0) THEN
            IF ( KEEP(38) .NE. 0 )THEN
                 LBUFRX = min(int(root%MBLOCK,8)*int(root%NBLOCK,8),    &
     &            int(root%TOT_ROOT_SIZE,8)*int(root%TOT_ROOT_SIZE,8) )
                 IF ( LRLU .GT. LBUFRX ) THEN
                   BUFRX => A(POSFAC:POSFAC+LRLU-1_8)
                   LBUFRX=LRLU
                   IS_BUFRX_ALLOCATED = .FALSE.
                 ELSE
                   ALLOCATE( BUFRX( LBUFRX ), stat = IERR )
                   IF (IERR.gt.0) THEN
                         INFO(1) = -9
                         CALL AGMG_MUMPS_731(LBUFRX, INFO(2) )
                         write(LP,*) ' Error allocating, real array ',  &
     &                   'of size before DMUMPS_146',  LBUFRX
                         CALL AGMG_MUMPS_ABORT()
                   ENDIF
                   IS_BUFRX_ALLOCATED = .FALSE.
                ENDIF
                CALL DAGMG_MUMPS_146( MYID_NODES,                            &
     &               root, N, KEEP(38),                                 &
     &               COMM_NODES, IW, LIW, IWPOS + 1,                    &
     &               A, LA, PTRAST, PTLUST_S, PTRFAC, STEP,             &
     &               INFO(1), KEEP(50), KEEP(19),                       &
     &               BUFRX, LBUFRX, KEEP,KEEP8 )
                IF (IS_BUFRX_ALLOCATED) DEALLOCATE ( BUFRX )
                NULLIFY(BUFRX)
                IF ( MYID_NODES .eq. AGMG_MUMPS_275(STEP(KEEP(38)),          &
     &               PROCNODE_STEPS,SLAVEF)) THEN
                   IF ( INFO(1) .EQ. -10 .OR. INFO(1) .EQ. -40 ) THEN
                      NPVW = NPVW + INFO(2)
                   ELSE
                      NPVW = NPVW + root%TOT_ROOT_SIZE
                      NMAXNPIV = max(NMAXNPIV,root%TOT_ROOT_SIZE)
                   END IF
                END IF
                IF (root%yes.AND.KEEP(60).EQ.0) THEN
                  IF (KEEP(201) .NE.1) THEN
                    KEEP8(31)=KEEP8(31)+                                &
     &    int(IW(PTLUST_S(STEP(KEEP(38)))+2+KEEP(IXSZ)),8)*             &
     &    int(IW(PTLUST_S(STEP(KEEP(38)))+1+KEEP(IXSZ)),8)
                  ENDIF
                  IF (KEEP(201).EQ.1) THEN
                    IOLDPS = PTLUST_S(STEP(KEEP(38)))
                    CALL AGMG_MUMPS_729(LAFAC, IW(IOLDPS+XXR))
                    LIWFAC    = IW(IOLDPS+XXI)
                    TYPEFile  = TYPEF_L
                    NextPiv2beWritten = 1
                    MonBloc%INODE    = KEEP(38)
                    MonBloc%MASTER   = .TRUE.
                    MonBloc%Typenode = 3
                    MonBloc%NROW     = IW(IOLDPS + 2 + KEEP(IXSZ))
                    MonBloc%NCOL     = IW(IOLDPS + 1 + KEEP(IXSZ))
                    MonBloc%NFS      = MonBloc%NCOL
                    MonBloc%Last     = .TRUE.
                    MonBloc%LastPiv  =  MonBloc%NCOL
                    NULLIFY(MonBloc%INDICES)
                    STRAT        = STRAT_WRITE_MAX
                    MonBloc%Last = .TRUE.
                    LAST_CALL = .TRUE.
                    CALL DAGMG_MUMPS_688                                     &
     &                                 ( STRAT, TYPEFile,               &
     &                                  A(PTRFAC(STEP(KEEP(38)))),      &
     &                                  LAFAC, MonBloc,                 &
     &                                  NextPiv2beWritten, IDUMMY,      &
     &                                  IW(IOLDPS), LIWFAC,             &
     &                                  MYID, KEEP8(31), IERR,LAST_CALL)
                  ELSE IF (KEEP(201).EQ.2) THEN
                    CALL DAGMG_MUMPS_576(KEEP(38),PTRFAC,                    &
     &              KEEP,KEEP8,A,LA,                                    &
     &              int(IW(PTLUST_S(STEP(KEEP(38)))+2+KEEP(IXSZ)),8)*   &
     &              int(IW(PTLUST_S(STEP(KEEP(38)))+1+KEEP(IXSZ)),8),   &
     &              IERR)
                    IF(IERR.LT.0)THEN
               WRITE(*,*)MYID,': Internal error in DMUMPS_576'
                     CALL AGMG_MUMPS_ABORT()
                    ENDIF
                  ENDIF
                  ITMP8=                                                &
     &            int(IW(PTLUST_S(STEP(KEEP(38)))+2+KEEP(IXSZ)),8)*     &
     &            int(IW(PTLUST_S(STEP(KEEP(38)))+1+KEEP(IXSZ)),8)
                  IF(KEEP(201).NE.0)THEN
                     POSFAC = POSFAC  - ITMP8
                     LRLU   = LRLU    + ITMP8
                     LRLUS  = LRLUS   + ITMP8
                  ENDIF
                  CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                      &
     &                 LA-LRLUS                                         &
     &                 ,ITMP8,0_8,                                      &
     &                 KEEP,KEEP8,LRLU)
               ENDIF
            ELSE
                IF (KEEP(19).NE.0) THEN
                  CALL AGMG_COPY(KEEP(109), GLOBK109, 1,                                        AGMG_MPF_INTEGER, IERR)
                ENDIF
                CONCERNED =  (MYID_NODES .EQ.                           &
     &                        AGMG_MUMPS_275(STEP(KEEP(20)),                 &
     &                              PROCNODE_STEPS,SLAVEF))
                IF (CONCERNED ) THEN
                   IPOSROOT = PTLUST_S(STEP(KEEP(20)))
                   NFRONT   = IW(IPOSROOT+KEEP(IXSZ))
                   NFRONT8  = int(NFRONT,8)
                   IPOSROOTROWINDICES=IPOSROOT+6+KEEP(IXSZ)+            &
     &                             IW(IPOSROOT+5+KEEP(IXSZ))
                   NPVW = NPVW + NFRONT
                   NMAXNPIV = max(NMAXNPIV,NFRONT)
                END IF
               IF (CONCERNED.AND.KEEP(60).NE.0) THEN
                IF (KEEP(201).NE.0) THEN
                  LRLUS = LRLUS + NFRONT8*NFRONT8
                  LRLU  = LRLUS + NFRONT8*NFRONT8
                  POSFAC = POSFAC - NFRONT8*NFRONT8
                ENDIF
                CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                        &
     &          LA-LRLUS,NFRONT8*NFRONT8,0_8,KEEP,KEEP8,LRLU)
               ENDIF
            END IF
          END IF
       END IF
       IF ( KEEP(38) .NE. 0 ) THEN
         IF (MYID_NODES.EQ. AGMG_MUMPS_275(STEP(KEEP(38)),                   &
     &           PROCNODE_STEPS,SLAVEF)) THEN
           MAXFRW = max ( MAXFRW, root%TOT_ROOT_SIZE)
         END IF
       END IF
       MAXFRT       = MAXFRW
       NTOTPV       = NPVW
       INFO(12)     = NOFFW
       RINFO(2)     = dble(OPASSW)
       RINFO(3)     = dble(OPELIW)
       INFO(13)     = NELVAW
       INFO(14)     = COMP
      RETURN
      END SUBROUTINE DAGMG_MUMPS_251
      SUBROUTINE DAGMG_MUMPS_87( HEADER )
        INTEGER HEADER( 6 )
        INTEGER NFRONT, NASS
        NFRONT = HEADER(1)
        IF ( HEADER(2) .ne. 0 ) THEN
          WRITE(*,*) ' *** CHG_HEADER ERROR 1 :',HEADER(2)
          CALL AGMG_MUMPS_ABORT()
        END IF
        NASS   = IABS( HEADER( 3 ) )
        IF ( NASS .NE. IABS( HEADER( 4 ) ) ) THEN
          WRITE(*,*) ' *** CHG_HEADER ERROR 2 :',HEADER(3:4)
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF ( NASS .NE. NFRONT ) THEN
          WRITE(*,*) ' *** CHG_HEADER ERROR 3 : not root'
          CALL AGMG_MUMPS_ABORT()
        END IF
        HEADER( 1 ) = NFRONT
        HEADER( 2 ) = 0
        HEADER( 3 ) = NFRONT
        HEADER( 4 ) = NFRONT
        RETURN
      END SUBROUTINE DAGMG_MUMPS_87
      SUBROUTINE DAGMG_MUMPS_136( id )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_STRUC_DEF
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE( DAGMG_MUMPS_STRUC ) :: id
      LOGICAL I_AM_SLAVE
      INTEGER IERR, MASTER, STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER MAXS_BYTES
      PARAMETER ( MASTER = 0 )
      I_AM_SLAVE = ( id%MYID .ne. MASTER .OR. id%KEEP(46) .NE. 0 )
      IF (id%KEEP(201).GT.0 .AND. I_AM_SLAVE) THEN
        CALL DAGMG_MUMPS_587(id,IERR)
        IF (IERR < 0) THEN
          id%INFO(1) = -90
          id%INFO(2) = 0
        ENDIF
      END IF
      CALL AGMG_MUMPS_276(id%ICNTL, id%INFO,                                 &
     &     id%COMM, id%MYID)
      IF (id%root%gridinit_done) THEN
        IF ( id%KEEP(38).NE.0 .and. id%root%yes ) THEN
          CALL AGMG_NOCALL('BLACS_GRIDEXIT')
          id%root%gridinit_done = .FALSE.
        END IF
      END IF
      IF ( id%MYID .NE. MASTER .OR. id%KEEP(46) .ne. 0 ) THEN
        CALL AGMG_SETIERR( IERR )
        CALL AGMG_SETIERR( IERR )
      END IF
      IF (associated(id%MEM_DIST))  THEN
         DEALLOCATE(id%MEM_DIST)
         NULLIFY(id%MEM_DIST)
      ENDIF
      IF (associated(id%MAPPING)) THEN
        DEALLOCATE(id%MAPPING)
        NULLIFY(id%MAPPING)
      END IF
      IF (associated(id%NULL_SPACE)) THEN
        DEALLOCATE(id%NULL_SPACE)
        NULLIFY(id%NULL_SPACE)
      ENDIF
       NULLIFY(id%SCHUR_CINTERFACE)
      IF ( id%KEEP(52) .NE. -1 .or. id%MYID .ne. MASTER ) THEN
        IF (associated(id%COLSCA)) THEN
          DEALLOCATE(id%COLSCA)
          NULLIFY(id%COLSCA)
        ENDIF
        IF (associated(id%ROWSCA)) THEN
          DEALLOCATE(id%ROWSCA)
          NULLIFY(id%ROWSCA)
        ENDIF
      END IF
      IF (associated(id%PTLUST_S)) THEN
        DEALLOCATE(id%PTLUST_S)
        NULLIFY(id%PTLUST_S)
      END IF
      IF (associated(id%PTRFAC)) THEN
        DEALLOCATE(id%PTRFAC)
        NULLIFY(id%PTRFAC)
      END IF
      IF (associated(id%POIDS)) THEN
        DEALLOCATE(id%POIDS)
        NULLIFY(id%POIDS)
      ENDIF
      IF (associated(id%IS)) THEN
        DEALLOCATE(id%IS)
        NULLIFY(id%IS)
      ENDIF
      IF (associated(id%IS1)) THEN
        DEALLOCATE(id%IS1)
        NULLIFY(id%IS1)
      ENDIF
      IF (associated(id%STEP))      THEN
        DEALLOCATE(id%STEP)
        NULLIFY(id%STEP)
      ENDIF
      IF (associated(id%NE_STEPS))  THEN
        DEALLOCATE(id%NE_STEPS)
        NULLIFY(id%NE_STEPS)
      ENDIF
      IF (associated(id%ND_STEPS))  THEN
        DEALLOCATE(id%ND_STEPS)
        NULLIFY(id%ND_STEPS)
      ENDIF
      IF (associated(id%FRERE_STEPS))  THEN
        DEALLOCATE(id%FRERE_STEPS)
        NULLIFY(id%FRERE_STEPS)
      ENDIF
      IF (associated(id%DAD_STEPS))  THEN
        DEALLOCATE(id%DAD_STEPS)
        NULLIFY(id%DAD_STEPS)
      ENDIF
      IF (associated(id%SYM_PERM))  THEN
        DEALLOCATE(id%SYM_PERM)
        NULLIFY(id%SYM_PERM)
      ENDIF
      IF (associated(id%UNS_PERM))  THEN
        DEALLOCATE(id%UNS_PERM)
        NULLIFY(id%UNS_PERM)
      ENDIF
      IF (associated(id%PIVNUL_LIST))  THEN
        DEALLOCATE(id%PIVNUL_LIST)
        NULLIFY(id%PIVNUL_LIST)
      ENDIF
      IF (associated(id%FILS))      THEN
        DEALLOCATE(id%FILS)
        NULLIFY(id%FILS)
      ENDIF
      IF (associated(id%PTRAR))     THEN
        DEALLOCATE(id%PTRAR)
        NULLIFY(id%PTRAR)
      ENDIF
      IF (associated(id%FRTPTR))    THEN
        DEALLOCATE(id%FRTPTR)
        NULLIFY(id%FRTPTR)
      ENDIF
      IF (associated(id%FRTELT))    THEN
        DEALLOCATE(id%FRTELT)
        NULLIFY(id%FRTELT)
      ENDIF
      IF (associated(id%NA))        THEN
        DEALLOCATE(id%NA)
        NULLIFY(id%NA)
      ENDIF
      IF (associated(id%PROCNODE_STEPS)) THEN
        DEALLOCATE(id%PROCNODE_STEPS)
        NULLIFY(id%PROCNODE_STEPS)
      ENDIF
      IF (associated(id%PROCNODE)) THEN
        DEALLOCATE(id%PROCNODE)
        NULLIFY(id%PROCNODE)
      ENDIF
      IF (associated(id%RHSCOMP)) THEN
        DEALLOCATE(id%RHSCOMP)
        NULLIFY(id%RHSCOMP)
      ENDIF
      IF (associated(id%POSINRHSCOMP)) THEN
        DEALLOCATE(id%POSINRHSCOMP)
        NULLIFY(id%POSINRHSCOMP)
      ENDIF
      IF (id%KEEP(46).eq.1 .and.                                        &
     &    id%KEEP(55).ne.0 .and.                                        &
     &    id%MYID .eq. MASTER .and.                                     &
     &    id%KEEP(52) .eq. 0 ) THEN
        NULLIFY(id%DBLARR)
      ELSE
        IF (associated(id%DBLARR)) THEN
          DEALLOCATE(id%DBLARR)
          NULLIFY(id%DBLARR)
        ENDIF
      END IF
      IF (associated(id%INTARR))       THEN
        DEALLOCATE(id%INTARR)
        NULLIFY(id%INTARR)
      ENDIF
      IF (associated(id%root%RG2L_ROW))THEN
        DEALLOCATE(id%root%RG2L_ROW)
        NULLIFY(id%root%RG2L_ROW)
      ENDIF
      IF (associated(id%root%RG2L_COL))THEN
        DEALLOCATE(id%root%RG2L_COL)
        NULLIFY(id%root%RG2L_COL)
      ENDIF
      IF (associated(id%root%IPIV))    THEN
        DEALLOCATE(id%root%IPIV)
        NULLIFY(id%root%IPIV)
      ENDIF
      CALL DAGMG_MUMPS_636(id)
      IF (associated(id%ELTPROC))     THEN
        DEALLOCATE(id%ELTPROC)
        NULLIFY(id%ELTPROC)
      ENDIF
      IF (associated(id%CANDIDATES)) THEN
        DEALLOCATE(id%CANDIDATES)
        NULLIFY(id%CANDIDATES)
      ENDIF
      IF (associated(id%I_AM_CAND)) THEN
        DEALLOCATE(id%I_AM_CAND)
        NULLIFY(id%I_AM_CAND)
      ENDIF
      IF (associated(id%ISTEP_TO_INIV2)) THEN
        DEALLOCATE(id%ISTEP_TO_INIV2)
        NULLIFY(id%ISTEP_TO_INIV2)
      ENDIF
      IF (I_AM_SLAVE) THEN
       IF (associated(id%TAB_POS_IN_PERE)) THEN
        DEALLOCATE(id%TAB_POS_IN_PERE)
        NULLIFY(id%TAB_POS_IN_PERE)
       ENDIF
       IF (associated(id%FUTURE_NIV2)) THEN
        DEALLOCATE(id%FUTURE_NIV2)
        NULLIFY(id%FUTURE_NIV2)
       ENDIF
      ENDIF
      IF(associated(id%DEPTH_FIRST))THEN
        DEALLOCATE(id%DEPTH_FIRST)
        NULLIFY(id%DEPTH_FIRST)
      ENDIF
      IF (associated(id%MEM_SUBTREE)) THEN
        DEALLOCATE(id%MEM_SUBTREE)
        NULLIFY(id%MEM_SUBTREE)
      ENDIF
      IF (associated(id%MY_ROOT_SBTR)) THEN
        DEALLOCATE(id%MY_ROOT_SBTR)
        NULLIFY(id%MY_ROOT_SBTR)
      ENDIF
      IF (associated(id%MY_FIRST_LEAF)) THEN
        DEALLOCATE(id%MY_FIRST_LEAF)
        NULLIFY(id%MY_FIRST_LEAF)
      ENDIF
      IF (associated(id%MY_NB_LEAF)) THEN
        DEALLOCATE(id%MY_NB_LEAF)
        NULLIFY(id%MY_NB_LEAF)
      ENDIF
      IF (associated(id%COST_TRAV)) THEN
        DEALLOCATE(id%COST_TRAV)
        NULLIFY(id%COST_TRAV)
      ENDIF
        IF(associated (id%OOC_INODE_SEQUENCE))THEN
           DEALLOCATE(id%OOC_INODE_SEQUENCE)
           NULLIFY(id%OOC_INODE_SEQUENCE)
        ENDIF
        IF(associated (id%OOC_TOTAL_NB_NODES))THEN
           DEALLOCATE(id%OOC_TOTAL_NB_NODES)
           NULLIFY(id%OOC_TOTAL_NB_NODES)
        ENDIF
        IF(associated (id%OOC_SIZE_OF_BLOCK))THEN
           DEALLOCATE(id%OOC_SIZE_OF_BLOCK)
           NULLIFY(id%OOC_SIZE_OF_BLOCK)
        ENDIF
        IF(associated (id%OOC_VADDR))THEN
           DEALLOCATE(id%OOC_VADDR)
           NULLIFY(id%OOC_VADDR)
        ENDIF
        IF(associated (id%OOC_NB_FILES))THEN
           DEALLOCATE(id%OOC_NB_FILES)
           NULLIFY(id%OOC_NB_FILES)
        ENDIF
      IF (id%KEEP8(24).EQ.0_8) THEN
        IF (associated(id%S))        DEALLOCATE(id%S)
      ELSE
      ENDIF
      NULLIFY(id%S)
      IF (I_AM_SLAVE) THEN
        CALL DAGMG_MUMPS_57( IERR )
        CALL DAGMG_MUMPS_59( IERR )
      END IF
      IF ( associated( id%BUFR ) ) DEALLOCATE( id%BUFR )
      NULLIFY( id%BUFR )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_136
      SUBROUTINE DAGMG_MUMPS_150(MYID,COMM,S,MAXS,MAXS_BYTES)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER COMM, MYID, MAXS, MAXS_BYTES
      INTEGER S( MAXS )
      INTEGER MSGTAG, MSGSOU, MSGLEN
      LOGICAL FLAG
      FLAG = .TRUE.
      DO WHILE ( FLAG )
        CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG, COMM,             &
     &                   FLAG, STATUS, IERR )
        IF (FLAG) THEN
          MSGTAG=STATUS(AGMG_MPF_TAG)
          MSGSOU=STATUS(AGMG_MPF_SOURCE)
          CALL AGMG_NOCALL('MPI_GET_COUNT')
          IF (MSGLEN <= MAXS_BYTES) THEN
            CALL AGMG_NOCALL('MPI_RECV')
          ELSE
            EXIT
          ENDIF
        END IF
      END DO
      CALL AGMG_SETIERR( IERR )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_150
      SUBROUTINE DAGMG_MUMPS_254(COMM_LOAD, ASS_IRECV,                       &
     &    N, INODE, TYPE, TYPEF,                                        &
     &    LA, IW, LIW, A,                                               &
     &    IFLAG, IERROR, OPELIW, NELVAW, NMAXNPIV,                      &
     &    PTRIST, PTLUST_S,                                             &
     &    PTRFAC, PTRAST,                                               &
     &    STEP, PIMASTER, PAMASTER, NE,                                 &
     &    POSFAC, LRLU, LRLUS, IPTRLU, ICNTL, KEEP,KEEP8,               &
     &    COMP, IWPOS, IWPOSCB, PROCNODE_STEPS, SLAVEF,                 &
     &    FPERE, COMM, MYID,                                            &
     &    IPOOL, LPOOL, LEAF, NSTK_S,                                   &
     &    NBPROCFILS,                                                   &
     &    BUFR, LBUFR, LBUFR_BYTES, NBFIN, root,                        &
     &    OPASSW, ITLOC, FILS, PTRARW, PTRAIW, INTARR, DBLARR,          &
     &    ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,                      &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER COMM, MYID, TYPE, TYPEF
      INTEGER N, LIW, INODE,IFLAG,IERROR
      INTEGER ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA, POSFAC, LRLU, LRLUS, IPTRLU
      INTEGER IWPOSCB, IWPOS,                                           &
     &        FPERE, SLAVEF, NELVAW, NMAXNPIV
      INTEGER IW(LIW),PROCNODE_STEPS(KEEP(28))
      INTEGER(8) :: PTRAST  (KEEP(28))
      INTEGER(8) :: PTRFAC  (KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28)), NE(KEEP(28))
      DOUBLE PRECISION    A(LA)
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER ITLOC( N ), FILS( N ),                                    &
     &        ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER PTRAIW( LPTRAR ), PTRARW( LPTRAR )
      INTEGER LPOOL, LEAF, COMP
      INTEGER IPOOL( LPOOL )
      INTEGER NSTK_S( KEEP(28) )
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER NBFIN
      INTEGER IWRITEFAC, IREADFAC,NFRONT_ESTIM,NELIM_ESTIM
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER LP
      INTEGER NBROWS_ALREADY_SENT
      INTEGER(8) :: APOS, POSELT, OPSFAC
      INTEGER(8) :: IOLD, INEW, FACTOR_POS
      INTEGER NSLAVES, NCB,                                             &
     &        H_INODE, IERR, IERR_MPI, NBCOL, NBROW, NBROW_SEND,        &
     &        NBROW_STACK, NBCOL_STACK, NELIM
      INTEGER NCBROW_ALREADY_MOVED, NCBROW_PREVIOUSLY_MOVED,            &
     &NCBROW_NEWLY_MOVED
      INTEGER(8) :: LAST_ALLOWED_POS
      INTEGER(8) :: LREQCB, MIN_SPACE_IN_PLACE
      INTEGER(8) :: SHIFT_VAL_SON
      INTEGER SHIFT_LIST_ROW_SON,                                       &
     &        SHIFT_LIST_COL_SON,                                       &
     &        LIST_ROW_SON, LIST_COL_SON, LIST_SLAVES
      INTEGER IOLDPS,NFRONT,NPIV,NASS,IOLDP1,PTROWEND,                  &
     &        LREQI, LCONT
      INTEGER I,NPOS,J,J1,LDA, INIV2
      INTEGER MSGDEST, MSGTAG, CHK_LOAD
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL  COMPRESSCB, MUST_COMPACT_FACTORS
      LOGICAL  INPLACE
      INTEGER(8) :: SIZE_INPLACE
      INTEGER INTSIZ
      DOUBLE PRECISION FLOP1, FLOP1_EFFECTIVE
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      LOGICAL SSARBR, SSARBR_ROOT, AGMG_MUMPS_167,                           &
     &AGMG_MUMPS_170
      EXTERNAL AGMG_MUMPS_167, AGMG_MUMPS_170
      LP = ICNTL(1)
      IF (ICNTL(4) .LE. 0) LP = -1
      INPLACE = .FALSE.
      MIN_SPACE_IN_PLACE = 0_8
      IOLDPS = PTLUST_S(STEP(INODE))
      INTSIZ = IW(IOLDPS+XXI)
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      NPIV   = IW(IOLDPS + 1+KEEP(IXSZ))
      NMAXNPIV = MAX(NPIV, NMAXNPIV)
      NASS   = iabs(IW(IOLDPS + 2+KEEP(IXSZ)))
      NSLAVES=  IW(IOLDPS+5+KEEP(IXSZ))
      H_INODE= 6 + NSLAVES + KEEP(IXSZ)
      LCONT = NFRONT - NPIV
      NBCOL = LCONT
      SSARBR = AGMG_MUMPS_167(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      SSARBR_ROOT = AGMG_MUMPS_170                                           &
     &              (STEP(INODE),PROCNODE_STEPS,SLAVEF)
      LREQCB = 0_8
      INPLACE = .FALSE.
      COMPRESSCB= ((KEEP(215).EQ.0)                                     &
     &             .AND.(KEEP(50).NE.0)                                 &
     &             .AND.(TYPEF.EQ.1                                     &
     &             .OR.TYPEF.EQ.2                                       &
     &              )                                                   &
     &             .AND.(TYPE.EQ.1))
      MUST_COMPACT_FACTORS = .TRUE.
      IF (KEEP(201).EQ.1 .OR. KEEP(201).EQ.-1) THEN
            MUST_COMPACT_FACTORS = .FALSE.
      ENDIF
      IF ((FPERE.EQ.0).AND.(NASS.NE.NPIV)) THEN
        IFLAG = -10
        GOTO 600
      ENDIF
      NBROW      = LCONT
      IF (TYPE.EQ.2) NBROW = NASS - NPIV
      IF ((KEEP(50).NE.0).AND.(TYPE.EQ.2)) THEN
        LDA = NASS
      ELSE
        LDA = NFRONT
      ENDIF
      NBROW_SEND = NBROW
      NELIM = NASS-NPIV
      IF (TYPEF.EQ.2) NBROW_SEND = NELIM
      POSELT = PTRAST(STEP(INODE))
      IF (POSELT .ne. PTRFAC(STEP(INODE))) THEN
        WRITE(*,*) "Error 1 in G"
        CALL AGMG_MUMPS_ABORT()
      END IF
      NELVAW = NELVAW + NASS - NPIV
      IF (KEEP(50) .eq. 0) THEN
        KEEP8(10) = KEEP8(10) + int(NPIV,8) * int(NFRONT,8)
      ELSE
        KEEP8(10) = KEEP8(10) + ( int(NPIV,8)*int(NPIV+1,8) )/ 2_8
      ENDIF
      KEEP8(10) = KEEP8(10) + int(NBROW,8) * int(NPIV,8)
      CALL AGMG_MUMPS_511( NFRONT, NPIV, NASS,                               &
     &     KEEP(50), TYPE,FLOP1 )
      IF ( (.NOT. SSARBR_ROOT) .and. TYPE == 1) THEN
        IF (NE(STEP(INODE))==0) THEN
          CHK_LOAD=0
        ELSE
          CHK_LOAD=1
        ENDIF
        CALL DAGMG_MUMPS_190(CHK_LOAD, .FALSE., -FLOP1,                      &
     &                      KEEP,KEEP8)
      ENDIF
      FLOP1_EFFECTIVE = FLOP1
      OPELIW = OPELIW + FLOP1
      IF ( NPIV .NE. NASS ) THEN
        CALL AGMG_MUMPS_511( NFRONT, NASS, NASS,                             &
     &       KEEP(50), TYPE,FLOP1 )
         IF (.NOT. SSARBR_ROOT ) THEN
            IF (NE(STEP(INODE))==0) THEN
              CHK_LOAD=0
            ELSE
              CHK_LOAD=1
            ENDIF
            CALL DAGMG_MUMPS_190(CHK_LOAD, .FALSE.,                          &
     &                         FLOP1_EFFECTIVE-FLOP1,                   &
     &                         KEEP,KEEP8)
         ENDIF
      END IF
      IF ( SSARBR_ROOT ) THEN
        NFRONT_ESTIM=ND(STEP(INODE))
        NELIM_ESTIM=NASS-(NFRONT-NFRONT_ESTIM)
        CALL AGMG_MUMPS_511(NFRONT_ESTIM,NELIM_ESTIM,NELIM_ESTIM,            &
     &       KEEP(50),1,FLOP1)
      END IF
      FLOP1=-FLOP1
      IF (SSARBR_ROOT) THEN
        CALL DAGMG_MUMPS_190(0,.FALSE.,FLOP1,KEEP,KEEP8)
      ELSE
        CALL DAGMG_MUMPS_190(2,.FALSE.,FLOP1,KEEP,KEEP8)
      ENDIF
      IF ( FPERE .EQ. 0 ) THEN
         MUST_COMPACT_FACTORS = .FALSE.
         GOTO 190
      ENDIF
      IF ( FPERE.EQ.KEEP(38) ) THEN
       NCB   = NFRONT - NASS
       SHIFT_LIST_ROW_SON = H_INODE + NASS
       SHIFT_LIST_COL_SON = H_INODE + NFRONT + NASS
       SHIFT_VAL_SON      = int(NASS,8)*int(NFRONT+1,8)
       IF (TYPE.EQ.1) THEN
         CALL DAGMG_MUMPS_80(                                                &
     &    COMM_LOAD, ASS_IRECV,                                         &
     &    N, INODE, FPERE,                                              &
     &    PTLUST_S, PTRAST,                                             &
     &    root, NCB, NCB, SHIFT_LIST_ROW_SON,                           &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, NFRONT,                   &
     &    ROOT_CONT_STATIC, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, .FALSE., ND, FRERE,        &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF (IFLAG < 0 ) GOTO 500
       ENDIF
       MSGDEST=  AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,SLAVEF)
       IOLDPS = PTLUST_S(STEP(INODE))
       LIST_ROW_SON = IOLDPS + H_INODE + NPIV
       LIST_COL_SON = IOLDPS + H_INODE + NFRONT + NPIV
       LIST_SLAVES  = IOLDPS + 6 + KEEP(IXSZ)
       IF (MSGDEST.EQ.MYID) THEN
         CALL DAGMG_MUMPS_273( root,                                         &
     &      INODE, NELIM, NSLAVES, IW(LIST_ROW_SON),                    &
     &      IW(LIST_COL_SON), IW(LIST_SLAVES),                          &
     &      PROCNODE_STEPS, IWPOS, IWPOSCB, IPTRLU,                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                     &
     &      PTLUST_S, PTRFAC,                                           &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, ITLOC, COMP,      &
     &      IFLAG, IERROR,                                              &
     &      IPOOL, LPOOL, LEAF, MYID, SLAVEF, KEEP,KEEP8,               &
     &      COMM, COMM_LOAD, FILS, ND)
         IF (IFLAG.LT.0) GOTO 600
       ELSE
        IERR = -1
        DO WHILE (IERR.EQ.-1)
         CALL DAGMG_MUMPS_76( INODE, NELIM,                                  &
     &     IW(LIST_ROW_SON), IW(LIST_COL_SON), NSLAVES,                 &
     &     IW(LIST_SLAVES), MSGDEST, COMM, IERR)
         IF ( IERR .EQ. -1 ) THEN
            BLOCKING   =.FALSE.
            SET_IRECV  =.TRUE.
            MESSAGE_RECEIVED = .FALSE.
            CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                      &
     &       BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                     &
     &       AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                               &
     &       STATUS,                                                    &
     &       BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,          &
     &       IWPOS, IWPOSCB, IPTRLU,                                    &
     &       LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                    &
     &       PTLUST_S, PTRFAC,                                          &
     &       PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,            &
     &       IFLAG, IERROR, COMM,                                       &
     &       NBPROCFILS,                                                &
     &       IPOOL, LPOOL, LEAF,                                        &
     &       NBFIN, MYID, SLAVEF,                                       &
     &       root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &       INTARR, DBLARR, ICNTL, KEEP,KEEP8,                         &
     &       ND, FRERE, LPTRAR, NELT,                                   &
     &       FRTPTR, FRTELT,                                            &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE,                           &
     &       .TRUE.)
            IF ( IFLAG .LT. 0 ) GOTO 500
            IOLDPS = PTLUST_S(STEP(INODE))
            LIST_ROW_SON = IOLDPS + H_INODE + NPIV
            LIST_COL_SON = IOLDPS + H_INODE + NFRONT + NPIV
            LIST_SLAVES  = IOLDPS + 6 + KEEP(IXSZ)
         ENDIF
        ENDDO
        IF ( IERR .EQ. -2 ) THEN
            IERROR = ( 3 + NSLAVES + 2 * NELIM ) * KEEP( 34 )
            IFLAG  = - 17
            GOTO 600
        ELSE IF ( IERR .EQ. -3 ) THEN
            IERROR = ( 3 + NSLAVES + 2 * NELIM ) * KEEP( 34 )
            IFLAG  = -20
            GOTO 600
        ENDIF
       ENDIF
       IF (NELIM.EQ.0) THEN
          POSELT = PTRAST(STEP(INODE))
          OPSFAC = POSELT + int(NPIV,8) * int(NFRONT,8) + int(NPIV,8)
          GOTO 190
       ELSE
          GOTO 500
       ENDIF
      ENDIF
      OPSFAC = POSELT + int(NPIV,8) * int(LDA,8) + int(NPIV,8)
      IF ( AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,                        &
     &     SLAVEF) .NE. MYID ) THEN
        MSGTAG =NOEUD
        MSGDEST=AGMG_MUMPS_275( STEP(FPERE), PROCNODE_STEPS, SLAVEF )
        IERR = -1
        NBROWS_ALREADY_SENT = 0
        DO WHILE (IERR.EQ.-1)
          IF ( (TYPE.EQ.1) .AND. (TYPEF.EQ.1) ) THEN
             CALL DAGMG_MUMPS_66( NBROWS_ALREADY_SENT,                       &
     &         INODE, FPERE, NFRONT,                                    &
     &         LCONT, NASS, NPIV, IW( IOLDPS +  H_INODE + NPIV ),       &
     &         IW( IOLDPS +  H_INODE + NPIV + NFRONT ),                 &
     &         A( OPSFAC ), COMPRESSCB,                                 &
     &         MSGDEST, MSGTAG, COMM, IERR )
          ELSE
             IF ( (TYPE.EQ.2).AND.(KEEP(48).NE.0)) THEN
              INIV2 = ISTEP_TO_INIV2 ( STEP(INODE) )
             ELSE
              INIV2 = -9999
             ENDIF
             CALL DAGMG_MUMPS_70( NBROWS_ALREADY_SENT,                       &
     &             FPERE, INODE,                                        &
     &             NBROW_SEND, IW(IOLDPS +  H_INODE + NPIV ),           &
     &             NBCOL, IW(IOLDPS +  H_INODE + NPIV + NFRONT ),       &
     &             A(OPSFAC), LDA, NELIM, TYPE,                         &
     &             NSLAVES, IW(IOLDPS+6+KEEP(IXSZ)), MSGDEST,           &
     &             COMM, IERR,                                          &
     &             SLAVEF, KEEP,KEEP8, INIV2, TAB_POS_IN_PERE )
          END IF
          IF ( IERR .EQ. -1 ) THEN
            BLOCKING  = .FALSE.
            SET_IRECV = .TRUE.
            MESSAGE_RECEIVED = .FALSE.
            CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                      &
     &       BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                     &
     &       AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                               &
     &       STATUS,                                                    &
     &       BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,          &
     &       IWPOS, IWPOSCB, IPTRLU,                                    &
     &       LRLU, LRLUS, N, IW, LIW, A, LA,                            &
     &       PTRIST, PTLUST_S, PTRFAC,                                  &
     &       PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,            &
     &       IFLAG, IERROR, COMM,                                       &
     &       NBPROCFILS,                                                &
     &       IPOOL, LPOOL, LEAF,                                        &
     &       NBFIN, MYID, SLAVEF,                                       &
     &       root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &       INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,              &
     &       LPTRAR, NELT, FRTPTR, FRTELT,                              &
     &       ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.  )
             IF ( IFLAG .LT. 0 ) GOTO 500
          ENDIF
          IOLDPS = PTLUST_S(STEP( INODE ))
          OPSFAC = POSELT + int(NPIV,8) * int(LDA,8) + int(NPIV,8)
        END DO
        IF ( IERR .EQ. -2 .OR. IERR .EQ. -3 ) THEN
          IF ( (TYPE.EQ.1) .AND. (TYPEF.EQ.1) ) THEN
            IERROR = ( 2*LCONT + 9 ) * KEEP( 34 ) +                     &
     &          LCONT*LCONT * KEEP( 35 )
          ELSE IF (KEEP(50).ne.0 .AND. TYPE .eq. 2 ) THEN
            IERROR = ( NBROW_SEND + NBCOL+ 5 + NSLAVES)                 &
     &                 * KEEP( 34 ) +                                   &
     &          NBROW_SEND*NBROW_SEND*KEEP( 35 )
          ELSE
            IERROR = ( NBROW_SEND + NBCOL+ 5 + NSLAVES) * KEEP( 34 ) +  &
     &          NBROW_SEND*NBCOL*KEEP( 35 )
          ENDIF
          IF (IERR .EQ. -2) THEN
            IFLAG = -17
            IF ( LP  >  0 ) THEN
              WRITE(LP, *) MYID,                                        &
     & ": FAILURE, SEND BUFFER TOO SMALL DURING                         &
     & DAGMG_MUMPS_254", TYPE, TYPEF
            ENDIF
          ENDIF
          IF (IERR .EQ. -3) THEN
            IFLAG = -20
            IF ( LP  >  0 ) THEN
              WRITE(LP, *) MYID,                                        &
     & ": FAILURE, RECV BUFFER TOO SMALL DURING                         &
     & DAGMG_MUMPS_254", TYPE, TYPEF
            ENDIF
          ENDIF
          GOTO 600
        ENDIF
      ENDIF
      IF ( AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,                        &
     &     SLAVEF) .EQ. MYID ) THEN
        LREQI = 2 + KEEP(IXSZ)
        NBROW_STACK = NBROW
        NBROW_SEND = 0
        IF ((KEEP(50).NE.0).AND.(TYPE.EQ.2)) THEN
          NBCOL_STACK = NBROW
        ELSE
          NBCOL_STACK = NBCOL
        ENDIF
      ELSE
        NBROW_STACK = NBROW-NBROW_SEND
        NBCOL_STACK = NBCOL
        LREQI       = 6 + NBROW_STACK + NBCOL + KEEP(IXSZ)
        IF (.NOT. (TYPE.EQ.1 .AND. TYPEF.EQ.2 ) ) GOTO 190
        IF (FPERE.EQ.0) GOTO 190
      ENDIF
      IF (COMPRESSCB) THEN
        LREQCB = ( int(NBCOL_STACK,8) * int( NBCOL_STACK + 1, 8) ) / 2_8&
     &         - ( int(NBROW_SEND ,8) * int( NBROW_SEND  + 1, 8) ) / 2_8
      ELSE
        LREQCB = int(NBROW_STACK,8) * int(NBCOL_STACK,8)
      ENDIF
      INPLACE = ( KEEP(234).NE.0 )
      IF (KEEP(50).NE.0 .AND. TYPE .EQ. 2) INPLACE = .FALSE.
      INPLACE = INPLACE .OR. .NOT. MUST_COMPACT_FACTORS
      INPLACE = INPLACE .AND.                                           &
     &            ( PTLUST_S(STEP(INODE)) + INTSIZ .EQ. IWPOS )
      MIN_SPACE_IN_PLACE = 0_8
      IF ( INPLACE .AND. KEEP(50).eq. 0 .AND.                           &
     &     MUST_COMPACT_FACTORS) THEN
        MIN_SPACE_IN_PLACE = int(NBCOL_STACK,8)
      ENDIF
      IF ( MIN_SPACE_IN_PLACE .GT. LREQCB ) THEN
        INPLACE = .FALSE.
      ENDIF
      CALL DAGMG_MUMPS_22( INPLACE, MIN_SPACE_IN_PLACE,                      &
     &   SSARBR, .FALSE.,                                               &
     &   MYID,N,KEEP,KEEP8,IW, LIW, A, LA,                              &
     &   LRLU, IPTRLU,IWPOS,IWPOSCB,                                    &
     &   PTRIST,PTRAST,STEP, PIMASTER,PAMASTER, ITLOC,                  &
     &   LREQI, LREQCB, INODE, S_NOTFREE, .TRUE.,                       &
     &   COMP, LRLUS, IFLAG, IERROR )
      IF (IFLAG.LT.0) GOTO 600
      PTRIST(STEP(INODE)) = IWPOSCB+1
      IF ( AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,                        &
     &     SLAVEF) .EQ. MYID ) THEN
        PIMASTER (STEP(INODE)) = PTLUST_S(STEP(INODE))
        PAMASTER(STEP(INODE)) = IPTRLU + 1_8
        PTRAST(STEP(INODE)) = -99999999_8
          IW(IWPOSCB+1+KEEP(IXSZ)) = min(-NBCOL_STACK,-1)
          IW(IWPOSCB+2+KEEP(IXSZ)) = NBROW_STACK
          IF (COMPRESSCB) IW(IWPOSCB+1+XXS) = S_CB1COMP
      ELSE
        PTRAST(STEP(INODE)) = IPTRLU+1_8
        IF (COMPRESSCB) IW(IWPOSCB+1+XXS)=S_CB1COMP
        IW(IWPOSCB+1+KEEP(IXSZ)) = NBCOL
        IW(IWPOSCB+2+KEEP(IXSZ)) = 0
        IW(IWPOSCB+3+KEEP(IXSZ)) = NBROW_STACK
        IW(IWPOSCB+4+KEEP(IXSZ)) = 0
        IW(IWPOSCB+5+KEEP(IXSZ)) = 1
        IW(IWPOSCB+6+KEEP(IXSZ)) = 0
        IOLDP1   = PTLUST_S(STEP(INODE))+H_INODE
        PTROWEND = IWPOSCB+6+NBROW_STACK+KEEP(IXSZ)
        IW(IWPOSCB+7+KEEP(IXSZ):PTROWEND) =                             &
     &    IW(IOLDP1+NFRONT-NBROW_STACK:IOLDP1+NFRONT-1)
        IW(PTROWEND+1:PTROWEND+NBCOL) =                                 &
     &    IW(IOLDP1+NFRONT+NPIV: IOLDP1+2*NFRONT-1)
      END IF
      IF ( KEEP(50).NE.0 .AND. TYPE .EQ. 1                              &
     &     .AND. MUST_COMPACT_FACTORS ) THEN
        POSELT = PTRFAC(STEP(INODE))
        CALL DAGMG_MUMPS_324(A(POSELT), LDA,                                 &
     &                         NPIV, NBROW, KEEP(50))
        MUST_COMPACT_FACTORS = .FALSE.
      ENDIF
      IF (  KEEP(50).EQ.0 .AND. MUST_COMPACT_FACTORS )                  &
     &     THEN
        LAST_ALLOWED_POS = POSELT + int(LDA,8)*int(NPIV+NBROW-1,8)      &
     &                     + int(NPIV,8)
      ELSE
        LAST_ALLOWED_POS = -1_8
      ENDIF
      NCBROW_ALREADY_MOVED = 0
   10 CONTINUE
      NCBROW_PREVIOUSLY_MOVED = NCBROW_ALREADY_MOVED
      CALL DAGMG_MUMPS_652( A, LA, LDA,                                      &
     &  POSELT, IPTRLU, NPIV, NBCOL_STACK, NBROW_STACK,                 &
     &  NBROW_SEND, LREQCB, KEEP, COMPRESSCB,                           &
     &  LAST_ALLOWED_POS, NCBROW_ALREADY_MOVED )
   20 CONTINUE
      IF (LAST_ALLOWED_POS .NE. -1_8) THEN
      MUST_COMPACT_FACTORS =.FALSE.
        IF ( NCBROW_ALREADY_MOVED .EQ. NBROW_STACK ) THEN
          NCBROW_ALREADY_MOVED = NCBROW_ALREADY_MOVED + NBROW_SEND
        ENDIF
        NCBROW_NEWLY_MOVED = NCBROW_ALREADY_MOVED                       &
     &                    - NCBROW_PREVIOUSLY_MOVED
        FACTOR_POS = POSELT +                                           &
     &         int(LDA,8)*int(NPIV+NBROW-NCBROW_ALREADY_MOVED,8)
        CALL DAGMG_MUMPS_651( A(FACTOR_POS), LDA, NPIV,                      &
     &       NCBROW_NEWLY_MOVED )
        INEW = FACTOR_POS + int(NPIV,8) * int(NCBROW_NEWLY_MOVED,8)
        IOLD = INEW + int(NCBROW_NEWLY_MOVED,8) * int(NBCOL_STACK,8)
        DO I = 1, NCBROW_PREVIOUSLY_MOVED*NPIV
            A(INEW) = A(IOLD)
            IOLD = IOLD + 1_8
            INEW = INEW + 1_8
        ENDDO
        KEEP8(8)=KEEP8(8) + int(NCBROW_PREVIOUSLY_MOVED,8)              &
     &                    * int(NPIV,8)
        LAST_ALLOWED_POS = INEW
        IF (NCBROW_ALREADY_MOVED.LT.NBROW_STACK) THEN
          GOTO 10
        ENDIF
      ENDIF
  190 CONTINUE
      IF (MUST_COMPACT_FACTORS) THEN
       POSELT = PTRFAC(STEP(INODE))
       CALL DAGMG_MUMPS_324(A(POSELT), LDA,                                  &
     &                         NPIV, NBROW, KEEP(50))
       MUST_COMPACT_FACTORS = .FALSE.
      ENDIF
      IOLDPS = PTLUST_S(STEP(INODE))
      IW(IOLDPS+KEEP(IXSZ))     = NBCOL
      IW(IOLDPS + 1+KEEP(IXSZ)) = NASS - NPIV
      IF (TYPE.EQ.2) THEN
        IW(IOLDPS + 2+KEEP(IXSZ)) = NASS
      ELSE
        IW(IOLDPS + 2+KEEP(IXSZ)) = NFRONT
      ENDIF
      IW(IOLDPS + 3+KEEP(IXSZ)) = NPIV
      IF (INPLACE) THEN
        SIZE_INPLACE = LREQCB - MIN_SPACE_IN_PLACE
      ELSE
        SIZE_INPLACE = 0_8
      ENDIF
      CALL DAGMG_MUMPS_93(SIZE_INPLACE,MYID,N,IOLDPS,TYPE, IW, LIW,          &
     &    A, LA, POSFAC, LRLU, LRLUS,                                   &
     &    IWPOS, PTRAST, PTRFAC, STEP, KEEP,KEEP8, SSARBR,INODE,IERR)
      IF(IERR.LT.0)THEN
         IFLAG=IERR
         IERROR=0
         GOTO 600
      ENDIF
  500 CONTINUE
      RETURN
  600 CONTINUE
      IF (IFLAG .NE. -1) CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_254
      SUBROUTINE DAGMG_MUMPS_142( id)
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTERFACE
      SUBROUTINE DAGMG_MUMPS_27(id, ANORMINF, LSCAL)
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC), TARGET :: id
      DOUBLE PRECISION, INTENT(OUT) :: ANORMINF
      LOGICAL :: LSCAL
      END SUBROUTINE DAGMG_MUMPS_27
      END INTERFACE
      TYPE(DAGMG_MUMPS_STRUC), TARGET :: id
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER IERR, MASTER
      PARAMETER( MASTER = 0 )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER NSEND, NSEND_TOT, LDPTRAR, NELT
      INTEGER NLOCAL, NLOCAL_TOT, KEEP13_SAVE, ITMP
      INTEGER(8) K67
      INTEGER*8 ITMP8
      INTEGER  AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      INTEGER MP, LP, MPG, allocok
      LOGICAL PROK, PROKG, LSCAL
      INTEGER DAGMG_MUMPS_LBUF, DAGMG_MUMPS_LBUFR_BYTES, DAGMG_MUMPS_LBUF_INT
      INTEGER PTRIST, PTRWB, MAXELT_SIZE, LOC_DIM_BUF_IO,               &
     &     ITLOC, IPOOL, NSTEPS, K28, LPOOL, LIW
      INTEGER IRANK, ID_SCHUR, ID_ROOT, SIZE_SCHUR
      INTEGER KKKK, NZ_locMAX
      INTEGER(8) MEMORY_MD_ARG
      INTEGER*8 MAXS_BASE8, MAXS_BASE_RELAXED8
      DOUBLE PRECISION CNTL4
      INTEGER MIN_PERLU, MAXIS_ESTIM
      INTEGER   MAXIS
      INTEGER(8) :: MAXS
      DOUBLE PRECISION TIME
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      INTEGER PERLU, TOTAL_MBYTES, K231, K232, K233
      INTEGER COLOUR, COMM_FOR_SCALING
      INTEGER LIWK, LWK, LWK_REAL
      LOGICAL I_AM_SLAVE, OOC_ON, PERLU_ON, WK_USER_PROVIDED
      DOUBLE PRECISION :: ANORMINF, SEUIL, SEUIL_LDLT_NIV2
      DOUBLE PRECISION :: CNTL1, CNTL3, CNTL5, CNTL6, EPS
      INTEGER N, LPN_LIST,POSBUF
      INTEGER, DIMENSION (:), ALLOCATABLE :: ITMP2
      INTEGER DUMMY,I
      INTEGER, DIMENSION(:), ALLOCATABLE :: IWK
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: WK
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: WK_REAL
      INTEGER(8), DIMENSION(:), ALLOCATABLE :: IWK8
      INTEGER, DIMENSION(:), ALLOCATABLE :: BURP
      INTEGER, DIMENSION(:), ALLOCATABLE :: BUCP
      INTEGER, DIMENSION(:), ALLOCATABLE :: BURS
      INTEGER, DIMENSION(:), ALLOCATABLE :: BUCS
      INTEGER BUREGISTRE(12)
      INTEGER BUINTSZ, BURESZ, BUJOB
      INTEGER BUMAXMN, M, SCMYID, SCNPROCS
      DOUBLE PRECISION    SCONEERR, SCINFERR
      INTEGER, POINTER ::  JOB, NZ
      DOUBLE PRECISION,DIMENSION(:),POINTER::RINFO, RINFOG
      DOUBLE PRECISION,DIMENSION(:),POINTER::    CNTL
      INTEGER,DIMENSION(:),POINTER::INFO, INFOG, KEEP
      INTEGER, DIMENSION(:), POINTER :: MYIRN_loc, MYJCN_loc
      DOUBLE PRECISION, DIMENSION(:), POINTER :: MYA_loc
      INTEGER, TARGET :: DUMMYIRN_loc(1), DUMMYJCN_loc(1)
      DOUBLE PRECISION, TARGET :: DUMMYA_loc(1)
      INTEGER*8,DIMENSION(:),POINTER::KEEP8
      INTEGER,DIMENSION(:),POINTER::ICNTL
      EXTERNAL DAGMG_MUMPS_505
      INTEGER DAGMG_MUMPS_505
      INTEGER SIZE_DEPTH_FIRST
      INTEGER*8 TOTAL_BYTES
      INTEGER(8) :: I8TMP
      JOB=>id%JOB
      NZ=>id%NZ
      RINFO=>id%RINFO
      RINFOG=>id%RINFOG
      CNTL=>id%CNTL
      INFO=>id%INFO
      INFOG=>id%INFOG
      KEEP=>id%KEEP
      KEEP8=>id%KEEP8
      ICNTL=>id%ICNTL
      IF (id%NZ_loc .NE. 0) THEN
        MYIRN_loc=>id%IRN_loc
        MYJCN_loc=>id%JCN_loc
        MYA_loc=>id%A_loc
      ELSE
        MYIRN_loc=>DUMMYIRN_loc
        MYJCN_loc=>DUMMYJCN_loc
        MYA_loc=>DUMMYA_loc
      ENDIF
      N = id%N
      EPS = epsilon ( ZERO )
      IF (KEEP8(24).GT.0_8) THEN
           NULLIFY(id%S)
      ENDIF
      WK_USER_PROVIDED = (id%LWK_USER.NE.0)
      IF (WK_USER_PROVIDED) THEN
          IF (id%LWK_USER.GT.0) THEN
            KEEP8(24) = int(id%LWK_USER,8)
          ELSE
            KEEP8(24) = -int(id%LWK_USER,8)* 1000000_8
          ENDIF
      ELSE
          KEEP8(24) = 0_8
      ENDIF
      IF (KEEP(219).NE.0) THEN
       CALL DAGMG_MUMPS_617(max(KEEP(108),1),IERR)
       IF (IERR .NE. 0) THEN
          INFO(1) = -13
          INFO(2) = max(KEEP(108),1)
          GOTO 137
       END IF
      ENDIF
      KEEP13_SAVE = KEEP(13)
      id%DKEEP(4)=-1.0D0
      id%DKEEP(5)=-1.0D0
      MP  = ICNTL( 2 )
      MPG = ICNTL( 3 )
      LP  = ICNTL( 1 )
      PROK  = ( MP  .GT. 0 )
      PROKG = ( MPG .GT. 0 .and. id%MYID .eq. MASTER )
      IF ( PROK ) WRITE( MP, 130 )
      IF ( PROKG ) WRITE( MPG, 130 )
      IF ( PROKG .and. KEEP(53).GT.0 ) THEN
        WRITE(MPG,'(/A,I3)') ' Null space option :', KEEP(19)
        IF ( KEEP(21) .ne. 0 ) THEN
          WRITE( MPG, '(A,I10)') ' Max deficiency    : ', KEEP(21)
        END IF
        IF ( KEEP(22) .ne. 0 ) THEN
          WRITE( MPG, '(A,I10)') ' Min deficiency    : ', KEEP(22)
        END IF
      END IF
      I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR.                          &
     &             ( id%MYID .eq. MASTER .AND.                          &
     &               KEEP(46) .eq. 1 ) )
        IF (id%MYID .EQ. MASTER) THEN
          KEEP(201)=id%ICNTL(22)
          IF (KEEP(201) .NE. 0) THEN
              KEEP(201)=1
          ENDIF
        ENDIF
        CALL AGMG_SETIERR( IERR )
        CALL AGMG_SETIERR( IERR )
        CALL AGMG_SETIERR( IERR )
        CALL AGMG_SETIERR( IERR )
        IF (KEEP(201).NE.0) THEN
            OOC_ON   = .TRUE.
        ELSE
            OOC_ON   = .FALSE.
        ENDIF
        IF (id%MYID.EQ.MASTER) THEN
          IF (KEEP(217).GT.2.OR.KEEP(217).LT.0) THEN
            KEEP(217)=0
          ENDIF
          KEEP(214)=KEEP(217)
          IF (KEEP(214).EQ.0) THEN
            IF (KEEP(201).NE.0) THEN
              KEEP(214)=1
            ELSE
              KEEP(214)=2
            ENDIF
          ENDIF
        ENDIF
        CALL AGMG_SETIERR( IERR )
        IF (KEEP(201).NE.0) THEN
          CALL AGMG_SETIERR( IERR )
          CALL AGMG_SETIERR( IERR )
          CALL AGMG_SETIERR( IERR )
        ENDIF
        IF ( KEEP(50) .eq. 1 ) THEN
          IF (id%CNTL(1) .ne. ZERO ) THEN
            IF ( MPG .GT. 0 ) THEN
              WRITE(MPG,'(A)')                                          &
     &' ** Warning : SPD solver called, resetting CNTL(1) to 0.0D0'
            END IF
          END IF
          id%CNTL(1) = ZERO
        END IF
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &                        id%COMM, id%MYID )
      IF (INFO(1).LT.0) GOTO 530
      IF ( PROKG ) THEN
          WRITE( MPG, 172 ) id%NSLAVES, id%ICNTL(22),                   &
     &    KEEP8(111), KEEP(126), KEEP(127), KEEP(28)
      ENDIF
      IF (KEEP(201).LE.0) THEN
        KEEP(IXSZ)=XSIZE_IC
      ELSE IF (KEEP(201).EQ.2) THEN
        KEEP(IXSZ)=XSIZE_OOC_NOPANEL
      ELSE IF (KEEP(201).EQ.1) THEN
        IF (KEEP(50).EQ.0) THEN
          KEEP(IXSZ)=XSIZE_OOC_UNSYM
        ELSE
          KEEP(IXSZ)=XSIZE_OOC_SYM
        ENDIF
      ENDIF
      CALL AGMG_SETIERR( IERR)
      LSCAL = ((KEEP(52) .GT. 0) .AND. (KEEP(52) .LE. 8))
      IF (LSCAL) THEN
        IF ( id%MYID.EQ.MASTER ) THEN
        ENDIF
        IF (KEEP(52) .EQ. 7) THEN
           K231= KEEP(231)
           K232= KEEP(232)
           K233= KEEP(233)
        ELSEIF (KEEP(52) .EQ. 8) THEN
           K231= KEEP(239)
           K232= KEEP(240)
           K233= KEEP(241)
        ENDIF
        CALL AGMG_SETIERR(IERR)
        IF ( ((KEEP(52).EQ.7).OR.(KEEP(52).EQ.8)) .AND.                 &
     &       KEEP(54).NE.0 ) THEN
           IF ( id%MYID .NE. MASTER ) THEN
              IF ( associated(id%COLSCA))                               &
     &             DEALLOCATE( id%COLSCA )
              IF ( associated(id%ROWSCA))                               &
     &             DEALLOCATE( id%ROWSCA )
            ALLOCATE( id%COLSCA(N), stat=ierr)
            IF (ierr .GT.0) THEN
               id%INFO(1)=-13
               id%INFO(2)=N
            ENDIF
            ALLOCATE( id%ROWSCA(N), stat=ierr)
            IF (ierr .GT.0) THEN
               id%INFO(1)=-13
               id%INFO(2)=N
            ENDIF
         ENDIF
         M = N
         BUMAXMN=M
         IF(N > BUMAXMN) BUMAXMN = N
         LIWK = 4*BUMAXMN
         ALLOCATE (IWK(LIWK),BURP(M),BUCP(N),                           &
     &            BURS(2* (id%NPROCS)),BUCS(2* (id%NPROCS)),            &
     &            stat=allocok)
         IF (allocok > 0) THEN
            INFO(1)=-13
            INFO(2)=LIWK+M+N+4* (id%NPROCS)
         ENDIF
         CALL AGMG_MUMPS_276( ICNTL, INFO,                                   &
     &        id%COMM, id%MYID )
         IF (INFO(1).LT.0) GOTO 530
         BUJOB = 1
         LWK_REAL   = 1
         ALLOCATE(WK_REAL(LWK_REAL))
         CALL DAGMG_MUMPS_693(                                               &
     &        MYIRN_loc(1), MYJCN_loc(1), MYA_loc(1),                   &
     &        id%NZ_loc,                                                &
     &        M, N,  id%NPROCS, id%MYID, id%COMM,                       &
     &        BURP, BUCP,                                               &
     &        BURS, BUCS, BUREGISTRE,                                   &
     &        IWK, LIWK,                                                &
     &        BUINTSZ, BURESZ, BUJOB,                                   &
     &        id%ROWSCA(1), id%COLSCA(1), WK_REAL, LWK_REAL,            &
     &        id%SYM,                                                   &
     &        K231, K232, K233,                                         &
     &        id%DKEEP(3),                                              &
     &        SCONEERR, SCINFERR)
         IF(LIWK < BUINTSZ) THEN
            DEALLOCATE(IWK)
            LIWK = BUINTSZ
            ALLOCATE(IWK(LIWK), stat=allocok)
            IF (allocok > 0) THEN
               INFO(1)=-13
               INFO(2)=LIWK
            ENDIF
         ENDIF
         LWK_REAL = BURESZ
         DEALLOCATE(WK_REAL)
         ALLOCATE (WK_REAL(LWK_REAL), stat=allocok)
         IF (allocok > 0) THEN
            INFO(1)=-13
            INFO(2)=LWK_REAL
         ENDIF
         CALL AGMG_MUMPS_276( ICNTL, INFO,                                   &
     &        id%COMM, id%MYID )
         IF (INFO(1).LT.0) GOTO 530
         BUJOB = 2
         CALL DAGMG_MUMPS_693(                                               &
     &        MYIRN_loc(1), MYJCN_loc(1), MYA_loc(1),                   &
     &        id%NZ_loc,                                                &
     &        M, N,  id%NPROCS, id%MYID, id%COMM,                       &
     &        BURP, BUCP,                                               &
     &        BURS, BUCS, BUREGISTRE,                                   &
     &        IWK, LIWK,                                                &
     &        BUINTSZ, BURESZ, BUJOB,                                   &
     &        id%ROWSCA(1), id%COLSCA(1), WK_REAL, LWK_REAL,            &
     &        id%SYM,                                                   &
     &        K231, K232, K233,                                         &
     &        id%DKEEP(3),                                              &
     &        SCONEERR, SCINFERR)
         id%DKEEP(4) = SCONEERR
         id%DKEEP(5) = SCINFERR
         DEALLOCATE(IWK, WK_REAL,BURP,BUCP,BURS, BUCS)
        ELSE IF ( KEEP(54) .EQ. 0 ) THEN
          IF ((KEEP(52).EQ.7).OR.(KEEP(52).EQ.8))  THEN
              IF (id%MYID.EQ.MASTER) THEN
                COLOUR = 0
              ELSE
                COLOUR = AGMG_MPF_UNDEFINED
              ENDIF
              CALL AGMG_SETIERR( IERR )
              IF (id%MYID.EQ.MASTER) THEN
                 M = N
                 BUMAXMN=N
                 IF(N > BUMAXMN) BUMAXMN = N
                 LIWK = 1
                 ALLOCATE (IWK(LIWK),BURP(1),BUCP(1),                   &
     &                BURS(1),BUCS(1),                                  &
     &                stat=allocok)
                 LWK_REAL = M + N
                 ALLOCATE (WK_REAL(LWK_REAL), stat=allocok)
                 IF (allocok > 0) THEN
                    INFO(1)=-13
                    INFO(2)=1
                 ENDIF
                 IF (INFO(1) .LT. 0) GOTO 400
                 CALL AGMG_SETIERR2( SCMYID, IERR)
                 CALL AGMG_SETIERR12( SCNPROCS, IERR)
                 BUJOB = 1
                 CALL DAGMG_MUMPS_693(                                       &
     &                id%IRN(1), id%JCN(1), id%A(1),                    &
     &                id%NZ,                                            &
     &                M, N,  SCNPROCS, SCMYID, COMM_FOR_SCALING,        &
     &                BURP, BUCP,                                       &
     &                BURS, BUCS, BUREGISTRE,                           &
     &                IWK, LIWK,                                        &
     &                BUINTSZ, BURESZ, BUJOB,                           &
     &                id%ROWSCA(1), id%COLSCA(1), WK_REAL, LWK_REAL,    &
     &                id%SYM,                                           &
     &                K231, K232, K233,                                 &
     &                id%DKEEP(3),                                      &
     &                SCONEERR, SCINFERR)
                 IF(LWK_REAL < BURESZ) THEN
                    INFO(1) = -136
                    GOTO 400
                 ENDIF
                 BUJOB = 2
                 CALL DAGMG_MUMPS_693(id%IRN(1),                             &
     &                id%JCN(1), id%A(1),                               &
     &                id%NZ,                                            &
     &                M, N,  SCNPROCS, SCMYID, COMM_FOR_SCALING,        &
     &                BURP, BUCP,                                       &
     &                BURS, BUCS, BUREGISTRE,                           &
     &                IWK, LIWK,                                        &
     &                BUINTSZ, BURESZ, BUJOB,                           &
     &                id%ROWSCA(1), id%COLSCA(1), WK_REAL, LWK_REAL,    &
     &                id%SYM,                                           &
     &                K231, K232, K233,                                 &
     &                id%DKEEP(3),                                      &
     &                SCONEERR, SCINFERR)
                 id%DKEEP(4) = SCONEERR
                 id%DKEEP(5) = SCINFERR
                 DEALLOCATE(WK_REAL)
                 DEALLOCATE (IWK,BURP,BUCP,                             &
     &                BURS,BUCS)
              ENDIF
              CALL AGMG_SETIERR( IERR )
  400         CONTINUE
              IF (id%MYID.EQ.MASTER) THEN
                CALL AGMG_SETIERR( IERR)
              ENDIF
              CALL AGMG_MUMPS_276(ICNTL, INFO, id%COMM, id%MYID)
              IF (INFO(1).LT.0) GOTO 530
          ELSE IF (id%MYID.EQ.MASTER) THEN
            IF (KEEP(52).GT.0 .AND. KEEP(52).LE.6) THEN
              IF ( KEEP(52) .eq. 5 .or.                                 &
     &          KEEP(52) .eq. 6 ) THEN
                LWK = NZ
              ELSE
                LWK = 1
              END IF
              LWK_REAL = 5 * N
              ALLOCATE( WK_REAL( LWK_REAL ), stat = IERR )
              IF ( IERR .GT. 0 ) THEN
                INFO(1) = -13
                INFO(2) = LWK_REAL
                GOTO 137
              END IF
              ALLOCATE( WK( LWK ), stat = IERR )
              IF ( IERR .GT. 0 ) THEN
                INFO(1) = -13
                INFO(2) = LWK
                GOTO 137
              END IF
              CALL DAGMG_MUMPS_217(N, NZ, KEEP(52), id%A(1),                 &
     &             id%IRN(1), id%JCN(1),                                &
     &             id%COLSCA(1), id%ROWSCA(1),                          &
     &             WK, LWK, WK_REAL, LWK_REAL, ICNTL, INFO )
              DEALLOCATE( WK_REAL )
              DEALLOCATE( WK )
            ENDIF
          ENDIF
        ENDIF
        IF (id%MYID.EQ.MASTER) THEN
          IF (PROKG.AND.(KEEP(52).EQ.7.OR.KEEP(52).EQ.8)                &
     &             .AND. (K233+K231+K232).GT.0) THEN
           IF (K232.GT.0) WRITE(MPG, 166) id%DKEEP(4)
          ENDIF
        ENDIF
      ENDIF
        LSCAL = (LSCAL .OR. (KEEP(52) .EQ. -1) .OR. KEEP(52) .EQ. -2)
  137 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO(1).lt.0 ) GOTO 530
      KEEP(110)=ICNTL(24)
      CALL AGMG_SETIERR( IERR)
      IF (KEEP(110).NE.1) KEEP(110)=0
      IF (id%MYID .EQ. MASTER) CNTL3 = id%CNTL(3)
      CALL AGMG_SETIERR( IERR)
      IF (id%MYID .EQ. MASTER) CNTL5 = id%CNTL(5)
      CALL AGMG_SETIERR( IERR)
      IF (id%MYID .EQ. MASTER) CNTL6 = id%CNTL(6)
      CALL AGMG_SETIERR( IERR)
      IF (id%MYID .EQ. MASTER) CNTL1 = id%CNTL(1)
      CALL AGMG_SETIERR( IERR)
      ANORMINF = ZERO
      IF (KEEP(19).EQ.0) THEN
         SEUIL = ZERO
      ELSE
         CALL DAGMG_MUMPS_27(  id , ANORMINF, LSCAL )
         IF (CNTL6 .LT. ZERO) THEN
           SEUIL = EPS*ANORMINF
         ELSE
           SEUIL = CNTL6*ANORMINF
         ENDIF
         IF (PROKG) WRITE(MPG,*)                                        &
     &   ' ABSOLUTE PIVOT THRESHOLD for rank revealing =',SEUIL
      ENDIF
      SEUIL_LDLT_NIV2 = SEUIL
      IF (KEEP(110).EQ.0) THEN
         id%DKEEP(1) = -1.0D0
         id%DKEEP(2) = ZERO
      ELSE
         IF (ANORMINF.EQ.ZERO)                                          &
     &       CALL DAGMG_MUMPS_27(  id , ANORMINF, LSCAL )
         IF (CNTL3 .LT. ZERO) THEN
           id%DKEEP(1)  = abs(CNTL(3))
         ELSE IF  (CNTL3 .GT. ZERO) THEN
           id%DKEEP(1)  = CNTL3*ANORMINF
         ELSE
           id%DKEEP(1)  = 1.0D-5*EPS*ANORMINF
         ENDIF
         IF (PROKG) WRITE(MPG,*)                                        &
     &    ' ZERO PIVOT DETECTION ON, THRESHOLD          =',id%DKEEP(1)
         IF (CNTL5.GT.ZERO) THEN
            id%DKEEP(2) = CNTL5 * ANORMINF
            IF (PROKG) WRITE(MPG,*)                                     &
     &    ' FIXATION FOR NULL PIVOTS                    =',id%DKEEP(2)
         ELSE
            IF (PROKG) WRITE(MPG,*) 'INFINITE FIXATION '
            id%DKEEP(2) = ZERO
         ENDIF
      ENDIF
      IF (KEEP(53).NE.0) THEN
        ID_ROOT =AGMG_MUMPS_275(id%STEP(KEEP(20)),                           &
     &            id%PROCNODE_STEPS(1),id%NSLAVES)
        IF ( KEEP( 46 )  .NE. 1 ) THEN
          ID_ROOT = ID_ROOT + 1
        END IF
      ENDIF
      IF ( associated( id%PIVNUL_LIST) ) DEALLOCATE(id%PIVNUL_LIST)
      IF(KEEP(110) .EQ. 1) THEN
         LPN_LIST = N
      ELSE
         LPN_LIST = 1
      ENDIF
      IF (KEEP(19).NE.0 .AND.                                           &
     &   (ID_ROOT.EQ.id%MYID .OR. id%MYID.EQ.MASTER)) THEN
         LPN_LIST = N
      ENDIF
      ALLOCATE( id%PIVNUL_LIST(LPN_LIST),stat = IERR )
      IF ( IERR .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=LPN_LIST
      END IF
      id%PIVNUL_LIST(1:LPN_LIST) = 0
      KEEP(109) = 0
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO(1).lt.0 ) GOTO 530
      IF ((KEEP(19).EQ.0).AND.(KEEP(110).EQ.0)) THEN
        IF (id%MYID .EQ. MASTER) CNTL4 = id%CNTL(4)
        CALL AGMG_SETIERR( IERR )
        IF ( CNTL4 .GE. ZERO ) THEN
         KEEP(97) = 1
         IF ( CNTL4 .EQ. ZERO ) THEN
            IF(ANORMINF .EQ. ZERO) THEN
               CALL DAGMG_MUMPS_27(  id , ANORMINF, LSCAL )
            ENDIF
            SEUIL = sqrt(EPS) * ANORMINF
         ELSE
            SEUIL = CNTL4
         ENDIF
         SEUIL_LDLT_NIV2 = SEUIL
        ELSE
         SEUIL = ZERO
        ENDIF
      ENDIF
      KEEP(98)  = 0
      KEEP(103) = 0
      KEEP(105) = 0
      MAXS      = 1_8
      IF ( id%MYID.EQ.MASTER ) THEN
        ITMP = ICNTL(23)
      END IF
      CALL AGMG_SETIERR( IERR )
      IF (WK_USER_PROVIDED) ITMP = 0
      ITMP8 = int(ITMP, 8)
      KEEP8(4) = ITMP8 * 1000000_8
      PERLU = KEEP(12)
      IF (KEEP(201) .EQ. 0) THEN
        MAXS_BASE8=KEEP8(12)
       ELSE
        MAXS_BASE8=KEEP8(14)
      ENDIF
      IF (WK_USER_PROVIDED) THEN
        MAXS = KEEP8(24)
      ELSE
       IF ( MAXS_BASE8 .GT. 0_8 ) THEN
          MAXS_BASE_RELAXED8 =                                          &
     &         MAXS_BASE8 + int(PERLU,8) * ( MAXS_BASE8 / 100_8 + 1_8)
          IF (MAXS_BASE_RELAXED8 > huge(MAXS)) THEN
            INFO(1)=-37
            INFO(2)=int(MAXS_BASE_RELAXED8/1000000_8)
          ENDIF
          MAXS_BASE_RELAXED8 = max(MAXS_BASE_RELAXED8, 1_8)
          MAXS = MAXS_BASE_RELAXED8
       ELSE
        MAXS = 1_8
        MAXS_BASE_RELAXED8 = 1_8
       END IF
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF (INFO(1) .LT. 0) THEN
        GOTO 530
      ENDIF
      IF ((.NOT.WK_USER_PROVIDED).AND.(I_AM_SLAVE)) THEN
          IF (KEEP(96).GT.0) THEN
            MAXS=int(KEEP(96),8)
          ELSE
            IF (KEEP8(4) .NE. 0_8) THEN
              PERLU_ON = .TRUE.
              CALL DAGMG_MUMPS_214( id%KEEP(1), id%KEEP8(1),                 &
     &        id%MYID, id%N, id%NELT, id%LNA, id%NZ, id%NA_ELT,         &
     &        id%NSLAVES, TOTAL_MBYTES, .FALSE., OOC_ON,                &
     &        PERLU_ON, TOTAL_BYTES)
              MAXS_BASE_RELAXED8=MAXS_BASE_RELAXED8 +                   &
     &        (KEEP8(4)-TOTAL_BYTES)/int(KEEP(35),8)
              IF (MAXS_BASE_RELAXED8 > int(huge(MAXS),8)) THEN
                id%INFO(1)=-37
                id%INFO(2)=int(MAXS_BASE_RELAXED8/1000000_8)
              ELSE IF (MAXS_BASE_RELAXED8 .LE. 0_8) THEN
                id%INFO(1)=-9
                IF ( -MAXS_BASE_RELAXED8 .GT.                           &
     &               int(huge(id%INFO(1)),8) ) THEN
                  WRITE(*,*) "I8: OVERFLOW"
                  CALL AGMG_MUMPS_ABORT()
                ENDIF
                id%INFO(2)=-int(MAXS_BASE_RELAXED8,4)
              ELSE
                MAXS=MAXS_BASE_RELAXED8
              ENDIF
            ENDIF
          ENDIF
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF (INFO(1) .LT. 0) THEN
        GOTO 530
      ENDIF
      CALL DAGMG_MUMPS_713(PROKG, MPG, MAXS, id%NSLAVES,                     &
     & id%COMM, "effective relaxed size of S              =")
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF (id%INFO(1) .LT. 0) THEN
        GOTO 530
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        CALL DAGMG_MUMPS_188( dble(id%COST_SUBTREES),                        &
     &        KEEP(64), KEEP(66),MAXS )
        K28=KEEP(28)
        MEMORY_MD_ARG = min(int(PERLU,8) * ( MAXS_BASE8 / 100_8 + 1_8 ),&
     &                      max(0_8, MAXS-MAXS_BASE8))
        CALL DAGMG_MUMPS_185( id, MEMORY_MD_ARG, MAXS )
        IF (KEEP(205) .GT. 0) THEN
          KEEP(100) = KEEP(205)
        ELSE
         IF (KEEP(201).EQ.1) THEN
           IF (KEEP(50).EQ.0)THEN
             I8TMP = 8_8 * int(KEEP(226),8)
           ELSE
             I8TMP = 4_8 * int(KEEP(226),8)
           ENDIF
         ELSE
           I8TMP = 2_8 * KEEP8(119)
         END IF
         I8TMP = I8TMP +  int(max(KEEP(12),0),8) *                      &
     &           (I8TMP/100_8+1_8)
         I8TMP = min(I8TMP, 12000000_8)
         KEEP(100)=int(I8TMP)
        ENDIF
        IF (KEEP(201).EQ.1) THEN
         IF ( KEEP(99) < 3 ) THEN
           KEEP(99) = KEEP(99) + 3
         ENDIF
        ENDIF
        IF (KEEP(99) .LT.3) KEEP(100)=0
        IF((dble(KEEP(100))*dble(KEEP(35))/dble(2)).GT.                 &
     &     (dble(1999999999)))THEN
           IF (PROKG) THEN
             WRITE(MPG,*)id%MYID,': Warning: DIM_BUF_IO might be        &
     &  too big for Filesystem'
           ENDIF
        ENDIF
        CALL DAGMG_MUMPS_587(id, IERR)
        IF (IERR < 0) THEN
          INFO(1) = -90
          INFO(2) = 0
          GOTO 112
        ENDIF
        IF (KEEP(201) .GT. 0) THEN
           IF (KEEP(201).EQ.1                                           &
     &                          .AND.KEEP(50).EQ.0) THEN
             OOC_NB_FILE_TYPE=2
           ELSE
             OOC_NB_FILE_TYPE=1
           ENDIF
           ALLOCATE (id%OOC_INODE_SEQUENCE(KEEP(28),                    &
     &          OOC_NB_FILE_TYPE),                                      &
     &          stat=IERR)
           IF ( IERR .GT. 0 ) THEN
              INFO(1) = -13
              INFO(2) = OOC_NB_FILE_TYPE*KEEP(28)
              NULLIFY(id%OOC_INODE_SEQUENCE)
              GOTO 112
           ENDIF
           ALLOCATE (id%OOC_TOTAL_NB_NODES(OOC_NB_FILE_TYPE),           &
     &          stat=IERR)
           IF ( IERR .GT. 0 ) THEN
              INFO(1) = -13
              INFO(2) = OOC_NB_FILE_TYPE
              NULLIFY(id%OOC_TOTAL_NB_NODES)
              GOTO 112
           ENDIF
           ALLOCATE (id%OOC_SIZE_OF_BLOCK(KEEP(28),                     &
     &          OOC_NB_FILE_TYPE),                                      &
     &          stat=IERR)
           IF ( IERR .GT. 0 ) THEN
              INFO(1) = -13
              INFO(2) = OOC_NB_FILE_TYPE*KEEP(28)
              NULLIFY(id%OOC_SIZE_OF_BLOCK)
              GOTO 112
           ENDIF
           ALLOCATE (id%OOC_VADDR(KEEP(28),OOC_NB_FILE_TYPE),           &
     &          stat=IERR)
           IF ( IERR .GT. 0 ) THEN
              INFO(1) = -13
              INFO(2) = OOC_NB_FILE_TYPE*KEEP(28)
              NULLIFY(id%OOC_VADDR)
              GOTO 112
           ENDIF
        ENDIF
      ENDIF
  112 CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF (INFO(1) < 0) THEN
        GOTO 513
      ENDIF
      IF (I_AM_SLAVE) THEN
        IF (KEEP(201) .GT.0) THEN
           IF ((KEEP(201).EQ.1).OR.(KEEP(201).EQ.2)) THEN
             CALL DAGMG_MUMPS_575(id,MAXS)
           ELSE
             WRITE(*,*) "Internal error in DAGMG_MUMPS_142"
             CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF(INFO(1).LT.0)THEN
              GOTO 111
           ENDIF
        ENDIF
        CALL DAGMG_MUMPS_190(0,.FALSE.,dble(id%COST_SUBTREES),               &
     &          KEEP,KEEP8)
        IF (INFO(1).LT.0) GOTO 111
      END IF
      IF ( associated (id%S) ) THEN
        DEALLOCATE(id%S)
        NULLIFY(id%S)
        KEEP8(23)=0_8
      ENDIF
      IF (.NOT.WK_USER_PROVIDED) THEN
        ALLOCATE (id%S(MAXS),stat=IERR)
        KEEP8(23) = MAXS
        IF ( IERR .GT. 0 ) THEN
          INFO(1) = -13
          CALL AGMG_MUMPS_735(MAXS, INFO(2))
          NULLIFY(id%S)
          KEEP8(23)=0_8
        ENDIF
      ELSE
       id%S => id%WK_USER(1:KEEP8(24))
      ENDIF
  111 CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) GOTO 500
      IF ( KEEP(55) .eq. 0 ) THEN
        IF (associated( id%DBLARR)) THEN
          DEALLOCATE(id%DBLARR)
          NULLIFY(id%DBLARR)
        ENDIF
        IF ( I_AM_SLAVE .and. KEEP(13) .ne. 0 ) THEN
          ALLOCATE( id%DBLARR( KEEP(13) ), stat = IERR )
        ELSE
          ALLOCATE( id%DBLARR( 1 ), stat =IERR )
        END IF
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,                                           &
     &       ':Error allocating DBLARR : IERR = ', IERR
          INFO(1)=-13
          INFO(2)=KEEP(13)
          NULLIFY(id%DBLARR)
          GOTO 100
        END IF
      ELSE
         IF ( associated( id%INTARR ) ) THEN
           DEALLOCATE( id%INTARR )
           NULLIFY( id%INTARR )
         END IF
         IF ( I_AM_SLAVE .and. KEEP(14) .ne. 0 ) THEN
           ALLOCATE( id%INTARR( KEEP(14) ), stat = allocok )
           IF ( allocok .GT. 0 ) THEN
             id%INFO(1) = -13
             id%INFO(2) = KEEP(14)
             NULLIFY(id%INTARR)
             GOTO 100
           END IF
         ELSE
           ALLOCATE( id%INTARR(1),stat=allocok )
           IF ( allocok .GT. 0 ) THEN
             id%INFO(1) = -13
             id%INFO(2) = 1
             NULLIFY(id%INTARR)
             GOTO 100
           END IF
         END IF
         IF (associated( id%DBLARR)) THEN
           DEALLOCATE(id%DBLARR)
           NULLIFY(id%DBLARR)
         ENDIF
         IF ( I_AM_SLAVE ) THEN
           IF (      id%MYID_NODES .eq. MASTER                          &
     &       .AND.   KEEP(46)   .eq. 1                                  &
     &       .AND.   KEEP(52)   .eq. 0 ) THEN
             id%DBLARR => id%A_ELT
           ELSE
             IF ( KEEP(13) .ne. 0 ) THEN
               ALLOCATE( id%DBLARR( KEEP(13) ), stat = allocok )
               IF ( allocok .GT. 0 ) THEN
                 id%INFO(1) = -13
                 id%INFO(2) = KEEP(13)
                 NULLIFY(id%DBLARR)
                 GOTO 100
               END IF
             ELSE
               ALLOCATE( id%DBLARR(1), stat = allocok )
               IF ( allocok .GT. 0 ) THEN
                 id%INFO(1) = -13
                 id%INFO(2) = 1
                 NULLIFY(id%DBLARR)
                 GOTO 100
               END IF
             END IF
           END IF
         ELSE
           ALLOCATE( id%DBLARR(1), stat = allocok )
           IF ( allocok .GT. 0 ) THEN
             id%INFO(1) = -13
             id%INFO(2) = 1
             NULLIFY(id%DBLARR)
             GOTO 100
           END IF
         END IF
      END IF
      IF ( KEEP(38).NE.0 .AND.  I_AM_SLAVE ) THEN
         CALL DAGMG_MUMPS_165( id%N,                                         &
     &   id%root, id%FILS(1), KEEP(38), id%INFO )
      END IF
  100 CONTINUE
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &                        id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) GOTO 500
      IF ( KEEP( 55 ) .eq. 0 ) THEN
      IF ( KEEP(54) .eq. 0 ) THEN
      IF ( id%MYID .eq. MASTER ) THEN
        ALLOCATE(IWK(id%N), stat=allocok)
        IF ( allocok .NE. 0 ) THEN
          INFO(1)=-13
          INFO(2)=id%N
        END IF
      ENDIF
      CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                                &
     &                        id%COMM, id%MYID )
      IF ( INFO(1).LT.0 ) GOTO 500
      IF ( id%MYID .eq. MASTER ) THEN
        IF (PROKG ) THEN
          CALL AGMG_MUMPS_291(TIME)
        END IF
        IF ( .not. associated( id%INTARR ) ) THEN
          ALLOCATE( id%INTARR( 1 ) )
        ENDIF
        CALL DAGMG_MUMPS_148(id%N, NZ, id%A(1),                              &
     &   id%IRN(1), id%JCN(1), id%SYM_PERM(1),                          &
     &   LSCAL, id%COLSCA(1), id%ROWSCA(1),                             &
     &   id%MYID, id%NSLAVES, id%PROCNODE_STEPS(1),                     &
     &   min(KEEP(39),id%NZ),                                           &
     &   LP, id%COMM, id%root, KEEP,KEEP8,                              &
     &   id%FILS(1), IWK(1),                                            &
     &   id%INTARR(1), id%DBLARR(1),                                    &
     &   id%PTRAR(1), id%PTRAR(id%N+1),                                 &
     &   id%FRERE_STEPS(1), id%STEP(1), id%S(1), MAXS,                  &
     &   id%ISTEP_TO_INIV2(1), id%I_AM_CAND(1),                         &
     &   id%CANDIDATES(1,1) )
      DEALLOCATE(IWK)
        IF ( PROKG ) THEN
          CALL AGMG_MUMPS_292(TIME)
          WRITE(MPG,160) TIME
          CALL AGMG_MUMPS_291(TIME)
        END IF
      ELSE
        CALL DAGMG_MUMPS_145( id%N,                                          &
     &       id%DBLARR( 1 ), max(1,KEEP( 13 )),                         &
     &       id%INTARR( 1 ), max(1,KEEP( 14 )),                         &
     &       id%PTRAR( 1 ),                                             &
     &       id%PTRAR(id%N+1),                                          &
     &       KEEP( 1 ), KEEP8(1), id%MYID, id%COMM,                     &
     &       min(id%KEEP(39),id%NZ),                                    &
     &       id%S(1), MAXS,                                             &
     &       id%root,                                                   &
     &       id%PROCNODE_STEPS(1), id%NSLAVES,                          &
     &       id%SYM_PERM(1), id%FRERE_STEPS(1), id%STEP(1),             &
     &       id%INFO(1), id%INFO(2) )
      ENDIF
      ELSE
      IF (PROKG ) THEN
        CALL AGMG_MUMPS_291(TIME)
      END IF
      IF ( I_AM_SLAVE ) THEN
       NZ_locMAX = 0
       CALL AGMG_COPY(id%NZ_loc, NZ_locMAX, 1, AGMG_MPF_INTEGER, IERR)
        CALL DAGMG_MUMPS_282( id%N,                                          &
     &  id%NZ_loc,                                                      &
     &  id,                                                             &
     &  id%DBLARR(1), KEEP(13), id%INTARR(1),                           &
     &  KEEP(14), id%PTRAR(1), id%PTRAR(id%N+1),                        &
     &  KEEP(1), KEEP8(1), id%MYID_NODES,                               &
     &  id%COMM_NODES, min(id%KEEP(39),NZ_locMAX),                      &
     &  id%S(1), MAXS, id%root, id%PROCNODE_STEPS,                      &
     &  id%NSLAVES, id%SYM_PERM(1), id%STEP(1),                         &
     &  id%ICNTL(1), id%INFO(1), NSEND, NLOCAL,                         &
     &  id%ISTEP_TO_INIV2,                                              &
     &  id%CANDIDATES )
        IF ( ( KEEP(52).EQ.7 ).OR. (KEEP(52).EQ.8) ) THEN
          IF ( id%MYID > 0 ) THEN
            IF (associated(id%ROWSCA)) THEN
              DEALLOCATE(id%ROWSCA)
              NULLIFY(id%ROWSCA)
            ENDIF
            IF (associated(id%COLSCA)) THEN
              DEALLOCATE(id%COLSCA)
              NULLIFY(id%COLSCA)
            ENDIF
          ENDIF
        ENDIF
      IF (PROK) THEN
        WRITE(MP,120) NLOCAL, NSEND
      END IF
      END IF
      IF ( KEEP(46) .eq. 0 .AND. id%MYID.eq.MASTER ) THEN
        NSEND  = 0
        NLOCAL = 0
      END IF
      CALL AGMG_COPY( NSEND, NSEND_TOT, 1, AGMG_MPF_INTEGER, IERR )
      CALL AGMG_COPY( NLOCAL, NLOCAL_TOT, 1, AGMG_MPF_INTEGER, IERR )
      IF ( PROKG ) THEN
        WRITE(MPG,125) NLOCAL_TOT, NSEND_TOT
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO( 1 ) .LT. 0 ) GOTO 500
      IF ( PROKG ) THEN
          CALL AGMG_MUMPS_292(TIME)
          WRITE(MPG,160) TIME
          CALL AGMG_MUMPS_291(TIME)
      END IF
      END IF
      ELSE
        IF (PROKG ) THEN
          CALL AGMG_MUMPS_291(TIME)
        END IF
      IF ( id%MYID.eq.MASTER)                                           &
     &CALL DAGMG_MUMPS_213( id%ELTPTR(1),                                    &
     &                        id%NELT,                                  &
     &                        MAXELT_SIZE )
      CALL DAGMG_MUMPS_126( id%N, id%NELT, id%NA_ELT,                        &
     &     id%COMM, id%MYID,                                            &
     &     id%NSLAVES, id%PTRAR(1),                                     &
     &     id%PTRAR(id%NELT+2),                                         &
     &     id%INTARR(1), id%DBLARR(1),                                  &
     &     id%KEEP(1), id%KEEP8(1), MAXELT_SIZE,                        &
     &     id%FRTPTR(1), id%FRTELT(1),                                  &
     &     id%S(1), MAXS, id%FILS(1),                                   &
     &     id, id%root )
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO( 1 ) .LT. 0 ) GOTO 500
      IF ( PROKG ) THEN
          CALL AGMG_MUMPS_292(TIME)
          WRITE(MPG,160) TIME
          CALL AGMG_MUMPS_291(TIME)
      END IF
      END IF
      IF ( I_AM_SLAVE )  THEN
        CALL DAGMG_MUMPS_528(id%MYID_NODES)
        DAGMG_MUMPS_LBUFR_BYTES = KEEP( 44 ) * KEEP( 35 )
        DAGMG_MUMPS_LBUFR_BYTES = max( DAGMG_MUMPS_LBUFR_BYTES,                   &
     &                      100000 )
        PERLU = KEEP( 12 )
        IF (KEEP(48).EQ.5) THEN
          MIN_PERLU=2
        ELSE
          MIN_PERLU=0
        ENDIF
        DAGMG_MUMPS_LBUFR_BYTES = DAGMG_MUMPS_LBUFR_BYTES                         &
     &        + int( dble(max(PERLU,MIN_PERLU))*                        &
     &        dble(DAGMG_MUMPS_LBUFR_BYTES)/100D0)
        IF (KEEP(48)==5) THEN
           KEEP8(21) = KEEP8(22) + int( dble(max(PERLU,MIN_PERLU))*     &
     &        dble(KEEP8(22))/100D0,8)
        ENDIF
        IF (KEEP(50).NE.1) THEN
           DAGMG_MUMPS_LBUFR_BYTES = DAGMG_MUMPS_LBUFR_BYTES                      &
     &            + int( dble(max(PERLU,0))*                            &
     &            dble(DAGMG_MUMPS_LBUFR_BYTES)/100D0)
        ENDIF
        IF (id%NSLAVES.EQ.2) THEN
         DAGMG_MUMPS_LBUF = int( 1.01D0 * dble(KEEP(43)) * dble(KEEP(35)) )
        ELSE
         DAGMG_MUMPS_LBUF = int( dble(KEEP(213)) / 100.0D0 *                 &
     &                      dble(KEEP(43)) * dble(KEEP(35))  )
        ENDIF
        DAGMG_MUMPS_LBUF = max( DAGMG_MUMPS_LBUF, 100000 )
        DAGMG_MUMPS_LBUF = DAGMG_MUMPS_LBUF                                       &
     &                 + int( 2.0D0 * dble(max(PERLU,MIN_PERLU))*       &
     &                   dble(DAGMG_MUMPS_LBUF)/100D0)
        IF(id%KEEP(48).EQ.4)THEN
           DAGMG_MUMPS_LBUFR_BYTES=DAGMG_MUMPS_LBUFR_BYTES*5
           DAGMG_MUMPS_LBUF=DAGMG_MUMPS_LBUF*5
        ENDIF
        DAGMG_MUMPS_LBUF_INT = ( KEEP(56) + id%NSLAVES * id%NSLAVES ) * 5    &
     &               * KEEP(34)
        IF ( KEEP( 38 ) .NE. 0 ) THEN
          KKKK = AGMG_MUMPS_275( id%STEP(KEEP(38)),                          &
     &         id%PROCNODE_STEPS, id%NSLAVES )
          IF ( KKKK .EQ. id%MYID_NODES ) THEN
             DAGMG_MUMPS_LBUF_INT = DAGMG_MUMPS_LBUF_INT +                        &
     &     10 *                                                         &
     &      2 * ( id%NE_STEPS(id%STEP(KEEP(38))) + 1 ) * id%NSLAVES     &
     &                      * KEEP(34)
          END IF
        END IF
        IF ( MP .GT. 0 ) THEN
          WRITE( MP, 9999 ) DAGMG_MUMPS_LBUFR_BYTES,                         &
     &                      DAGMG_MUMPS_LBUF, DAGMG_MUMPS_LBUF_INT
        END IF
 9999   FORMAT( /,' Allocated buffers',/,' ------------------',/,       &
     &  ' Size of reception buffer in bytes ...... = ', I10,            &
     &  /,                                                              &
     &  ' Size of async. emission buffer (bytes).. = ', I10,/,          &
     &  ' Small emission buffer (bytes) .......... = ', I10)
        CALL DAGMG_MUMPS_55( DAGMG_MUMPS_LBUF_INT, IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,                                           &
     &   ':Error allocating small Send buffer:IERR='                    &
     &   ,IERR
          INFO(1)= -13
          INFO(2)= (DAGMG_MUMPS_LBUF_INT+KEEP(34)-1)/KEEP(34)
          GO TO 110
        END IF
        CALL DAGMG_MUMPS_53( DAGMG_MUMPS_LBUF, IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocating Send buffer:IERR='      &
     &   ,IERR
          INFO(1)= -13
          INFO(2)= (DAGMG_MUMPS_LBUF+KEEP(34)-1)/KEEP(34)
          GO TO 110
        END IF
        id%LBUFR_BYTES = DAGMG_MUMPS_LBUFR_BYTES
        id%LBUFR = (DAGMG_MUMPS_LBUFR_BYTES+KEEP(34)-1)/KEEP(34)
        IF (associated(id%BUFR)) DEALLOCATE(id%BUFR)
        ALLOCATE( id%BUFR( id%LBUFR ),stat=IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocating BUFR:IERR='             &
     &   ,IERR
          INFO(1)=-13
          INFO(2)=id%LBUFR
          NULLIFY(id%BUFR)
          GO TO 110
        END IF
        PERLU          = KEEP( 12 )
        IF (OOC_ON) THEN
          MAXIS_ESTIM   = KEEP(225)
        ELSE
          MAXIS_ESTIM   = KEEP(15)
        ENDIF
        MAXIS = max( 1,                                                 &
     &       MAXIS_ESTIM + 2 * max(PERLU,10) *                          &
     &          ( MAXIS_ESTIM / 100 + 1 )                               &
     &  )
        IF (associated(id%IS)) DEALLOCATE( id%IS )
        ALLOCATE( id%IS( MAXIS  ), stat = IERR )
        IF ( IERR .NE. 0 ) THEN
         WRITE(*,*) id%MYID,':Error allocating IS:IERR=',IERR
         INFO(1)=-13
         INFO(2)=MAXIS
         NULLIFY(id%IS)
         GO TO 110
        END IF
        LIW = MAXIS
        IF (associated( id%PTLUST_S )) DEALLOCATE(id%PTLUST_S)
        ALLOCATE( id%PTLUST_S( id%KEEP(28) ), stat = IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocatingPTLUST:IERR = ',         &
     &    IERR
          INFO(1)=-13
          INFO(2)=id%KEEP(28)
          NULLIFY(id%PTLUST_S)
          GOTO 100
        END IF
        IF (associated( id%PTRFAC )) DEALLOCATE(id%PTRFAC)
        ALLOCATE( id%PTRFAC( id%KEEP(28) ), stat = IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocatingPTRFAC:IERR = ',         &
     &    IERR
          INFO(1)=-13
          INFO(2)=id%KEEP(28)
          NULLIFY(id%PTRFAC)
          GOTO 100
        END IF
        PTRIST = 1
        PTRWB  = PTRIST + id%KEEP(28)
        ITLOC  = PTRWB  + 3 * id%KEEP(28)
        IPOOL  = ITLOC  + id%N
        LPOOL  = DAGMG_MUMPS_505(id%KEEP(1),id%KEEP8(1))
        ALLOCATE( IWK(  IPOOL + LPOOL - 1 ), stat = IERR )
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocating IWK : IERR = ',         &
     &    IERR
          INFO(1)=-13
          INFO(2)=IPOOL + LPOOL - 1
          GOTO 110
        END IF
        ALLOCATE(IWK8( 2 * id%KEEP(28)), stat = IERR)
        IF ( IERR .NE. 0 ) THEN
          WRITE(*,*) id%MYID,':Error allocating IWK : IERR = ',         &
     &    IERR
          INFO(1)=-13
          INFO(2)=2 * id%KEEP(28)
          GOTO 110
        END IF
      ENDIF
  110 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( INFO( 1 ) .LT. 0 ) GOTO 500
      IF ( I_AM_SLAVE )  THEN
        CALL DAGMG_MUMPS_60( id%LBUFR_BYTES )
        IF (MP .GT. 0) THEN
          WRITE( MP, 170 ) MAXS, MAXIS, KEEP8(12), KEEP(15), KEEP(13),  &
     &    KEEP(14), KEEP8(11), KEEP(26), KEEP(27)
        ENDIF
      END IF
      PERLU_ON = .TRUE.
      CALL DAGMG_MUMPS_214( id%KEEP(1), id%KEEP8(1),                         &
     &     id%MYID, id%N, id%NELT, id%LNA, id%NZ,                       &
     &     id%NA_ELT,                                                   &
     &     id%NSLAVES, TOTAL_MBYTES, .FALSE., OOC_ON,                   &
     &     PERLU_ON, TOTAL_BYTES)
      id%INFO(16) = TOTAL_MBYTES
      IF ( MP .gt. 0 ) THEN
          WRITE(MP,'(A,I10) ')                                          &
     &    ' ** Space in MBYTES used during factorization  :',           &
     &                id%INFO(16)
      END IF
      CALL AGMG_MUMPS_243( id%MYID, id%COMM,                                 &
     &                           id%INFO(16), id%INFOG(18), IRANK )
      IF ( PROKG ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Memory relaxation parameter ( ICNTL(14)  )            :',  &
     &  KEEP(12)
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Rank of processor needing largest memory in facto     :',  &
     &  IRANK
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Space in MBYTES used by this processor for facto      :',  &
     &  id%INFOG(18)
        IF ( KEEP(46) .eq. 0 ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Avg. Space in MBYTES per working proc during facto    :',  &
     &  ( id%INFOG(19)-id%INFO(16) ) / id%NSLAVES
        ELSE
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Avg. Space in MBYTES per working proc during facto    :',  &
     &  id%INFOG(19) / id%NSLAVES
        END IF
      END IF
      KEEP8(31)= 0_8
      KEEP8(10) = 0_8
      KEEP8(8)=0_8
      INFO(9:14)=0
      RINFO(2:3)=ZERO
      IF ( I_AM_SLAVE ) THEN
        IF ( KEEP(55) .eq. 0 ) THEN
          LDPTRAR = id%N
        ELSE
          LDPTRAR = id%NELT + 1
        END IF
        IF ( id%KEEP(55) .NE. 0 ) THEN
          NELT = id%NELT
        ELSE
          NELT = 1
        END IF
        CALL DAGMG_MUMPS_244( id%N, NSTEPS, id%S(1),                         &
     &      MAXS, id%IS( 1 ), LIW,                                      &
     &      id%SYM_PERM(1), id%NA(1), id%LNA, id%NE_STEPS(1),           &
     &      id%ND_STEPS(1), id%FILS(1), id%STEP(1),                     &
     &      id%FRERE_STEPS(1), id%DAD_STEPS(1), id%CANDIDATES(1,1),     &
     &      id%ISTEP_TO_INIV2(1), id%TAB_POS_IN_PERE(1,1),              &
     &      id%PTRAR(1), LDPTRAR, IWK( PTRIST ),                        &
     &      id%PTLUST_S(1), id%PTRFAC(1), IWK( PTRWB ),                 &
     &      IWK8,                                                       &
     &      IWK( ITLOC ), IWK( IPOOL ), LPOOL,                          &
     &      CNTL1, ICNTL, INFO, RINFO, KEEP,KEEP8,                      &
     &      id%PROCNODE_STEPS(1),                                       &
     &      id%NSLAVES, id%COMM_NODES,                                  &
     &      id%MYID, id%MYID_NODES,                                     &
     &      id%BUFR(1),id%LBUFR,id%LBUFR_BYTES,                         &
     &      id%INTARR(1), id%DBLARR(1), id%root,                        &
     &      NELT, id%FRTPTR(1),                                         &
     &      id%FRTELT(1), id%COMM_LOAD, id%ASS_IRECV, SEUIL,            &
     &      SEUIL_LDLT_NIV2, id%MEM_DIST(0),                            &
     &       id%DKEEP(1),id%PIVNUL_LIST(1),LPN_LIST)
        IF ( MP  .GT. 0 .and. KEEP(38) .ne. 0 ) THEN
          WRITE( MP, 175 ) KEEP(49)
        END IF
        DEALLOCATE( IWK  )
        DEALLOCATE( IWK8 )
      ENDIF
        IF ( KEEP(55) .eq. 0 ) THEN
          IF (associated( id%DBLARR)) THEN
            DEALLOCATE(id%DBLARR)
            NULLIFY(id%DBLARR)
          ENDIF
        ELSE
          DEALLOCATE( id%INTARR)
          NULLIFY( id%INTARR )
          IF (      id%MYID_NODES .eq. MASTER                           &
     &      .AND.   KEEP(46)   .eq. 1                                   &
     &      .AND.   KEEP(52)   .eq. 0 ) THEN
            NULLIFY( id%DBLARR )
          ELSE
            IF (associated( id%DBLARR)) THEN
              DEALLOCATE(id%DBLARR)
              NULLIFY(id%DBLARR)
            ENDIF
          END IF
        END IF
      IF ( KEEP(19) .NE. 0 ) THEN
        IF ( KEEP(46) .NE. 1 ) THEN
          IF ( id%MYID .eq. MASTER ) THEN
            CALL AGMG_NOCALL('MPI_RECV')
          ELSE IF ( id%MYID .EQ. 1 ) THEN
            CALL AGMG_NOCALL('MPI_SEND')
          END IF
        END IF
      END IF
      IF (associated(id%BUFR)) THEN
        DEALLOCATE(id%BUFR)
        NULLIFY(id%BUFR)
      END IF
      CALL DAGMG_MUMPS_57( IERR )
      CALL DAGMG_MUMPS_59( IERR )
      IF (KEEP(219).NE.0) THEN
      CALL DAGMG_MUMPS_620()
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                    id%COMM, id%MYID )
      IF ( ( KEEP(60) .EQ. 1 ).AND. INFO(1).GE.0 ) THEN
        ID_SCHUR =AGMG_MUMPS_275(id%STEP(id%KEEP(20)),                       &
     &            id%PROCNODE_STEPS(1),id%NSLAVES)
        IF ( id%KEEP( 46 )  .NE. 1 ) THEN
          ID_SCHUR = ID_SCHUR + 1
        END IF
        IF ( id%MYID .eq. MASTER .and. ID_SCHUR .eq. MASTER ) THEN
          CALL DCOPY( id%SIZE_SCHUR * id%SIZE_SCHUR,                    &
     &    id%S(id%PTRFAC(id%IS(                                         &
     &      id%PTLUST_S(id%STEP(id%KEEP(20)))+4+KEEP(IXSZ)))),          &
     &    1, id%SCHUR(1), 1 )
        ELSE
          IF ( id%MYID .eq. ID_SCHUR ) THEN
            SIZE_SCHUR =                                                &
     &        id%IS(id%PTLUST_S(id%STEP(id%KEEP(20)))+0+KEEP(IXSZ))
            CALL AGMG_NOCALL('MPI_SEND')
          ELSE IF ( id%MYID .eq. MASTER ) THEN
            CALL AGMG_NOCALL('MPI_RECV')
          END IF
        END IF
      END IF
      IF (KEEP(201) .NE. 0) THEN
         IF ((KEEP(201).EQ.1) .OR. (KEEP(201).EQ.2)) THEN
            IF ( I_AM_SLAVE ) THEN
               CALL DAGMG_MUMPS_591(IERR)
               IF(IERR.LT.0)THEN
                  INFO(1)=IERR
                  INFO(2)=0
               ENDIF
            ENDIF
            CALL AGMG_MUMPS_276( id%ICNTL, id%INFO,                          &
     &           id%COMM, id%MYID )
         END IF
      END IF
      IF ( PROKG ) THEN
         CALL AGMG_MUMPS_292(TIME)
         WRITE(MPG,180) TIME
      END IF
      PERLU_ON = .TRUE.
      CALL DAGMG_MUMPS_214( id%KEEP(1),id%KEEP8(1),                          &
     &     id%MYID, N, id%NELT, id%LNA, id%NZ,                          &
     &     id%NA_ELT,                                                   &
     &     id%NSLAVES, TOTAL_MBYTES, .TRUE., OOC_ON,                    &
     &     PERLU_ON, TOTAL_BYTES)
      KEEP8(7) = TOTAL_BYTES
      id%INFO(22) = TOTAL_MBYTES
      IF ( MP .gt. 0 ) THEN
          WRITE(MP,'(A,I10) ')                                          &
     &    ' ** Effective minimum Space in MBYTES for facto  :',         &
     &                TOTAL_MBYTES
      ENDIF
      IF (I_AM_SLAVE) THEN
       K67 = KEEP8(67)
      ELSE
       K67 = 0_8
      ENDIF
      CALL AGMG_MUMPS_735(K67,id%INFO(21))
      CALL DAGMG_MUMPS_713(PROKG, MPG, K67, id%NSLAVES,                      &
     & id%COMM, "effective space used in S   (KEEP8(67)   =")
      CALL AGMG_MUMPS_243( id%MYID, id%COMM,                                 &
     &                    TOTAL_MBYTES, id%INFOG(21), IRANK )
      IF ( PROKG ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** EFF Min: Rank of processor needing largest memory :',      &
     &  IRANK
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** EFF Min: Space in MBYTES used by this processor   :',      &
     &  id%INFOG(21)
        IF ( KEEP(46) .eq. 0 ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** EFF Min: Avg. Space in MBYTES per working proc    :',      &
     &  ( id%INFOG(22)-TOTAL_MBYTES ) / id%NSLAVES
        ELSE
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** EFF Min: Avg. Space in MBYTES per working proc    :',      &
     &  id%INFOG(22) / id%NSLAVES
        END IF
      END IF
      KEEP(33) = INFO(11)
      CALL AGMG_COPY( RINFO(2:3), RINFOG(2:3), 2,                             AGMG_MPF_DOUBLE_PRECISION, IERR)
      KEEP(247) = 0
      CALL AGMG_COPY( KEEP(246), KEEP(247), 1, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_COPY( RINFO(2:3), RINFOG(2:3), 2,                             AGMG_MPF_DOUBLE_PRECISION, IERR)
      CALL AGMG_MUMPS_646( KEEP8(31),KEEP8(6), AGMG_MPF_SUM,                      &
     &                     MASTER, id%COMM )
      CALL AGMG_MUMPS_735(KEEP8(6), INFOG(9))
      CALL AGMG_COPY( INFO(10), INFOG(10), 1, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_COPY( INFO(11), INFOG(11), 1, AGMG_MPF_INTEGER, IERR)
      KEEP(133) = INFOG(11)
      CALL AGMG_COPY( INFO(12:14), INFOG(12:14), 3, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_COPY( KEEP(103), INFOG(25), 1, AGMG_MPF_INTEGER, IERR)
      KEEP(229) = INFOG(25)
      CALL AGMG_COPY( KEEP(105), INFOG(25), 1, AGMG_MPF_INTEGER, IERR)
      KEEP(230) = INFOG(25)
      INFO(25) = KEEP(98)
      CALL AGMG_COPY( INFO(25), INFOG(25), 1, AGMG_MPF_INTEGER, IERR)
      CALL AGMG_MUMPS_646( KEEP8(8), KEEP8(108), AGMG_MPF_SUM,                    &
     &                     MASTER, id%COMM )
      CALL AGMG_MUMPS_735(KEEP8(10), INFO(27))
      CALL AGMG_MUMPS_646( KEEP8(10),KEEP8(110), AGMG_MPF_SUM,                    &
     &                     MASTER, id%COMM )
      CALL AGMG_MUMPS_735(KEEP8(110), INFOG(29))
      IF(KEEP(110) .EQ. 1) THEN
         INFO(18) = KEEP(109)
         CALL AGMG_COPY( KEEP(109), KEEP(112), 1, AGMG_MPF_INTEGER, IERR)
      ELSE
         INFO(18)  = 0
         KEEP(109) = 0
         KEEP(112) = 0
      ENDIF
      INFOG(28)=KEEP(112)+KEEP(17)
      IF (KEEP(17) .NE. 0) THEN
        IF (id%MYID .EQ. ID_ROOT) THEN
          INFO(18)=INFO(18)+KEEP(17)
        ENDIF
        IF (ID_ROOT .EQ. MASTER) THEN
          IF (id%MYID.EQ.MASTER) THEN
            DO I=1, KEEP(17)
              id%PIVNUL_LIST(KEEP(112)+I)=id%PIVNUL_LIST(KEEP(109)+I)
            ENDDO
          ENDIF
        ELSE
          IF (id%MYID .EQ. ID_ROOT) THEN
            CALL AGMG_NOCALL('MPI_SEND')
          ELSE IF (id%MYID .EQ. MASTER) THEN
            CALL AGMG_NOCALL('MPI_RECV')
          ENDIF
        ENDIF
      ENDIF
      IF(KEEP(110) .EQ. 1) THEN
         ALLOCATE(ITMP2(id%NPROCS),stat = IERR )
         IF ( IERR .GT. 0 ) THEN
            INFO(1)=-13
            INFO(2)=id%NPROCS
         END IF
         CALL AGMG_MUMPS_276( ICNTL, INFO,                                   &
     &     id%COMM, id%MYID )
         IF (INFO(1).LT.0) GOTO 490
         CALL AGMG_COPY( KEEP(109),                  ITMP2(1),1, AGMG_MPF_INTEGER, IERR)
         IF(id%MYID .EQ. MASTER) THEN
            POSBUF = ITMP2(1)+1
            KEEP(220)=1
            DO I = 1,id%NPROCS-1
               CALL AGMG_NOCALL('MPI_RECV')
               CALL AGMG_NOCALL('MPI_SEND')
               POSBUF = POSBUF + ITMP2(I+1)
            ENDDO
         ELSE
            CALL AGMG_NOCALL('MPI_SEND')
            CALL AGMG_NOCALL('MPI_RECV')
         ENDIF
         DEALLOCATE(ITMP2)
      ENDIF
  490 IF ( PROKG ) THEN
          WRITE(MPG,99984) RINFOG(2),RINFOG(3),KEEP8(6),INFOG(10),      &
     &                    INFOG(11), KEEP8(110)
          IF (id%SYM == 1 .OR. id%SYM == 2) THEN
            WRITE(MPG, 99987) INFOG(12)
          END IF
          IF (id%SYM == 0) THEN
            WRITE(MPG, 99985) INFOG(12)
          END IF
          IF (id%SYM .NE. 1) THEN
            WRITE(MPG, 99982) INFOG(13)
          END IF
          IF (KEEP(97) .NE. 0) THEN
            WRITE(MPG, 99986) KEEP(98)
          ENDIF
          IF (id%SYM == 2) THEN
             WRITE(MPG, 99988) KEEP(229)
             WRITE(MPG, 99989) KEEP(230)
          ENDIF
          IF (KEEP(110) .NE.0) THEN
              WRITE(MPG, 99991) KEEP(112)
          ENDIF
          IF ( KEEP(17) .ne. 0 )                                        &
     &    WRITE(MPG, 99983) KEEP(17)
          IF (KEEP(110).NE.0.OR.KEEP(17).NE.0)                          &
     &    WRITE(MPG, 99992) KEEP(17)+KEEP(112)
          WRITE(MPG, 99981) INFOG(14)
          IF ((KEEP(201).EQ.0.OR.KEEP(201).EQ.2).AND.                   &
     &        KEEP(50).EQ.0) THEN
          WRITE(MPG, 99980) KEEP8(108)
          ENDIF
          IF  ((KEEP(60).NE.0) .AND. INFOG(25).GT.0) THEN
           WRITE(MPG, '(A)')                                            &
     & " ** Warning Static pivoting was necessary"
           WRITE(MPG, '(A)')                                            &
     & " ** to factor interior variables with Schur ON"
          ENDIF
      END IF
  500 CONTINUE
      IF ( I_AM_SLAVE ) THEN
         IF ((KEEP(201).EQ.1).OR.(KEEP(201).EQ.2)) THEN
            CALL DAGMG_MUMPS_592(id,IERR)
            IF (IERR.LT.0 .AND. INFO(1) .GE. 0) INFO(1) = IERR
         ENDIF
         IF (WK_USER_PROVIDED) THEN
            NULLIFY(id%S)
         ELSE IF (KEEP(201).NE.0) THEN
            IF (associated(id%S))  DEALLOCATE(id%S)
            NULLIFY(id%S)
            KEEP8(23)=0_8
         ENDIF
      ELSE
         IF (WK_USER_PROVIDED) THEN
            NULLIFY(id%S)
         ELSE
            IF (associated(id%S))  DEALLOCATE(id%S)
            NULLIFY(id%S)
            KEEP8(23)=0_8
         END IF
      END IF
  513 CONTINUE
      IF ( I_AM_SLAVE ) THEN
         CALL DAGMG_MUMPS_183( INFO(1), IERR )
         IF (IERR.LT.0 .AND. INFO(1) .GE. 0) INFO(1) = IERR
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &     id%COMM, id%MYID )
  530 CONTINUE
      id%KEEP(13) = KEEP13_SAVE
      RETURN
  120 FORMAT(/' LOCAL REDISTRIB: DATA LOCAL/SENT     =',I12,I12)
  125 FORMAT(/' REDISTRIB: TOTAL DATA LOCAL/SENT     =',I12,I12)
  130 FORMAT(/' ****** FACTORIZATION STEP ********'/)
  160 FORMAT(' GLOBAL TIME FOR MATRIX DISTRIBUTION  =',F12.4)
  165 FORMAT(' Convergence error after scaling for INF-NORM',           &
     &       ' (option 7/8)   =',D9.2)
  166 FORMAT(' Convergence error after scaling for ONE-NORM',           &
     &       ' (option 7/8)   =',D9.2)
  170 FORMAT(/' STATISTICS PRIOR NUMERICAL FACTORIZATION ...'/          &
     &        ' Size of internal working array S     =',I12/            &
     &        ' Size of internal working array IS    =',I12/            &
     &        ' MINIMUM (ICNTL(14)=0) size of S      =',I12/            &
     &        ' MINIMUM (ICNTL(14)=0) size of IS     =',I12/            &
     &        ' REAL SPACE FOR ORIGINAL MATRIX       =',I12/            &
     &        ' INTEGER SPACE FOR ORIGINAL MATRIX    =',I12/            &
     &        ' REAL SPACE FOR FACTORS               =',I12/            &
     &        ' INTEGER SPACE FOR FACTORS            =',I12/            &
     &        ' MAXIMUM FRONTAL SIZE (ESTIMATED)     =',I12)
  172 FORMAT(/' GLOBAL STATISTICS PRIOR NUMERICAL FACTORIZATION ...'/   &
     &        ' NUMBER OF WORKING PROCESSES          =',I12/            &
     &        ' OUT-OF-CORE OPTION (ICNTL(22))       =',I12/            &
     &        ' REAL SPACE FOR FACTORS               =',I12/            &
     &        ' INTEGER SPACE FOR FACTORS            =',I12/            &
     &        ' MAXIMUM FRONTAL SIZE (ESTIMATED)     =',I12/            &
     &        ' NUMBER OF NODES IN THE TREE          =',I12)
  175 FORMAT(/' NUMBER OF ENTRIES FOR // ROOT                 =',I12)
  180 FORMAT(/' ELAPSED TIME FOR FACTORIZATION       =',F12.4)
99980 FORMAT(                                                           &
     &  ' KEEP8(108) Extra copies due to IP stacking     =',I12)
99981 FORMAT(                                                           &
     &  ' INFOG(14)  NUMBER OF MEMORY COMPRESS           =',I12)
99982 FORMAT( ' INFOG(12)  NUMBER OF DELAYED PIVOTS      =',I12)
99983 FORMAT( ' NB OF NULL PIVOTS DETECTED BY ICNTL(16)  =',I12)
99991 FORMAT( ' NB OF NULL PIVOTS DETECTED BY ICNTL(24)  =',I12)
99992 FORMAT( ' INFOG(28)  ESTIMATED DEFICIENCY          =',I12)
99984 FORMAT(/' GLOBAL STATISTICS '/                                    &
     &  ' RINFOG(2)  OPERATIONS DURING NODE ASSEMBLY     =',1PD10.3/    &
     &  ' ------(3)  OPERATIONS DURING NODE ELIMINATION  =',1PD10.3/    &
     &  ' INFOG (9)  REAL SPACE FOR FACTORS              =',I12/        &
     &  ' INFOG(10)  INTEGER SPACE FOR FACTORS           =',I12/        &
     &  ' INFOG(11)  MAXIMUM FRONT SIZE                  =',I12/        &
     &  ' INFOG(29)  NUMBER OF ENTRIES IN FACTORS        =',I12)
99985 FORMAT( ' INFOG(13) NB OF OFF DIAGONAL PIVOTS      =',I12)
99986 FORMAT( ' INFOG(25) NB TINY PIVOTS/STATIC PIVOTING =',I12)
99987 FORMAT( ' INFOG(12) NB OF NEGATIVE PIVOTS          =',I12)
99988 FORMAT( ' NUMBER OF 2x2 PIVOTS in type 1 nodes     =',I12)
99989 FORMAT( ' NUMBER OF 2x2 PIVOTS in type 2 nodes     =',I12)
      END SUBROUTINE DAGMG_MUMPS_142
      SUBROUTINE DAGMG_MUMPS_536(PROKG, MPG, VAL, NSLAVES,                   &
     &     COMM, MSG)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      LOGICAL PROKG
      INTEGER MPG
      INTEGER(8) :: VAL
      INTEGER NSLAVES
      INTEGER COMM
      CHARACTER*42 MSG
      INTEGER MAX_VAL
      INTEGER IERR, MASTER
      DOUBLE PRECISION LOC_VAL, AVG_VAL
      PARAMETER(MASTER=0)
      CALL AGMG_COPY( VAL, MAX_VAL, 1, AGMG_MPF_INTEGER, IERR )
      LOC_VAL = dble(VAL)/dble(NSLAVES)
      CALL AGMG_COPY( LOC_VAL, AVG_VAL, 1, AGMG_MPF_DOUBLE_PRECISION, IERR )
      IF (PROKG) THEN
        WRITE(MPG,100) " Maximum ", MSG, MAX_VAL
        WRITE(MPG,100) " Average ", MSG, int(AVG_VAL)
      ENDIF
      RETURN
  100 FORMAT(A9,A42,I12)
      END SUBROUTINE DAGMG_MUMPS_536
      SUBROUTINE DAGMG_MUMPS_713(PROKG, MPG, VAL, NSLAVES,                   &
     &     COMM, MSG)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      LOGICAL PROKG
      INTEGER MPG
      INTEGER*8 VAL
      INTEGER NSLAVES
      INTEGER COMM
      CHARACTER*42 MSG
      INTEGER*8 MAX_VAL
      INTEGER IERR, MASTER
      DOUBLE PRECISION LOC_VAL, AVG_VAL
      PARAMETER(MASTER=0)
      CALL AGMG_MUMPS_646( VAL, MAX_VAL, AGMG_MPF_MAX, MASTER, COMM)
      LOC_VAL = dble(VAL)/dble(NSLAVES)
      CALL AGMG_COPY( LOC_VAL, AVG_VAL, 1, AGMG_MPF_DOUBLE_PRECISION, IERR )
      IF (PROKG) THEN
        WRITE(MPG,100) " Maximum ", MSG, MAX_VAL
        WRITE(MPG,100) " Average ", MSG, int(AVG_VAL,8)
      ENDIF
      RETURN
  100 FORMAT(A9,A42,I12)
      END SUBROUTINE DAGMG_MUMPS_713
      SUBROUTINE DAGMG_MUMPS_83                                              &
     & ( N, MAPPING, NZ, IRN, JCN, PROCNODE, STEP,                      &
     &   SLAVEF, PERM, FILS,                                            &
     &   RG2L, KEEP,KEEP8, MBLOCK, NBLOCK, NPROW, NPCOL )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTEGER N, NZ, SLAVEF, MBLOCK, NBLOCK, NPROW, NPCOL
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER IRN( NZ ), JCN( NZ )
      INTEGER MAPPING( NZ ), STEP( N )
      INTEGER PROCNODE( KEEP(28) ), PERM( N ), FILS( N ), RG2L( N )
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330
      INTEGER K, IOLD, JOLD, INEW, JNEW, ISEND, JSEND, IARR, INODE
      INTEGER TYPE_NODE, DEST
      INTEGER IPOSROOT, JPOSROOT, IROW_GRID, JCOL_GRID
      INODE = KEEP(38)
      K = 1
      DO WHILE ( INODE .GT. 0 )
        RG2L( INODE ) = K
        INODE = FILS( INODE )
        K = K + 1
      END DO
      DO K = 1, NZ
        IOLD = IRN( K )
        JOLD = JCN( K )
        IF ( IOLD .GT. N .OR. IOLD .LT. 1 .OR.                          &
     &       JOLD .GT. N .OR. JOLD .LT. 1 ) THEN
           MAPPING( K ) = -1
           CYCLE
        END IF
        IF ( IOLD .eq. JOLD ) THEN
          ISEND = IOLD
          JSEND = JOLD
        ELSE
          INEW = PERM( IOLD )
          JNEW = PERM( JOLD )
          IF ( INEW .LT. JNEW ) THEN
            ISEND = IOLD
            IF ( KEEP(50) .ne. 0 ) ISEND = -IOLD
            JSEND = JOLD
          ELSE
            ISEND = -JOLD
            JSEND = IOLD
          END IF
        END IF
        IARR = abs( ISEND )
        TYPE_NODE = AGMG_MUMPS_330( abs(STEP(IARR)),                         &
     &                              PROCNODE, SLAVEF )
        IF ( TYPE_NODE .eq. 1 .or. TYPE_NODE .eq. 2 ) THEN
          IF ( KEEP(46) .eq. 0 ) THEN
            DEST = AGMG_MUMPS_275( abs(STEP(IARR)),                          &
     &                             PROCNODE, SLAVEF ) + 1
          ELSE
            DEST = AGMG_MUMPS_275( abs(STEP(IARR)),                          &
     &                             PROCNODE, SLAVEF )
          END IF
        ELSE
          IF ( ISEND .LT. 0 ) THEN
            IPOSROOT = RG2L( JSEND )
            JPOSROOT = RG2L( IARR  )
          ELSE
            IPOSROOT = RG2L( IARR  )
            JPOSROOT = RG2L( JSEND )
          END IF
          IROW_GRID = mod( ( IPOSROOT - 1 )/MBLOCK, NPROW )
          JCOL_GRID = mod( ( JPOSROOT - 1 )/NBLOCK, NPCOL )
          IF ( KEEP( 46 ) .eq. 0 ) THEN
            DEST = IROW_GRID * NPCOL + JCOL_GRID + 1
          ELSE
            DEST = IROW_GRID * NPCOL + JCOL_GRID
          END IF
        END IF
        MAPPING( K ) = DEST
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_83
      SUBROUTINE DAGMG_MUMPS_282(                                            &
     & N, NZ_loc, id,                                                   &
     & DBLARR, LDBLARR, INTARR, LINTARR,                                &
     & PTRAIW, PTRARW, KEEP,KEEP8, MYID, COMM, NBRECORDS,               &
     & A, LA, root, PROCNODE_STEPS, SLAVEF, PERM, STEP,                 &
     & ICNTL, INFO, NSEND, NLOCAL,                                      &
     & ISTEP_TO_INIV2, CANDIDATES                                       &
     & )
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      INTEGER N, NZ_loc
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER LDBLARR, LINTARR
      DOUBLE PRECISION DBLARR( LDBLARR )
      INTEGER INTARR( LINTARR )
      INTEGER PTRAIW( N ), PTRARW( N )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER MYID, COMM, NBRECORDS
      INTEGER(8) :: LA
      INTEGER SLAVEF
      INTEGER ISTEP_TO_INIV2(KEEP(71))
      INTEGER CANDIDATES(SLAVEF+1, max(1,KEEP(56)))
      DOUBLE PRECISION A( LA )
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER PROCNODE_STEPS(KEEP(28)), PERM( N ), STEP( N )
      INTEGER INFO( 40 ), ICNTL(40)
      INTEGER AGMG_MUMPS_275, AGMG_MUMPS_330, NUMROC_FOOL
      EXTERNAL AGMG_MUMPS_275, AGMG_MUMPS_330, NUMROC_FOOL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE ), MSGSOU
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      INTEGER, ALLOCATABLE, DIMENSION(:,:) :: IW4
      INTEGER END_MSG_2_RECV
      INTEGER I, K, I1, IA
      INTEGER TYPE_NODE, DEST
      INTEGER IOLD, JOLD, IARR, ISEND, JSEND, INEW, JNEW
      INTEGER allocok
      DOUBLE PRECISION VAL
      INTEGER(8) :: PTR_ROOT
      INTEGER LOCAL_M, LOCAL_N, ARROW_ROOT
      INTEGER IROW_GRID, JCOL_GRID, IPOSROOT, JPOSROOT
      INTEGER MP,LP
      INTEGER KPROBE, FREQPROBE
      INTEGER, ALLOCATABLE, DIMENSION(:,:,:) :: BUFI
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:,:) :: BUFR
      INTEGER, ALLOCATABLE, DIMENSION(:) :: BUFRECI
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: BUFRECR
      INTEGER IACT( SLAVEF ), IREQI( SLAVEF ), IREQR( SLAVEF )
      LOGICAL SEND_ACTIVE( SLAVEF )
      LOGICAL FLAG
      INTEGER NSEND, NLOCAL
      INTEGER MASTER_NODE, ISTEP
      NSEND = 0
      NLOCAL = 0
      LP = ICNTL(1)
      MP = ICNTL(2)
      END_MSG_2_RECV = SLAVEF
      ALLOCATE( BUFI( NBRECORDS * 2 + 1, 2, SLAVEF ), stat=allocok)
      IF ( allocok .GT. 0 ) THEN
        IF ( LP > 0 ) THEN
          WRITE(LP,*)                                                   &
     &     '** Error allocating int buffer for matrix distribution'
        END IF
        INFO(1) = -13
        INFO(2) = ( NBRECORDS * 2 + 1 ) * SLAVEF * 2
      END IF
      ALLOCATE( BUFR( NBRECORDS, 2, SLAVEF), stat = allocok)
      IF ( allocok .GT. 0 ) THEN
        IF ( LP > 0 ) THEN
          WRITE(LP,*)                                                   &
     &     '** Error allocating real buffer for matrix distribution'
        END IF
        INFO(1) = -13
        INFO(2) = NBRECORDS * SLAVEF * 2
        GOTO 20
      END IF
      ALLOCATE( BUFRECI( NBRECORDS * 2 + 1 ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        IF ( LP > 0 ) THEN
          WRITE(LP,*)                                                   &
     &    '** Error allocating int recv buffer for matrix distribution'
        END IF
        INFO(1) = -13
        INFO(2) = NBRECORDS * 2 + 1
        GOTO 20
      END IF
      ALLOCATE( BUFRECR( NBRECORDS ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        IF ( LP > 0 ) THEN
          WRITE(LP,*)                                                   &
     &    '** Error allocating int recv buffer for matrix distribution'
        END IF
        INFO(1) = -13
        INFO(2) = NBRECORDS
        GOTO 20
      END IF
      ALLOCATE( IW4( N, 2 ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        WRITE(LP,*) '** Error allocating IW4 for matrix distribution'
        INFO(1) = -13
        INFO(2) = N * 2
      END IF
   20 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO, COMM, MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      ARROW_ROOT = 0
      DO I = 1, N
          I1 = PTRAIW( I )
          IA = PTRARW( I )
          IF ( IA .GT. 0 ) THEN
            DBLARR( IA ) = dble(ZERO)
            IW4( I, 1 ) = INTARR( I1 )
            IW4( I, 2 ) = -INTARR( I1 + 1 )
            INTARR( I1 + 2 ) = I
          END IF
      END DO
      IF ( KEEP(38) .NE. 0 ) THEN
          IF (KEEP(60)==0) THEN
          LOCAL_M = NUMROC_FOOL( root%ROOT_SIZE, root%MBLOCK,                &
     &               root%MYROW, 0, root%NPROW )
          LOCAL_M = max( 1, LOCAL_M )
          LOCAL_N = NUMROC_FOOL( root%ROOT_SIZE, root%NBLOCK,                &
     &               root%MYCOL, 0, root%NPCOL )
          PTR_ROOT = LA - int(LOCAL_M,8) * int(LOCAL_N,8) + 1_8
          IF ( PTR_ROOT .LE. LA ) THEN
            A( PTR_ROOT:LA ) = dble(ZERO)
          END IF
          ELSE
            DO I = 1, root%SCHUR_NLOC
              root%SCHUR_POINTER((I-1)*root%SCHUR_LLD+1:                &
     &        (I-1)*root%SCHUR_LLD+root%SCHUR_MLOC)=dble(ZERO)
            ENDDO
          ENDIF
      END IF
      DO I = 1, SLAVEF
        BUFI( 1, 1, I ) = 0
      END DO
      DO I = 1, SLAVEF
        BUFI( 1, 2, I ) = 0
      END DO
      DO I = 1, SLAVEF
        SEND_ACTIVE( I ) = .FALSE.
        IACT( I ) = 1
      END DO
      KPROBE = 0
      FREQPROBE = max(1,NBRECORDS/10)
      DO K = 1, NZ_loc
        KPROBE = KPROBE + 1
        IF ( KPROBE .eq. FREQPROBE ) THEN
          KPROBE = 0
          CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, ARR_INT, COMM,               &
     &                     FLAG, STATUS, IERR )
          IF ( FLAG ) THEN
            MSGSOU = STATUS( AGMG_MPF_SOURCE )
            CALL AGMG_NOCALL('MPI_RECV')
            CALL AGMG_NOCALL('MPI_RECV')
            CALL DAGMG_MUMPS_102(                                            &
     &             BUFRECI, BUFRECR, NBRECORDS, N, IW4(1,1),            &
     &             KEEP,KEEP8, LOCAL_M, LOCAL_N, root, PTR_ROOT,        &
     &             A, LA,                                               &
     &             END_MSG_2_RECV, MYID, PROCNODE_STEPS, SLAVEF,        &
     &             ARROW_ROOT, PTRAIW, PTRARW, PERM, STEP,              &
     &             INTARR, LINTARR, DBLARR, LDBLARR                     &
     &             )
          END IF
        END IF
        IOLD = id%IRN_loc(K)
        JOLD = id%JCN_loc(K)
        IF ( (IOLD.GT.N).OR.(JOLD.GT.N).OR.(IOLD.LT.1)                  &
     &                 .OR.(JOLD.LT.1) ) CYCLE
        VAL = id%A_loc(K)
        IF ((KEEP(52).EQ.7).OR.(KEEP(52).EQ.8)) THEN
          VAL = VAL * id%ROWSCA(IOLD)*id%COLSCA(JOLD)
        ENDIF
        IF (IOLD.EQ.JOLD) THEN
          ISEND = IOLD
          JSEND = JOLD
        ELSE
          INEW = PERM(IOLD)
          JNEW = PERM(JOLD)
          IF (INEW.LT.JNEW) THEN
            ISEND = IOLD
            IF ( KEEP(50) .NE. 0 ) ISEND = -IOLD
            JSEND = JOLD
          ELSE
            ISEND = -JOLD
            JSEND = IOLD
          ENDIF
        ENDIF
        IARR = abs( ISEND )
        ISTEP = abs(STEP(IARR))
        TYPE_NODE = AGMG_MUMPS_330( ISTEP,                                   &
     &              PROCNODE_STEPS, SLAVEF )
        MASTER_NODE= AGMG_MUMPS_275( ISTEP,                                  &
     &           PROCNODE_STEPS, SLAVEF )
        IF ( TYPE_NODE .eq. 1 ) THEN
          DEST = MASTER_NODE
        ELSE IF ( TYPE_NODE .eq. 2 ) THEN
          IF ( ISEND .LT. 0 ) THEN
            DEST = -1
          ELSE
            DEST = MASTER_NODE
          END IF
        ELSE
          IF ( ISEND < 0 ) THEN
            IPOSROOT = root%RG2L_ROW(JSEND)
            JPOSROOT = root%RG2L_ROW(IARR )
          ELSE
            IPOSROOT = root%RG2L_ROW(IARR )
            JPOSROOT = root%RG2L_ROW(JSEND)
          END IF
          IROW_GRID = mod( ( IPOSROOT - 1 )/root%MBLOCK, root%NPROW )
          JCOL_GRID = mod( ( JPOSROOT - 1 )/root%NBLOCK, root%NPCOL )
          DEST = IROW_GRID * root%NPCOL + JCOL_GRID
        END IF
        if (DEST .eq. -1) then
          NLOCAL = NLOCAL + 1
          NSEND = NSEND + SLAVEF -1
        else
          if (DEST .eq.MYID ) then
            NLOCAL = NLOCAL + 1
          else
            NSEND = NSEND + 1
          endif
        end if
        IF ( DEST.EQ.-1) THEN
         DO I=1, CANDIDATES(SLAVEF+1,ISTEP_TO_INIV2(ISTEP))
            DEST=CANDIDATES(I,ISTEP_TO_INIV2(ISTEP))
            CALL DAGMG_MUMPS_101( DEST, ISEND, JSEND, VAL,                   &
     &   BUFI, BUFR, BUFRECI, BUFRECR,                                  &
     &   NBRECORDS, SLAVEF, COMM, MYID, IACT, IREQI, IREQR,             &
     &   SEND_ACTIVE, INTARR, LINTARR, DBLARR, LDBLARR,                 &
     &   N, PTRAIW, PTRARW, PERM, STEP, ARROW_ROOT, END_MSG_2_RECV,     &
     &   PROCNODE_STEPS, A, LA, PTR_ROOT, LOCAL_M, LOCAL_N, IW4(1,1),   &
     &   root, KEEP,KEEP8 )
         ENDDO
         DEST=MASTER_NODE
         CALL DAGMG_MUMPS_101( DEST, ISEND, JSEND, VAL,                      &
     &   BUFI, BUFR, BUFRECI, BUFRECR,                                  &
     &   NBRECORDS, SLAVEF, COMM, MYID, IACT, IREQI, IREQR,             &
     &   SEND_ACTIVE, INTARR, LINTARR, DBLARR, LDBLARR,                 &
     &   N, PTRAIW, PTRARW, PERM, STEP, ARROW_ROOT, END_MSG_2_RECV,     &
     &   PROCNODE_STEPS, A, LA, PTR_ROOT, LOCAL_M, LOCAL_N, IW4(1,1),   &
     &   root, KEEP,KEEP8 )
        ELSE
         CALL DAGMG_MUMPS_101( DEST, ISEND, JSEND, VAL,                      &
     &   BUFI, BUFR, BUFRECI, BUFRECR,                                  &
     &   NBRECORDS, SLAVEF, COMM, MYID, IACT, IREQI, IREQR,             &
     &   SEND_ACTIVE, INTARR, LINTARR, DBLARR, LDBLARR,                 &
     &   N, PTRAIW, PTRARW, PERM, STEP, ARROW_ROOT, END_MSG_2_RECV,     &
     &   PROCNODE_STEPS, A, LA, PTR_ROOT, LOCAL_M, LOCAL_N, IW4(1,1),   &
     &   root, KEEP,KEEP8 )
        ENDIF
      END DO
      DEST = -2
        CALL DAGMG_MUMPS_101( DEST, ISEND, JSEND, VAL,                       &
     &  BUFI, BUFR, BUFRECI, BUFRECR,                                   &
     &  NBRECORDS, SLAVEF, COMM, MYID, IACT, IREQI, IREQR,              &
     &  SEND_ACTIVE, INTARR, LINTARR, DBLARR, LDBLARR,                  &
     &  N, PTRAIW, PTRARW, PERM, STEP, ARROW_ROOT, END_MSG_2_RECV,      &
     &  PROCNODE_STEPS, A, LA, PTR_ROOT, LOCAL_M, LOCAL_N,              &
     &  IW4(1,1), root, KEEP,KEEP8 )
      DO WHILE ( END_MSG_2_RECV .NE. 0 )
        CALL AGMG_NOCALL('MPI_RECV')
        MSGSOU = STATUS( AGMG_MPF_SOURCE )
        CALL AGMG_NOCALL('MPI_RECV')
        CALL DAGMG_MUMPS_102(                                                &
     &           BUFRECI, BUFRECR, NBRECORDS, N, IW4(1,1),              &
     &           KEEP,KEEP8, LOCAL_M, LOCAL_N, root, PTR_ROOT,          &
     &           A, LA,                                                 &
     &           END_MSG_2_RECV, MYID, PROCNODE_STEPS, SLAVEF,          &
     &           ARROW_ROOT, PTRAIW, PTRARW, PERM, STEP,                &
     &           INTARR, LINTARR, DBLARR, LDBLARR                       &
     &           )
      END DO
      DO I = 1, SLAVEF
        IF ( SEND_ACTIVE( I ) ) THEN
          CALL AGMG_NOCALL('MPI_WAIT')
          CALL AGMG_NOCALL('MPI_WAIT')
        END IF
      END DO
      KEEP(49) = ARROW_ROOT
      DEALLOCATE( IW4 )
      DEALLOCATE( BUFI )
      DEALLOCATE( BUFR )
      DEALLOCATE( BUFRECI )
      DEALLOCATE( BUFRECR )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_282
      SUBROUTINE DAGMG_MUMPS_101( DEST, ISEND, JSEND, VAL,                   &
     &  BUFI, BUFR, BUFRECI, BUFRECR,                                   &
     &  NBRECORDS, SLAVEF, COMM, MYID, IACT, IREQI, IREQR,              &
     &  SEND_ACTIVE, INTARR, LINTARR, DBLARR, LDBLARR, N,               &
     &  PTRAIW, PTRARW, PERM, STEP, ARROW_ROOT, END_MSG_2_RECV,         &
     &  PROCNODE_STEPS, A, LA, PTR_ROOT, LOCAL_M, LOCAL_N, IW4, root,   &
     &  KEEP,KEEP8 )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER ISEND, JSEND, DEST, NBRECORDS, SLAVEF, COMM, MYID, N
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER ARROW_ROOT, END_MSG_2_RECV, LOCAL_M, LOCAL_N
      INTEGER LINTARR, LDBLARR
      INTEGER(8) :: LA, PTR_ROOT
      INTEGER BUFI( NBRECORDS * 2 + 1, 2, SLAVEF )
      INTEGER BUFRECI( NBRECORDS * 2 + 1 )
      INTEGER IREQI(SLAVEF), IREQR(SLAVEF), IACT(SLAVEF)
      INTEGER IW4( N, 2 )
      INTEGER PTRAIW( N ), PTRARW( N ), PERM( N ), STEP( N )
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER INTARR( LINTARR )
      DOUBLE PRECISION DBLARR( LDBLARR ), A( LA )
      LOGICAL SEND_ACTIVE(SLAVEF)
      DOUBLE PRECISION BUFR( NBRECORDS, 2, SLAVEF )
      DOUBLE PRECISION BUFRECR( NBRECORDS )
      DOUBLE PRECISION VAL
      INTEGER ISLAVE, IBEG, IEND, NBREC, IREQ
      INTEGER TAILLE_SEND_I, TAILLE_SEND_R, MSGSOU
      LOGICAL FLAG, SEND_LOCAL
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR, STATUS(AGMG_MPF_STATUS_SIZE)
      IF ( DEST .eq. -2 ) THEN
        IBEG = 1
        IEND = SLAVEF
      ELSE
        IBEG = DEST + 1
        IEND = DEST + 1
      END IF
      SEND_LOCAL = .FALSE.
      DO ISLAVE = IBEG, IEND
        NBREC = BUFI(1,IACT(ISLAVE),ISLAVE)
        IF ( DEST .eq. -2 ) THEN
          BUFI(1,IACT(ISLAVE),ISLAVE) = - NBREC
        END IF
        IF ( DEST .eq. -2 .or. NBREC + 1 > NBRECORDS ) THEN
          DO WHILE ( SEND_ACTIVE( ISLAVE ) )
            CALL AGMG_MPF_TEST( IREQR( ISLAVE ), FLAG, STATUS, IERR )
            IF ( .NOT. FLAG ) THEN
                CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, ARR_INT, COMM,         &
     &                           FLAG, STATUS, IERR )
                IF ( FLAG ) THEN
                  MSGSOU = STATUS(AGMG_MPF_SOURCE)
                  CALL AGMG_NOCALL('MPI_RECV')
                  CALL AGMG_NOCALL('MPI_RECV')
                  CALL DAGMG_MUMPS_102(                                      &
     &              BUFRECI, BUFRECR, NBRECORDS, N, IW4(1,1),           &
     &              KEEP,KEEP8, LOCAL_M, LOCAL_N, root, PTR_ROOT,       &
     &              A, LA,                                              &
     &              END_MSG_2_RECV, MYID, PROCNODE_STEPS, SLAVEF,       &
     &              ARROW_ROOT, PTRAIW, PTRARW, PERM, STEP,             &
     &              INTARR, LINTARR, DBLARR, LDBLARR                    &
     &              )
                END IF
            ELSE
                CALL AGMG_NOCALL('MPI_WAIT')
                SEND_ACTIVE( ISLAVE ) = .FALSE.
            END IF
          END DO
          IF ( ISLAVE - 1 .ne. MYID ) THEN
            TAILLE_SEND_I = NBREC * 2 + 1
            TAILLE_SEND_R = NBREC
            CALL AGMG_NOCALL('MPI_ISEND')
            CALL AGMG_NOCALL('MPI_ISEND')
            SEND_ACTIVE( ISLAVE ) = .TRUE.
          ELSE
            SEND_LOCAL = .TRUE.
          END IF
          IACT( ISLAVE ) = 3 - IACT( ISLAVE )
          BUFI( 1, IACT( ISLAVE ), ISLAVE ) = 0
        END IF
        IF ( DEST .ne. -2 ) THEN
          IREQ = BUFI(1,IACT(ISLAVE),ISLAVE) + 1
          BUFI(1,IACT(ISLAVE),ISLAVE) = IREQ
          BUFI(IREQ*2,IACT(ISLAVE),ISLAVE)  = ISEND
          BUFI(IREQ*2+1,IACT(ISLAVE),ISLAVE) = JSEND
          BUFR(IREQ,IACT(ISLAVE),ISLAVE )    = VAL
        END IF
      END DO
      IF ( SEND_LOCAL ) THEN
            ISLAVE = MYID + 1
            CALL DAGMG_MUMPS_102(                                            &
     &              BUFI(1,3-IACT(ISLAVE),ISLAVE),                      &
     &              BUFR(1,3-IACT(ISLAVE),ISLAVE),                      &
     &              NBRECORDS, N, IW4(1,1),                             &
     &              KEEP,KEEP8, LOCAL_M, LOCAL_N, root, PTR_ROOT,       &
     &              A, LA,                                              &
     &              END_MSG_2_RECV, MYID, PROCNODE_STEPS, SLAVEF,       &
     &              ARROW_ROOT, PTRAIW, PTRARW, PERM, STEP,             &
     &              INTARR, LINTARR, DBLARR, LDBLARR                    &
     &              )
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_101
      SUBROUTINE DAGMG_MUMPS_102                                             &
     &           ( BUFI, BUFR, NBRECORDS, N, IW4,                       &
     &             KEEP,KEEP8, LOCAL_M, LOCAL_N, root, PTR_ROOT, A, LA, &
     &             END_MSG_2_RECV, MYID, PROCNODE_STEPS,                &
     &             SLAVEF, ARROW_ROOT,                                  &
     &             PTRAIW, PTRARW, PERM, STEP,                          &
     &             INTARR, LINTARR, DBLARR, LDBLARR )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER NBRECORDS, N, ARROW_ROOT, MYID, SLAVEF
      INTEGER BUFI( NBRECORDS * 2 + 1 )
      DOUBLE PRECISION BUFR( NBRECORDS )
      INTEGER IW4( N, 2 )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER END_MSG_2_RECV
      INTEGER PTRAIW( N ), PTRARW( N ), PERM( N ), STEP( N )
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER LINTARR, LDBLARR
      INTEGER INTARR( LINTARR )
      INTEGER LOCAL_M, LOCAL_N
      INTEGER(8) :: PTR_ROOT, LA
      DOUBLE PRECISION A( LA ), DBLARR( LDBLARR )
      INTEGER AGMG_MUMPS_330, AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_330, AGMG_MUMPS_275
      INTEGER IREC, NB_REC, NODE_TYPE, IPROC
      INTEGER IPOSROOT, JPOSROOT, IROW_GRID, JCOL_GRID,                 &
     &        ILOCROOT, JLOCROOT
      INTEGER IA, IS1, ISHIFT, IIW, IS, IAS, IARR, JARR
      INTEGER TAILLE
      DOUBLE PRECISION VAL
      NB_REC = BUFI( 1 )
      IF ( NB_REC .LE. 0 ) THEN
        END_MSG_2_RECV = END_MSG_2_RECV - 1
        NB_REC = - NB_REC
      END IF
      IF ( NB_REC .eq. 0 ) GOTO 100
      DO IREC = 1, NB_REC
        IARR = BUFI( IREC * 2 )
        JARR = BUFI( IREC * 2 + 1 )
        VAL  = BUFR( IREC )
        NODE_TYPE = AGMG_MUMPS_330( abs(STEP(abs( IARR ))),                  &
     &              PROCNODE_STEPS, SLAVEF )
        IF ( NODE_TYPE .eq. 3 ) THEN
          ARROW_ROOT = ARROW_ROOT + 1
          IF ( IARR .GT. 0 ) THEN
            IPOSROOT = root%RG2L_ROW( IARR )
            JPOSROOT = root%RG2L_COL( JARR )
          ELSE
            IPOSROOT = root%RG2L_ROW( JARR )
            JPOSROOT = root%RG2L_COL( -IARR )
          END IF
          IROW_GRID = mod( ( IPOSROOT - 1 )/root%MBLOCK, root%NPROW )
          JCOL_GRID = mod( ( JPOSROOT - 1 )/root%NBLOCK, root%NPCOL )
          IF ( IROW_GRID .NE. root%MYROW .OR.                           &
     &       JCOL_GRID .NE. root%MYCOL ) THEN
            WRITE(*,*) MYID,':INTERNAL Error: recvd root arrowhead '
            WRITE(*,*) MYID,':not belonging to me. IARR,JARR=',IARR,JARR
            WRITE(*,*) MYID,':IROW_GRID,JCOL_GRID=',IROW_GRID,JCOL_GRID
            WRITE(*,*) MYID,':MYROW, MYCOL=', root%MYROW, root%MYCOL
            WRITE(*,*) MYID,':IPOSROOT,JPOSROOT=', IPOSROOT, JPOSROOT
            CALL AGMG_MUMPS_ABORT()
          END IF
          ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /                 &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
          JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /                 &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
          IF (KEEP(60)==0) THEN
            A( PTR_ROOT + int(JLOCROOT-1,8) * int(LOCAL_M,8)            &
     &        + int(ILOCROOT-1,8)) =  A( PTR_ROOT                       &
     &        + int(JLOCROOT - 1,8) * int(LOCAL_M,8)                    &
     &        + int(ILOCROOT - 1,8) )                                   &
     &      + VAL
          ELSE
            root%SCHUR_POINTER( int(JLOCROOT-1,8)                       &
     &                      * int(root%SCHUR_LLD,8)                     &
     &                      + int(ILOCROOT,8) )                         &
     &      = root%SCHUR_POINTER( int(JLOCROOT - 1,8)                   &
     &                      * int(root%SCHUR_LLD,8)                     &
     &                      + int(ILOCROOT,8))                          &
     &      + VAL
          ENDIF
        ELSE IF (IARR.GE.0) THEN
         IF (IARR.EQ.JARR) THEN
          IA = PTRARW(IARR)
          DBLARR(IA) = DBLARR(IA) + VAL
         ELSE
          IS1 =  PTRAIW(IARR)
          ISHIFT      = INTARR(IS1) + IW4(IARR,2)
          IW4(IARR,2) = IW4(IARR,2) - 1
          IIW         = IS1 + ISHIFT + 2
          INTARR(IIW)     = JARR
          IS          = PTRARW(IARR)
          IAS         = IS + ISHIFT
          DBLARR(IAS) = VAL
         ENDIF
        ELSE
           IARR = -IARR
           ISHIFT      = PTRAIW(IARR)+IW4(IARR,1)+2
           INTARR(ISHIFT)  = JARR
           IAS         = PTRARW(IARR)+IW4(IARR,1)
           IW4(IARR,1) = IW4(IARR,1) - 1
           DBLARR(IAS)      = VAL
           IPROC = AGMG_MUMPS_275( abs(STEP(IARR)),                          &
     &             PROCNODE_STEPS,SLAVEF )
           IF ( (KEEP(50) .NE. 0 .OR. KEEP(234).NE.0)                   &
     &          .AND.                                                   &
     &          IW4(IARR,1) .EQ. 0 .AND.                                &
     &          IPROC .EQ. MYID                                         &
     &          .AND. STEP(IARR) > 0 ) THEN
             TAILLE = INTARR( PTRAIW(IARR) )
             CALL DAGMG_MUMPS_310( N, PERM,                                  &
     &            INTARR( PTRAIW(IARR) + 3 ),                           &
     &            DBLARR( PTRARW(IARR) + 1 ),                           &
     &            TAILLE, 1, TAILLE )
           END IF
        ENDIF
      ENDDO
  100 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_102
      SUBROUTINE DAGMG_MUMPS_151( NRHS, N, KEEP28, IWCB, LIWW,               &
     &       W, LWC,                                                    &
     &       POSWCB,IWPOSCB,PTRICB,PTRACB)
      IMPLICIT NONE
      INTEGER NRHS, N,LIWW,LWC,POSWCB,IWPOSCB, KEEP28
      INTEGER IWCB(LIWW),PTRICB(KEEP28),PTRACB(KEEP28)
      DOUBLE PRECISION W(LWC)
      INTEGER SIZFI, SIZFR
      IF ( IWPOSCB .eq. LIWW ) RETURN
      DO WHILE ( IWCB( IWPOSCB + 2 ) .eq. 0 )
        SIZFR = IWCB( IWPOSCB + 1 )
        SIZFI =  2
        SIZFR = SIZFR * NRHS
        IWPOSCB = IWPOSCB + SIZFI
        POSWCB  = POSWCB  + SIZFR
        IF ( IWPOSCB .eq. LIWW ) RETURN
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_151
      SUBROUTINE DAGMG_MUMPS_95(NRHS,N,KEEP28,IWCB,LIWW,W,LWC,               &
     &       POSWCB,IWPOSCB,PTRICB,PTRACB)
      IMPLICIT NONE
      INTEGER NRHS,N,LIWW,LWC,POSWCB,IWPOSCB,KEEP28
      INTEGER IWCB(LIWW),PTRICB(KEEP28),PTRACB(KEEP28)
      DOUBLE PRECISION W(LWC)
      INTEGER IPTIW,IPTA,SIZFI,SIZFR,LONGI,LONGR
      INTEGER I
      IPTIW = IWPOSCB
      IPTA  = POSWCB
      LONGI = 0
      LONGR = 0
      IF ( IPTIW .EQ. LIWW ) RETURN
   10 CONTINUE
      IF (IWCB(IPTIW+2).EQ.0) THEN
        SIZFR  = IWCB(IPTIW+1)
        SIZFI =  2
        SIZFR  = SIZFR * NRHS
        IF (LONGI.NE.0) THEN
          DO 20 I=0,LONGI-1
            IWCB(IPTIW + SIZFI - I) = IWCB (IPTIW - I )
   20     CONTINUE
          DO 30 I=0,LONGR-1
            W(IPTA + SIZFR - I)   = W(IPTA - I )
   30     CONTINUE
        ENDIF
        DO 40 I=1,KEEP28
          IF ((PTRICB(I).LE.(IPTIW+1)).AND.                             &
     &        (PTRICB(I).GT.IWPOSCB) ) THEN
            PTRICB(I) = PTRICB(I) + SIZFI
            PTRACB(I) = PTRACB(I) + SIZFR
          ENDIF
   40   CONTINUE
        IWPOSCB = IWPOSCB + SIZFI
        IPTIW   = IPTIW + SIZFI
        POSWCB = POSWCB + SIZFR
        IPTA   = IPTA + SIZFR
       ELSE
        SIZFR  = IWCB(IPTIW+1)
        SIZFI  = 2
        SIZFR  = SIZFR * NRHS
        IPTIW = IPTIW + SIZFI
        LONGI = LONGI + SIZFI
        IPTA  = IPTA + SIZFR
        LONGR = LONGR + SIZFR
       ENDIF
       IF (IPTIW.NE.LIWW) GOTO 10
       RETURN
       END SUBROUTINE DAGMG_MUMPS_95
      SUBROUTINE DAGMG_MUMPS_205(MTYPE, IFLAG, N, NZ,                        &
     &    LHS, WRHS, W, RHS, GIVSOL, SOL, ANORM, XNORM, SCLNRM,         &
     &    MPRINT, ICNTL, KEEP,KEEP8)
      INTEGER MTYPE,N,NZ,IFLAG,ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION RHS(N),LHS(N)
      DOUBLE PRECISION WRHS(N),SOL(*)
      DOUBLE PRECISION W(N)
      DOUBLE PRECISION RESMAX,RESL2,XNORM, ERMAX,MAXSOL,                &
     &     COMAX, SCLNRM, ERL2, ERREL
      DOUBLE PRECISION ANORM,DZERO,EPSI
      LOGICAL GIVSOL,PROK
      INTEGER MPRINT, MP
      INTEGER I,J,K
      INTRINSIC abs, max, sqrt
      MP = ICNTL(2)
      PROK = (MPRINT .GT. 0)
      DZERO = 0.0D0
      EPSI = 0.1D-9
      ANORM = DZERO
      RESMAX = DZERO
      RESL2 = DZERO
      DO 40 K = 1, N
        RESMAX = max(RESMAX, abs(RHS(K)))
        RESL2 = RESL2 + abs(RHS(K)) * abs(RHS(K))
        ANORM = max(ANORM, W(K))
   40 END DO
      XNORM = DZERO
      DO 50 K = 1, N
        XNORM = max(XNORM, abs(LHS(K)))
   50 END DO
      IF (XNORM .GT. EPSI) THEN
        SCLNRM = RESMAX / (ANORM * XNORM)
      ELSE
        IFLAG = IFLAG + 2
        IF ((MP .GT. 0) .AND. (ICNTL(4) .GE. 2)) WRITE( MP, * )         &
     &' max-NORM of computed solut. is zero'
        SCLNRM = RESMAX / ANORM
      ENDIF
      RESL2 = sqrt(RESL2)
      ERMAX = DZERO
      COMAX = DZERO
      ERL2 = DZERO
      IF (.NOT.GIVSOL) THEN
        IF (PROK) WRITE( MPRINT, 90 ) RESMAX, RESL2, ANORM, XNORM,      &
     &      SCLNRM
      ELSE
        MAXSOL = DZERO
        DO 60 K = 1, N
          MAXSOL = max(MAXSOL, abs(SOL(K)))
   60   CONTINUE
        DO 70 K = 1, N
          ERL2 = abs(LHS(K) - SOL(K)) ** 2 + ERL2
          ERMAX = max(ERMAX, abs(LHS(K) - SOL(K)))
   70   CONTINUE
        DO 80 K = 1, N
          IF (abs(SOL(K)) .GT. EPSI) THEN
            COMAX = max(COMAX, (abs(LHS(K) - SOL(K)) / abs(SOL(K))))
          ENDIF
   80   CONTINUE
        ERL2 = sqrt(ERL2)
        IF (MAXSOL .GT. EPSI) THEN
          ERREL = ERMAX / MAXSOL
        ELSE
          IFLAG = IFLAG + 2
          IF ((MP .GT. 0) .AND. (ICNTL(4) .GE. 2)) WRITE( MP, * )       &
     &' MAX-NORM of exact solution is zero'
          ERREL = ERMAX
        ENDIF
        IF (PROK) WRITE( MPRINT, 100 ) ERMAX, ERL2, ERREL, COMAX, RESMAX&
     &      , RESL2, ANORM, XNORM, SCLNRM
      ENDIF
   90  FORMAT (/' RESIDUAL IS ............ (MAX-NORM)        =',1PD9.2/ &
     &       '                       .. (2-NORM)          =',1PD9.2/    &
     &       ' RINFOG(4):NORM OF input  Matrix  (MAX-NORM)=',1PD9.2/    &
     &       ' RINFOG(5):NORM OF Computed SOLUT (MAX-NORM)=',1PD9.2/    &
     &       ' RINFOG(6):SCALED RESIDUAL ...... (MAX-NORM)=',1PD9.2)
      RETURN
  100  FORMAT (/' ERROR IS     ............ (MAX-NORM)       =',1PD9.2/ &
     &       '              ............ (2-NORM)         =',1PD9.2/    &
     &       ' RELATIVE ERROR........... (MAX-NORM)       =',1PD9.2/    &
     &       ' Comp. Wise ERROR......... (MAX-NORM)       =',1PD9.2/    &
     &       ' AND RESIDUAL IS ......... (MAX-NORM)       =',1PD9.2/    &
     &       '                        .. (2-NORM)         =',1PD9.2/    &
     &       ' NORM OF input  MATRIX ... (MAX-NORM)       =',1PD9.2/    &
     &       ' NORM of computed SOLUT... (MAX-NORM)       =',1PD9.2/    &
     &       ' SCALED RESIDUAL ......... (MAX-NORM)       =',1PD9.2)
      END SUBROUTINE DAGMG_MUMPS_205
      SUBROUTINE DAGMG_MUMPS_206(NZ, N, RHS,                                 &
     &    X, Y, D, R_W, C_W, IW, KASE,                                  &
     &    OMEGA, ERX, JOB, COND, MAXIT, NOITER, LP, KEEP,KEEP8,         &
     &    ARRET )
      IMPLICIT NONE
      INTEGER NZ, N, KASE, KEEP(500), JOB
      INTEGER*8 KEEP8(150)
      INTEGER IW(N,2)
      DOUBLE PRECISION RHS(N)
      DOUBLE PRECISION X(N), Y(N)
      DOUBLE PRECISION D(N)
      DOUBLE PRECISION R_W(N,2)
      DOUBLE PRECISION C_W(N)
      INTEGER LP, MAXIT, NOITER
      DOUBLE PRECISION COND(2),OMEGA(2)
      DOUBLE PRECISION ARRET
      DOUBLE PRECISION CGCE, CTAU
      DATA  CTAU /1.0D3/, CGCE /0.2D0/
      LOGICAL LCOND1, LCOND2
      INTEGER IFLAG, JUMP, I, IMAX
      DOUBLE PRECISION ERX, DXMAX
      DOUBLE PRECISION CONVER, OM1, OM2, DXIMAX
      DOUBLE PRECISION ZERO, ONE,TAU, DD
      DOUBLE PRECISION OLDOMG(2)
      INTEGER DAGMG_MUMPS_IXAMAX
      INTRINSIC     abs, max
      SAVE LCOND1, LCOND2, JUMP,  DXIMAX, DXMAX, CONVER,                &
     &     OM1, OLDOMG, IFLAG
      DATA ZERO /0.0D0/, ONE /1.0D0/
      IF (KASE .EQ. 0) THEN
        LCOND1 = .FALSE.
        LCOND2 = .FALSE.
        COND(1) = ONE
        COND(2) = ONE
        ERX = ZERO
        OM1 = ZERO
        IFLAG = 0
        NOITER = 0
        JUMP = 1
      ENDIF
      SELECT CASE (JUMP)
      CASE (1)
        GOTO 30
      CASE(2)
        GOTO 10
      CASE(3)
        GOTO 110
      CASE(4)
        GOTO 150
      CASE(5)
        GOTO 35
      CASE DEFAULT
      END SELECT
   10 CONTINUE
      DO 20 I = 1, N
        X(I) = X(I) + Y(I)
   20 END DO
      IF (NOITER .GT. MAXIT) THEN
        IFLAG = IFLAG + 8
        GOTO 70
      ENDIF
   30 CONTINUE
      KASE = 14
      JUMP = 5
      RETURN
   35 CONTINUE
      IMAX = DAGMG_MUMPS_IXAMAX(N, X, 1)
      DXMAX = abs(X(IMAX))
      OMEGA(1) = ZERO
      OMEGA(2) = ZERO
      DO 40 I = 1, N
        TAU = (R_W(I, 2) * DXMAX + abs(RHS(I))) * dble(N) * CTAU
        DD = R_W(I, 1) + abs(RHS(I))
        IF ((DD + TAU) .GT. TAU) THEN
          OMEGA(1) = max(OMEGA(1), abs(Y(I)) / DD)
          IW(I, 1) = 1
        ELSE
          IF (TAU .GT. ZERO) THEN
            OMEGA(2) = max(OMEGA(2),                                    &
     &                     abs(Y(I)) / (DD + R_W(I, 2) * DXMAX))
          ENDIF
          IW(I, 1) = 2
        ENDIF
   40 END DO
      OM2 = OMEGA(1) + OMEGA(2)
      IF (OM2 .LT. ARRET ) GOTO 70
      IF (MAXIT .EQ. 0) GOTO 70
      IF (NOITER .GT. 1 .AND. OM2 .GT. OM1 * CGCE) THEN
        CONVER = OM2 / OM1
        IF (OM2 .GT. OM1) THEN
          OMEGA(1) = OLDOMG(1)
          OMEGA(2) = OLDOMG(2)
          DO 50 I = 1, N
            X(I) = C_W(I)
   50     CONTINUE
        ENDIF
        GOTO 70
      ENDIF
      DO 60 I = 1, N
        C_W(I) = X(I)
   60 END DO
      OLDOMG(1) = OMEGA(1)
      OLDOMG(2) = OMEGA(2)
      OM1 = OM2
      NOITER = NOITER + 1
      KASE = 2
      JUMP = 2
      RETURN
   70 KASE = 0
      IF (JOB .LE. 0) GOTO 170
      DO 80 I = 1, N
        IF (IW(I, 1) .EQ. 1) THEN
          R_W(I, 1) = R_W(I, 1) + abs(RHS(I))
          R_W(I, 2) = ZERO
          LCOND1 = .TRUE.
        ELSE
          R_W(I, 2) = R_W(I, 2) * DXMAX + R_W(I, 1)
          R_W(I, 1) = ZERO
          LCOND2 = .TRUE.
        ENDIF
   80 END DO
      DO 90 I = 1, N
        C_W(I) = X(I) * D(I)
   90 END DO
      IMAX = DAGMG_MUMPS_IXAMAX(N, C_W(1), 1)
      DXIMAX = abs(C_W(IMAX))
      IF (.NOT.LCOND1) GOTO 130
  100 CALL DAGMG_MUMPS_218(N, KASE, Y, COND(1), C_W, IW(1, 2))
      IF (KASE .EQ. 0) GOTO 120
      IF (KASE .EQ. 1) CALL DAGMG_MUMPS_204(N, Y, D)
      IF (KASE .EQ. 2) CALL DAGMG_MUMPS_204(N, Y, R_W)
      JUMP = 3
      RETURN
  110 CONTINUE
      IF (KASE .EQ. 1) CALL DAGMG_MUMPS_204(N, Y, R_W)
      IF (KASE .EQ. 2) CALL DAGMG_MUMPS_204(N, Y, D)
      GOTO 100
  120 IF (DXIMAX .GT. ZERO) COND(1) = COND(1) / DXIMAX
      ERX = OMEGA(1) * COND(1)
  130 IF (.NOT.LCOND2) GOTO 170
      KASE = 0
  140 CALL DAGMG_MUMPS_218(N, KASE, Y, COND(2), C_W, IW(1, 2))
      IF (KASE .EQ. 0) GOTO 160
      IF (KASE .EQ. 1) CALL DAGMG_MUMPS_204(N, Y, D)
      IF (KASE .EQ. 2) CALL DAGMG_MUMPS_204(N, Y, R_W(1, 2))
      JUMP = 4
      RETURN
  150 CONTINUE
      IF (KASE .EQ. 1) CALL DAGMG_MUMPS_204(N, Y, R_W(1, 2))
      IF (KASE .EQ. 2) CALL DAGMG_MUMPS_204(N, Y, D)
      GOTO 140
  160 IF (DXIMAX .GT. ZERO) THEN
        COND(2) = COND(2) / DXIMAX
      ENDIF
      ERX = ERX + OMEGA(2) * COND(2)
  170 KASE = -IFLAG
      RETURN
      END SUBROUTINE DAGMG_MUMPS_206
      SUBROUTINE DAGMG_MUMPS_207(A, NZ, N, IRN, ICN, Z, KEEP,KEEP8)
      INTEGER NZ, N, I, J, K, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER IRN(NZ), ICN(NZ)
      DOUBLE PRECISION A(NZ)
      DOUBLE PRECISION Z(N)
      DOUBLE PRECISION ZERO
      INTRINSIC     abs
      DATA ZERO /0.0D0/
      DO 10 I = 1, N
        Z(I) = ZERO
   10 END DO
      IF (KEEP(50) .EQ.0) THEN
       DO K = 1, NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I .LT. 1) .OR. (I .GT. N)) CYCLE
        IF ((J .LT. 1) .OR. (J .GT. N)) CYCLE
        Z(I) = Z(I) + abs(A(K))
       ENDDO
      ELSE
       DO K = 1, NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I .LT. 1) .OR. (I .GT. N)) CYCLE
        IF ((J .LT. 1) .OR. (J .GT. N)) CYCLE
        Z(I) = Z(I) + abs(A(K))
        IF (J.NE.I) THEN
          Z(J) = Z(J) + abs(A(K))
        ENDIF
       ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_207
      SUBROUTINE DAGMG_MUMPS_289(A, NZ, N, IRN, ICN, Z,                      &
     &            KEEP, KEEP8, COLSCA)
      INTEGER,   intent(in)  :: NZ, N, KEEP(500)
      INTEGER*8, intent(in)  :: KEEP8(150)
      INTEGER,   intent(in)  :: IRN(NZ), ICN(NZ)
      DOUBLE PRECISION,   intent(in)  :: A(NZ)
      DOUBLE PRECISION,      intent(in)  :: COLSCA(N)
      DOUBLE PRECISION,      intent(out) :: Z(N)
      DOUBLE PRECISION  ZERO
      DATA ZERO /0.0D0/
      INTEGER I, J, K
      DO 10 I = 1, N
        Z(I) = ZERO
   10 END DO
      IF (KEEP(50) .EQ.0) THEN
       DO K = 1, NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I .LT. 1) .OR. (I .GT. N)) CYCLE
        IF ((J .LT. 1) .OR. (J .GT. N)) CYCLE
        Z(I) = Z(I) + abs(A(K)*COLSCA(J))
       ENDDO
      ELSE
       DO K = 1, NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I .LT. 1) .OR. (I .GT. N)) CYCLE
        IF ((J .LT. 1) .OR. (J .GT. N)) CYCLE
        Z(I) = Z(I) + abs(A(K)*COLSCA(J))
        IF (J.NE.I) THEN
          Z(J) = Z(J) + abs(A(K)*COLSCA(I))
        ENDIF
       ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_289
      SUBROUTINE DAGMG_MUMPS_208(A, NZ, N, IRN, ICN, RHS, X, R, W,           &
     &           KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER,   intent(in)   :: NZ, N, KEEP(500)
      INTEGER*8, intent(in)   ::  KEEP8(150)
      INTEGER,   intent(in)   :: IRN(NZ), ICN(NZ)
      DOUBLE PRECISION,   intent(in)   :: A(NZ), RHS(N), X(N)
      DOUBLE PRECISION,      intent(out)  :: W(N)
      DOUBLE PRECISION,   intent(out)  :: R(N)
      INTEGER I, K, J
      DOUBLE PRECISION ZERO
      DATA ZERO /0.0D0/
      DOUBLE PRECISION D
      DO I = 1, N
        R(I) = RHS(I)
        W(I) = ZERO
      ENDDO
      DO K = 1, NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I .GT. N) .OR. (J .GT. N) .OR. (I .LT. 1) .OR. (J .LT. 1)) &
     &      CYCLE
        D = A(K) * X(J)
        R(I) = R(I) - D
        W(I) = W(I) + abs(D)
        IF ((I.NE.J) .AND. (KEEP(50).NE.0) ) THEN
          D = A(K) * X(I)
          R(J) = R(J) - D
          W(J) = W(J) + abs(D)
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_208
      SUBROUTINE DAGMG_MUMPS_204(N, R, W)
      INTEGER, intent(in)  :: N
      DOUBLE PRECISION,    intent(in)  :: W(N)
      DOUBLE PRECISION, intent(inout) :: R(N)
      INTEGER I
      DO 10 I = 1, N
        R(I) = R(I) * W(I)
   10 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_204
      SUBROUTINE DAGMG_MUMPS_218(N, KASE, X, EST, W, IW)
      INTEGER, intent(in)    :: N
      INTEGER, intent(inout) :: KASE
      INTEGER IW(N)
      DOUBLE PRECISION W(N), X(N)
      DOUBLE PRECISION EST
      INTRINSIC abs, nint, REAL, SIGN
      INTEGER DAGMG_MUMPS_IXAMAX
      EXTERNAL DAGMG_MUMPS_IXAMAX
      INTEGER ITMAX
      PARAMETER (ITMAX = 5)
      INTEGER I, ITER, J, JLAST, JUMP
      DOUBLE PRECISION ALTSGN
      DOUBLE PRECISION ZERO, ONE, TEMP
      SAVE ITER, J, JLAST, JUMP
      DATA ZERO /0.0D0/
      DATA ONE  /1.0D0/
      IF (KASE .EQ. 0) THEN
        DO 10 I = 1, N
          X(I) = dble(ONE / dble(N))
   10   CONTINUE
        KASE = 1
        JUMP = 1
        RETURN
      ENDIF
      SELECT CASE (JUMP)
      CASE (1)
        GOTO 20
      CASE(2)
        GOTO 40
      CASE(3)
        GOTO 70
      CASE(4)
        GOTO 120
      CASE(5)
        GOTO 160
      CASE DEFAULT
      END SELECT
   20 CONTINUE
      IF (N .EQ. 1) THEN
        W(1) = X(1)
        EST = abs(W(1))
        GOTO 190
      ENDIF
      DO 30 I = 1, N
        X(I)  = dble(sign(ONE,dble( X(I))))
        IW(I) = nint(dble(X(I)))
   30 END DO
      KASE = 2
      JUMP = 2
      RETURN
   40 CONTINUE
      J = DAGMG_MUMPS_IXAMAX(N, X, 1)
      ITER = 2
   50 CONTINUE
      DO 60 I = 1, N
        X(I) = dble(ZERO)
   60 END DO
      X(J) = dble(ONE)
      KASE = 1
      JUMP = 3
      RETURN
   70 CONTINUE
      DO 80 I = 1, N
        W(I) = X(I)
   80 END DO
      DO 90 I = 1, N
        IF (nint(sign(ONE, dble(X(I)))) .NE. IW(I)) GOTO 100
   90 END DO
      GOTO 130
  100 CONTINUE
      DO 110 I = 1, N
        X(I) = dble(sign(ONE, dble(X(I))))
        IW(I) = nint(dble(X(I)))
  110 END DO
      KASE = 2
      JUMP = 4
      RETURN
  120 CONTINUE
      JLAST = J
      J = DAGMG_MUMPS_IXAMAX(N, X, 1)
      IF ((abs(X(JLAST)) .NE. abs(X(J))) .AND. (ITER .LT. ITMAX)) THEN
        ITER = ITER + 1
        GOTO 50
      ENDIF
  130 CONTINUE
      EST = ZERO
      DO 140 I = 1, N
        EST = EST + abs(W(I))
  140 END DO
      ALTSGN = ONE
      DO 150 I = 1, N
        X(I) = dble(ALTSGN * (ONE + dble(I - 1) / dble(N - 1)))
        ALTSGN = -ALTSGN
  150 END DO
      KASE = 1
      JUMP = 5
      RETURN
  160 CONTINUE
      TEMP = ZERO
      DO 170 I = 1, N
        TEMP = TEMP + abs(X(I))
  170 END DO
      TEMP = 2.0D0 * TEMP / dble(3 * N)
      IF (TEMP .GT. EST) THEN
        DO 180 I = 1, N
          W(I) = X(I)
  180   CONTINUE
        EST = TEMP
      ENDIF
  190 KASE = 0
      RETURN
      END SUBROUTINE DAGMG_MUMPS_218
      SUBROUTINE DAGMG_MUMPS_278( MTYPE, N, NZ, ASPK, IRN, ICN,              &
     &    LHS, WRHS, W, RHS, KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER MTYPE, N, NZ
      INTEGER IRN( NZ ), ICN( NZ )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION, intent(in) :: ASPK( NZ )
      DOUBLE PRECISION, intent(in) :: LHS( N ), WRHS( N )
      DOUBLE PRECISION, intent(out):: RHS( N )
      DOUBLE PRECISION,    intent(out):: W( N )
      INTEGER K, I, J
      DOUBLE PRECISION DZERO
      PARAMETER(DZERO = 0.0D0)
      DO 10 K = 1, N
        W(K) = DZERO
        RHS(K) = WRHS(K)
   10 END DO
      IF ( KEEP(50) .EQ. 0 ) THEN
       IF (MTYPE .EQ. 1) THEN
        DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          RHS(I) = RHS(I) - ASPK(K) * LHS(J)
          W(I) = W(I) + abs(ASPK(K))
        ENDDO
       ELSE
        DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          RHS(J) = RHS(J) - ASPK(K) * LHS(I)
          W(J) = W(J) + abs(ASPK(K))
        ENDDO
       ENDIF
      ELSE
       DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          RHS(I) = RHS(I) - ASPK(K) * LHS(J)
          W(I) = W(I) + abs(ASPK(K))
          IF (J.NE.I) THEN
            RHS(J) = RHS(J) - ASPK(K) * LHS(I)
            W(J) = W(J) + abs(ASPK(K))
          ENDIF
        ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_278
      SUBROUTINE DAGMG_MUMPS_121( MTYPE, N,                                  &
     &    NELT, ELTPTR, LELTVAR, ELTVAR, NA_ELT, A_ELT,                 &
     &    LHS, WRHS, W, RHS, KEEP,KEEP8)
      IMPLICIT NONE
      INTEGER MTYPE, N, NELT, LELTVAR, NA_ELT
      INTEGER ELTPTR(NELT+1), ELTVAR(LELTVAR)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION A_ELT(NA_ELT)
      DOUBLE PRECISION LHS( N ), WRHS( N ), RHS( N )
      DOUBLE PRECISION W(N)
      CALL DAGMG_MUMPS_257(N, NELT, ELTPTR, ELTVAR, A_ELT,                   &
     &                         LHS, RHS, KEEP(50), MTYPE )
      RHS = WRHS - RHS
      CALL DAGMG_MUMPS_119( MTYPE, N,                                        &
     &    NELT, ELTPTR, LELTVAR, ELTVAR, NA_ELT, A_ELT,                 &
     &    W, KEEP,KEEP8 )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_121
      SUBROUTINE DAGMG_MUMPS_119( MTYPE, N,                                  &
     &    NELT, ELTPTR, LELTVAR, ELTVAR, NA_ELT, A_ELT,                 &
     &    W, KEEP,KEEP8 )
      IMPLICIT NONE
      INTEGER MTYPE, N, NELT, LELTVAR, NA_ELT
      INTEGER ELTPTR(NELT+1), ELTVAR(LELTVAR)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION A_ELT(NA_ELT)
      DOUBLE PRECISION TEMP
      DOUBLE PRECISION W(N)
      INTEGER K, I, J, IEL, SIZEI, IELPTR
      DOUBLE PRECISION DZERO
      PARAMETER(DZERO = 0.0D0)
      W = DZERO
      K = 1
      DO IEL = 1, NELT
        SIZEI  = ELTPTR( IEL + 1 ) - ELTPTR( IEL )
        IELPTR = ELTPTR( IEL ) - 1
        IF ( KEEP(50).EQ.0 ) THEN
         IF (MTYPE.EQ.1) THEN
           DO J = 1, SIZEI
              DO I = 1, SIZEI
               W( ELTVAR( IELPTR + I) ) =                               &
     &           W( ELTVAR( IELPTR + I) )                               &
     &           + abs(A_ELT( K ))
               K = K + 1
              END DO
            END DO
         ELSE
           DO J = 1, SIZEI
              TEMP = W( ELTVAR( IELPTR + J ) )
              DO I = 1, SIZEI
               TEMP = TEMP + abs( A_ELT(K))
               K = K + 1
              END DO
              W(ELTVAR( IELPTR + J )) =                                 &
     &          W(ELTVAR( IELPTR + J )) + TEMP
            END DO
         ENDIF
        ELSE
         DO J = 1, SIZEI
          W(ELTVAR( IELPTR + J )) =                                     &
     &        W(ELTVAR( IELPTR + J )) + abs(A_ELT( K ))
          K = K + 1
          DO I = J+1, SIZEI
              W(ELTVAR( IELPTR + J )) =                                 &
     &           W(ELTVAR( IELPTR + J )) + abs(A_ELT( K ))
              W(ELTVAR( IELPTR + I ) ) =                                &
     &           W(ELTVAR( IELPTR + I )) + abs(A_ELT( K ))
              K = K + 1
          END DO
         ENDDO
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_119
      SUBROUTINE DAGMG_MUMPS_135(MTYPE, N,                                   &
     &    NELT, ELTPTR, LELTVAR, ELTVAR, NA_ELT, A_ELT,                 &
     &    W, KEEP,KEEP8, COLSCA )
      IMPLICIT NONE
      INTEGER MTYPE, N, NELT, LELTVAR, NA_ELT
      INTEGER ELTPTR(NELT+1), ELTVAR(LELTVAR)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION COLSCA(N)
      DOUBLE PRECISION A_ELT(NA_ELT)
      DOUBLE PRECISION W(N)
      DOUBLE PRECISION TEMP, TEMP2
      INTEGER K, I, J, IEL, SIZEI, IELPTR
      DOUBLE PRECISION DZERO
      PARAMETER(DZERO = 0.0D0)
      W = DZERO
      K = 1
      DO IEL = 1, NELT
        SIZEI  = ELTPTR( IEL + 1 ) - ELTPTR( IEL )
        IELPTR = ELTPTR( IEL ) - 1
        IF ( KEEP(50).EQ.0 ) THEN
         IF (MTYPE.EQ.1) THEN
           DO J = 1, SIZEI
              TEMP2 = abs(COLSCA(ELTVAR( IELPTR + J) ))
              DO I = 1, SIZEI
               W( ELTVAR( IELPTR + I) ) =                               &
     &           W( ELTVAR( IELPTR + I) )                               &
     &           + abs(A_ELT( K )) * TEMP2
               K = K + 1
              END DO
            END DO
         ELSE
           DO J = 1, SIZEI
              TEMP = W( ELTVAR( IELPTR + J ) )
              TEMP2= abs(COLSCA(ELTVAR( IELPTR + J) ))
              DO I = 1, SIZEI
               TEMP = TEMP + abs(A_ELT( K )) * TEMP2
               K = K + 1
              END DO
              W(ELTVAR( IELPTR + J )) =                                 &
     &          W(ELTVAR( IELPTR + J )) + TEMP
            END DO
         ENDIF
        ELSE
         DO J = 1, SIZEI
          W(ELTVAR( IELPTR + J )) =                                     &
     &        W(ELTVAR( IELPTR + J )) +                                 &
     &        abs( A_ELT( K )*COLSCA(ELTVAR( IELPTR + J)) )
          K = K + 1
          DO I = J+1, SIZEI
              W(ELTVAR( IELPTR + J )) =                                 &
     &           W(ELTVAR( IELPTR + J )) +                              &
     &           abs(A_ELT( K )*COLSCA(ELTVAR( IELPTR + J)))
              W(ELTVAR( IELPTR + I ) ) =                                &
     &           W(ELTVAR( IELPTR + I )) +                              &
     &           abs(A_ELT( K )*COLSCA(ELTVAR( IELPTR + I)))
              K = K + 1
          END DO
         ENDDO
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_135
      SUBROUTINE DAGMG_MUMPS_122( MTYPE, N, NELT, ELTPTR,                    &
     &                     LELTVAR, ELTVAR, NA_ELT, A_ELT,              &
     &                     SAVERHS, X, Y, W, K50 )
      IMPLICIT NONE
      INTEGER N, NELT, K50, MTYPE, LELTVAR, NA_ELT
      INTEGER ELTPTR( NELT + 1 ), ELTVAR( LELTVAR )
      DOUBLE PRECISION A_ELT( NA_ELT ), X( N ), Y( N ),                 &
     &                 SAVERHS(N)
      DOUBLE PRECISION W(N)
      INTEGER IEL, I , J, K, SIZEI, IELPTR
      DOUBLE PRECISION ZERO
      DOUBLE PRECISION TEMP
      DOUBLE PRECISION TEMP2
      PARAMETER( ZERO = 0.0D0 )
      Y = SAVERHS
      W = ZERO
      K = 1
      DO IEL = 1, NELT
        SIZEI  = ELTPTR( IEL + 1 ) - ELTPTR( IEL )
        IELPTR = ELTPTR( IEL ) - 1
        IF ( K50 .eq. 0 ) THEN
          IF ( MTYPE .eq. 1 ) THEN
            DO J = 1, SIZEI
              TEMP = X( ELTVAR( IELPTR + J ) )
              DO I = 1, SIZEI
                Y( ELTVAR( IELPTR + I ) ) =                             &
     &          Y( ELTVAR( IELPTR + I ) ) -                             &
     &             A_ELT( K ) * TEMP
                W( ELTVAR( IELPTR + I ) ) =                             &
     &          W( ELTVAR( IELPTR + I ) ) +                             &
     &             abs( A_ELT( K ) * TEMP )
                K = K + 1
              END DO
            END DO
          ELSE
            DO J = 1, SIZEI
              TEMP = Y( ELTVAR( IELPTR + J ) )
              TEMP2 = W( ELTVAR( IELPTR + J ) )
              DO I = 1, SIZEI
                TEMP = TEMP -                                           &
     &          A_ELT( K ) * X( ELTVAR( IELPTR + I ) )
                TEMP2 = TEMP2 +  abs(                                   &
     &          A_ELT( K ) * X( ELTVAR( IELPTR + I ) ) )
                K = K + 1
              END DO
              Y( ELTVAR( IELPTR + J ) ) = TEMP
              W( ELTVAR( IELPTR + J ) ) = TEMP2
            END DO
          END IF
        ELSE
          DO J = 1, SIZEI
            Y( ELTVAR( IELPTR + J ) ) =                                 &
     &      Y( ELTVAR( IELPTR + J ) ) -                                 &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) )
            W( ELTVAR( IELPTR + J ) ) =                                 &
     &      W( ELTVAR( IELPTR + J ) ) + abs(                            &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) ) )
            K = K + 1
            DO I = J+1, SIZEI
              Y( ELTVAR( IELPTR + I ) ) =                               &
     &        Y( ELTVAR( IELPTR + I ) ) -                               &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) )
              Y( ELTVAR( IELPTR + J ) ) =                               &
     &        Y( ELTVAR( IELPTR + J ) ) -                               &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + I ) )
              W( ELTVAR( IELPTR + I ) ) =                               &
     &        W( ELTVAR( IELPTR + I ) ) + abs(                          &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) ) )
              W( ELTVAR( IELPTR + J ) ) =                               &
     &        W( ELTVAR( IELPTR + J ) ) + abs(                          &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + I ) ) )
              K = K + 1
            END DO
          END DO
        END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_122
      SUBROUTINE DAGMG_MUMPS_643(                                            &
     &     INODE,PTRFAC,KEEP,A,LA,STEP,                                 &
     &     KEEP8,N,MUST_BE_PERMUTED,IERR)
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER INODE,KEEP(500),N
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: LA
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER STEP(N)
      INTEGER IERR
      DOUBLE PRECISION A(LA)
      INTEGER RETURN_VALUE
      LOGICAL MUST_BE_PERMUTED
      RETURN_VALUE=DAGMG_MUMPS_726(INODE,PTRFAC,                             &
     &     KEEP(28),A,LA,IERR)
      IF(RETURN_VALUE.EQ.OOC_NODE_NOT_IN_MEM)THEN
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
         CALL DAGMG_MUMPS_578(INODE,PTRFAC,                                  &
     &        KEEP,KEEP8,A,IERR)
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
         CALL DAGMG_MUMPS_577(                                               &
     &        A(PTRFAC(STEP(INODE))),                                   &
     &        INODE,IERR                                                &
     &        )
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ELSE
         IF(IERR.LT.0)THEN
            RETURN
         ENDIF
      ENDIF
      IF(RETURN_VALUE.NE.OOC_NODE_PERMUTED)THEN
         MUST_BE_PERMUTED=.TRUE.
         CALL DAGMG_MUMPS_682(INODE)
      ELSE
         MUST_BE_PERMUTED=.FALSE.
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_643
      SUBROUTINE DAGMG_MUMPS_257( N, NELT, ELTPTR, ELTVAR, A_ELT,            &
     &                         X, Y, K50, MTYPE )
      IMPLICIT NONE
      INTEGER N, NELT, K50, MTYPE
      INTEGER ELTPTR( NELT + 1 ), ELTVAR( * )
      DOUBLE PRECISION A_ELT( * ), X( N ), Y( N )
      INTEGER IEL, I , J, K, SIZEI, IELPTR
      DOUBLE PRECISION TEMP
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      Y = dble(ZERO)
      K = 1
      DO IEL = 1, NELT
        SIZEI  = ELTPTR( IEL + 1 ) - ELTPTR( IEL )
        IELPTR = ELTPTR( IEL ) - 1
        IF ( K50 .eq. 0 ) THEN
          IF ( MTYPE .eq. 1 ) THEN
            DO J = 1, SIZEI
              TEMP = X( ELTVAR( IELPTR + J ) )
              DO I = 1, SIZEI
                Y( ELTVAR( IELPTR + I ) ) =                             &
     &          Y( ELTVAR( IELPTR + I ) ) +                             &
     &             A_ELT( K ) * TEMP
                K = K + 1
              END DO
            END DO
          ELSE
            DO J = 1, SIZEI
              TEMP = Y( ELTVAR( IELPTR + J ) )
              DO I = 1, SIZEI
                TEMP = TEMP +                                           &
     &          A_ELT( K ) * X( ELTVAR( IELPTR + I ) )
                K = K + 1
              END DO
              Y( ELTVAR( IELPTR + J ) ) = TEMP
            END DO
          END IF
        ELSE
          DO J = 1, SIZEI
            Y( ELTVAR( IELPTR + J ) ) =                                 &
     &      Y( ELTVAR( IELPTR + J ) ) +                                 &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) )
            K = K + 1
            DO I = J+1, SIZEI
              Y( ELTVAR( IELPTR + I ) ) =                               &
     &        Y( ELTVAR( IELPTR + I ) ) +                               &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + J ) )
              Y( ELTVAR( IELPTR + J ) ) =                               &
     &        Y( ELTVAR( IELPTR + J ) ) +                               &
     &           A_ELT( K ) * X( ELTVAR( IELPTR + I ) )
              K = K + 1
            END DO
          END DO
        END IF
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_257
      SUBROUTINE DAGMG_MUMPS_192                                             &
     &( N, NZ_loc, IRN_loc, JCN_loc, A_loc, X, Y_loc,                   &
     &  LDLT, MTYPE)
      IMPLICIT NONE
      INTEGER N, NZ_loc
      INTEGER IRN_loc( NZ_loc ), JCN_loc( NZ_loc )
      DOUBLE PRECISION A_loc( NZ_loc ), X( N ), Y_loc( N )
      INTEGER LDLT, MTYPE
      INTEGER I, J, K
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      Y_loc = dble(ZERO)
      IF ( LDLT .eq. 0 ) THEN
        IF ( MTYPE .eq. 1 ) THEN
          DO K = 1, NZ_loc
            I = IRN_loc(K)
            J = JCN_loc(K)
            IF ((I .LE. 0) .OR. (I .GT. N) .OR.                         &
     &          (J .LE. 0) .OR. (J .GT. N)                              &
     &        ) CYCLE
          Y_loc(I) = Y_loc(I) + A_loc(K) * X(J)
        ENDDO
        ELSE
          DO K = 1, NZ_loc
            I = IRN_loc(K)
            J = JCN_loc(K)
            IF ((I .LE. 0) .OR. (I .GT. N)                              &
     &        .OR. (J .LE. 0) .OR. (J .GT. N)                           &
     &        ) CYCLE
          Y_loc(J) = Y_loc(J) + A_loc(K) * X(I)
        ENDDO
        END IF
      ELSE
        DO K = 1, NZ_loc
          I = IRN_loc(K)
          J = JCN_loc(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR.                           &
     &        (J .LE. 0) .OR. (J .GT. N)                                &
     &        ) CYCLE
          Y_loc(I) = Y_loc(I) + A_loc(K) * X(J)
          IF (J.NE.I) THEN
            Y_loc(J) = Y_loc(J) + A_loc(K) * X(I)
          ENDIF
        ENDDO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_192
      SUBROUTINE DAGMG_MUMPS_256( N, NZ, IRN, ICN, ASPK, X, Y,               &
     &                         LDLT, MTYPE, MAXTRANS, PERM )
      INTEGER N, NZ, LDLT, MTYPE, MAXTRANS
      INTEGER IRN( NZ ), ICN( NZ )
      INTEGER PERM( N )
      DOUBLE PRECISION ASPK( NZ ), X( N ), Y( N )
      INTEGER K, I, J
      DOUBLE PRECISION PX( N )
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      Y = dble(ZERO)
      IF ( MAXTRANS .eq. 1 .and. MTYPE .eq. 1) THEN
        DO I = 1, N
          PX(I) = X( PERM( I ) )
        END DO
      ELSE
        PX = X
      END IF
      IF ( LDLT .eq. 0 ) THEN
       IF (MTYPE .EQ. 1) THEN
        DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          Y(I) = Y(I) + ASPK(K) * PX(J)
        ENDDO
       ELSE
        DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          Y(J) = Y(J) + ASPK(K) * PX(I)
        ENDDO
       ENDIF
      ELSE
        DO K = 1, NZ
          I = IRN(K)
          J = ICN(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR. (J .LE. 0) .OR. (J .GT. N)&
     &        ) CYCLE
          Y(I) = Y(I) + ASPK(K) * PX(J)
          IF (J.NE.I) THEN
            Y(J) = Y(J) + ASPK(K) * PX(I)
          ENDIF
        ENDDO
      END IF
      IF ( MAXTRANS .EQ. 1 .AND. MTYPE .eq. 0 ) THEN
      PX = Y
      DO I = 1, N
        Y( PERM( I ) ) = PX( I )
      END DO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_256
      SUBROUTINE DAGMG_MUMPS_193                                             &
     &( N, NZ_loc, IRN_loc, JCN_loc, A_loc, X, Y_loc,                   &
     &  LDLT, MTYPE)
      IMPLICIT NONE
      INTEGER N, NZ_loc
      INTEGER IRN_loc( NZ_loc ), JCN_loc( NZ_loc )
      DOUBLE PRECISION A_loc( NZ_loc ), X( N )
      DOUBLE PRECISION Y_loc( N )
      INTEGER LDLT, MTYPE
      INTEGER I, J, K
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      Y_loc = ZERO
      IF ( LDLT .eq. 0 ) THEN
        IF ( MTYPE .eq. 1 ) THEN
          DO K = 1, NZ_loc
            I = IRN_loc(K)
            J = JCN_loc(K)
            IF ((I .LE. 0) .OR. (I .GT. N) .OR.                         &
     &          (J .LE. 0) .OR. (J .GT. N)                              &
     &        ) CYCLE
          Y_loc(I) = Y_loc(I) + abs( A_loc(K) * X(J) )
        ENDDO
        ELSE
          DO K = 1, NZ_loc
            I = IRN_loc(K)
            J = JCN_loc(K)
            IF ((I .LE. 0) .OR. (I .GT. N)                              &
     &        .OR. (J .LE. 0) .OR. (J .GT. N)                           &
     &        ) CYCLE
          Y_loc(J) = Y_loc(J) + abs( A_loc(K) * X(I) )
        ENDDO
        END IF
      ELSE
        DO K = 1, NZ_loc
          I = IRN_loc(K)
          J = JCN_loc(K)
          IF ((I .LE. 0) .OR. (I .GT. N) .OR.                           &
     &        (J .LE. 0) .OR. (J .GT. N)                                &
     &        ) CYCLE
          Y_loc(I) = Y_loc(I) + abs( A_loc(K) * X(J) )
          IF (J.NE.I) THEN
            Y_loc(J) = Y_loc(J) + abs( A_loc(K) * X(I) )
          ENDIF
        ENDDO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_193
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_324(A, LDA, NPIV, NBROW, K50 )
      IMPLICIT NONE
      INTEGER LDA, NPIV, NBROW, K50
      DOUBLE PRECISION A(int(LDA,8)*int(NBROW+NPIV,8))
      INTEGER(8) :: IOLD, INEW, J8
      INTEGER I , ILAST
      INTEGER NBROW_L_RECTANGLE_TO_MOVE
      IF ((NPIV.EQ.0).OR.(LDA.EQ.NPIV)) GOTO 500
      IF ( K50.NE.0 ) THEN
        IOLD = int(LDA  + 1,8)
        INEW = int(NPIV + 1,8)
        IF (IOLD .EQ. INEW ) THEN
          INEW = INEW + int(NPIV,8) * int(NPIV - 1,8)
          IOLD = IOLD + int(LDA,8) * int(NPIV - 1,8)
        ELSE
          DO I = 1, NPIV - 1
            IF ( I .LE. NPIV-2 ) THEN
              ILAST = I+1
            ELSE
              ILAST = I
            ENDIF
            DO J8 = 0_8, int(ILAST,8)
              A( INEW + J8 ) = A( IOLD + J8 )
            END DO
            INEW = INEW + int(NPIV,8)
            IOLD = IOLD + int(LDA,8)
          END DO
        ENDIF
        NBROW_L_RECTANGLE_TO_MOVE = NBROW
      ELSE
        INEW = 1_8 + int(NPIV,8) * int(LDA + 1,8)
        IOLD = 1_8 + int(LDA,8) * int(NPIV +1,8)
        NBROW_L_RECTANGLE_TO_MOVE = NBROW - 1
      ENDIF
      DO I = 1, NBROW_L_RECTANGLE_TO_MOVE
         DO J8 = 0_8, int(NPIV - 1,8)
           A( INEW + J8 ) = A( IOLD + J8 )
         END DO
         INEW = INEW + int(NPIV,8)
         IOLD = IOLD + int(LDA,8)
      ENDDO
  500 RETURN
      END SUBROUTINE DAGMG_MUMPS_324
      SUBROUTINE DAGMG_MUMPS_651(A, LDA, NPIV, NCONTIG )
      IMPLICIT NONE
      INTEGER NCONTIG, NPIV, LDA
      DOUBLE PRECISION A(NCONTIG*LDA)
      INTEGER I, J
      INTEGER(8) :: INEW, IOLD
      INEW = int(NPIV+1,8)
      IOLD = int(LDA+1,8)
      DO I = 2, NCONTIG
        DO J = 1, NPIV
          A(INEW)=A(IOLD)
          INEW = INEW + 1_8
          IOLD = IOLD + 1_8
        ENDDO
        IOLD = IOLD + int(LDA - NPIV,8)
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_651
      SUBROUTINE DAGMG_MUMPS_652( A, LA, LDA, POSELT,                        &
     &           IPTRLU, NPIV,                                          &
     &           NBCOL_STACK, NBROW_STACK,                              &
     &           NBROW_SEND, SIZECB, KEEP, COMPRESSCB,                  &
     &           LAST_ALLOWED, NBROW_ALREADY_STACKED )
      IMPLICIT NONE
      INTEGER(8), intent (in) :: POSELT, IPTRLU, LA, SIZECB
      LOGICAL, intent (in) :: COMPRESSCB
      DOUBLE PRECISION A(LA)
      INTEGER, intent(in):: LDA, NPIV, NBCOL_STACK, NBROW_STACK,        &
     &                      NBROW_SEND
      INTEGER, intent(inout) :: NBROW_ALREADY_STACKED
      INTEGER(8), intent(in)    :: LAST_ALLOWED
      INTEGER(8) :: APOS, NPOS
      INTEGER NBROW
      INTEGER(8) :: J
      INTEGER I, KEEP(500)
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      NBROW = NBROW_STACK + NBROW_SEND
      IF (NBROW_STACK .NE. 0 ) THEN
        NPOS = IPTRLU + SIZECB
        APOS = POSELT + int(NPIV+NBROW,8) * int(LDA,8) - 1_8
        IF ( KEEP(50) .EQ. 0 .OR. .NOT. COMPRESSCB ) THEN
          APOS = APOS - int(LDA,8) * int(NBROW_ALREADY_STACKED,8)
          NPOS = NPOS                                                   &
     &         - int(NBCOL_STACK,8) * int(NBROW_ALREADY_STACKED,8)
        ELSE
          APOS = APOS - int(LDA - 1,8) * int(NBROW_ALREADY_STACKED,8)
          NPOS = NPOS - ( int(NBROW_ALREADY_STACKED,8) *                &
     &                    int(NBROW_ALREADY_STACKED+1,8) ) / 2_8
        ENDIF
        DO I = NBROW - NBROW_ALREADY_STACKED, NBROW_SEND+1, -1
          IF (KEEP(50).EQ.0) THEN
            IF ( NPOS - int(NBCOL_STACK,8) + 1_8 .LT.                   &
     &                                  LAST_ALLOWED ) THEN
              EXIT
            ENDIF
            DO J= 1_8,int(NBCOL_STACK,8)
              A(NPOS-J+1_8) = A(APOS-J+1_8)
            ENDDO
            NPOS = NPOS - int(NBCOL_STACK,8)
          ELSE
            IF (.NOT. COMPRESSCB) THEN
              IF ( NPOS - int(NBCOL_STACK,8) + 1_8 .LT.                 &
     &                                  LAST_ALLOWED ) THEN
                EXIT
              ENDIF
              DO J = 1_8, int(NBCOL_STACK - I,8)
                A(NPOS - J + 1_8) = dble(ZERO)
              END DO
              NPOS = NPOS + int(- NBCOL_STACK + I,8)
            ENDIF
            IF ( NPOS - int(I,8) + 1_8 .LT. LAST_ALLOWED ) THEN
              EXIT
            ENDIF
            DO J =1_8, int(I,8)
              A(NPOS-J+1_8) = A(APOS-J+1_8)
            ENDDO
            NPOS = NPOS - int(I,8)
          ENDIF
          IF (KEEP(50).EQ.0) THEN
            APOS = APOS - int(LDA,8)
          ELSE
            APOS = APOS - int(LDA + 1,8)
          ENDIF
          NBROW_ALREADY_STACKED = NBROW_ALREADY_STACKED + 1
        ENDDO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_652
      SUBROUTINE DAGMG_MUMPS_705( A, LA, LDA, POSELT,                        &
     &           IPTRLU, NPIV,                                          &
     &           NBCOL_STACK, NBROW_STACK,                              &
     &           NBROW_SEND, SIZECB, KEEP, COMPRESSCB)
      IMPLICIT NONE
      INTEGER, intent (in) :: POSELT, IPTRLU, LA, SIZECB
      LOGICAL, intent (in) :: COMPRESSCB
      DOUBLE PRECISION A(LA)
      INTEGER, intent(in):: LDA, NPIV, NBCOL_STACK, NBROW_STACK,        &
     &                      NBROW_SEND
      INTEGER APOS, NPOS
      INTEGER NBROW
      INTEGER I, J, KEEP(500)
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      NPOS = IPTRLU + 1
      APOS = POSELT + NPIV * LDA + NPIV + NBROW_SEND * LDA
      DO I = 1, NBROW_STACK
        IF (KEEP(50).EQ.0) THEN
          DO J = 1, NBCOL_STACK
            A(NPOS+J-1) = A(APOS+J-1)
          ENDDO
        ELSE
          DO J  = 1, I + NBROW_SEND
            A(NPOS+J-1)=A(APOS+J-1)
          ENDDO
          IF (.NOT. COMPRESSCB) THEN
            A(NPOS+I+NBROW_SEND: NPOS+NBCOL_STACK-1)=dble(ZERO)
          ENDIF
        ENDIF
        IF (COMPRESSCB) THEN
           NPOS = NPOS + I + NBROW_SEND
        ELSE
           NPOS = NPOS + NBCOL_STACK
        ENDIF
        APOS = APOS + LDA
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_705
      SUBROUTINE DAGMG_MUMPS_140( N, INODE, IW, LIW, A, LA,                  &
     &                           IOLDPS, POSELT, IFLAG,                 &
     &                           UU, NNEG, NPVW,                        &
     &                           KEEP,KEEP8,                            &
     &                           MYID, SEUIL, AVOID_DELAYED, ETATASS,   &
     &     DKEEP,PIVNUL_LIST,LPN_LIST, IWPOS )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER(8) :: LA, POSELT
      INTEGER N, INODE, LIW, IFLAG, NNEG, NPVW
      INTEGER MYID, SLAVEF, IOLDPS
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION UU, SEUIL
      DOUBLE PRECISION A( LA )
      INTEGER, TARGET :: IW( LIW )
      LOGICAL AVOID_DELAYED
      INTEGER ETATASS, IWPOS
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER INOPV, IFINB, NFRONT, NPIV, NBOLKJ,                       &
     &        NBTLKJ,IBEG_BLOCK
      INTEGER NASS, NEL1, IFLAG_OOC
      INTEGER :: LDA
      DOUBLE PRECISION UUTEMP
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      EXTERNAL DAGMG_MUMPS_222, DAGMG_MUMPS_234,                                  &
     &         DAGMG_MUMPS_230, DAGMG_MUMPS_226,                                  &
     &         DAGMG_MUMPS_237
      LOGICAL STATICMODE
      DOUBLE PRECISION SEUIL_LOC
      INTEGER PIVSIZ,IWPOSP2
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, TYPEFile, NextPiv2beWritten,               &
     &        IDUMMY
      LOGICAL POSTPONE_COL_UPDATE
      TYPE(IO_BLOCK) :: MonBloc
      LOGICAL LAST_CALL
      INTEGER PP_FIRST2SWAP_L
      INTEGER PP_LastPIVRPTRFilled
      INOPV = 0
      SEUIL_LOC = SEUIL
      IF(KEEP(97) .EQ. 0) THEN
         STATICMODE = .FALSE.
      ELSE
         STATICMODE = .TRUE.
      ENDIF
      IF (AVOID_DELAYED) THEN
        STATICMODE = .TRUE.
        UUTEMP=UU
        SEUIL_LOC = max(SEUIL,epsilon(SEUIL))
      ELSE
        UUTEMP=UU
      ENDIF
      POSTPONE_COL_UPDATE = (UUTEMP == 0.0D0 .AND. KEEP(201).NE.1)
      IBEG_BLOCK = 1
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      LDA    = NFRONT
      NASS   = iabs(IW(IOLDPS+2+KEEP(IXSZ)))
      IF (NASS .GT. KEEP(3)) THEN
        NBOLKJ = min( KEEP(6), NASS )
      ELSE
        NBOLKJ = min( KEEP(5), NASS )
      ENDIF
      NBTLKJ = NBOLKJ
      IF (KEEP(201).EQ.1) THEN
          IDUMMY    = -8765
          CALL AGMG_MUMPS_729(LAFAC,IW(IOLDPS+XXR))
          LIWFAC    = IW(IOLDPS+XXI)
          TYPEFile  = TYPEF_L
          NextPiv2beWritten = 1
          PP_FIRST2SWAP_L = NextPiv2beWritten
          MonBloc%LastPanelWritten_L = 0
          PP_LastPIVRPTRFilled       = 0
          MonBloc%INODE    = INODE
          MonBloc%MASTER   = .TRUE.
          MonBloc%Typenode = 1
          MonBloc%NROW     = NFRONT
          MonBloc%NCOL     = NFRONT
          MonBloc%NFS      = NASS
          MonBloc%Last     = .FALSE.
          MonBloc%LastPiv  = -77777
          MonBloc%INDICES  =>                                           &
     &              IW(IOLDPS+6+NFRONT+KEEP(IXSZ):                      &
     &                 IOLDPS+5+NFRONT+KEEP(IXSZ)+NFRONT)
      ENDIF
      IW(IOLDPS+3+KEEP(IXSZ)) = min0(NASS,NBTLKJ)
      UUTEMP = UU
   50 CONTINUE
      CALL DAGMG_MUMPS_222(NFRONT,NASS,N,INODE,IW,LIW,A,LA,                  &
     &                INOPV, NNEG, IFLAG,IOLDPS,POSELT,UUTEMP,          &
     &                SEUIL_LOC,KEEP,KEEP8,PIVSIZ,                      &
     &     DKEEP(1),PIVNUL_LIST(1),LPN_LIST, KEEP(IXSZ),                &
     &     PP_FIRST2SWAP_L, MonBloc%LastPanelWritten_L,                 &
     &     PP_LastPIVRPTRFilled)
      IF (IFLAG.LT.0) GOTO 500
      IF(KEEP(109).GT. 0) THEN
         IF(PIVNUL_LIST(KEEP(109)).EQ.-1) THEN
            IWPOSP2 = IOLDPS+IW(IOLDPS+1+KEEP(IXSZ))+6+KEEP(IXSZ)       &
     &              +IW(IOLDPS+5+KEEP(IXSZ))
            PIVNUL_LIST(KEEP(109)) = IW(IWPOSP2)
         ENDIF
      ENDIF
      IF (INOPV.EQ.1) THEN
         IF(STATICMODE) THEN
            INOPV = -1
            GOTO 50
         ENDIF
         CALL DAGMG_MUMPS_237(NFRONT,NASS,N,INODE,IW,LIW,A,LA,               &
     &        LDA, IOLDPS,POSELT, KEEP,KEEP8, POSTPONE_COL_UPDATE,      &
     &        ETATASS,                                                  &
     &         TYPEFile, LAFAC, MonBloc, NextPiv2beWritten,             &
     &         LIWFAC, MYID, IFLAG)
         GOTO 500
      END IF
      IF (INOPV.EQ.2) THEN
         CALL DAGMG_MUMPS_234(IBEG_BLOCK,                                    &
     &            NFRONT,NASS,N,INODE,IW,LIW,A,LA,                      &
     &            LDA, IOLDPS,POSELT, NBOLKJ, NBTLKJ,KEEP(4),           &
     &            POSTPONE_COL_UPDATE,                                  &
     &            KEEP,KEEP8)
         GOTO 50
      ENDIF
      NPVW = NPVW + PIVSIZ
      IF (NASS.LE.1) THEN
       CALL DAGMG_MUMPS_230(NFRONT,N,INODE,IW,LIW,A,LA,                      &
     &                 IOLDPS,POSELT)
       IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + 1
       GO TO 500
      ENDIF
       CALL DAGMG_MUMPS_226(IBEG_BLOCK,                                      &
     &             NFRONT, NASS, N,INODE,IW,LIW,A,LA,                   &
     &             LDA, POSTPONE_COL_UPDATE, IOLDPS,                    &
     &             POSELT,IFINB,                                        &
     &             NBTLKJ,PIVSIZ, KEEP(IXSZ))
       IF(PIVSIZ .EQ. 2) THEN
          IWPOSP2 = IOLDPS+IW(IOLDPS+1+KEEP(IXSZ))+6
          IW(IWPOSP2+NFRONT+KEEP(IXSZ)) = -IW(IWPOSP2+NFRONT+KEEP(IXSZ))
       ENDIF
       IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + PIVSIZ
       IF (IFINB.EQ.0) GOTO 50
       NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
       NEL1   = NASS - NPIV
        IF (KEEP(201).EQ.1) THEN
          IF (IFINB.EQ.-1) THEN
            MonBloc%Last = .TRUE.
          ELSE
            MonBloc%Last   = .FALSE.
          ENDIF
          MonBloc%LastPiv= NPIV
          LAST_CALL=.FALSE.
          CALL DAGMG_MUMPS_688(                                              &
     &        STRAT_TRY_WRITE,                                          &
     &        TYPEFile, A(POSELT),                                      &
     &        LAFAC, MonBloc, NextPiv2beWritten, IDUMMY, IW(IOLDPS),    &
     &        LIWFAC, MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
          IF (IFLAG .LT. 0 ) RETURN
        ENDIF
       CALL DAGMG_MUMPS_234(IBEG_BLOCK,                                      &
     &            NFRONT,NASS,N,INODE,IW,LIW,A,LA,                      &
     &            LDA, IOLDPS,POSELT, NBOLKJ, NBTLKJ,KEEP(4),           &
     &            POSTPONE_COL_UPDATE,                                  &
     &            KEEP,KEEP8)
       IF (IFINB.EQ.-1) THEN
         CALL DAGMG_MUMPS_237(NFRONT,NASS,N,INODE,IW,LIW,A,LA,               &
     &         LDA, IOLDPS,POSELT, KEEP,KEEP8,                          &
     &         POSTPONE_COL_UPDATE, ETATASS,                            &
     &         TYPEFile, LAFAC, MonBloc, NextPiv2beWritten,             &
     &         LIWFAC, MYID, IFLAG)
         GOTO 500
       ENDIF
      GO TO 50
  500 CONTINUE
      IF (KEEP(201).EQ.1) THEN
          STRAT        = STRAT_WRITE_MAX
          MonBloc%Last = .TRUE.
          MonBloc%LastPiv  = IW(IOLDPS+1+KEEP(IXSZ))
          LAST_CALL=.TRUE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           NextPiv2beWritten, IDUMMY,                             &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
          IF (IFLAG_OOC < 0 ) IFLAG=IFLAG_OOC
          IF (IFLAG < 0 ) RETURN
          CALL DAGMG_MUMPS_644(IWPOS,                                        &
     &      IOLDPS, IW, LIW, MonBloc , NFRONT, KEEP)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_140
      SUBROUTINE DAGMG_MUMPS_222                                             &
     &   (NFRONT,NASS,N,INODE,IW,LIW,                                   &
     &    A,LA, INOPV,                                                  &
     &    NNEG,                                                         &
     &    IFLAG,IOLDPS,POSELT,UU, SEUIL,KEEP,KEEP8,PIVSIZ,              &
     &     DKEEP,PIVNUL_LIST,LPN_LIST, XSIZE,                           &
     &     PP_FIRST2SWAP_L, PP_LastPanelonDisk,                         &
     &     PP_LastPIVRPTRIndexFilled)
      IMPLICIT NONE
      INTEGER(8) :: POSELT, LA
      INTEGER NFRONT,NASS,N,LIW,INODE,IFLAG,INOPV,                      &
     &        IOLDPS, NNEG
      INTEGER PIVSIZ,LPIV, XSIZE
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION UU, UULOC, SEUIL
      INTEGER IW(LIW)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER PP_FIRST2SWAP_L, PP_LastPanelonDisk
      INTEGER PP_LastPIVRPTRIndexFilled
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER (8) :: POSPV1,POSPV2,OFFDAG,APOSJ
      INTEGER JMAX
      DOUBLE PRECISION RMAX,AMAX,TMAX,SWOP,TOL
      DOUBLE PRECISION DELTA,MAXPIV
      DOUBLE PRECISION PIVNUL,FIXA
      DOUBLE PRECISION PIVOT,DETPIV
      PARAMETER(TOL = 1.0D-20)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER :: J
      INTEGER(8) :: APOS, J1, J2, JJ, NFRONT8, KK
      INTEGER    :: LDA
      INTEGER(8) :: LDA8
      DOUBLE PRECISION ZERO,ONE
      INTEGER NPIV,NASSW,IPIV
      INTEGER NPIVP1,K
      INTRINSIC max
      DATA ZERO /0.0D0/
      DATA ONE /1.0D0/
      INTEGER I_PIVRPTR, I_PIVR, NBPANELS_L
      PIVNUL = DKEEP(1)
      FIXA   = DKEEP(2)
      LDA     = NFRONT
      LDA8    = int(LDA,8)
      NFRONT8 = int(NFRONT,8)
      IF (KEEP(201).EQ.1 .AND. KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_667(1, NBPANELS_L,                                  &
     &       I_PIVRPTR, I_PIVR, IOLDPS+2*NFRONT+6+KEEP(IXSZ),           &
     &       IW, LIW)
      ENDIF
      UULOC = UU
      PIVSIZ = 1
      NPIV    = IW(IOLDPS+1+XSIZE)
      NPIVP1  = NPIV + 1
      NASSW   = iabs(IW(IOLDPS+3+XSIZE))
      IF(INOPV .EQ. -1) THEN
         APOS = POSELT + (LDA8+1_8) * int(NPIV,8)
         POSPV1 = APOS
         IF(abs(A(APOS)).LT.SEUIL) THEN
            IF(dble(A(APOS)) .GE. ZERO) THEN
               A(APOS) = dble(SEUIL)
            ELSE
               A(APOS) = dble(-SEUIL)
               NNEG = NNEG+1
            ENDIF
            KEEP(98) = KEEP(98)+1
         ENDIF
              IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR), NBPANELS_L,             &
     &               IW(I_PIVR), NASS, NPIVP1, NPIVP1,                  &
     &               PP_LastPanelonDisk,                                &
     &               PP_LastPIVRPTRIndexFilled)
              ENDIF
         GO TO 420
      ENDIF
      INOPV   = 0
      DO 460 IPIV=NPIVP1,NASSW
         APOS = POSELT + LDA8*int(IPIV-1,8) + int(NPIV,8)
         POSPV1 = APOS + int(IPIV - NPIVP1,8)
         PIVOT = A(POSPV1)
         IF (UULOC.EQ.ZERO) THEN
            IF (abs(A(APOS)).EQ.ZERO) GO TO 630
            IF (A(APOS).LT.ZERO) NNEG = NNEG+1
            GO TO 420
         ENDIF
         AMAX = ZERO
         JMAX = 0
         J1 = APOS
         J2 = POSPV1 - 1_8
         DO JJ=J1,J2
            IF(abs(A(JJ)) .GT. AMAX) THEN
               AMAX = abs(A(JJ))
               JMAX = IPIV - int(POSPV1-JJ)
            ENDIF
         ENDDO
         J1 = POSPV1 + LDA8
         DO J=1,NASSW - IPIV
            IF(abs(A(J1)) .GT. AMAX) THEN
               AMAX = abs(A(J1))
               JMAX = IPIV + J
            ENDIF
            J1 = J1 + LDA8
         ENDDO
         RMAX = ZERO
         DO J=1, NFRONT - NASSW
            RMAX = max(abs(A(J1)),RMAX)
            J1 = J1 + LDA8
         ENDDO
         IF (max(AMAX,RMAX,abs(PIVOT)).LE.PIVNUL) THEN
            KEEP(109) = KEEP(109)+1
            PIVNUL_LIST(KEEP(109)) = -1
            IF(FIXA.GT.ZERO) THEN
               IF(dble(PIVOT) .GE. ZERO) THEN
                  A(POSPV1) = dble(FIXA)
               ELSE
                  A(POSPV1) = dble(-FIXA)
               ENDIF
            ELSE
               J1 = APOS
               J2 = POSPV1 - 1_8
               DO JJ=J1,J2
                  A(JJ) = dble(ZERO)
               ENDDO
               J1 = POSPV1 + LDA8
               DO J=1, NASSW - IPIV
                  A(J1) = dble(ZERO)
                  J1 = J1 + LDA8
               ENDDO
               DO J=1,NFRONT - NASSW
                  A(J1) = dble(ZERO)
                  J1 = J1 + LDA8
               ENDDO
               A(POSPV1) = dble(ONE)
            ENDIF
            PIVOT = A(POSPV1)
            GO TO 415
         ENDIF
         IF ((KEEP(19).EQ.0).AND.(KEEP(110).EQ.0)) THEN
           IF (max(AMAX,RMAX,abs(PIVOT)).LE.TOL) THEN
            IF(SEUIL .GT. epsilon(SEUIL)) THEN
               IF(dble(PIVOT) .GE. ZERO) THEN
                  A(POSPV1) = dble(SEUIL)
               ELSE
                  A(POSPV1) = dble(-SEUIL)
                  NNEG = NNEG+1
               ENDIF
               PIVOT = A(POSPV1)
               KEEP(98) = KEEP(98)+1
               GO TO 415
            ENDIF
           ENDIF
         ENDIF
         IF (max(AMAX,abs(PIVOT)).LE.TOL) GO TO 460
         IF (abs(PIVOT).GT.max(UULOC*max(RMAX,AMAX),SEUIL)) THEN
               A(POSPV1) = PIVOT
               IF (A(POSPV1).LT.ZERO) NNEG = NNEG+1
               GO TO 415
         END IF
         IF (AMAX.LE.TOL) GO TO 460
         IF (RMAX.LT.AMAX) THEN
               J1 = APOS
               J2 = POSPV1 - 1_8
               DO JJ=J1,J2
                  IF(int(POSPV1-JJ) .NE. IPIV-JMAX) THEN
                     RMAX = max(RMAX,abs(A(JJ)))
                  ENDIF
               ENDDO
               J1 = POSPV1 + LDA8
               DO J=1,NASS-IPIV
                  IF(IPIV+J .NE. JMAX) THEN
                     RMAX = max(abs(A(J1)),RMAX)
                  ENDIF
                  J1 = J1 + LDA8
               ENDDO
           ENDIF
           APOSJ = POSELT + int(JMAX-1,8)*LDA8 + int(NPIV,8)
           POSPV2 = APOSJ + int(JMAX - NPIVP1,8)
           IF (IPIV.LT.JMAX) THEN
              OFFDAG = APOSJ + int(IPIV - NPIVP1,8)
           ELSE
              OFFDAG = APOS + int(JMAX - NPIVP1,8)
           END IF
           TMAX = ZERO
           IF(JMAX .LT. IPIV) THEN
              JJ = POSPV2
              DO K = 1, NFRONT-JMAX
                 JJ = JJ+ NFRONT8
                 IF (JMAX+K.NE.IPIV) THEN
                    TMAX=max(TMAX,abs(A(JJ)))
                 ENDIF
              ENDDO
              DO KK =  APOSJ, POSPV2-1_8
                 TMAX = max(TMAX,abs(A(KK)))
              ENDDO
           ELSE
              JJ = POSPV2
              DO K = 1, NFRONT-JMAX
                 JJ = JJ+NFRONT8
                 TMAX=max(TMAX,abs(A(JJ)))
              ENDDO
              DO KK =  APOSJ, POSPV2 - 1_8
                 IF (KK.NE.OFFDAG) THEN
                    TMAX = max(TMAX,abs(A(KK)))
                 ENDIF
              ENDDO
           ENDIF
           DETPIV = A(POSPV1)*A(POSPV2) - A(OFFDAG)**2
           IF (SEUIL.GT.ZERO) THEN
                IF (sqrt(abs(DETPIV)) .LE. SEUIL ) GOTO 460
           ENDIF
           MAXPIV = max(abs(A(POSPV1)),abs(A(POSPV2)))
           IF (MAXPIV.EQ.ZERO) MAXPIV = ONE
           IF (abs(DETPIV)/MAXPIV.LE.TOL) GO TO 460
           IF ((abs(A(POSPV2))*RMAX+AMAX*TMAX)*UULOC.GT.                &
     &          abs(DETPIV)) GO TO 460
           IF ((abs(A(POSPV1))*TMAX+AMAX*RMAX)*UULOC.GT.                &
     &          abs(DETPIV)) GO TO 460
           PIVSIZ = 2
           KEEP(103) = KEEP(103)+1
           IF(DETPIV .LT. ZERO) THEN
             NNEG = NNEG+1
           ELSE IF(A(POSPV2) .LT. ZERO) THEN
             NNEG = NNEG+2
           ENDIF
  415      CONTINUE
           DO K=1,PIVSIZ
              IF (PIVSIZ .EQ. 2) THEN
                IF (K==1) THEN
                  LPIV = min(IPIV,JMAX)
                ELSE
                  LPIV   = max(IPIV,JMAX)
                ENDIF
              ELSE
                LPIV = IPIV
              ENDIF
              IF (LPIV.EQ.NPIVP1) THEN
                 GOTO 416
              ENDIF
              CALL DAGMG_MUMPS_319( A, LA, IW, LIW,                          &
     &             IOLDPS, NPIVP1, LPIV, POSELT, NASS,                  &
     &             LDA, NFRONT, 1, KEEP(219), KEEP(50),                 &
     &             KEEP(IXSZ))
  416         CONTINUE
              IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR), NBPANELS_L,             &
     &               IW(I_PIVR), NASS, NPIVP1, LPIV, PP_LastPanelonDisk,&
     &               PP_LastPIVRPTRIndexFilled)
              ENDIF
              NPIVP1 = NPIVP1 + 1
           ENDDO
           IF(PIVSIZ .EQ. 2) THEN
              A(POSELT+(LDA8+1_8)*int(NPIV,8)+1_8) = DETPIV
           ENDIF
           GOTO 420
  460   CONTINUE
      IF (NASSW.EQ.NASS) THEN
       INOPV = 1
      ELSE
       INOPV = 2
      ENDIF
      GO TO 420
  630 CONTINUE
      PIVSIZ = 0
      IFLAG = -10
  420 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_222
      SUBROUTINE DAGMG_MUMPS_680( PIVRPTR, NBPANELS, PIVR, NASS,             &
     &                                  K, P, LastPanelonDisk,          &
     &                                  LastPIVRPTRIndexFilled)
      IMPLICIT NONE
      INTEGER, intent(in) :: NBPANELS, NASS, K, P
      INTEGER, intent(inout) :: PIVRPTR(NBPANELS), PIVR(NASS)
      INTEGER LastPanelonDisk, LastPIVRPTRIndexFilled
      INTEGER I
      IF ( LastPanelonDisk+1 > NBPANELS ) THEN
           WRITE(*,*) "NASS=",NASS,"PIVRPTR=",PIVRPTR(1:NBPANELS)
           WRITE(*,*) "K=",K, "P=",P, "LastPanelonDisk=",LastPanelonDisk
           WRITE(*,*) "LastPIVRPTRIndexFilled=", LastPIVRPTRIndexFilled
           CALL AGMG_MUMPS_ABORT()
      ENDIF
      PIVRPTR(LastPanelonDisk+1) = K + 1
      IF (LastPanelOnDisk.NE.0) THEN
        PIVR(K - PIVRPTR(1) + 1) = P
        DO I = LastPIVRPTRindexFilled + 1, LastPanelonDisk
          PIVRPTR(I)=PIVRPTR(LastPIVRPTRindexFilled)
        ENDDO
      ENDIF
      LastPIVRPTRIndexFilled = LastPanelonDisk + 1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_680
      SUBROUTINE DAGMG_MUMPS_226(IBEG_BLOCK,                                 &
     &     NFRONT,NASS,N,INODE,IW,LIW,                                  &
     &     A,LA,LDA, POSTPONE_COL_UPDATE,                               &
     &     IOLDPS,POSELT,IFINB,LKJIB,PIVSIZ,XSIZE)
      IMPLICIT NONE
      INTEGER NFRONT,NASS,N,LIW,INODE,IFINB,LKJIB,                      &
     &        NPBEG, IBEG_BLOCK
      INTEGER LDA
      INTEGER(8) :: LA
      INTEGER(8) :: NFRONT8
      DOUBLE PRECISION    A(LA)
      LOGICAL POSTPONE_COL_UPDATE
      INTEGER IW(LIW)
      DOUBLE PRECISION    VALPIV
      INTEGER(8) :: POSELT
      INTEGER IOLDPS, NCB1
      INTEGER(8) :: LDA8
      INTEGER(8) :: K1POS
      INTEGER NPIV,JROW2
      INTEGER NEL2,NEL
      INTEGER XSIZE
      DOUBLE PRECISION ONE, ALPHA, ZERO
      INTEGER(8) :: APOS, LPOS, LPOS1, LPOS2
      INTEGER(8) :: POSPV1, POSPV2
      INTEGER PIVSIZ,NPIV_NEW,J2
      INTEGER(8) :: OFFDAG, OFFDAG_OLD, IBEG, IEND
      INTEGER(8) :: JJ, K1, K2, IROW
      DOUBLE PRECISION SWOP,DETPIV,MULT1,MULT2
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      PARAMETER(ONE  = 1.0D0,                                           &
     &          ALPHA= -1.0D0,                                          &
     &          ZERO = 0.0D0)
      LDA8   = int(LDA,8)
      NFRONT8= int(NFRONT,8)
      NPIV   = IW(IOLDPS+1+XSIZE)
      NPIV_NEW = NPIV + PIVSIZ
      NEL    = NFRONT - NPIV_NEW
      IFINB  = 0
      JROW2 = IW(IOLDPS+3+XSIZE)
      NPBEG = IBEG_BLOCK
      NEL2   = JROW2 - NPIV_NEW
      IF (NEL2.EQ.0) THEN
        IF (JROW2.EQ.NASS) THEN
          IFINB        = -1
        ELSE
          IFINB        = 1
        ENDIF
      ENDIF
      IF(PIVSIZ .EQ. 1) THEN
         APOS   = POSELT + int(NPIV,8)*(NFRONT8 + 1_8)
         VALPIV = ONE/A(APOS)
         A(APOS) = VALPIV
         LPOS   = APOS + LDA8
         IF ( POSTPONE_COL_UPDATE ) THEN
            CALL DCOPY(NASS-NPIV_NEW, A(LPOS), LDA, A(APOS+1_8), 1)
         ELSE
            CALL DCOPY(NFRONT-NPIV_NEW, A(LPOS), LDA, A(APOS+1_8), 1)
         END IF
         CALL DAGMG_MUMPS_XSYR('U', NEL2, -VALPIV, A(LPOS),                  &
     &        LDA, A(LPOS+1_8), LDA)
         IF ( POSTPONE_COL_UPDATE ) THEN
            CALL DSCAL( NASS-NPIV_NEW, VALPIV, A(LPOS), LDA )
         ELSE
            CALL DSCAL( NFRONT-NPIV_NEW, VALPIV, A(LPOS), LDA )
         ENDIF
         IF (NEL2.GT.0) THEN
            K1POS = LPOS + int(NEL2,8)*LDA8
            IF ( POSTPONE_COL_UPDATE ) THEN
               NCB1  = NASS   - JROW2
            ELSE
               NCB1  = NFRONT - JROW2
            END IF
            CALL DGER(NEL2, NCB1 , ALPHA, A(APOS+1_8), 1,               &
     &           A(K1POS), LDA, A(K1POS+1_8), LDA)
         ENDIF
      ELSE
         POSPV1 = POSELT + int(NPIV,8)*(NFRONT8 + 1_8)
         POSPV2 = POSPV1 + NFRONT8 + 1_8
         OFFDAG_OLD = POSPV2 - 1_8
         OFFDAG = POSPV1 + 1_8
         SWOP = A(POSPV2)
         DETPIV = A(OFFDAG)
         A(POSPV2) = A(POSPV1)/DETPIV
         A(POSPV1) = SWOP/DETPIV
         A(OFFDAG) = -A(OFFDAG_OLD)/DETPIV
         A(OFFDAG_OLD) = ZERO
         LPOS1   = POSPV2 + LDA8 - 1_8
         LPOS2   = LPOS1 + 1_8
         CALL DCOPY(NFRONT-NPIV_NEW, A(LPOS1), LDA, A(POSPV1+2_8), 1)
         CALL DCOPY(NFRONT-NPIV_NEW, A(LPOS2), LDA, A(POSPV2+1_8), 1)
         JJ = POSPV2 + NFRONT8-1_8
         IBEG = JJ + 2_8
         IEND = IBEG
         DO J2 = 1,NEL2
            K1 = JJ
            K2 = JJ+1_8
            MULT1 = - (A(POSPV1)*A(K1)+A(OFFDAG)*A(K2))
            MULT2 = - (A(OFFDAG)*A(K1)+A(POSPV2)*A(K2))
            K1 = POSPV1 + 2_8
            K2 = POSPV2 + 1_8
            DO IROW = IBEG, IEND
               A(IROW) = A(IROW) + MULT1*A(K1) + MULT2*A(K2)
               K1 = K1 + 1_8
               K2 = K2 + 1_8
            ENDDO
            A( JJ       ) = -MULT1
            A( JJ + 1_8 ) = -MULT2
            IBEG = IBEG + NFRONT8
            IEND = IEND + NFRONT8 + 1_8
            JJ = JJ+NFRONT8
         ENDDO
         IEND = IEND-1_8
         DO J2 = JROW2+1,NFRONT
            K1 = JJ
            K2 = JJ+1_8
            MULT1 = - (A(POSPV1)*A(K1)+A(OFFDAG)*A(K2))
            MULT2 = - (A(OFFDAG)*A(K1)+A(POSPV2)*A(K2))
            K1 = POSPV1 + 2_8
            K2 = POSPV2 + 1_8
            DO IROW = IBEG, IEND
               A(IROW) = A(IROW) + MULT1*A(K1) + MULT2*A(K2)
               K1 = K1 + 1_8
               K2 = K2 + 1_8
            ENDDO
            A( JJ       ) = -MULT1
            A( JJ + 1_8 ) = -MULT2
            IBEG = IBEG + NFRONT8
            IEND = IEND + NFRONT8
            JJ   = JJ   + NFRONT8
         ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_226
      SUBROUTINE DAGMG_MUMPS_230(NFRONT,N,INODE,IW,LIW,A,LA,                 &
     &           IOLDPS,POSELT)
      IMPLICIT NONE
      INTEGER NFRONT,N,INODE,LIW
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION    VALPIV
      INTEGER (8) :: APOS, POSELT, LPOS, NFRONT8
      INTEGER IOLDPS,NEL
      INTEGER JROW
      DOUBLE PRECISION, PARAMETER :: ONE = 1.0D0
        APOS   = POSELT
        VALPIV = ONE/A(APOS)
        A(APOS) = VALPIV
        NEL    = NFRONT - 1
        IF (NEL.EQ.0) GO TO 500
        NFRONT8 = int(NFRONT,8)
        LPOS   = APOS + NFRONT8
        CALL DAGMG_MUMPS_XSYR('U',NEL, -VALPIV,                              &
     &             A(LPOS), NFRONT, A(LPOS+1_8), NFRONT)
          DO JROW = 1,NEL
            A(LPOS) = VALPIV*A(LPOS)
            LPOS    = LPOS + NFRONT8
          END DO
  500   CONTINUE
        RETURN
        END SUBROUTINE DAGMG_MUMPS_230
      SUBROUTINE DAGMG_MUMPS_234(IBEG_BLOCK,                                 &
     &    NFRONT,NASS,N,INODE,IW,LIW,A,LA,                              &
     &    LDA,                                                          &
     &    IOLDPS,POSELT,LKJIB_ORIG,LKJIB,LKJIT,                         &
     &    POSTPONE_COL_UPDATE,                                          &
     &    KEEP,KEEP8 )
      IMPLICIT NONE
      INTEGER NFRONT, NASS,N,LIW, IBEG_BLOCK
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      INTEGER LKJIB_ORIG, LKJIB, INODE, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: POSELT
      INTEGER LDA
      INTEGER(8) :: LDA8
      INTEGER IOLDPS, NPIV, JROW2, NPBEG
      INTEGER NONEL, LKJIW, NEL1, NEL11
      INTEGER LBP, HF
      INTEGER(8) :: LPOS,UPOS,APOS
      INTEGER LKJIT
      INTEGER LKJIBOLD, IROW
      INTEGER I, Block
      INTEGER BLSIZE
      LOGICAL POSTPONE_COL_UPDATE
      DOUBLE PRECISION ONE, ALPHA
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      PARAMETER (ONE=1.0D0, ALPHA=-1.0D0)
      LDA8 = int(LDA,8)
      LKJIBOLD = LKJIB
      NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
      JROW2  = iabs(IW(IOLDPS+3+KEEP(IXSZ)))
      NPBEG  = IBEG_BLOCK
      HF     = 6 + IW(IOLDPS+5+KEEP(IXSZ)) + KEEP(IXSZ)
      NEL1   = NASS - JROW2
      LKJIW  = NPIV - NPBEG + 1
      NEL11  = NFRONT - NPIV
      IF ( LKJIW .NE. LKJIB ) THEN
        NONEL         = JROW2 - NPIV + 1
        IF ((NASS-NPIV).GE.LKJIT) THEN
          LKJIB       = LKJIB_ORIG + NONEL
          IW(IOLDPS+3+KEEP(IXSZ))= min0(NPIV+LKJIB,NASS)
          LKJIB       = min0(LKJIB, NASS - NPIV)
        ELSE
          LKJIB = NASS - NPIV
          IW(IOLDPS+3+KEEP(IXSZ)) = NASS
        ENDIF
        IBEG_BLOCK = NPIV + 1
      ELSEIF (JROW2.LT.NASS) THEN
          IBEG_BLOCK   = NPIV + 1
          IW(IOLDPS+3+KEEP(IXSZ)) = min0(JROW2+LKJIB,NASS)
          LKJIB  = min0(LKJIB,NASS-NPIV)
      ENDIF
      IF (LKJIW.EQ.0) GO TO 500
      IF (NEL1.NE.0) THEN
        IF ( NASS - JROW2 > KEEP(7) ) THEN
          BLSIZE = KEEP(8)
        ELSE
          BLSIZE = NASS - JROW2
        END IF
        IF ( NASS - JROW2 .GT. 0 ) THEN
         DO IROW = JROW2+1, NASS, BLSIZE
          Block = min( BLSIZE, NASS - IROW + 1 )
           LPOS = POSELT + int( IROW - 1,8) * LDA8 + int(NPBEG - 1,8)
           UPOS = POSELT + int(NPBEG - 1,8) * LDA8 + int( IROW - 1,8)
           APOS = POSELT + int( IROW - 1,8) * LDA8 + int( IROW - 1,8)
           CALL DGEMM( 'N','N', Block, NASS - IROW + 1, LKJIW,          &
     &                ALPHA, A( UPOS ), LDA,                            &
     &                A( LPOS ), LDA, ONE, A( APOS ), LDA )
         END DO
        END IF
       LPOS = POSELT + int(NASS,8)*LDA8 + int(NPBEG - 1,8)
       UPOS = POSELT + int(NPBEG-1,8) * LDA8 + int(JROW2,8)
       APOS = POSELT + int(NASS,8)*LDA8 + int(JROW2,8)
       IF ( .NOT. POSTPONE_COL_UPDATE ) THEN
         CALL DGEMM('N', 'N', NEL1, NFRONT-NASS, LKJIW, ALPHA,          &
     &              A(UPOS), LDA, A(LPOS), LDA, ONE,                    &
     &              A(APOS), LDA)
       END IF
      ENDIF
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_234
        SUBROUTINE DAGMG_MUMPS_319( A, LA, IW, LIW,                          &
     &                       IOLDPS, NPIVP1, IPIV, POSELT, NASS,        &
     &                       LDA, NFRONT, LEVEL, K219, K50, XSIZE )
        IMPLICIT NONE
      INTEGER(8) :: POSELT, LA
      INTEGER LIW, IOLDPS, NPIVP1, IPIV
      INTEGER LDA, NFRONT, NASS, LEVEL, K219, K50, XSIZE
      DOUBLE PRECISION A( LA )
      INTEGER IW( LIW )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER ISW, ISWPS1, ISWPS2, HF
      INTEGER(8) :: IDIAG, APOS
      INTEGER(8) :: LDA8
      DOUBLE PRECISION SWOP
            LDA8 = int(LDA,8)
            APOS = POSELT + LDA8*int(IPIV-1,8) + int(NPIVP1-1,8)
            IDIAG = APOS + int(IPIV - NPIVP1,8)
            HF = 6 + IW( IOLDPS + 5 + XSIZE) + XSIZE
            ISWPS1 = IOLDPS + HF + NPIVP1 - 1
            ISWPS2 = IOLDPS + HF + IPIV - 1
            ISW = IW(ISWPS1)
            IW(ISWPS1) = IW(ISWPS2)
            IW(ISWPS2) = ISW
            ISW = IW(ISWPS1+NFRONT)
            IW(ISWPS1+NFRONT) = IW(ISWPS2+NFRONT)
            IW(ISWPS2+NFRONT) = ISW
            IF ( LEVEL .eq. 2 ) THEN
              CALL DSWAP( NPIVP1 - 1,                                   &
     &            A( POSELT + int(NPIVP1-1,8) ), LDA,                   &
     &            A( POSELT + int(IPIV-1,8)   ), LDA )
            END IF
            CALL DSWAP( NPIVP1-1,                                       &
     &           A( POSELT+int(NPIVP1-1,8) * LDA8 ), 1,                 &
     &           A( POSELT + int(IPIV-1,8) * LDA8 ), 1 )
             CALL DSWAP( IPIV - NPIVP1 - 1,                             &
     &           A( POSELT+int(NPIVP1,8) * LDA8 + int(NPIVP1-1,8) ),    &
     &           LDA, A( APOS + 1_8 ), 1 )
            SWOP = A(IDIAG)
            A(IDIAG) = A( POSELT+int(NPIVP1-1,8)*LDA8+int(NPIVP1-1,8) )
            A( POSELT + int(NPIVP1-1,8)*LDA8 + int(NPIVP1-1,8) ) = SWOP
            CALL DSWAP( NASS - IPIV, A( APOS + LDA8 ), LDA,             &
     &                  A( IDIAG + LDA8 ), LDA )
            IF ( LEVEL .eq. 1 ) THEN
              CALL DSWAP( NFRONT - NASS,                                &
     &        A( APOS  + int(NASS-IPIV+1,8) * LDA8 ), LDA,              &
     &        A( IDIAG + int(NASS-IPIV+1,8) * LDA8 ), LDA )
            END IF
            IF (K219.NE.0 .AND.K50.EQ.2) THEN
             IF ( LEVEL .eq. 2) THEN
              APOS                 = POSELT+LDA8*LDA8-1_8
              SWOP                 = A(APOS+int(NPIVP1,8))
              A(APOS+int(NPIVP1,8))= A(APOS+int(IPIV,8))
              A(APOS+int(IPIV,8))  = SWOP
             ENDIF
            ENDIF
        RETURN
        END SUBROUTINE DAGMG_MUMPS_319
      SUBROUTINE DAGMG_MUMPS_237(NFRONT,NASS,N,INODE,                        &
     &    IW,LIW,A,LA,                                                  &
     &    LDA,                                                          &
     &    IOLDPS,POSELT,KEEP,KEEP8,                                     &
     &    POSTPONE_COL_UPDATE, ETATASS,                                 &
     &    TYPEFile, LAFAC, MonBloc, NextPiv2beWritten,                  &
     &    LIWFAC, MYID, IFLAG                                           &
     &    )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER NFRONT, NASS,N,INODE,LIW
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: POSELT
      INTEGER LDA
      INTEGER IOLDPS, ETATASS
      LOGICAL POSTPONE_COL_UPDATE
      INTEGER(8) :: LAFAC
      INTEGER TYPEFile, NextPiv2beWritten
      INTEGER LIWFAC, MYID, IFLAG
      TYPE(IO_BLOCK):: MonBloc
      INTEGER IDUMMY
      LOGICAL LAST_CALL
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER(8) :: UPOS, APOS, LPOS
      INTEGER(8) :: LDA8
      INTEGER BLSIZE, BLSIZE2, Block, IROW, NPIV, I, IROWEND
      INTEGER I2, I2END, Block2
      DOUBLE PRECISION  ONE, ALPHA, BETA
      DOUBLE PRECISION, PARAMETER :: ZERO = 0.0D0
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
      LDA8 = int(LDA,8)
      IF (ETATASS.EQ.1) THEN
        BETA = dble(ZERO)
      ELSE
        BETA = ONE
      ENDIF
      IF ( NFRONT - NASS > KEEP(57) ) THEN
        BLSIZE = KEEP(58)
      ELSE
        BLSIZE = NFRONT - NASS
      END IF
      BLSIZE2 = KEEP(218)
      NPIV = IW( IOLDPS + 1 + KEEP(IXSZ))
      IF ( NFRONT - NASS .GT. 0 ) THEN
       IF ( POSTPONE_COL_UPDATE ) THEN
         CALL DTRSM( 'L', 'U', 'T', 'U',                                &
     &               NPIV, NFRONT-NPIV, ONE,                            &
     &               A( POSELT ), LDA,                                  &
     &               A( POSELT + LDA8 * int(NPIV,8) ), LDA )
       ENDIF
       DO IROWEND = NFRONT - NASS, 1, -BLSIZE
        Block = min( BLSIZE, IROWEND )
        IROW  = IROWEND - Block + 1
        LPOS = POSELT + int(NASS,8)*LDA8 + int(IROW-1,8) * LDA8
        APOS = POSELT + int(NASS,8)*LDA8 + int(IROW-1,8) * LDA8 +       &
     &                  int(NASS + IROW - 1,8)
        UPOS = POSELT + int(NASS,8)
        IF (.NOT. POSTPONE_COL_UPDATE) THEN
          UPOS = POSELT + int(NASS + IROW - 1,8)
        ENDIF
        IF (POSTPONE_COL_UPDATE) THEN
         DO I = 1, NPIV
          CALL DCOPY( Block, A( LPOS+int(I-1,8) ), LDA,                 &
     &                       A( UPOS+int(I-1,8)*LDA8 ), 1 )
          CALL DSCAL( Block, A(POSELT+(LDA8+1_8)*int(I-1,8)),           &
     &                A( LPOS + int(I - 1,8) ), LDA )
         ENDDO
        ENDIF
        DO I2END = Block, 1, -BLSIZE2
          Block2 = min(BLSIZE2, I2END)
          I2 = I2END - Block2+1
          CALL DGEMM('N', 'N', Block2, Block-I2+1, NPIV, ALPHA,         &
     &               A(UPOS+int(I2-1,8)), LDA,                          &
     &               A(LPOS+int(I2-1,8)*LDA8), LDA,                     &
     &               BETA,                                              &
     &               A(APOS + int(I2-1,8) + int(I2-1,8)*LDA8), LDA)
          IF (KEEP(201).EQ.1) THEN
            IF (NextPiv2beWritten.LE.NPIV) THEN
              LAST_CALL=.FALSE.
              CALL DAGMG_MUMPS_688(                                          &
     &        STRAT_TRY_WRITE, TYPEFile,                                &
     &        A(POSELT), LAFAC, MonBloc,                                &
     &        NextPiv2beWritten, IDUMMY,                                &
     &        IW(IOLDPS), LIWFAC, MYID,                                 &
     &        KEEP8(31),                                                &
     &        IFLAG,LAST_CALL )
              IF (IFLAG .LT. 0 ) RETURN
            ENDIF
          ENDIF
        ENDDO
        IF ( NFRONT - NASS - IROW + 1 - Block > 0 ) THEN
        CALL DGEMM( 'N', 'N', Block, NFRONT-NASS-Block-IROW+1, NPIV,    &
     &              ALPHA,  A( UPOS ), LDA,                             &
     &              A( LPOS + LDA8 * int(Block,8) ), LDA,               &
     &              BETA,                                               &
     &              A( APOS + LDA8 * int(Block,8) ), LDA )
        ENDIF
       END DO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_237
      SUBROUTINE DAGMG_MUMPS_320( BUF, BLOCK_SIZE,                           &
     &                           MYROW, MYCOL, NPROW, NPCOL,            &
     &                           A, LOCAL_M, LOCAL_N, N, MYID, COMM )
      IMPLICIT NONE
      INTEGER BLOCK_SIZE, NPROW, NPCOL, LOCAL_M, LOCAL_N, N, COMM
      INTEGER MYROW, MYCOL, MYID
      DOUBLE PRECISION BUF( BLOCK_SIZE * BLOCK_SIZE )
      DOUBLE PRECISION A( LOCAL_M, LOCAL_N )
      INTEGER NBLOCK, IBLOCK, JBLOCK, IBLOCK_SIZE, JBLOCK_SIZE
      INTEGER ROW_SOURCE, ROW_DEST, COL_SOURCE, COL_DEST
      INTEGER IGLOB, JGLOB
      INTEGER IROW_LOC_SOURCE, JCOL_LOC_SOURCE
      INTEGER IROW_LOC_DEST, JCOL_LOC_DEST
      INTEGER PROC_SOURCE, PROC_DEST
      NBLOCK = ( N - 1 ) / BLOCK_SIZE + 1
      DO IBLOCK = 1, NBLOCK
        IF ( IBLOCK .NE. NBLOCK                                         &
     &    ) THEN
          IBLOCK_SIZE = BLOCK_SIZE
        ELSE
          IBLOCK_SIZE = N - ( NBLOCK - 1 ) * BLOCK_SIZE
        END IF
        ROW_SOURCE = mod( IBLOCK - 1, NPROW )
        COL_DEST   = mod( IBLOCK - 1, NPCOL )
        IGLOB = ( IBLOCK - 1 ) * BLOCK_SIZE + 1
        IROW_LOC_SOURCE = BLOCK_SIZE *                                  &
     &                    ( ( IGLOB - 1 ) / (BLOCK_SIZE*NPROW) )        &
     &                  + mod( IGLOB - 1, BLOCK_SIZE ) + 1
        JCOL_LOC_DEST   = BLOCK_SIZE *                                  &
     &                    ( ( IGLOB - 1 ) / (BLOCK_SIZE*NPCOL) )        &
     &                  + mod( IGLOB - 1, BLOCK_SIZE ) + 1
        DO JBLOCK = 1, IBLOCK
          IF ( JBLOCK .NE. NBLOCK                                       &
     &      ) THEN
            JBLOCK_SIZE = BLOCK_SIZE
          ELSE
            JBLOCK_SIZE = N - ( NBLOCK - 1 ) * BLOCK_SIZE
          END IF
          COL_SOURCE = mod( JBLOCK - 1, NPCOL )
          ROW_DEST   = mod( JBLOCK - 1, NPROW )
          PROC_SOURCE = ROW_SOURCE * NPCOL + COL_SOURCE
          PROC_DEST   = ROW_DEST   * NPCOL + COL_DEST
          IF ( PROC_SOURCE .eq. PROC_DEST ) THEN
           IF ( MYID .eq. PROC_DEST ) THEN
            JGLOB = ( JBLOCK - 1 ) * BLOCK_SIZE + 1
            JCOL_LOC_SOURCE = BLOCK_SIZE *                              &
     &                  ( ( JGLOB - 1 ) / (BLOCK_SIZE*NPCOL) )          &
     &                  + mod( JGLOB - 1, BLOCK_SIZE ) + 1
            IROW_LOC_DEST   = BLOCK_SIZE *                              &
     &                    ( ( JGLOB - 1 ) / (BLOCK_SIZE*NPROW) )        &
     &                  + mod( JGLOB - 1, BLOCK_SIZE ) + 1
            IF ( IBLOCK .eq. JBLOCK ) THEN
              IF ( IBLOCK_SIZE .ne. JBLOCK_SIZE ) THEN
                WRITE(*,*) MYID,': Error in calling transdiag:unsym'
                CALL AGMG_MUMPS_ABORT()
              END IF
              CALL DAGMG_MUMPS_327( A( IROW_LOC_SOURCE,                      &
     &                 JCOL_LOC_SOURCE),                                &
     &                 IBLOCK_SIZE, LOCAL_M )
            ELSE
              CALL DAGMG_MUMPS_326(                                          &
     &           A( IROW_LOC_SOURCE, JCOL_LOC_SOURCE ),                 &
     &           A( IROW_LOC_DEST, JCOL_LOC_DEST ),                     &
     &           IBLOCK_SIZE, JBLOCK_SIZE, LOCAL_M )
            END IF
           END IF
          ELSE IF (  MYROW .eq. ROW_SOURCE                              &
     &    .AND. MYCOL .eq. COL_SOURCE ) THEN
            JGLOB = ( JBLOCK - 1 ) * BLOCK_SIZE + 1
            JCOL_LOC_SOURCE = BLOCK_SIZE *                              &
     &                    ( ( JGLOB - 1 ) / (BLOCK_SIZE*NPCOL) )        &
     &                  + mod( JGLOB - 1, BLOCK_SIZE ) + 1
            CALL DAGMG_MUMPS_293( BUF,                                       &
     &           A( IROW_LOC_SOURCE, JCOL_LOC_SOURCE ), LOCAL_M,        &
     &           IBLOCK_SIZE, JBLOCK_SIZE, COMM, PROC_DEST )
          ELSE IF ( MYROW .eq. ROW_DEST                                 &
     &    .AND.     MYCOL .eq. COL_DEST ) THEN
            JGLOB = ( JBLOCK - 1 ) * BLOCK_SIZE + 1
            IROW_LOC_DEST   = BLOCK_SIZE *                              &
     &                    ( ( JGLOB - 1 ) / (BLOCK_SIZE*NPROW) )        &
     &                  + mod( JGLOB - 1, BLOCK_SIZE ) + 1
            CALL DAGMG_MUMPS_281( BUF,                                       &
     &           A( IROW_LOC_DEST, JCOL_LOC_DEST ), LOCAL_M,            &
     &           JBLOCK_SIZE, IBLOCK_SIZE, COMM, PROC_SOURCE )
          END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_320
      SUBROUTINE DAGMG_MUMPS_293( BUF, A, LDA, M, N, COMM, DEST )
      IMPLICIT NONE
      INTEGER M, N, LDA, DEST, COMM
      DOUBLE PRECISION BUF(*), A(LDA,*)
      INTEGER I, IBUF, IERR
      INTEGER J
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      IBUF = 1
      DO J = 1, N
        BUF( IBUF: IBUF + M - 1 ) = A( 1 : M, J )
        DO I = 1, M
        END DO
        IBUF = IBUF + M
      END DO
      CALL AGMG_NOCALL('MPI_SEND')
      RETURN
      END SUBROUTINE DAGMG_MUMPS_293
      SUBROUTINE DAGMG_MUMPS_281( BUF, A, LDA, M, N, COMM, SOURCE )
      IMPLICIT NONE
      INTEGER LDA, M, N, COMM, SOURCE
      DOUBLE PRECISION BUF(*), A( LDA, *)
      INTEGER I, IBUF, IERR
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      CALL AGMG_NOCALL('MPI_RECV')
      IBUF = 1
      DO I = 1, M
        CALL DCOPY( N, BUF(IBUF), 1, A(I,1), LDA )
        IBUF = IBUF + N
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_281
      SUBROUTINE DAGMG_MUMPS_327( A, N, LDA )
      IMPLICIT NONE
      INTEGER N,LDA
      DOUBLE PRECISION A( LDA, * )
      INTEGER I, J
      DO I = 2, N
        DO J = 1, I - 1
          A( J, I ) = A( I, J )
        END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_327
      SUBROUTINE DAGMG_MUMPS_326( A1, A2, M, N, LD )
      IMPLICIT NONE
      INTEGER M,N,LD
      DOUBLE PRECISION A1( LD,* ), A2( LD, * )
      INTEGER I, J
      DO J = 1, N
        DO I = 1, M
          A2( J, I ) = A1( I, J )
        END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_326
      RECURSIVE SUBROUTINE DAGMG_MUMPS_274(                                  &
     &   COMM_LOAD, ASS_IRECV,                                          &
     &   BUFR, LBUFR,                                                   &
     &   LBUFR_BYTES, PROCNODE_STEPS, MSGSOU,                           &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM, IFLAG, IERROR, NBFIN,                              &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE_STEPS,       &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER ICNTL( 40 ), KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER N, SLAVEF, IWPOS, IWPOSCB, LIW
      INTEGER(8) IPTRLU, LRLU, LRLUS, LA, POSFAC
      INTEGER COMP
      INTEGER IFLAG, IERROR, NBFIN, MSGSOU
      INTEGER PROCNODE_STEPS(KEEP(28)), PTRIST(KEEP(28)),               &
     &        NSTK_S(KEEP(28))
      INTEGER(8) PTRAST(KEEP(28)), PTRFAC(KEEP(28)), PAMASTER(KEEP(28))
      INTEGER NBPROCFILS( KEEP(28) ), STEP(N),                          &
     & PIMASTER(KEEP(28))
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER LPTRAR, NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER COMM, MYID
      INTEGER PTLUST_S(KEEP(28)),                                       &
     &        ITLOC(N), FILS(N), ND(KEEP(28))
      INTEGER PTRAIW( LPTRAR ), PTRARW( LPTRAR )
      INTEGER FRERE_STEPS(KEEP(28))
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION FLOP1
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      INTEGER LEAF, LPOOL
      INTEGER IPOOL( LPOOL )
      LOGICAL FLAG
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER PIVI
      INTEGER (8) POSPV1,POSPV2,OFFDAG,LPOS1
      INTEGER J2
      DOUBLE PRECISION MULT1,MULT2
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER LP
      INTEGER INODE, POSITION, NPIV, IERR, IERR_MPI
      INTEGER NCOL, NROW
      INTEGER(8) LAELL, POSBLOCFACTO
      INTEGER(8) POSELT, MEM_GAIN
      INTEGER IOLDPS, LCONT1, NASS1, NROW1, NCOL1, NPIV1
      INTEGER NSLAV1, HS, ISW, DEST
      INTEGER ICT11
      INTEGER(8) LPOS, LPOS2, DPOS, UPOS
      INTEGER (8) IPOS, KPOS
      INTEGER I, IPIV, FPERE, NSLAVES_TOT,                              &
     &        NSLAVES_FOLLOW, NB_BLOC_FAC
      INTEGER LCONT,NELIM,NASS, LDA, NCOL_TO_SEND,                      &
     &        SHIFT_LIST_ROW_SON, SHIFT_LIST_COL_SON
      INTEGER(8) :: SHIFT_VAL_SON
      INTEGER IPOSK, JPOSK, NPIVSENT, Block, IROW, BLSIZE
      INTEGER allocok, TO_UPDATE_CPT_END
      DOUBLE PRECISION, DIMENSION(:),ALLOCATABLE :: UIP21K
      INTEGER ITYPE2
      PARAMETER (ITYPE2=2)
      INTEGER, DIMENSION(:), ALLOCATABLE :: LIST_SLAVES_FOLLOW
      LOGICAL LASTBL
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      DOUBLE PRECISION ONE,ALPHA
      DOUBLE PRECISION VALPIV
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, NextPivDummy
      LOGICAL LAST_CALL
      TYPE(IO_BLOCK) :: MonBloc
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      LP = ICNTL(1)
      IF (ICNTL(4) .LE. 0) LP = -1
      FPERE    = -1
      POSITION = 0
      TO_UPDATE_CPT_END = -654321
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      LASTBL = (NPIV.LE.0)
      IF (LASTBL) THEN
         NPIV = -NPIV
         CALL AGMG_NOCALL('MPI_UNPACK')
         CALL AGMG_NOCALL('MPI_UNPACK')
      ENDIF
      CALL AGMG_NOCALL('MPI_UNPACK')
      LAELL = int(NPIV,8) * int(NCOL,8)
      IF ( NPIV.GT.0 ) THEN
       IF ( LRLU .LT. LAELL .OR. IWPOS + NPIV - 1 .GT. IWPOSCB ) THEN
        IF ( LRLUS .LT. LAELL ) THEN
          IFLAG = -9
          CALL AGMG_MUMPS_731(LAELL-LRLUS, IERROR)
          IF (LP > 0 ) WRITE(LP,*) MYID,                                &
     &": FAILURE IN DAGMG_MUMPS_274,                                         &
     & REAL WORKSPACE TOO SMALL"
          GOTO 700
        END IF
        CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                     &
     &       LRLU, IPTRLU,                                              &
     &       IWPOS, IWPOSCB, PTRIST, PTRAST,                            &
     &       STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,           &
     &       KEEP(IXSZ))
        COMP = COMP+1
        IF ( LRLU .NE. LRLUS ) THEN
             WRITE(*,*) 'PB compress ass..blocfacto: LRLU,LRLUS='       &
     &       ,LRLU,LRLUS
             IFLAG = -9
             CALL AGMG_MUMPS_731(LAELL-LRLUS,IERROR)
             GOTO 700
        END IF
        IF ( IWPOS + NPIV - 1 .GT. IWPOSCB ) THEN
          IF (LP > 0 ) WRITE(LP,*) MYID,                                &
     &": FAILURE IN DAGMG_MUMPS_274,                                         &
     & INTEGER WORKSPACE TOO SMALL"
          IFLAG = -8
          IERROR = IWPOS + NPIV - 1 - IWPOSCB
          GOTO 700
        END IF
       END IF
       LRLU  = LRLU - LAELL
       LRLUS = LRLUS - LAELL
      ENDIF
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSBLOCFACTO = POSFAC
      POSFAC = POSFAC + LAELL
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &                           LA-LRLUS,0_8,LAELL,KEEP,KEEP8,LRLU)
      IF ( NPIV.GT.0 ) THEN
        IPIV = IWPOS
        IWPOS = IWPOS + NPIV
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
      ENDIF
      IF (PTRIST(STEP( INODE )) .EQ. 0) THEN
         DO WHILE ( PTRIST(STEP(INODE)) .EQ. 0 )
          BLOCKING = .TRUE.
          SET_IRECV= .FALSE.
          MESSAGE_RECEIVED = .FALSE.
          CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                        &
     &      BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                      &
     &      MSGSOU, MAITRE_DESC_BANDE,                                  &
     &      STATUS,                                                     &
     &      BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,           &
     &      IWPOS, IWPOSCB, IPTRLU,                                     &
     &      LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                     &
     &      PTLUST_S, PTRFAC,                                           &
     &      PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,             &
     &      IFLAG, IERROR, COMM,                                        &
     &      NBPROCFILS,                                                 &
     &      IPOOL, LPOOL, LEAF,                                         &
     &      NBFIN, MYID, SLAVEF,                                        &
     &      root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,          &
     &      INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,         &
     &      LPTRAR, NELT, FRTPTR, FRTELT,                               &
     &      ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
          IF ( IFLAG .LT. 0 ) GOTO 600
         END DO
      ENDIF
      DO WHILE ( NBPROCFILS(STEP(INODE)) .NE. 0 )
        BLOCKING = .TRUE.
        SET_IRECV=.FALSE.
        MESSAGE_RECEIVED = .FALSE.
        CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                          &
     &    BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                        &
     &    AGMG_MPF_ANY_SOURCE, CONTRIB_TYPE2,                                &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
        IF ( IFLAG .LT. 0 ) GOTO 600
      END  DO
        SET_IRECV = .TRUE.
        BLOCKING  = .FALSE.
        MESSAGE_RECEIVED = .TRUE.
        CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                          &
     &    BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                        &
     &    AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                  &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
      IOLDPS = PTRIST(STEP(INODE))
      POSELT = PTRAST(STEP(INODE))
      LCONT1 = IW( IOLDPS + KEEP(IXSZ))
      NASS1  = IW( IOLDPS + 1 + KEEP(IXSZ))
      NROW1  = IW( IOLDPS + 2 + KEEP(IXSZ))
      NPIV1  = IW( IOLDPS + 3 + KEEP(IXSZ))
      NSLAV1 = IW( IOLDPS + 5 + KEEP(IXSZ))
      NSLAVES_FOLLOW = NSLAV1 - XTRA_SLAVES_SYM
      HS     = 6 + NSLAV1 + KEEP(IXSZ)
      NCOL1  = LCONT1 + NPIV1
      IF ( LASTBL ) THEN
        TO_UPDATE_CPT_END = ( NSLAVES_TOT - NSLAVES_FOLLOW - 1 ) *      &
     &                       NB_BLOC_FAC
      END IF
      IF (NPIV.GT.0) THEN
        IF ( NPIV1 + NCOL .NE. NASS1 ) THEN
          WRITE(*,*) 'SymBLFC Error: NPIV1 + NCOL .NE. NASS1 :',        &
     &               NPIV1,NCOL,NASS1
          CALL AGMG_MUMPS_ABORT()
        END IF
        ICT11 = IOLDPS+HS+NROW1+NPIV1 - 1
        DO I = 1, NPIV
          PIVI = abs(IW(IPIV+I-1))
          IF (PIVI.EQ.I) CYCLE
          ISW = IW(ICT11+I)
          IW(ICT11+I) = IW(ICT11+PIVI)
          IW(ICT11+PIVI) = ISW
          IPOS = POSELT + int(NPIV1 + I - 1,8)
          KPOS = POSELT + int(NPIV1 + PIVI - 1,8)
          CALL DSWAP(NROW1, A(IPOS), NCOL1, A(KPOS), NCOL1)
        ENDDO
        ALLOCATE( UIP21K( NPIV * NROW1 ), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
            IF (LP > 0 ) WRITE(LP,*) MYID,                              &
     &": ALLOCATION FAILURE FOR UIP21K IN DAGMG_MUMPS_274"
          IFLAG = -13
          IERROR = NPIV * NROW1
          GOTO 700
        END IF
        IF ( NSLAVES_FOLLOW .NE. 0 .and. NPIV .NE. 0 ) THEN
          ALLOCATE( LIST_SLAVES_FOLLOW ( NSLAVES_FOLLOW ),              &
     &            stat = allocok )
          IF ( allocok .GT. 0 ) THEN
            IF (LP > 0 ) WRITE(LP,*) MYID,                              &
     &": ALLOCATION FAILURE FOR LIST_SLAVES_FOLLOW                      &
     & IN DAGMG_MUMPS_274"
            IFLAG = -13
            IERROR = NSLAVES_FOLLOW
            GOTO 700
          END IF
          LIST_SLAVES_FOLLOW(1:NSLAVES_FOLLOW)=                         &
     &    IW(IOLDPS+6+XTRA_SLAVES_SYM+KEEP(IXSZ):                       &
     &     IOLDPS+5+XTRA_SLAVES_SYM+KEEP(IXSZ)+NSLAVES_FOLLOW)
        END IF
        CALL DTRSM( 'L', 'U', 'T', 'U', NPIV, NROW1, ONE,               &
     &               A( POSBLOCFACTO ), NCOL,                           &
     &               A(POSELT+int(NPIV1,8)), NCOL1 )
        LPOS = POSELT + int(NPIV1,8)
        UPOS = 1_8
        DO I = 1, NROW1
          UIP21K( UPOS: UPOS + int(NPIV-1,8) ) =                        &
     &                       A(LPOS: LPOS+int(NPIV-1,8))
          LPOS = LPOS + int(NCOL1,8)
          UPOS = UPOS + int(NPIV,8)
        END DO
        LPOS = POSELT + int(NPIV1,8)
        DPOS = POSBLOCFACTO
        I = 1
        DO
          IF(I .GT. NPIV) EXIT
          IF(IW(IPIV+I-1) .GT. 0) THEN
            CALL DSCAL( NROW1, A(DPOS), A(LPOS), NCOL1 )
            LPOS = LPOS + 1_8
            DPOS = DPOS + int(NCOL + 1,8)
            I = I+1
          ELSE
            POSPV1 = DPOS
            POSPV2 = DPOS+ int(NCOL + 1,8)
            OFFDAG = POSPV1+1_8
            LPOS1 = LPOS
            DO J2 = 1,NROW1
               MULT1 = A(POSPV1)*A(LPOS1)+A(OFFDAG)*A(LPOS1+1_8)
               MULT2 = A(OFFDAG)*A(LPOS1)+A(POSPV2)*A(LPOS1+1_8)
               A(LPOS1) = MULT1
               A(LPOS1+1_8) = MULT2
               LPOS1 = LPOS1 + int(NCOL1,8)
            ENDDO
            LPOS = LPOS + 2_8
            DPOS = POSPV2 + int(NCOL + 1,8)
            I = I+2
          ENDIF
        ENDDO
      ENDIF
      IF (KEEP(201).eq.1) THEN
        MonBloc%INODE = INODE
        MonBloc%MASTER = .FALSE.
        MonBloc%TypeNode = 2
        MonBloc%NROW = NROW1
        MonBloc%NCOL = NCOL1
        MonBloc%NFS  = NASS1
        MonBloc%LastPiv = NPIV1 + NPIV
        NULLIFY(MonBloc%INDICES)
        MonBloc%LAST = LASTBL
        STRAT = STRAT_TRY_WRITE
        NextPivDummy      = -8888
        LIWFAC = IW(IOLDPS+XXI)
        CALL AGMG_MUMPS_729(LAFAC, IW(IOLDPS+XXR))
        LAST_CALL=.FALSE.
        CALL DAGMG_MUMPS_688( STRAT, TYPEF_L, A(POSELT),                     &
     &       LAFAC, MonBloc, NextPivDummy, NextPivDummy,                &
     &       IW(IOLDPS), LIWFAC, MYID, KEEP8(31), IFLAG,LAST_CALL)
      ENDIF
      IF (NPIV.GT.0) THEN
        LPOS2 = POSELT + int(NPIV1,8)
        UPOS = POSBLOCFACTO+int(NPIV,8)
        LPOS  = LPOS2 + int(NPIV,8)
        CALL DGEMM('N','N', NCOL-NPIV,NROW1,NPIV,ALPHA,A(UPOS),NCOL,    &
     &           A(LPOS2),NCOL1,ONE, A(LPOS),NCOL1)
        DPOS = POSELT + int(NCOL1 - NROW1,8)
        IF ( NROW1 .GT. KEEP(7) ) THEN
          BLSIZE = KEEP(8)
        ELSE
          BLSIZE = NROW1
        ENDIF
        IF ( NROW1 .GT. 0 ) THEN
          DO IROW = 1, NROW1, BLSIZE
            Block = min( BLSIZE, NROW1 - IROW + 1 )
            DPOS  = POSELT + int(NCOL1 - NROW1,8)                       &
     &            + int( IROW - 1, 8 ) * int( NCOL1 + 1, 8 )
            LPOS2 = POSELT + int(NPIV1,8)                               &
     &            + int( IROW - 1, 8 ) * int( NCOL1, 8 )
            UPOS  = int( IROW - 1, 8 ) * int(NPIV, 8) + 1_8
            DO I = 1, Block
              CALL DGEMV( 'T', NPIV, Block-I+1, ALPHA,                  &
     &                A( LPOS2 + int(I - 1,8) * int(NCOL1,8) ), NCOL1,  &
     &                UIP21K( UPOS + int(NPIV,8) * int( I - 1, 8 ) ),   &
     &                1, ONE, A(DPOS+int(NCOL1+1,8)*int(I-1,8)),NCOL1 )
            END DO
           IF ( NROW1-IROW+1-Block .ne. 0 )                             &
     &     CALL DGEMM( 'T', 'N', Block, NROW1-IROW+1-Block, NPIV, ALPHA,&
     &             UIP21K( UPOS ), NPIV,                                &
     &             A( LPOS2 + int(Block,8) * int(NCOL1,8) ), NCOL1, ONE,&
     &             A( DPOS + int(Block,8) * int(NCOL1,8) ), NCOL1 )
          ENDDO
        ENDIF
        FLOP1 = dble(NROW1) * dble(NPIV) *                              &
     &           dble( 2 * NCOL  - NPIV + NROW1 +1 )
        FLOP1 = -FLOP1
        CALL DAGMG_MUMPS_190( 1, .FALSE., FLOP1, KEEP,KEEP8 )
      ENDIF
  200 CONTINUE
      IW(IOLDPS+KEEP(IXSZ)) = IW(IOLDPS+KEEP(IXSZ)) - NPIV
      IW(IOLDPS + 3+KEEP(IXSZ)) = IW(IOLDPS+3+KEEP(IXSZ)) + NPIV
      IF (LASTBL) IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS + 3+KEEP(IXSZ))
      LRLU  = LRLU + LAELL
      LRLUS = LRLUS + LAELL
      POSFAC = POSFAC - LAELL
      IWPOS = IWPOS - NPIV
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &                           LA-LRLUS,0_8,-LAELL,KEEP,KEEP8,LRLU)
      IF ( NSLAVES_FOLLOW .NE. 0 .and. NPIV .NE. 0 ) THEN
         IPOSK = NPIV1 + 1
         JPOSK = NCOL1 - NROW1 + 1
           NPIVSENT = NPIV
          IERR = -1
           DO WHILE ( IERR .eq. -1 )
            CALL DAGMG_MUMPS_64(                                             &
     &                    INODE, NPIVSENT, FPERE,                       &
     &                    IPOSK, JPOSK,                                 &
     &                    UIP21K, NROW1,                                &
     &                    NSLAVES_FOLLOW,                               &
     &                    LIST_SLAVES_FOLLOW(1),                        &
     &                    COMM, IERR )
            IF (IERR .EQ. -1 ) THEN
              BLOCKING = .FALSE.
              SET_IRECV= .FALSE.
              MESSAGE_RECEIVED = .FALSE.
              CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                    &
     &         BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                   &
     &         AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                             &
     &         STATUS,                                                  &
     &         BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,        &
     &         IWPOS, IWPOSCB, IPTRLU,                                  &
     &         LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                  &
     &         PTLUST_S, PTRFAC,                                        &
     &         PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,          &
     &         IFLAG, IERROR, COMM,                                     &
     &         NBPROCFILS,                                              &
     &         IPOOL, LPOOL, LEAF,                                      &
     &         NBFIN, MYID, SLAVEF,                                     &
     &         root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,       &
     &         INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,      &
     &         LPTRAR, NELT, FRTPTR, FRTELT,                            &
     &         ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
             IF ( IFLAG .LT. 0 ) GOTO 600
            END IF
           END DO
           IF ( IERR .eq. -2 ) THEN
              IF (LP > 0 ) WRITE(LP,*) MYID,                            &
     &": FAILURE, SEND BUFFER TOO SMALL DURING                          &
     & DAGMG_MUMPS_274"
             WRITE(LP,*) "NPIV=", NPIV, "NROW1=",NROW1
             IFLAG = -17
             IERROR = 5 * KEEP(34) + NPIV * NROW1 * KEEP(35)
             GOTO 700
           END IF
           IF ( IERR .eq. -3 ) THEN
              IF (LP > 0 ) WRITE(LP,*) MYID,                            &
     &": FAILURE, RECV BUFFER TOO SMALL DURING                          &
     & DAGMG_MUMPS_274"
             IFLAG = -20
             IERROR = 5 * KEEP(34) + NPIV * NROW1 * KEEP(35)
             GOTO 700
           END IF
           DEALLOCATE(LIST_SLAVES_FOLLOW)
      END IF
      IF ( NPIV .NE. 0 ) DEALLOCATE( UIP21K )
      IOLDPS = PTRIST(STEP(INODE))
      IF (LASTBL) THEN
         IW(IOLDPS+6+KEEP(IXSZ)) =  IW(IOLDPS+6+KEEP(IXSZ)) -           &
     &                            TO_UPDATE_CPT_END
         IF ( IW(IOLDPS+6+KEEP(IXSZ) ) .eq. 0                           &
     &        .and. KEEP(50) .ne. 0 .and. NSLAVES_FOLLOW .eq. 0         &
     &        .and. NSLAVES_TOT.NE.1)THEN
         DEST = AGMG_MUMPS_275( STEP(INODE), PROCNODE_STEPS, SLAVEF )
         CALL DAGMG_MUMPS_62( INODE, DEST, END_NIV2_LDLT,                    &
     &                             COMM, IERR )
         IF ( IERR .LT. 0 ) THEN
           write(*,*) ' Internal error in PROCESS_SYM_BLOCFACTO.'
           IFLAG = -99
           GOTO 700
         END IF
         ENDIF
      END IF
      IF (LASTBL) THEN
      IF (IW(IOLDPS+6+KEEP(IXSZ)) .eq. 0 ) THEN
        IW(IOLDPS+XXS)=S_ALL
         IF (KEEP(214).EQ.1) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2         &
     &     )
          IOLDPS = PTRIST(STEP(INODE))
          IF (KEEP(38).NE.FPERE) THEN
            IW(IOLDPS+XXS)=S_NOLCBNOCONTIG
            IF (KEEP(216).NE.3) THEN
             MEM_GAIN=int(IW( IOLDPS + 2 + KEEP(IXSZ) ),8)*             &
     &                int(IW( IOLDPS + 3 + KEEP(IXSZ) ),8)
             LRLUS = LRLUS+MEM_GAIN
             CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                           &
     &              LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            ENDIF
          ENDIF
          IF (KEEP(216).EQ.2) THEN
           IF (FPERE.NE.KEEP(38)) THEN
           CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                    &
     &         IW( IOLDPS + 2 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) )+                           &
     &         IW( IOLDPS + KEEP(IXSZ) ), 0,                            &
     &         IW( IOLDPS + XXS ), 0_8 )
           IW(IOLDPS+XXS)=S_NOLCBCONTIG
           IW(IOLDPS+XXS)=S_NOLCBCONTIG
           ENDIF
          ENDIF
         ENDIF
      IF ( KEEP(38).EQ.FPERE) THEN
       LCONT  = IW(IOLDPS+KEEP(IXSZ))
       NROW   = IW(IOLDPS+2+KEEP(IXSZ))
       NPIV   = IW(IOLDPS+3+KEEP(IXSZ))
       NASS   = IW(IOLDPS+4+KEEP(IXSZ))
       NELIM  = NASS-NPIV
       NCOL_TO_SEND =  LCONT-NELIM
       SHIFT_LIST_ROW_SON = 6 + IW(IOLDPS+5+KEEP(IXSZ)) + KEEP(IXSZ)
       SHIFT_LIST_COL_SON = SHIFT_LIST_ROW_SON + NROW + NASS
       SHIFT_VAL_SON      = int(NASS,8)
       LDA                = LCONT + NPIV
      IF (IW(IOLDPS+8+KEEP(IXSZ)).EQ.S_ROOTBAND_INIT) THEN
        IW(IOLDPS+8+KEEP(IXSZ)) = S_REC_CONTSTATIC
      ELSE
      ENDIF
       CALL DAGMG_MUMPS_80( COMM_LOAD, ASS_IRECV,                            &
     &    N, INODE, FPERE,                                              &
     &    PTRIST, PTRAST,                                               &
     &    root, NROW, NCOL_TO_SEND, SHIFT_LIST_ROW_SON,                 &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, LDA,                      &
     &    ROOT_CONT_STATIC, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP, PIMASTER,             &
     &    PAMASTER,                                                     &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, .FALSE., ND, FRERE_STEPS,  &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE )
       IF ( IFLAG < 0 ) GOTO 600
       IF (NELIM.EQ.0) THEN
         IF (KEEP(214).EQ.2) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2         &
     &    )
         ENDIF
         CALL DAGMG_MUMPS_626( N, INODE, PTRIST, PTRAST, IW, LIW,            &
     &        A, LA, LRLU, LRLUS, IWPOSCB, IPTRLU, STEP,                &
     &        MYID, KEEP                                                &
     &         )
       ELSE
         IOLDPS = PTRIST(STEP(INODE))
         IF (IW(IOLDPS+8+KEEP(IXSZ)).EQ.S_ROOT2SON_CALLED) THEN
           CALL DAGMG_MUMPS_626( N, INODE, PTRIST, PTRAST, IW, LIW,          &
     &        A, LA, LRLU, LRLUS, IWPOSCB, IPTRLU, STEP,                &
     &        MYID, KEEP                                                &
     &         )
         ELSE
          IW(IOLDPS+8+KEEP(IXSZ)) = S_ROOTBAND_INIT
          IF (KEEP(214).EQ.1.AND.KEEP(216).NE.3) THEN
           IW(IOLDPS+XXS)=S_NOLCBNOCONTIG38
           CALL DAGMG_MUMPS_628( IW(IOLDPS),                                 &
     &                     LIW-IOLDPS+1,                                &
     &                     MEM_GAIN, KEEP(IXSZ) )
           LRLUS = LRLUS + MEM_GAIN
              CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                          &
     &                LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            IF (KEEP(216).EQ.2) THEN
              CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                 &
     &         IW( IOLDPS + 2 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) )+                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 4 + KEEP(IXSZ) ) -                          &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + XXS ),0_8)
              IW(IOLDPS+XXS)=S_NOLCBCONTIG38
            ENDIF
          ENDIF
         ENDIF
       ENDIF
      ENDIF
      ENDIF
      ENDIF
  600 CONTINUE
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_274
      SUBROUTINE DAGMG_MUMPS_141( COMM_LOAD, ASS_IRECV,                      &
     &           N, INODE, FPERE, IW, LIW, A, LA,                       &
     &           UU, NOFFW,                                             &
     &           NPVW,                                                  &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
     &             PIMASTER, PAMASTER,                                  &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT, SEUIL,                 &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE, AVOID_DELAYED,      &
     &            DKEEP,PIVNUL_LIST,LPN_LIST )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N, INODE, FPERE, LIW, NOFFW, NPVW
      INTEGER(8) :: LA
      DOUBLE PRECISION A( LA )
      DOUBLE PRECISION UU, SEUIL
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM, MYID, LBUFR, LBUFR_BYTES
      INTEGER LPTRAR, NELT
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS
      INTEGER NBFIN, IFLAG, IERROR, LEAF, LPOOL, SLAVEF,                &
     &        IWPOS, IWPOSCB, COMP
      INTEGER NB_BLOC_FAC
      INTEGER ICNTL(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER, TARGET :: IW( LIW )
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER BUFR( LBUFR ), IPOOL(LPOOL), ITLOC(N)
      INTEGER PTRARW(LPTRAR), PTRAIW(LPTRAR), ND( KEEP(28) )
      INTEGER FRERE(KEEP(28)), FILS(N)
      INTEGER INTARR(max(1,KEEP(14)))
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST(KEEP(28)),                                         &
     & PTLUST_S(KEEP(28)),                                              &
     & PIMASTER(KEEP(28)),                                              &
     &        NSTK_S(KEEP(28)), NBPROCFILS(KEEP(28)),                   &
     &        PROCNODE_STEPS(KEEP(28)), STEP(N)
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION  DBLARR(max(1,KEEP(13)))
      LOGICAL AVOID_DELAYED
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER(8) :: POSELT
      INTEGER INOPV, IFINB, NFRONT, NPIV, IBEGKJI, NBOLKJ, NBTLKJ
      INTEGER NASS, IEND, IOLDPS, LDAFS,allocok, IBEG_BLOCK
      LOGICAL LASTBL
      LOGICAL RESET_TO_ONE, TO_UPDATE
      INTEGER K109_ON_ENTRY
      INTEGER I,J,JJ,K,IDEB
      DOUBLE PRECISION UUTEMP
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER , ALLOCATABLE, DIMENSION ( : ) :: IPIV
      INTEGER(8) :: LAFAC
      INTEGER LIWFAC, STRAT, TYPEFile, NextPiv2beWritten,               &
     &        IDUMMY
      TYPE(IO_BLOCK) :: MonBloc
      LOGICAL LAST_CALL
      INTEGER PP_FIRST2SWAP_L, IFLAG_OOC
      INTEGER PP_LastPIVRPTRFilled
      EXTERNAL DAGMG_MUMPS_223, DAGMG_MUMPS_235,                                  &
     &         DAGMG_MUMPS_227, DAGMG_MUMPS_294,                                  &
     &         DAGMG_MUMPS_44
      LOGICAL STATICMODE
      DOUBLE PRECISION SEUIL_LOC
      INTEGER PIVSIZ,IWPOSPIV
      DOUBLE PRECISION ONE
      PARAMETER (ONE = 1.0D0)
      INOPV = 0
      IF(KEEP(97) .EQ. 0) THEN
         STATICMODE = .FALSE.
      ELSE
         STATICMODE = .TRUE.
      ENDIF
      IF (AVOID_DELAYED) THEN
        STATICMODE = .TRUE.
        UUTEMP=UU
        SEUIL_LOC = max(SEUIL,epsilon(SEUIL))
      ELSE
        SEUIL_LOC=SEUIL
        UUTEMP=UU
      ENDIF
      RESET_TO_ONE = ((KEEP(110).GT.0).AND.(DKEEP(2).LE.0.0D0))
      IF (RESET_TO_ONE) THEN
        K109_ON_ENTRY = KEEP(109)
      ENDIF
      IBEG_BLOCK=1
      NB_BLOC_FAC = 0
      IOLDPS = PTLUST_S(STEP( INODE ))
      POSELT = PTRAST( STEP( INODE ))
      NFRONT = IW(IOLDPS+KEEP(IXSZ))
      NASS   = iabs(IW(IOLDPS+2+KEEP(IXSZ)))
      LDAFS  = NASS
      IF (NASS .GT. KEEP(3)) THEN
        NBOLKJ = min( KEEP(6), NASS )
      ELSE
        NBOLKJ = min( KEEP(5), NASS )
      ENDIF
      NBTLKJ = NBOLKJ
      IW(IOLDPS+3+KEEP(IXSZ)) = min0(NASS,NBTLKJ)
      IF (KEEP(201).EQ.1) THEN
        IDUMMY    = -9876
        CALL AGMG_MUMPS_729(LAFAC,IW(IOLDPS+XXR))
        LIWFAC    = IW(IOLDPS+XXI)
        TYPEFile  = TYPEF_L
        NextPiv2beWritten = 1
        PP_FIRST2SWAP_L = NextPiv2beWritten
        MonBloc%LastPanelWritten_L = 0
        MonBloc%INODE    = INODE
        MonBloc%MASTER   = .TRUE.
        MonBloc%Typenode = 2
        MonBloc%NROW     = NASS
        MonBloc%NCOL     = NASS
        MonBloc%NFS      = NASS
        MonBloc%Last     = .FALSE.
        MonBloc%LastPiv  = -66666
        MonBloc%INDICES =>                                              &
     &  IW(IOLDPS+6+NFRONT+KEEP(IXSZ)+IW(IOLDPS+5+KEEP(IXSZ))           &
     &    :IOLDPS+5+2*NFRONT+KEEP(IXSZ)+IW(IOLDPS+5+KEEP(IXSZ)))
      ENDIF
      ALLOCATE( IPIV( NASS ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        WRITE(*,*) MYID,' : FACTO_NIV2 :failed to allocate ',NASS,      &
     & ' integers'
        IFLAG=-13
        IERROR=NASS
        GO TO 490
      END IF
   50 CONTINUE
      IBEGKJI = IBEG_BLOCK
      CALL DAGMG_MUMPS_223(                                                  &
     &                NFRONT,NASS,IBEGKJI, NASS, IPIV,                  &
     &                N,INODE,IW,LIW,A,LA,NOFFW,INOPV,                  &
     &                IFLAG,IOLDPS,POSELT,UU, SEUIL_LOC,                &
     &                KEEP,KEEP8,PIVSIZ,                                &
     &           DKEEP(1),PIVNUL_LIST(1),LPN_LIST,                      &
     &           PP_FIRST2SWAP_L, MonBloc%LastPanelWritten_L,           &
     &           PP_LastPIVRPTRFilled)
      IF (IFLAG.LT.0) GOTO 490
      IF(KEEP(109).GT. 0) THEN
         IF(PIVNUL_LIST(KEEP(109)).EQ.-1) THEN
            IWPOSPIV = IOLDPS+IW(IOLDPS+1+KEEP(IXSZ))+6                 &
     &              +IW(IOLDPS+5+KEEP(IXSZ))
            PIVNUL_LIST(KEEP(109)) = IW(IWPOSPIV+KEEP(IXSZ))
         ENDIF
      ENDIF
         IF(INOPV.EQ. 1 .AND. STATICMODE) THEN
            INOPV = -1
            GOTO 50
         ENDIF
      IF (INOPV.GE.1) THEN
          LASTBL = (INOPV.EQ.1)
          IEND = IW(IOLDPS+1+KEEP(IXSZ))
          CALL DAGMG_MUMPS_294( COMM_LOAD, ASS_IRECV,                        &
     &             N, INODE, FPERE, IW, LIW,                            &
     &             IOLDPS, POSELT, A, LA, LDAFS,                        &
     &             IBEGKJI, IEND, IPIV, NASS,LASTBL, NB_BLOC_FAC,       &
     &             COMM, MYID, BUFR, LBUFR, LBUFR_BYTES,NBFIN,LEAF,     &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
     &             PIMASTER, PAMASTER,                                  &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF ( IFLAG .LT. 0 ) GOTO 500
      ENDIF
      IF (INOPV.EQ.1) GO TO 500
      IF (INOPV.EQ.2) THEN
         CALL DAGMG_MUMPS_235(IBEG_BLOCK,                                    &
     &            NASS,N,INODE,IW,LIW,A,LA,                             &
     &            LDAFS,                                                &
     &            IOLDPS,POSELT,NBOLKJ, NBTLKJ,KEEP(4),KEEP,KEEP8)
         GOTO 50
      ENDIF
      NPVW = NPVW + PIVSIZ
      IF (NASS.LE.1) THEN
        IFINB = -1
        IF (NASS == 1) A(POSELT)=ONE/A(POSELT)
      ELSE
         CALL DAGMG_MUMPS_227(IBEG_BLOCK,                                    &
     &             NASS, N,INODE,IW,LIW,A,LA,                           &
     &             LDAFS, IOLDPS,POSELT,IFINB,                          &
     &             NBTLKJ,KEEP(4),PIVSIZ,KEEP(IXSZ))
         IF(PIVSIZ .EQ. 2) THEN
            IWPOSPIV = IOLDPS+KEEP(IXSZ)+IW(IOLDPS+1+KEEP(IXSZ))+6+     &
     &                 IW(IOLDPS+5+KEEP(IXSZ))
            IW(IWPOSPIV+NFRONT) = -IW(IWPOSPIV+NFRONT)
         ENDIF
      ENDIF
      IW(IOLDPS+1+KEEP(IXSZ)) = IW(IOLDPS+1+KEEP(IXSZ)) + PIVSIZ
       IF (IFINB.EQ.0) GOTO 50
       IF ((IFINB.EQ.1).OR.(IFINB.EQ.-1)) THEN
          LASTBL = (IFINB.EQ.-1)
          IEND = IW(IOLDPS+1+KEEP(IXSZ))
          CALL DAGMG_MUMPS_294(COMM_LOAD, ASS_IRECV,                         &
     &             N, INODE, FPERE, IW, LIW,                            &
     &             IOLDPS, POSELT, A, LA, LDAFS,                        &
     &             IBEGKJI, IEND, IPIV, NASS, LASTBL,NB_BLOC_FAC,       &
     &             COMM, MYID, BUFR, LBUFR,LBUFR_BYTES,NBFIN,LEAF,      &
     &             IFLAG, IERROR, IPOOL,LPOOL,                          &
     &             SLAVEF, POSFAC, IWPOS, IWPOSCB, IPTRLU, LRLU,        &
     &             LRLUS, COMP,                                         &
     &             PTRIST, PTRAST, PTLUST_S, PTRFAC, STEP,              &
     &             PIMASTER, PAMASTER,                                  &
     &             NSTK_S,NBPROCFILS,PROCNODE_STEPS, root,              &
     &             OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,         &
     &             INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE,        &
     &             LPTRAR, NELT, FRTPTR, FRTELT,                        &
     &             ISTEP_TO_INIV2, TAB_POS_IN_PERE )
          IF ( IFLAG .LT. 0 ) GOTO 500
       ENDIF
       IF (IFINB.EQ.(-1)) GOTO 500
       NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
       IF (KEEP(201).EQ.1) THEN
        IF (.NOT.RESET_TO_ONE.OR.K109_ON_ENTRY.EQ.KEEP(109)) THEN
         MonBloc%Last   = .FALSE.
         MonBloc%LastPiv= NPIV
         LAST_CALL=.FALSE.
         CALL DAGMG_MUMPS_688(                                               &
     &        STRAT_TRY_WRITE,                                          &
     &        TYPEFile, A(POSELT),                                      &
     &        LAFAC, MonBloc, NextPiv2beWritten, IDUMMY, IW(IOLDPS),    &
     &        LIWFAC, MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
         IF (IFLAG_OOC .LT. 0 ) IFLAG = IFLAG_OOC
         IF (IFLAG .LT. 0 ) RETURN
        ENDIF
       ENDIF
      CALL DAGMG_MUMPS_235(IBEG_BLOCK,                                       &
     &            NASS,N,INODE,IW,LIW,A,LA,                             &
     &            LDAFS,                                                &
     &            IOLDPS,POSELT,NBOLKJ,NBTLKJ,KEEP(4),KEEP,KEEP8)
      IF (KEEP(201).EQ.1) THEN
         IF (RESET_TO_ONE.AND.K109_ON_ENTRY.LT.KEEP(109)) THEN
          IDEB =  IOLDPS+KEEP(IXSZ)+IW(IOLDPS+5+KEEP(IXSZ))+6
          JJ= IDEB
          TO_UPDATE=.FALSE.
          DO K = K109_ON_ENTRY+1, KEEP(109)
           I = PIVNUL_LIST(K)
           DO J=JJ,JJ+NASS
            IF (IW(J).EQ.I) THEN
              TO_UPDATE=.TRUE.
              EXIT
            ENDIF
           ENDDO
           IF (TO_UPDATE) THEN
            JJ= J
            J =  J-IDEB+1
            A(POSELT+int(J-1,8)+int(LDAFS,8)*int(J-1,8))= ONE
            TO_UPDATE=.FALSE.
           ELSE
            IF (ICNTL(1).GT.0) THEN
             write(ICNTL(1),*) ' Internal error related ',              &
     &                 'to null pivot row detection'
            ENDIF
            EXIT
           ENDIF
          ENDDO
         ENDIF
         K109_ON_ENTRY = KEEP(109)
         MonBloc%Last   = .FALSE.
         MonBloc%LastPiv= NPIV
         LAST_CALL=.FALSE.
         CALL DAGMG_MUMPS_688(                                               &
     &        STRAT_TRY_WRITE,                                          &
     &        TYPEFile, A(POSELT),                                      &
     &        LAFAC, MonBloc, NextPiv2beWritten, IDUMMY, IW(IOLDPS),    &
     &        LIWFAC, MYID, KEEP8(31), IFLAG_OOC,LAST_CALL )
         IF (IFLAG_OOC .LT. 0 ) IFLAG = IFLAG_OOC
         IF (IFLAG .LT. 0 ) RETURN
      ENDIF
      GO TO 50
  490 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  500 CONTINUE
      IF (RESET_TO_ONE.AND.K109_ON_ENTRY.LT.KEEP(109)) THEN
       IDEB =  IOLDPS+KEEP(IXSZ)+IW(IOLDPS+5+KEEP(IXSZ))+6
       JJ= IDEB
       TO_UPDATE=.FALSE.
       DO K = K109_ON_ENTRY+1, KEEP(109)
        I = PIVNUL_LIST(K)
        DO J=JJ,JJ+NASS
         IF (IW(J).EQ.I) THEN
           TO_UPDATE=.TRUE.
           EXIT
         ENDIF
        ENDDO
        IF (TO_UPDATE) THEN
            JJ= J
           J =  J-IDEB+1
           A(POSELT+int(J-1,8)+int(LDAFS,8)*int(J-1,8))= ONE
           TO_UPDATE=.FALSE.
        ELSE
        IF (ICNTL(1).GT.0) THEN
         write(ICNTL(1),*) ' Internal error related ',                  &
     &                'to null pivot row detection'
        ENDIF
         EXIT
        ENDIF
       ENDDO
      ENDIF
      IF (KEEP(201).EQ.1) THEN
          STRAT        = STRAT_WRITE_MAX
          MonBloc%Last = .TRUE.
          MonBloc%LastPiv  = IW(IOLDPS+1+KEEP(IXSZ))
          LAST_CALL = .TRUE.
          CALL DAGMG_MUMPS_688                                               &
     &          ( STRAT, TYPEFile,                                      &
     &           A(POSELT), LAFAC, MonBloc,                             &
     &           NextPiv2beWritten, IDUMMY,                             &
     &           IW(IOLDPS), LIWFAC,                                    &
     &           MYID, KEEP8(31), IFLAG_OOC, LAST_CALL )
         IF (IFLAG_OOC .LT. 0 ) IFLAG = IFLAG_OOC
         IF (IFLAG .LT. 0 ) RETURN
          CALL DAGMG_MUMPS_644(IWPOS,                                        &
     &      IOLDPS, IW, LIW, MonBloc , NFRONT, KEEP)
      ENDIF
      DEALLOCATE( IPIV )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_141
      SUBROUTINE DAGMG_MUMPS_223( NFRONT, NASS,                              &
     &                   IBEGKJI, NASS2, TIPIV,                         &
     &                   N, INODE, IW, LIW,                             &
     &                   A, LA, NNEG,                                   &
     &                   INOPV, IFLAG,                                  &
     &                   IOLDPS, POSELT, UU,                            &
     &                   SEUIL,KEEP,KEEP8,PIVSIZ,                       &
     &                   DKEEP,PIVNUL_LIST,LPN_LIST,                    &
     &                   PP_FIRST2SWAP_L, PP_LastPanelonDisk,           &
     &                   PP_LastPIVRPTRIndexFilled)
      IMPLICIT NONE
      INTEGER NFRONT,NASS,N,LIW,INODE,IFLAG,INOPV
      INTEGER NASS2, IBEGKJI, NNEG
      INTEGER TIPIV( NASS2 )
      INTEGER PIVSIZ,LPIV
      INTEGER(8) :: LA
      DOUBLE PRECISION A(LA)
      DOUBLE PRECISION UU, UULOC, SEUIL
      INTEGER IW(LIW)
      INTEGER   IOLDPS
      INTEGER(8) :: POSELT
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER LPN_LIST
      INTEGER PIVNUL_LIST(LPN_LIST)
      DOUBLE PRECISION DKEEP(30)
      INTEGER PP_FIRST2SWAP_L, PP_LastPanelonDisk
      INTEGER PP_LastPIVRPTRIndexFilled
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER(8) :: POSPV1,POSPV2,OFFDAG,APOSJ
      INTEGER JMAX
      DOUBLE PRECISION RMAX,AMAX,TMAX,SWOP,TOL
      DOUBLE PRECISION DELTA,MAXPIV
      DOUBLE PRECISION PIVOT,DETPIV
      PARAMETER(TOL = 1.0D-20)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER(8) :: APOSMAX
      INTEGER(8) :: APOS
      INTEGER(8) :: J1, J2, JJ, KK
      INTEGER    :: LDAFS
      INTEGER(8) :: LDAFS8
      DOUBLE PRECISION ZERO,ONE
      DOUBLE PRECISION PIVNUL,FIXA
      INTEGER NPIV,NASSW,IPIV
      INTEGER NPIVP1,ILOC,K,J
      INTRINSIC max
      DATA ZERO /0.0D0/
      DATA ONE /1.0D0/
      INTEGER I_PIVRPTR, I_PIVR, NBPANELS_L
      PIVNUL = DKEEP(1)
      FIXA = DKEEP(2)
      LDAFS  = NASS
      LDAFS8 = int(LDAFS,8)
      IF (KEEP(201).EQ.1 .AND. KEEP(50).NE.1) THEN
        CALL DAGMG_MUMPS_667(1, NBPANELS_L,                                  &
     &       I_PIVRPTR, I_PIVR,                                         &
     &       IOLDPS+2*NFRONT+6+IW(IOLDPS+5+KEEP(IXSZ))                  &
     &              +KEEP(IXSZ),                                        &
     &       IW, LIW)
      ENDIF
        UULOC = UU
        PIVSIZ = 1
        NPIV    = IW(IOLDPS+1+KEEP(IXSZ))
        NPIVP1  = NPIV + 1
        ILOC = NPIVP1 - IBEGKJI + 1
        TIPIV( ILOC ) = ILOC
        NASSW   = iabs(IW(IOLDPS+3+KEEP(IXSZ)))
        APOSMAX = POSELT+LDAFS8*LDAFS8-1_8
        IF(INOPV .EQ. -1) THEN
           APOS = POSELT + LDAFS8*int(NPIVP1-1,8) + int(NPIV,8)
           POSPV1 = APOS
           IF(abs(A(APOS)).LT.SEUIL) THEN
              IF(dble(A(APOS)) .GE. ZERO) THEN
                 A(APOS) = dble(SEUIL)
              ELSE
                 A(APOS) = dble(-SEUIL)
              ENDIF
              KEEP(98) = KEEP(98)+1
           ENDIF
           IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
             CALL DAGMG_MUMPS_680( IW(I_PIVRPTR), NBPANELS_L,                &
     &               IW(I_PIVR), NASS, NPIVP1, NPIVP1,                  &
     &               PP_LastPanelonDisk,                                &
     &               PP_LastPIVRPTRIndexFilled)
           ENDIF
           GO TO 420
        ENDIF
        INOPV   = 0
        DO 460 IPIV=NPIVP1,NASSW
            APOS = POSELT + LDAFS8*int(IPIV-1,8) + int(NPIV,8)
            POSPV1 = APOS + int(IPIV - NPIVP1,8)
            PIVOT = A(POSPV1)
            IF (UULOC.EQ.ZERO) THEN
              IF (abs(A(APOS)).EQ.ZERO) GO TO 630
              IF (A(APOS).LT.ZERO) NNEG = NNEG+1
              GO TO 420
            ENDIF
            AMAX = ZERO
            JMAX = 0
            J1 = APOS
            J2 = POSPV1 - 1_8
            DO JJ=J1,J2
               IF(abs(A(JJ)) .GT. AMAX) THEN
                  AMAX = abs(A(JJ))
                  JMAX = IPIV - int(POSPV1-JJ)
               ENDIF
            ENDDO
            J1 = POSPV1 + LDAFS8
            DO J=1, NASSW - IPIV
               IF(abs(A(J1)) .GT. AMAX) THEN
                  AMAX = max(abs(A(J1)),AMAX)
                  JMAX = IPIV + J
               ENDIF
               J1 = J1 + LDAFS8
            ENDDO
            IF (KEEP(219).NE.0) THEN
             RMAX = dble(A(APOSMAX+int(IPIV,8)))
            ELSE
             RMAX = ZERO
            ENDIF
            DO J=1,NASS - NASSW
               RMAX = max(abs(A(J1)),RMAX)
               J1 = J1 + LDAFS8
            ENDDO
         IF (max(AMAX,RMAX,abs(PIVOT)).LE.PIVNUL) THEN
            KEEP(109) = KEEP(109)+1
            PIVNUL_LIST(KEEP(109)) = -1
            IF(FIXA.GT.ZERO) THEN
               IF(dble(PIVOT) .GE. ZERO) THEN
                  A(POSPV1) = dble(FIXA)
               ELSE
                  A(POSPV1) = dble(-FIXA)
               ENDIF
            ELSE
               J1 = APOS
               J2 = POSPV1 - 1_8
               DO JJ=J1,J2
                  A(JJ) = dble(ZERO)
               ENDDO
               J1 = POSPV1 + LDAFS8
               DO J=1, NASSW - IPIV
                  A(J1) = dble(ZERO)
                  J1 = J1 + LDAFS8
               ENDDO
               DO J=1,NASS - NASSW
                  A(J1) = dble(ZERO)
                  J1 = J1 + LDAFS8
               ENDDO
                A(POSPV1) = dble(                                       &
     &                        max(1.0D10*RMAX, sqrt(huge(RMAX))/1.0D8)  &
     &                           )
            ENDIF
            PIVOT = A(POSPV1)
            GO TO 415
         ENDIF
        IF ((KEEP(19).EQ.0).AND.(KEEP(110).EQ.0)) THEN
         IF (max(AMAX,RMAX,abs(PIVOT)).LE.TOL) THEN
            IF(SEUIL .GT. epsilon(SEUIL)) THEN
               IF(dble(PIVOT) .GE. ZERO) THEN
                  A(POSPV1) = dble(SEUIL)
               ELSE
                  A(POSPV1) = dble(-SEUIL)
                  NNEG = NNEG+1
               ENDIF
               PIVOT = A(POSPV1)
               WRITE(*,*) 'WARNING matrix may be singular'
               KEEP(98) = KEEP(98)+1
               GO TO 415
            ENDIF
         ENDIF
        ENDIF
        IF (max(AMAX,abs(PIVOT)) .LE. TOL) GOTO 460
        IF (abs(PIVOT).GT.max(UULOC*max(RMAX,AMAX),SEUIL)) THEN
           IF (A(POSPV1).LT.ZERO) NNEG = NNEG+1
               GO TO 415
           END IF
            IF (AMAX.LE.TOL) GO TO 460
            IF (RMAX.LT.AMAX) THEN
               J1 = APOS
               J2 = POSPV1 - 1_8
               DO JJ=J1,J2
                  IF(int(POSPV1-JJ) .NE. IPIV-JMAX) THEN
                     RMAX = max(RMAX,abs(A(JJ)))
                  ENDIF
               ENDDO
               J1 = POSPV1 + LDAFS8
               DO J=1,NASS-IPIV
                  IF(IPIV+J .NE. JMAX) THEN
                     RMAX = max(abs(A(J1)),RMAX)
                  ENDIF
                  J1 = J1 + LDAFS8
               ENDDO
            ENDIF
            APOSJ = POSELT + int(JMAX-1,8)*LDAFS8 + int(NPIV,8)
            POSPV2 = APOSJ + int(JMAX - NPIVP1,8)
            IF (IPIV.LT.JMAX) THEN
               OFFDAG = APOSJ + int(IPIV - NPIVP1,8)
            ELSE
               OFFDAG = APOS + int(JMAX - NPIVP1,8)
            END IF
            IF (KEEP(219).NE.0) THEN
             TMAX = max(SEUIL/UULOC,dble(A(APOSMAX+int(JMAX,8))))
            ELSE
             TMAX = SEUIL/UULOC
            ENDIF
            IF(JMAX .LT. IPIV) THEN
               JJ = POSPV2
               DO K = 1, NASS-JMAX
                  JJ = JJ+int(NASS,8)
                  IF (JMAX+K.NE.IPIV) THEN
                     TMAX=max(TMAX,abs(A(JJ)))
                  ENDIF
               ENDDO
               DO KK =  APOSJ, POSPV2-1_8
                  TMAX = max(TMAX,abs(A(KK)))
               ENDDO
            ELSE
               JJ = POSPV2
               DO K = 1, NASS-JMAX
                  JJ = JJ+int(NASS,8)
                  TMAX=max(TMAX,abs(A(JJ)))
               ENDDO
               DO KK =  APOSJ, POSPV2 - 1_8
                  IF (KK.NE.OFFDAG) THEN
                     TMAX = max(TMAX,abs(A(KK)))
                  ENDIF
               ENDDO
            ENDIF
            DETPIV = A(POSPV1)*A(POSPV2) - A(OFFDAG)**2
            IF (SEUIL.GT.ZERO) THEN
               IF (sqrt(abs(DETPIV)) .LE. SEUIL ) GOTO 460
            ENDIF
            MAXPIV = max(abs(A(POSPV1)),abs(A(POSPV2)))
            IF (MAXPIV.EQ.ZERO) MAXPIV = ONE
            IF (abs(DETPIV)/MAXPIV.LE.TOL) GO TO 460
            IF ((abs(A(POSPV2))*RMAX+AMAX*TMAX)*UULOC.GT.               &
     &           abs(DETPIV)) GO TO 460
            IF ((abs(A(POSPV1))*TMAX+AMAX*RMAX)*UULOC.GT.               &
     &           abs(DETPIV)) GO TO 460
           PIVSIZ = 2
           KEEP(105) = KEEP(105)+1
           IF(DETPIV .LT. ZERO) THEN
             NNEG = NNEG+1
           ELSE IF(A(POSPV2) .LT. ZERO) THEN
             NNEG = NNEG+2
           ENDIF
  415      CONTINUE
           DO K=1,PIVSIZ
              IF (PIVSIZ .EQ. 2 ) THEN
                IF (K==1) THEN
                  LPIV = min(IPIV, JMAX)
                  TIPIV(ILOC) = -(LPIV - IBEGKJI + 1)
                ELSE
                  LPIV = max(IPIV, JMAX)
                  TIPIV(ILOC+1) = -(LPIV - IBEGKJI + 1)
                ENDIF
              ELSE
                LPIV = IPIV
                TIPIV(ILOC) = IPIV - IBEGKJI + 1
              ENDIF
              IF (LPIV.EQ.NPIVP1) THEN
                 GOTO 416
              ENDIF
              CALL DAGMG_MUMPS_319( A, LA, IW, LIW,                          &
     &             IOLDPS, NPIVP1, LPIV, POSELT, NASS,                  &
     &             LDAFS, NFRONT, 2, KEEP(219), KEEP(50),               &
     &             KEEP(IXSZ))
  416         CONTINUE
              IF (KEEP(201).EQ.1.AND.KEEP(50).NE.1) THEN
                CALL DAGMG_MUMPS_680( IW(I_PIVRPTR), NBPANELS_L,             &
     &               IW(I_PIVR), NASS, NPIVP1, LPIV, PP_LastPanelonDisk,&
     &               PP_LastPIVRPTRIndexFilled)
              ENDIF
              NPIVP1 = NPIVP1+1
           ENDDO
           IF(PIVSIZ .EQ. 2) THEN
              A(POSELT+LDAFS8*int(NPIV,8)+int(NPIV+1,8)) = DETPIV
           ENDIF
           GOTO 420
  460   CONTINUE
      IF (NASSW.EQ.NASS) THEN
       INOPV = 1
      ELSE
       INOPV = 2
      ENDIF
      GO TO 420
  630 CONTINUE
      IFLAG = -10
  420 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_223
      SUBROUTINE DAGMG_MUMPS_235(                                            &
     &                 IBEG_BLOCK,                                      &
     &                 NASS, N, INODE,                                  &
     &                 IW, LIW, A, LA,                                  &
     &                 LDAFS,                                           &
     &                 IOLDPS, POSELT,                                  &
     &                 LKJIB_ORIG, LKJIB, LKJIT, KEEP,KEEP8 )
      IMPLICIT NONE
      INTEGER NASS,N,LIW
      INTEGER(8) :: LA
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      INTEGER LKJIB_ORIG, LKJIB, INODE, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER (8) :: POSELT
      INTEGER (8) :: LDAFS8
      INTEGER LDAFS, IBEG_BLOCK
      INTEGER IOLDPS, NPIV, JROW2, NPBEG
      INTEGER NONEL, LKJIW, NEL1
      INTEGER HF
      INTEGER(8) :: LPOS,UPOS,APOS
      INTEGER LKJIT
      INTEGER LKJIBOLD, IROW
      INTEGER J, Block
      INTEGER BLSIZE
      DOUBLE PRECISION ONE, ALPHA
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LDAFS8 = int(LDAFS,8)
      LKJIBOLD = LKJIB
      NPIV   = IW(IOLDPS+1+KEEP(IXSZ))
      JROW2  = iabs(IW(IOLDPS+3+KEEP(IXSZ)))
      NPBEG  = IBEG_BLOCK
      HF     = 6 + IW(IOLDPS+5+KEEP(IXSZ)) + KEEP(IXSZ)
      NEL1   = NASS - JROW2
      LKJIW  = NPIV - NPBEG + 1
      IF ( LKJIW .NE. LKJIB ) THEN
        NONEL         = JROW2 - NPIV + 1
        IF ((NASS-NPIV).GE.LKJIT) THEN
          LKJIB       = LKJIB_ORIG + NONEL
          IW(IOLDPS+3+KEEP(IXSZ))= min0(NPIV+LKJIB,NASS)
          LKJIB       = min0(LKJIB, NASS - NPIV)
        ELSE
          LKJIB = NASS - NPIV
          IW(IOLDPS+3+KEEP(IXSZ)) = NASS
        ENDIF
      ELSEIF (JROW2.LT.NASS) THEN
          IW(IOLDPS+3+KEEP(IXSZ)) = min0(JROW2+LKJIB,NASS)
      ENDIF
      IBEG_BLOCK = NPIV + 1
      IF (LKJIW.EQ.0) GO TO 500
      IF (NEL1.NE.0) THEN
        IF ( NASS - JROW2 > KEEP(7) ) THEN
          BLSIZE = KEEP(8)
        ELSE
          BLSIZE = NASS - JROW2
        END IF
        IF ( NASS - JROW2 .GT. 0 ) THEN
         DO IROW = JROW2+1, NASS, BLSIZE
          Block = min( BLSIZE, NASS - IROW + 1 )
          LPOS = POSELT + int(IROW - 1,8) * LDAFS8 + int(NPBEG - 1,8)
          UPOS = POSELT + int(NPBEG - 1,8) * LDAFS8 + int(IROW - 1,8)
          APOS =  POSELT + int(IROW-1,8) * LDAFS8 + int(IROW - 1,8)
          DO J=1, Block
            CALL DGEMV( 'T', LKJIW, Block - J + 1, ALPHA,               &
     &                  A( LPOS ), LDAFS, A( UPOS ), LDAFS,             &
     &                  ONE, A( APOS ), LDAFS )
            LPOS = LPOS + LDAFS8
            APOS = APOS + LDAFS8 + 1_8
            UPOS = UPOS + 1_8
          END DO
          LPOS = POSELT + int(IROW-1+Block,8) * LDAFS8                  &
     &                  + int(NPBEG-1,8)
          UPOS = POSELT + int(NPBEG-1,8) * LDAFS8 + int(IROW-1,8)
          APOS = POSELT + int( IROW - 1 + Block,8 ) * LDAFS8            &
     &                  + int(IROW - 1,8)
          CALL DGEMM( 'N','N', Block, NASS - IROW + 1 - Block, LKJIW,   &
     &                ALPHA, A( UPOS ), LDAFS,                          &
     &                A( LPOS ), LDAFS, ONE, A( APOS ), LDAFS )
         END DO
        END IF
      END IF
  500 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_235
      SUBROUTINE DAGMG_MUMPS_227                                             &
     &     ( IBEG_BLOCK, NASS, N, INODE, IW, LIW,                       &
     &     A, LA, LDAFS,                                                &
     &     IOLDPS,POSELT,IFINB,LKJIB,LKJIT,PIVSIZ,                      &
     &     XSIZE)
      IMPLICIT NONE
      INTEGER(8) :: LA, POSELT
      INTEGER    :: LIW
      DOUBLE PRECISION    A(LA)
      INTEGER IW(LIW)
      DOUBLE PRECISION    VALPIV
      INTEGER IOLDPS, NCB1
      INTEGER LKJIT, IBEG_BLOCK
      INTEGER NPIV,JROW2
      INTEGER(8) :: APOS
      INTEGER(8) :: LPOS, LPOS1, LPOS2, K1POS
      INTEGER(8) :: JJ, K1, K2
      INTEGER(8) :: POSPV1, POSPV2, OFFDAG, OFFDAG_OLD
      INTEGER(8) :: LDAFS8
      INTEGER NASS,N,INODE,IFINB,LKJIB,LDAFS,                           &
     &        NPBEG
      INTEGER NEL2
      INTEGER XSIZE
      DOUBLE PRECISION ONE, ALPHA
      DOUBLE PRECISION  ZERO
      INTEGER PIVSIZ,NPIV_NEW
      INTEGER(8) :: IBEG, IEND, IROW
      INTEGER    :: J2
      DOUBLE PRECISION SWOP,DETPIV,MULT1,MULT2
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
      PARAMETER (ZERO = 0.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LDAFS8 = int(LDAFS,8)
      NPIV   = IW(IOLDPS+1+XSIZE)
      NPIV_NEW = NPIV + PIVSIZ
      IFINB  = 0
      IF (IW(IOLDPS+3+XSIZE).LE.0) THEN
         IW(IOLDPS+3+XSIZE) = min0(NASS,LKJIB)
      ENDIF
      JROW2 = IW(IOLDPS+3+XSIZE)
      NPBEG = IBEG_BLOCK
      NEL2   = JROW2 - NPIV_NEW
      IF (NEL2.EQ.0) THEN
        IF (JROW2.EQ.NASS) THEN
          IFINB        = -1
        ELSE
          IFINB        = 1
        ENDIF
      ENDIF
      IF(PIVSIZ .EQ. 1) THEN
         APOS   = POSELT + int(NPIV,8)*(LDAFS8 + 1_8)
         VALPIV = ONE/A(APOS)
         A(APOS) = VALPIV
         LPOS   = APOS + LDAFS8
         CALL DCOPY(NASS-NPIV_NEW, A(LPOS), LDAFS, A(APOS+1_8), 1)
         CALL DAGMG_MUMPS_XSYR('U', NEL2, -VALPIV, A(LPOS), LDAFS,           &
     &        A(LPOS+1_8), LDAFS)
         CALL DSCAL(NASS-NPIV_NEW, VALPIV, A(LPOS), LDAFS)
         IF (NEL2.GT.0) THEN
            K1POS = LPOS + int(NEL2,8)*LDAFS8
            NCB1  = NASS - JROW2
            CALL DGER(NEL2, NCB1 , ALPHA, A(APOS+1_8), 1,               &
     &           A(K1POS), LDAFS, A(K1POS+1_8), LDAFS)
         ENDIF
      ELSE
         POSPV1 = POSELT + int(NPIV,8)*(LDAFS8 + 1_8)
         POSPV2 = POSPV1+LDAFS8+1_8
         OFFDAG_OLD = POSPV2 - 1_8
         OFFDAG = POSPV1+1_8
         SWOP = A(POSPV2)
         DETPIV = A(OFFDAG)
         A(POSPV2) = A(POSPV1)/DETPIV
         A(POSPV1) = SWOP/DETPIV
         A(OFFDAG) = -A(OFFDAG_OLD)/DETPIV
         A(OFFDAG_OLD) = dble(ZERO)
         LPOS1   = POSPV2 + LDAFS8 - 1_8
         LPOS2   = LPOS1 + 1_8
         CALL DCOPY(NASS-NPIV_NEW, A(LPOS1), LDAFS, A(POSPV1+2_8), 1)
         CALL DCOPY(NASS-NPIV_NEW, A(LPOS2), LDAFS, A(POSPV2+1_8), 1)
         JJ = POSPV2 + int(NASS-1,8)
         IBEG = JJ + 2_8
         IEND = IBEG
         DO J2 = 1,NEL2
            K1 = JJ
            K2 = JJ+1_8
            MULT1 = - (A(POSPV1)*A(K1)+A(OFFDAG)*A(K2))
            MULT2 = - (A(OFFDAG)*A(K1)+A(POSPV2)*A(K2))
            K1 = POSPV1+2_8
            K2 = POSPV2+1_8
            DO IROW = IBEG,IEND
               A(IROW) = A(IROW) + MULT1*A(K1) + MULT2*A(K2)
               K1 = K1 + 1_8
               K2 = K2 + 1_8
            ENDDO
            A(JJ) = -MULT1
            A(JJ+1_8) = -MULT2
            IBEG = IBEG + int(NASS,8)
            IEND = IEND + int(NASS + 1,8)
            JJ = JJ+int(NASS,8)
         ENDDO
         IEND = IEND-1_8
         DO J2 = JROW2+1,NASS
            K1 = JJ
            K2 = JJ+1_8
            MULT1 = - (A(POSPV1)*A(K1)+A(POSPV1+1_8)*A(K2))
            MULT2 = - (A(POSPV1+1_8)*A(K1)+A(POSPV2)*A(K2))
            K1 = POSPV1+2_8
            K2 = POSPV2+1_8
            DO IROW = IBEG,IEND
               A(IROW) = A(IROW) + MULT1*A(K1) + MULT2*A(K2)
               K1 = K1 + 1_8
               K2 = K2 + 1_8
            ENDDO
            A(JJ) = -MULT1
            A(JJ+1_8) = -MULT2
            IBEG = IBEG + int(NASS,8)
            IEND = IEND + int(NASS,8)
            JJ = JJ+int(NASS,8)
         ENDDO
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_227
      RECURSIVE SUBROUTINE DAGMG_MUMPS_263(                                  &
     &   COMM_LOAD, ASS_IRECV,                                          &
     &   BUFR, LBUFR,                                                   &
     &   LBUFR_BYTES, PROCNODE_STEPS, MSGSOU,                           &
     &   SLAVEF, IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, N, IW, LIW,       &
     &   A, LA, PTRIST, PTRAST, NSTK_S, NBPROCFILS,                     &
     &   COMP, STEP, PIMASTER, PAMASTER, POSFAC,                        &
     &   MYID, COMM, IFLAG, IERROR, NBFIN,                              &
     &    PTLUST_S, PTRFAC, root, OPASSW, OPELIW, ITLOC, FILS,          &
     &    PTRARW, PTRAIW, INTARR, DBLARR,                               &
     &    ICNTL, KEEP,KEEP8, IPOOL, LPOOL, LEAF, ND, FRERE_STEPS,       &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &     )
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER ICNTL( 40 ), KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER BUFR( LBUFR )
      INTEGER N, SLAVEF, IWPOS, IWPOSCB, LIW
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS, LA
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER COMP
      INTEGER IFLAG, IERROR, NBFIN, MSGSOU
      INTEGER PROCNODE_STEPS(KEEP(28)), PTRIST(KEEP(28)),               &
     &        NSTK_S(KEEP(28))
      INTEGER NBPROCFILS(KEEP(28)), STEP(N), PIMASTER(KEEP(28))
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER NELT, LPTRAR
      INTEGER FRTPTR( N + 1 ), FRTELT( NELT )
      INTEGER PTRAIW( LPTRAR ), PTRARW( LPTRAR )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER COMM, MYID
      INTEGER PTLUST_S(KEEP(28))
      INTEGER ITLOC( N ), FILS( N )
      INTEGER ND( KEEP(28) ), FRERE_STEPS( KEEP(28) )
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION OPASSW, OPELIW
      DOUBLE PRECISION FLOP1
      DOUBLE PRECISION  DBLARR( max(1,KEEP(13)) )
      INTEGER LEAF, LPOOL
      INTEGER IPOOL( LPOOL )
      INTEGER ITYPE2
      PARAMETER(ITYPE2=2)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      INTEGER INODE, IPOSK, JPOSK, NCOLU, NPIV, POSITION, IERR
      INTEGER(8) POSELT, POSBLOCFACTO
      INTEGER(8) LAELL
      INTEGER(8) MEM_GAIN
      INTEGER IOLDPS, LCONT1, NASS1, NROW1, NCOL1, NPIV1
      INTEGER NELIM1, NCOL_TO_SEND
      INTEGER LDA
      INTEGER NSLAVES_TOT, HS, DEST, NSLAVES_FOLLOW
      INTEGER FPERE
      INTEGER(8) CPOS, LPOS
      INTEGER SHIFT_LIST_ROW_SON, SHIFT_LIST_COL_SON
      INTEGER(8) :: SHIFT_VAL_SON
      LOGICAL DYNAMIC
      LOGICAL BLOCKING, SET_IRECV, MESSAGE_RECEIVED
      INTEGER allocok
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: UDYNAMIC
      DOUBLE PRECISION ONE,ALPHA
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
      DYNAMIC = .FALSE.
      POSITION  = 0
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      IF ( NPIV .LE. 0 ) THEN
      NPIV = - NPIV
        WRITE(*,*) MYID,':error, received negative NPIV in BLFAC'
        CALL AGMG_MUMPS_ABORT()
      END IF
      CALL AGMG_NOCALL('MPI_UNPACK')
      CALL AGMG_NOCALL('MPI_UNPACK')
      LAELL = int(NPIV,8) * int(NCOLU,8)
      IF ( LRLU .LT. LAELL ) THEN
        IF ( LRLUS .LT. LAELL ) THEN
          IFLAG = -9
          CALL AGMG_MUMPS_731(LAELL - LRLU, IERROR)
          GOTO 700
        END IF
        CALL DAGMG_MUMPS_94(N, KEEP(28), IW, LIW, A, LA,                     &
     &        LRLU, IPTRLU,                                             &
     &        IWPOS, IWPOSCB, PTRIST, PTRAST,                           &
     &        STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,          &
     &        KEEP(IXSZ))
        COMP = COMP+1
        IF ( LRLU .NE. LRLUS ) THEN
             WRITE(*,*) 'PB compress ass..blocfacto: LRLU,LRLUS='       &
     &       ,LRLU,LRLUS
             IF (LAELL - LRLU .GT. int(huge(IERROR),8)) THEN
               WRITE(*,*) "OVERFLOW I8, LAELL,LRLU=",LAELL, LRLU
               CALL AGMG_MUMPS_ABORT()
             ENDIF
             IFLAG = -9
             IERROR = int(LAELL - LRLU, 4)
             GOTO 700
        END IF
      END IF
      LRLU  = LRLU - LAELL
      LRLUS = LRLUS - LAELL
      KEEP8(67) = min(LRLUS, KEEP8(67))
      POSBLOCFACTO = POSFAC
      POSFAC = POSFAC + LAELL
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &                           LA-LRLUS,0_8, LAELL,KEEP,KEEP8,LRLU)
      CALL AGMG_NOCALL('MPI_UNPACK')
      IF (PTRIST(STEP( INODE )) .EQ. 0) DYNAMIC = .TRUE.
      IF ( (PTRIST(STEP( INODE )).NE.0) .AND.                           &
     &  (IPOSK + NPIV -1 .GT.                                           &
     &   IW(PTRIST(STEP(INODE))+3+KEEP(IXSZ))) )THEN
        DYNAMIC = .TRUE.
      ENDIF
      IF (DYNAMIC)  THEN
        ALLOCATE(UDYNAMIC(LAELL), stat=allocok)
        if (allocok .GT. 0) THEN
          write(*,*) MYID, ' : PB allocation U in blfac_slave '         &
     &     , LAELL
          IFLAG = -13
          CALL AGMG_MUMPS_731(LAELL,IERROR)
          GOTO 700
        endif
        UDYNAMIC(1_8:LAELL) = A(POSBLOCFACTO:POSBLOCFACTO+LAELL-1_8)
        LRLU  = LRLU + LAELL
        LRLUS = LRLUS + LAELL
        POSFAC = POSFAC - LAELL
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &          LA-LRLUS,0_8,-LAELL,KEEP,KEEP8,LRLU)
      ENDIF
      DO WHILE ( PTRIST(STEP(INODE)) .EQ. 0 )
        MSGSOU = AGMG_MUMPS_275( STEP(INODE),                                &
     &           PROCNODE_STEPS, SLAVEF )
        SET_IRECV = .FALSE.
        BLOCKING  = .TRUE.
        MESSAGE_RECEIVED = .FALSE.
        CALL DAGMG_MUMPS_329( COMM_LOAD,                                     &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    MSGSOU, MAITRE_DESC_BANDE,                                    &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
        IF ( IFLAG .LT. 0 ) GOTO 600
      ENDDO
      DO WHILE ( IPOSK + NPIV -1 .GT.                                   &
     &            IW( PTRIST(STEP( INODE )) + 3 +KEEP(IXSZ)) )
        MSGSOU = AGMG_MUMPS_275( STEP(INODE), PROCNODE_STEPS, SLAVEF )
        SET_IRECV = .FALSE.
        BLOCKING  = .TRUE.
        MESSAGE_RECEIVED = .FALSE.
        CALL DAGMG_MUMPS_329( COMM_LOAD,                                     &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    MSGSOU, BLOC_FACTO_SYM,                                       &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.  )
        IF ( IFLAG .LT. 0 ) GOTO 600
      END DO
        SET_IRECV = .TRUE.
        BLOCKING  = .FALSE.
        MESSAGE_RECEIVED = .TRUE.
        CALL DAGMG_MUMPS_329( COMM_LOAD,                                     &
     &    ASS_IRECV, BLOCKING, SET_IRECV, MESSAGE_RECEIVED,             &
     &    AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                                  &
     &    STATUS,                                                       &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU,                                       &
     &    LRLU, LRLUS, N, IW, LIW, A, LA, PTRIST,                       &
     &    PTLUST_S, PTRFAC,                                             &
     &    PTRAST, STEP, PIMASTER, PAMASTER, NSTK_S, COMP,               &
     &    IFLAG, IERROR, COMM,                                          &
     &    NBPROCFILS,                                                   &
     &    IPOOL, LPOOL, LEAF,                                           &
     &    NBFIN, MYID, SLAVEF,                                          &
     &    root, OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,            &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, ND, FRERE_STEPS,           &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE. )
      IOLDPS  = PTRIST(STEP( INODE ))
      POSELT = PTRAST(STEP( INODE ))
      LCONT1 = IW( IOLDPS + KEEP(IXSZ) )
      NROW1  = IW( IOLDPS + 2  + KEEP(IXSZ))
      NPIV1  = IW( IOLDPS + 3  + KEEP(IXSZ))
      NSLAVES_TOT = IW( IOLDPS + 5  + KEEP(IXSZ))
      HS     = 6 + NSLAVES_TOT + KEEP(IXSZ)
      NCOL1  = LCONT1 + NPIV1
      CPOS = POSELT + int(JPOSK - 1,8)
      LPOS = POSELT + int(IPOSK - 1,8)
      IF ( NPIV .GT. 0 ) THEN
       IF (DYNAMIC) THEN
        CALL DGEMM( 'T', 'N', NCOLU, NROW1, NPIV, ALPHA,                &
     &            UDYNAMIC(1), NPIV,                                    &
     &            A( LPOS ), NCOL1, ONE,                                &
     &            A( CPOS ), NCOL1 )
       ELSE
        CALL DGEMM( 'T', 'N', NCOLU, NROW1, NPIV, ALPHA,                &
     &            A( POSBLOCFACTO ), NPIV,                              &
     &            A( LPOS ), NCOL1, ONE,                                &
     &            A( CPOS ), NCOL1 )
       ENDIF
       FLOP1 = dble(NCOLU*NPIV)*dble(2*NROW1)
       FLOP1 = -FLOP1
       CALL DAGMG_MUMPS_190(1, .FALSE., FLOP1, KEEP,KEEP8 )
      ENDIF
      IW( IOLDPS + 6 + KEEP(IXSZ) ) = IW( IOLDPS + 6+ KEEP(IXSZ) ) + 1
      IF (DYNAMIC) THEN
       DEALLOCATE(UDYNAMIC)
      ELSE
        LRLU  = LRLU + LAELL
        LRLUS = LRLUS + LAELL
        POSFAC = POSFAC - LAELL
      CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                                  &
     &                      LA-LRLUS,0_8,-LAELL,KEEP,KEEP8,LRLU)
      ENDIF
      NSLAVES_FOLLOW = IW( IOLDPS + 5 +KEEP(IXSZ) ) - XTRA_SLAVES_SYM
      IF ( IW( IOLDPS + 6  +KEEP(IXSZ)) .eq. 0 .and.                    &
     &     KEEP(50) .ne. 0 .and. NSLAVES_FOLLOW .eq. 0 )                &
     &     THEN
         DEST = AGMG_MUMPS_275( STEP(INODE), PROCNODE_STEPS, SLAVEF )
         CALL DAGMG_MUMPS_62( INODE, DEST, END_NIV2_LDLT,                    &
     &                             COMM, IERR )
         IF ( IERR .LT. 0 ) THEN
           write(*,*) ' Internal error in PROCESS_BLFAC_SLAVE.'
           IFLAG = -99
           GOTO 700
         END IF
      END IF
      IF (IW(PTRIST(STEP(INODE)) + 6+KEEP(IXSZ) ) .eq. 0) THEN
        IW(PTRIST(STEP(INODE))+XXS)=S_ALL
        IF (KEEP(214).EQ.1) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2         &
     &     )
          IOLDPS = PTRIST(STEP(INODE))
          IF (KEEP(38).NE.FPERE) THEN
            IW(PTRIST(STEP(INODE))+XXS)=S_NOLCBNOCONTIG
            IF (KEEP(216).NE.3) THEN
              MEM_GAIN=int(IW( IOLDPS + 2 + KEEP(IXSZ) ),8) *           &
     &                 int(IW( IOLDPS + 3 + KEEP(IXSZ) ),8)
              LRLUS = LRLUS+MEM_GAIN
              CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                          &
     &                LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            ENDIF
          ENDIF
          IF (KEEP(216).EQ.2)THEN
           IF (FPERE.NE.KEEP(38)) THEN
            CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                   &
     &         IW( IOLDPS + 2 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) )+                           &
     &         IW( IOLDPS + KEEP(IXSZ) ), 0,                            &
     &         IW( IOLDPS + XXS ), 0_8 )
             IW(IOLDPS+XXS) = S_NOLCBCONTIG
           ENDIF
          ENDIF
        ENDIF
       IF (KEEP(38).EQ.FPERE) THEN
       NPIV1  = IW( IOLDPS + 3 +KEEP(IXSZ))
       NASS1  = IW(IOLDPS+4+KEEP(IXSZ))
       NELIM1  = NASS1-NPIV1
       NCOL_TO_SEND =  LCONT1-NELIM1
       SHIFT_LIST_ROW_SON = 6 + IW(IOLDPS+5+KEEP(IXSZ))+ KEEP(IXSZ)
       SHIFT_LIST_COL_SON = SHIFT_LIST_ROW_SON + NROW1 + NASS1
       SHIFT_VAL_SON      = int(NASS1,8)
       LDA                = LCONT1 + NPIV1
      IF (IW(IOLDPS+8+KEEP(IXSZ)).EQ.0) THEN
        IW(IOLDPS+8+KEEP(IXSZ)) = 1
      ELSE
      ENDIF
       CALL DAGMG_MUMPS_80( COMM_LOAD, ASS_IRECV,                            &
     &    N, INODE, FPERE,                                              &
     &    PTRIST, PTRAST,                                               &
     &    root, NROW1, NCOL_TO_SEND, SHIFT_LIST_ROW_SON,                &
     &    SHIFT_LIST_COL_SON , SHIFT_VAL_SON, LDA,                      &
     &    ROOT_CONT_STATIC, MYID, COMM,                                 &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK_S, COMP, IFLAG, IERROR, NBPROCFILS,                      &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8,                            &
     &    .FALSE., ND, FRERE_STEPS,                                     &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
       IF ( IFLAG < 0 ) GOTO 600
       IF (NELIM1.EQ.0) THEN
         IF (KEEP(214).EQ.2) THEN
          CALL DAGMG_MUMPS_314( N, INODE,                                    &
     &    PTRIST, PTRAST, PTLUST_S, PTRFAC, IW, LIW, A, LA,             &
     &    LRLU, LRLUS, IWPOS, IWPOSCB, POSFAC, COMP,                    &
     &    IPTRLU, OPELIW, STEP, PIMASTER, PAMASTER, ITLOC,              &
     &    IFLAG, IERROR, SLAVEF, MYID, COMM, KEEP,KEEP8, ITYPE2         &
     &       )
         ENDIF
         CALL DAGMG_MUMPS_626( N, INODE,                                     &
     &         PTRIST, PTRAST, IW, LIW, A, LA,                          &
     &         LRLU, LRLUS, IWPOSCB,                                    &
     &         IPTRLU, STEP,                                            &
     &         MYID, KEEP                                               &
     &         )
       ELSE
         IOLDPS = PTRIST(STEP(INODE))
         IF (IW(IOLDPS+8+KEEP(IXSZ)).EQ.S_ROOT2SON_CALLED) THEN
           CALL DAGMG_MUMPS_626( N, INODE,                                   &
     &         PTRIST, PTRAST, IW, LIW, A, LA,                          &
     &         LRLU, LRLUS, IWPOSCB,                                    &
     &         IPTRLU, STEP,                                            &
     &         MYID, KEEP                                               &
     &         )
         ELSE
          IW(IOLDPS+8+KEEP(IXSZ)) = 0
          IF (KEEP(214).EQ.1.AND.KEEP(216).NE.3) THEN
            IW(IOLDPS+XXS)=S_NOLCBNOCONTIG38
            CALL DAGMG_MUMPS_628( IW(IOLDPS),                                &
     &                     LIW-IOLDPS+1,                                &
     &                     MEM_GAIN, KEEP(IXSZ) )
            LRLUS = LRLUS + MEM_GAIN
            CALL DAGMG_MUMPS_471(.FALSE.,.FALSE.,                            &
     &                LA-LRLUS,0_8,-MEM_GAIN,KEEP,KEEP8,LRLU)
            IF (KEEP(216).EQ.2) THEN
              CALL DAGMG_MUMPS_627(A,LA,PTRAST(STEP(INODE)),                 &
     &         IW( IOLDPS + 2 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) )+                           &
     &         IW( IOLDPS + KEEP(IXSZ) ),                               &
     &         IW( IOLDPS + 4 + KEEP(IXSZ) ) -                          &
     &         IW( IOLDPS + 3 + KEEP(IXSZ) ),                           &
     &         IW( IOLDPS + XXS ),0_8)
              IW(IOLDPS + XXS)=S_NOLCBCONTIG38
            ENDIF
          ENDIF
         ENDIF
       ENDIF
       ENDIF
       ENDIF
  600 CONTINUE
      RETURN
  700 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_263
      SUBROUTINE DAGMG_MUMPS_38( NROW_SON, NCOL_SON, INDROW_SON,             &
     &                         INDCOL_SON, VAL_SON, VAL_ROOT,           &
     &                         LOCAL_M, LOCAL_N )
      IMPLICIT NONE
      INTEGER NCOL_SON, NROW_SON
      INTEGER INDROW_SON( NROW_SON ), INDCOL_SON( NCOL_SON )
      INTEGER LOCAL_M, LOCAL_N
      DOUBLE PRECISION VAL_SON( NCOL_SON, NROW_SON )
      DOUBLE PRECISION VAL_ROOT( LOCAL_M, LOCAL_N )
      INTEGER I, J
      DO I = 1, NROW_SON
        DO J = 1, NCOL_SON
          VAL_ROOT( INDROW_SON( I ), INDCOL_SON( J ) ) =                &
     &    VAL_ROOT( INDROW_SON( I ), INDCOL_SON( J ) ) + VAL_SON(J,I)
        END DO
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_38
      RECURSIVE SUBROUTINE DAGMG_MUMPS_80                                    &
     &  ( COMM_LOAD, ASS_IRECV, N, ISON, IROOT,                         &
     &    PTRI, PTRR,                                                   &
     &    root,                                                         &
     &    NBROW, NBCOL, SHIFT_LIST_ROW_SON,                             &
     &    SHIFT_LIST_COL_SON,                                           &
     &    SHIFT_VAL_SON, LDA, TAG,                                      &
     &    MYID, COMM,                                                   &
     &    BUFR, LBUFR, LBUFR_BYTES, PROCNODE_STEPS, POSFAC,             &
     &    IWPOS, IWPOSCB, IPTRLU, LRLU, LRLUS, IW, LIW, A, LA,          &
     &    PTRIST, PTLUST_S, PTRFAC,                                     &
     &    PTRAST, STEP, PIMASTER, PAMASTER,                             &
     &    NSTK, COMP, IFLAG, IERROR, NBPROCFILS,                        &
     &    IPOOL, LPOOL, LEAF, NBFIN, SLAVEF,                            &
     &    OPASSW, OPELIW, ITLOC, FILS, PTRARW, PTRAIW,                  &
     &    INTARR, DBLARR, ICNTL, KEEP,KEEP8, INVERT, ND, FRERE,         &
     &    LPTRAR, NELT, FRTPTR, FRTELT,                                 &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE  )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_LOAD
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER KEEP(500), ICNTL(40)
      INTEGER*8 KEEP8(150)
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER COMM_LOAD, ASS_IRECV
      INTEGER N, ISON, IROOT, TAG
      INTEGER PTRI( KEEP(28) )
      INTEGER(8) :: PTRR( KEEP(28) )
      INTEGER NBROW, NBCOL, LDA
      INTEGER(8) :: SHIFT_VAL_SON
      INTEGER SHIFT_LIST_ROW_SON, SHIFT_LIST_COL_SON
      INTEGER MYID, COMM
      LOGICAL INVERT
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER(8) :: POSFAC, IPTRLU, LRLU, LRLUS, LA
      INTEGER IWPOS, IWPOSCB
      INTEGER LIW
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER LPTRAR, NELT
      INTEGER FRTPTR( N+1 ), FRTELT( NELT )
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER(8) :: PAMASTER(KEEP(28))
      INTEGER PTRIST( KEEP(28) ), PTLUST_S(KEEP(28))
      INTEGER STEP(N), PIMASTER(KEEP(28)), NSTK( N )
      INTEGER COMP, IFLAG, IERROR
      INTEGER NBPROCFILS( KEEP(28) )
      INTEGER LPOOL, LEAF
      INTEGER IPOOL( LPOOL )
      INTEGER NBFIN, SLAVEF
      DOUBLE PRECISION OPASSW, OPELIW
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER ITLOC( N ), FILS( N ), ND( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER PTRARW( LPTRAR ), PTRAIW( LPTRAR )
      INTEGER INTARR( max(1,KEEP(14)) )
      DOUBLE PRECISION DBLARR( max(1,KEEP(13)) )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PTRROW
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PTRCOL
      INTEGER, ALLOCATABLE, DIMENSION(:) :: ROW_INDEX_LIST
      INTEGER, ALLOCATABLE, DIMENSION(:) :: COL_INDEX_LIST
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER I, POS_IN_ROOT, IROW, JCOL
      INTEGER PDEST, IERR, IERR_MPI
      INTEGER LOCAL_M, LOCAL_N
      INTEGER(8) :: POSROOT
      INTEGER NSUBSET_ROW, NSUBSET_COL
      INTEGER NRLOCAL, NCLOCAL
      LOGICAL SET_IRECV, BLOCKING, MESSAGE_RECEIVED
      INTEGER NBROWS_ALREADY_SENT
      INTEGER SIZE_MSG
      INTEGER LP
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL FLAG
      LP = ICNTL(1)
      IF ( ICNTL(4) .LE. 0 ) LP = -1
      ALLOCATE(PTRROW(root%NPROW + 1 ),  stat=allocok)
      if (allocok .GT. 0) THEN
       IFLAG  =-13
       IERROR = root%NPROW + 1
      endif
      ALLOCATE(PTRCOL(root%NPCOL + 1 ),  stat=allocok)
      if (allocok .GT. 0) THEN
       IFLAG  =-13
       IERROR = root%NPCOL + 1
      endif
      ALLOCATE(ROW_INDEX_LIST(NBROW+1),  stat=allocok)
      if (allocok .GT. 0) THEN
       IFLAG  =-13
       IERROR = NBROW + 1
      endif
      ALLOCATE(COL_INDEX_LIST(NBCOL+1),  stat=allocok)
      if (allocok .GT. 0) THEN
       IFLAG  =-13
       IERROR = NBCOL + 1
      endif
      IF (IFLAG.LT.0) THEN
         IF (LP > 0) write(6,*) MYID, ' : MEMORY ALLOCATION ',          &
     &     'FAILURE in DMUMPS_80'
         CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
         RETURN
      ENDIF
      PTRROW = 0
      PTRCOL = 0
      DO I = 1, NBROW
        POS_IN_ROOT = root%RG2L_ROW( IW( PTRI(STEP(ISON)) +             &
     &                          SHIFT_LIST_ROW_SON + I - 1 ) )
        IF ( .NOT. INVERT ) THEN
          IROW  = mod( ( POS_IN_ROOT - 1 ) / root%MBLOCK, root%NPROW )
          PTRROW ( IROW + 2 ) = PTRROW( IROW + 2 ) + 1
        ELSE
          JCOL =  mod( ( POS_IN_ROOT - 1 ) / root%NBLOCK, root%NPCOL )
          PTRCOL( JCOL + 2 ) = PTRCOL( JCOL + 2 ) + 1
        END IF
      END DO
      DO I = 1, NBCOL
        POS_IN_ROOT = root%RG2L_COL( IW( PTRI(STEP(ISON)) +             &
     &                SHIFT_LIST_COL_SON + I - 1 ) )
        IF ( .NOT. INVERT ) THEN
          JCOL        = mod( ( POS_IN_ROOT - 1 ) /                      &
     &                  root%NBLOCK, root%NPCOL )
          PTRCOL ( JCOL + 2 ) = PTRCOL( JCOL + 2 ) + 1
        ELSE
          IROW        = mod( ( POS_IN_ROOT - 1 ) /                      &
     &                  root%MBLOCK, root%NPROW )
          PTRROW ( IROW + 2 ) = PTRROW( IROW + 2 ) + 1
        END IF
      END DO
      PTRROW( 1 ) = 1
      DO IROW = 2, root%NPROW + 1
        PTRROW( IROW ) = PTRROW( IROW ) + PTRROW( IROW - 1 )
      END DO
      PTRCOL( 1 ) = 1
      DO JCOL = 2, root%NPCOL + 1
        PTRCOL( JCOL ) = PTRCOL( JCOL ) + PTRCOL( JCOL - 1 )
      END DO
      DO I = 1, NBROW
        POS_IN_ROOT = root%RG2L_ROW( IW( PTRI(STEP(ISON)) +             &
     &                          SHIFT_LIST_ROW_SON + I - 1 ) )
        IF ( .NOT. INVERT ) THEN
          IROW        = mod( ( POS_IN_ROOT - 1 ) / root%MBLOCK,         &
     &                       root%NPROW )
          ROW_INDEX_LIST( PTRROW( IROW + 1 ) ) = I
          PTRROW ( IROW + 1 ) = PTRROW( IROW + 1 ) + 1
        ELSE
          JCOL        = mod( ( POS_IN_ROOT - 1 ) / root%NBLOCK,         &
     &                       root%NPCOL )
          ROW_INDEX_LIST( PTRCOL( JCOL + 1 ) ) = I
          PTRCOL ( JCOL + 1 ) = PTRCOL( JCOL + 1 ) + 1
        END IF
      END DO
      DO I = 1, NBCOL
        POS_IN_ROOT = root%RG2L_COL( IW( PTRI(STEP(ISON)) +             &
     &                SHIFT_LIST_COL_SON + I - 1 ) )
        IF ( .NOT. INVERT ) THEN
          JCOL        = mod( ( POS_IN_ROOT - 1 ) /                      &
     &                root%NBLOCK, root%NPCOL )
          COL_INDEX_LIST( PTRCOL( JCOL + 1 ) ) = I
          PTRCOL ( JCOL + 1 ) = PTRCOL( JCOL + 1 ) + 1
        ELSE
          IROW        = mod( ( POS_IN_ROOT - 1 ) /                      &
     &                root%MBLOCK, root%NPROW )
          COL_INDEX_LIST( PTRROW( IROW + 1 ) ) = I
          PTRROW( IROW + 1 ) = PTRROW( IROW + 1 ) + 1
        END IF
      END DO
      DO IROW = root%NPROW, 2, -1
        PTRROW( IROW ) = PTRROW( IROW - 1 )
      END DO
      PTRROW( 1 ) = 1
      DO JCOL = root%NPCOL, 2, -1
        PTRCOL( JCOL ) = PTRCOL( JCOL - 1 )
      END DO
      PTRCOL( 1 ) = 1
      JCOL  = root%MYCOL
      IROW  = root%MYROW
      IF ( root%yes ) THEN
        if (IROW .ne. root%MYROW .or. JCOL.ne.root%MYCOL) then
        write(*,*) ' error in grid position buildandsendcbroot'
        CALL AGMG_MUMPS_ABORT()
        end if
        IF ( PTRIST(STEP(IROOT)).EQ.0.AND.                              &
     &       PTLUST_S(STEP(IROOT)).EQ.0) THEN
           NBPROCFILS( STEP(IROOT) ) = -1
           IF (KEEP(60) .EQ. 0) THEN
             CALL DAGMG_MUMPS_284(root, IROOT, N, IW, LIW,                   &
     &                     A, LA,                                       &
     &                     FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,  &
     &                     LRLU, IPTRLU,                                &
     &                     IWPOS, IWPOSCB, PTRIST, PTRAST,              &
     &                     STEP, PIMASTER, PAMASTER, ITLOC,             &
     &                     COMP, LRLUS, IFLAG, KEEP,KEEP8, IERROR )
              IF (IFLAG.LT.0) THEN
                CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
                RETURN
              ENDIF
           ELSE
              PTRIST(STEP(IROOT))=-66666
           ENDIF
        ELSE
           NBPROCFILS(STEP(IROOT)) = NBPROCFILS(STEP(IROOT)) - 1
           IF ( NBPROCFILS( STEP(IROOT) ) .eq. 0 ) THEN
              IF (KEEP(201).EQ.1) THEN
                 CALL DAGMG_MUMPS_681(IERR)
              ELSE IF (KEEP(201).EQ.2) THEN
                 CALL DAGMG_MUMPS_580(IERR)
              ENDIF
              CALL DAGMG_MUMPS_507(N, IPOOL, LPOOL, PROCNODE_STEPS,          &
     &        SLAVEF, KEEP(28), KEEP(76), KEEP(80), KEEP(47),           &
     &        STEP, IROOT+N )
              IF (KEEP(47) .GE. 3) THEN
                 CALL DAGMG_MUMPS_500(                                       &
     &                IPOOL, LPOOL,                                     &
     &                PROCNODE_STEPS, KEEP,KEEP8, SLAVEF, COMM_LOAD,    &
     &                MYID, STEP, N, ND, FILS )
              ENDIF
          END IF
        END IF
       IF (KEEP(60) .NE. 0 ) THEN
         LOCAL_M = root%SCHUR_LLD
         LOCAL_N = root%SCHUR_NLOC
          IF ( .NOT. INVERT ) THEN
            NRLOCAL = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
            NCLOCAL = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
            CALL DAGMG_MUMPS_285( N,                                         &
     &        root%SCHUR_POINTER(1),                                    &
     &        LOCAL_M, LOCAL_N,                                         &
     &        root%NPCOL, root%NPROW, root%MBLOCK, root%NBLOCK,         &
     &        NBCOL, NBROW,                                             &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),              &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),              &
     &        LDA, A( PTRR( STEP(ISON)) + SHIFT_VAL_SON ),              &
     &        ROW_INDEX_LIST( PTRROW( IROW + 1 ) ),                     &
     &        COL_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                     &
     &        NRLOCAL,                                                  &
     &        NCLOCAL,                                                  &
     &        root%RG2L_ROW, root%RG2L_COL, INVERT )
          ELSE
            NCLOCAL = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
            NRLOCAL = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
            CALL DAGMG_MUMPS_285( N,                                         &
     &        root%SCHUR_POINTER(1),                                    &
     &        LOCAL_M, LOCAL_N,                                         &
     &        root%NPCOL, root%NPROW, root%MBLOCK, root%NBLOCK,         &
     &        NBCOL, NBROW,                                             &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),              &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),              &
     &        LDA, A(PTRR(STEP(ISON)) + SHIFT_VAL_SON ),                &
     &        ROW_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                     &
     &        COL_INDEX_LIST( PTRROW( IROW + 1 ) ),                     &
     &        NCLOCAL,                                                  &
     &        NRLOCAL,                                                  &
     &        root%RG2L_ROW, root%RG2L_COL, INVERT )
          END IF
       ELSE
        IF ( PTRIST(STEP( IROOT )) .GE. 0 ) THEN
          IF ( PTRIST(STEP( IROOT )) .EQ. 0 ) THEN
            LOCAL_N = IW( PTLUST_S(STEP(IROOT)) + 1 + KEEP(IXSZ))
            LOCAL_M = IW( PTLUST_S(STEP(IROOT)) + 2 + KEEP(IXSZ))
            POSROOT = PTRFAC(IW( PTLUST_S(STEP(IROOT)) +4+KEEP(IXSZ) ))
          ELSE
            LOCAL_N = - IW( PTRIST(STEP(IROOT)) +KEEP(IXSZ))
            LOCAL_M = IW( PTRIST(STEP(IROOT)) + 1 +KEEP(IXSZ))
            POSROOT = PAMASTER(STEP( IROOT ))
          ENDIF
          IF ( .NOT. INVERT ) THEN
            NRLOCAL = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
            NCLOCAL = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
            CALL DAGMG_MUMPS_285( N, A( POSROOT ),                           &
     &        LOCAL_M, LOCAL_N,                                         &
     &        root%NPCOL, root%NPROW, root%MBLOCK, root%NBLOCK,         &
     &        NBCOL, NBROW,                                             &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),              &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),              &
     &        LDA, A( PTRR( STEP(ISON)) + SHIFT_VAL_SON ),              &
     &        ROW_INDEX_LIST( PTRROW( IROW + 1 ) ),                     &
     &        COL_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                     &
     &        NRLOCAL,                                                  &
     &        NCLOCAL,                                                  &
     &        root%RG2L_ROW, root%RG2L_COL, INVERT )
          ELSE
            NCLOCAL = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
            NRLOCAL = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
            CALL DAGMG_MUMPS_285( N, A( POSROOT ),                           &
     &        LOCAL_M, LOCAL_N,                                         &
     &        root%NPCOL, root%NPROW, root%MBLOCK, root%NBLOCK,         &
     &        NBCOL, NBROW,                                             &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),              &
     &        IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),              &
     &        LDA, A(PTRR(STEP(ISON)) + SHIFT_VAL_SON ),                &
     &        ROW_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                     &
     &        COL_INDEX_LIST( PTRROW( IROW + 1 ) ),                     &
     &        NCLOCAL,                                                  &
     &        NRLOCAL,                                                  &
     &        root%RG2L_ROW, root%RG2L_COL, INVERT )
          END IF
        END IF
       ENDIF
      END IF
      DO IROW = 0, root%NPROW - 1
        DO JCOL = 0, root%NPCOL - 1
          PDEST = IROW * root%NPCOL + JCOL
          IF ( (root%MYROW.eq.IROW.and.root%MYCOL.eq.JCOL) .and.        &
     &      MYID.ne.PDEST) THEN
            write(*,*) 'error: myrow,mycol=',root%MYROW,root%MYCOL
            write(*,*) ' MYID,PDEST=',MYID,PDEST
            CALL AGMG_MUMPS_ABORT()
          END IF
          IF ( root%MYROW .NE. IROW .OR. root%MYCOL .NE. JCOL) THEN
            NBROWS_ALREADY_SENT = 0
            IERR = -1
            DO WHILE ( IERR .EQ. -1 )
              IF ( .NOT. INVERT ) THEN
              NSUBSET_ROW = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
              NSUBSET_COL = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
              ELSE
              NSUBSET_ROW = PTRCOL( JCOL + 2 ) - PTRCOL( JCOL + 1 )
              NSUBSET_COL = PTRROW( IROW + 2 ) - PTRROW( IROW + 1 )
              END IF
              IF ( LRLU .LT. int(NSUBSET_ROW,8) * int(NSUBSET_COL,8)    &
     &        .AND. LRLUS .GT. int(NSUBSET_ROW,8) * int(NSUBSET_COL,8) )&
     &        THEN
                CALL DAGMG_MUMPS_94(N, KEEP(28),                             &
     &          IW, LIW, A, LA,                                         &
     &          LRLU, IPTRLU,                                           &
     &          IWPOS, IWPOSCB, PTRIST, PTRAST,                         &
     &          STEP, PIMASTER, PAMASTER, ITLOC,KEEP(216),LRLUS,        &
     &          KEEP(IXSZ))
                COMP = COMP + 1
                IF ( LRLU .NE. LRLUS ) THEN
                  WRITE(*,*) MYID,': Error in b&scbroot: pb compress'
                  WRITE(*,*) MYID,': LRLU, LRLUS=',LRLU,LRLUS
                  CALL AGMG_MUMPS_ABORT()
                END IF
              END IF
              IF ( .NOT. INVERT ) THEN
                CALL DAGMG_MUMPS_648( N, ISON,                               &
     &          NBCOL, NBROW,                                           &
     &          IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),            &
     &          IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),            &
     &          LDA, A( PTRR(STEP(ISON)) + SHIFT_VAL_SON ),             &
     &          TAG,                                                    &
     &          ROW_INDEX_LIST( PTRROW( IROW + 1 ) ),                   &
     &          COL_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                   &
     &          NSUBSET_ROW, NSUBSET_COL,                               &
     &          root%NPROW, root%NPCOL, root%MBLOCK,                    &
     &          root%RG2L_ROW, root%RG2L_COL,                           &
     &          root%NBLOCK, PDEST,                                     &
     &          COMM, IERR, A( POSFAC ), LRLU, INVERT,                  &
     &          SIZE_MSG, NBROWS_ALREADY_SENT )
              ELSE
                CALL DAGMG_MUMPS_648( N, ISON,                               &
     &          NBCOL, NBROW,                                           &
     &          IW( PTRI(STEP(ISON)) + SHIFT_LIST_COL_SON ),            &
     &          IW( PTRI(STEP(ISON)) + SHIFT_LIST_ROW_SON ),            &
     &          LDA, A( PTRR(STEP(ISON)) + SHIFT_VAL_SON ),             &
     &          TAG,                                                    &
     &          ROW_INDEX_LIST( PTRCOL( JCOL + 1 ) ),                   &
     &          COL_INDEX_LIST( PTRROW( IROW + 1 ) ),                   &
     &          NSUBSET_ROW, NSUBSET_COL,                               &
     &          root%NPROW, root%NPCOL, root%MBLOCK,                    &
     &          root%RG2L_ROW, root%RG2L_COL,                           &
     &          root%NBLOCK, PDEST,                                     &
     &          COMM, IERR, A( POSFAC ), LRLU, INVERT,                  &
     &          SIZE_MSG, NBROWS_ALREADY_SENT )
              END IF
              IF ( IERR .EQ. -1 ) THEN
                  BLOCKING  = .FALSE.
                  SET_IRECV = .TRUE.
                  MESSAGE_RECEIVED = .FALSE.
                  CALL DAGMG_MUMPS_329( COMM_LOAD, ASS_IRECV,                &
     &            BLOCKING, SET_IRECV, MESSAGE_RECEIVED,                &
     &            AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG,                          &
     &            STATUS, BUFR, LBUFR,                                  &
     &            LBUFR_BYTES, PROCNODE_STEPS, POSFAC, IWPOS, IWPOSCB,  &
     &            IPTRLU, LRLU, LRLUS, N, IW, LIW, A, LA,               &
     &            PTRIST, PTLUST_S, PTRFAC, PTRAST, STEP,               &
     &            PIMASTER, PAMASTER, NSTK,                             &
     &            COMP, IFLAG, IERROR, COMM, NBPROCFILS, IPOOL, LPOOL,  &
     &            LEAF, NBFIN, MYID, SLAVEF, root,                      &
     &            OPASSW, OPELIW, ITLOC, FILS,                          &
     &            PTRARW, PTRAIW, INTARR, DBLARR, ICNTL, KEEP,KEEP8,    &
     &            ND, FRERE, LPTRAR, NELT, FRTPTR, FRTELT,              &
     &            ISTEP_TO_INIV2, TAB_POS_IN_PERE, .TRUE.  )
                  IF ( IFLAG .LT. 0 ) GOTO 500
              END IF
            END DO
            IF ( IERR == -2 ) THEN
              IFLAG  = -17
              IERROR = SIZE_MSG
              IF (LP > 0) WRITE(LP, *) "FAILURE, SEND BUFFER TOO        &
     & SMALL DURING DAGMG_MUMPS_80"
              CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
              GOTO 500
            ENDIF
            IF ( IERR == -3 ) THEN
              IF (LP > 0) WRITE(LP, *) "FAILURE, RECV BUFFER TOO        &
     & SMALL DURING DAGMG_MUMPS_80"
              IFLAG  = -20
              IERROR = SIZE_MSG
              CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
              GOTO 500
            ENDIF
          END IF
        END DO
      END DO
  500 CONTINUE
      DEALLOCATE(PTRROW)
      DEALLOCATE(PTRCOL)
      DEALLOCATE(ROW_INDEX_LIST)
      DEALLOCATE(COL_INDEX_LIST)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_80
      SUBROUTINE DAGMG_MUMPS_285( N, VAL_ROOT,                               &
     &   LOCAL_M, LOCAL_N,                                              &
     &   NPCOL, NPROW, MBLOCK, NBLOCK, NBCOL_SON, NBROW_SON, INDCOL_SON,&
     &   INDROW_SON, LD_SON, VAL_SON, SUBSET_ROW, SUBSET_COL,           &
     &   NSUBSET_ROW, NSUBSET_COL, RG2L_ROW, RG2L_COL, INVERT )
      IMPLICIT NONE
      INTEGER N, LOCAL_M, LOCAL_N
      DOUBLE PRECISION VAL_ROOT( LOCAL_M, LOCAL_N )
      INTEGER NPCOL, NPROW, MBLOCK, NBLOCK
      INTEGER NBCOL_SON, NBROW_SON
      INTEGER INDCOL_SON( NBCOL_SON ), INDROW_SON( NBROW_SON )
      INTEGER LD_SON
      DOUBLE PRECISION VAL_SON( LD_SON, NBROW_SON )
      INTEGER NSUBSET_ROW, NSUBSET_COL
      INTEGER SUBSET_ROW( NSUBSET_ROW ), SUBSET_COL( NSUBSET_COL )
      INTEGER RG2L_ROW( N ), RG2L_COL( N )
      LOGICAL INVERT
      INTEGER ISUB, JSUB, I, J, IPOS_ROOT, JPOS_ROOT
      INTEGER ILOC_ROOT, JLOC_ROOT, IGLOB, JGLOB
      IF ( .NOT. INVERT ) THEN
        DO ISUB = 1, NSUBSET_ROW
          I         = SUBSET_ROW( ISUB )
          IGLOB     = INDROW_SON( I )
          IPOS_ROOT = RG2L_ROW( IGLOB )
          ILOC_ROOT = MBLOCK                                            &
     &            * ( ( IPOS_ROOT - 1 ) / ( MBLOCK * NPROW ) )          &
     &            + mod( IPOS_ROOT - 1, MBLOCK ) + 1
          DO JSUB = 1, NSUBSET_COL
            J         = SUBSET_COL( JSUB )
            JGLOB     = INDCOL_SON( J )
            JPOS_ROOT = RG2L_COL( JGLOB )
            JLOC_ROOT = NBLOCK                                          &
     &                * ( ( JPOS_ROOT - 1 ) / ( NBLOCK * NPCOL ) )      &
     &                + mod( JPOS_ROOT - 1, NBLOCK ) + 1
            VAL_ROOT( ILOC_ROOT, JLOC_ROOT ) =                          &
     &            VAL_ROOT( ILOC_ROOT, JLOC_ROOT ) + VAL_SON( J, I )
          END DO
        END DO
      ELSE
        DO ISUB = 1, NSUBSET_ROW
          I         = SUBSET_ROW( ISUB )
          IGLOB     = INDROW_SON( I )
          JPOS_ROOT = RG2L_ROW( IGLOB )
          JLOC_ROOT = NBLOCK                                            &
     &                * ( ( JPOS_ROOT - 1 ) / ( NBLOCK * NPCOL ) )      &
     &                + mod( JPOS_ROOT - 1, NBLOCK ) + 1
          DO JSUB = 1, NSUBSET_COL
            J         = SUBSET_COL( JSUB )
            JGLOB     = INDCOL_SON( J )
            IPOS_ROOT = RG2L_COL( JGLOB )
            ILOC_ROOT = MBLOCK                                          &
     &                * ( ( IPOS_ROOT - 1 ) / ( MBLOCK * NPROW ) )      &
     &                + mod( IPOS_ROOT - 1, MBLOCK ) + 1
            VAL_ROOT( ILOC_ROOT, JLOC_ROOT ) =                          &
     &            VAL_ROOT( ILOC_ROOT, JLOC_ROOT ) + VAL_SON( J, I )
          END DO
        END DO
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_285
      SUBROUTINE DAGMG_MUMPS_164                                             &
     &( MYID, NPROCS, N, root, COMM_ROOT, IROOT, FILS,                  &
     &  K50, K46, K51                                                   &
     &     , K60, IDNPROW, IDNPCOL, IDMBLOCK, IDNBLOCK                  &
     & )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER MYID, MYID_ROOT
      TYPE (DAGMG_MUMPS_ROOT_STRUC)::root
      INTEGER COMM_ROOT
      INTEGER N, IROOT, NPROCS, K50, K46, K51
      INTEGER FILS( N )
      INTEGER K60, IDNPROW, IDNPCOL, IDMBLOCK, IDNBLOCK
      INTEGER INODE, NPROWtemp, NPCOLtemp
      LOGICAL SLAVE
      root%ROOT_SIZE     = 0
      root%TOT_ROOT_SIZE = 0
      NULLIFY( root%RG2L_ROW )
      NULLIFY( root%RG2L_COL )
      SLAVE = ( MYID .ne. 0 .or.                                        &
     &        ( MYID .eq. 0 .and. K46 .eq. 1 ) )
      INODE = IROOT
      DO WHILE ( INODE .GT. 0 )
        INODE = FILS( INODE )
        root%ROOT_SIZE = root%ROOT_SIZE + 1
      END DO
      IF ( ( K60 .NE. 2 .AND. K60 .NE. 3 ) .OR.                         &
     &       IDNPROW .LE. 0 .OR. IDNPCOL .LE. 0                         &
     &      .OR. IDMBLOCK .LE.0 .OR. IDNBLOCK.LE.0                      &
     &      .OR. IDNPROW * IDNPCOL .GT. NPROCS ) THEN
        root%MBLOCK = K51
        root%NBLOCK = K51
        CALL DAGMG_MUMPS_99( NPROCS, root%NPROW, root%NPCOL,                 &
     &                         root%ROOT_SIZE, K50 )
        IF  ( K60 .EQ. 2 .OR. K60 .EQ. 3 ) THEN
          IDNPROW = root%NPROW
          IDNPCOL = root%NPCOL
          IDMBLOCK = root%MBLOCK
          IDNBLOCK = root%NBLOCK
        ENDIF
      ELSE IF  ( K60 .EQ. 2 .OR. K60 .EQ. 3 ) THEN
        root%NPROW = IDNPROW
        root%NPCOL = IDNPCOL
        root%MBLOCK = IDMBLOCK
        root%NBLOCK = IDNBLOCK
      ENDIF
      IF  ( K60 .EQ. 2 .OR. K60 .EQ. 3 ) THEN
        IF (SLAVE) THEN
          root%LPIV = 0
          IF (K46.EQ.0) THEN
            MYID_ROOT=MYID-1
          ELSE
            MYID_ROOT=MYID
          ENDIF
          IF (MYID_ROOT < root%NPROW*root%NPCOL) THEN
            root%MYROW = MYID_ROOT / root%NPCOL
            root%MYCOL = mod(MYID_ROOT, root%NPCOL)
            root%yes  = .true.
          ELSE
            root%MYROW = -1
            root%MYCOL = -1
            root%yes  = .FALSE.
          ENDIF
        ELSE
          root%yes  = .FALSE.
        ENDIF
      ELSE IF ( SLAVE ) THEN
        IF ( root%gridinit_done) THEN
           CALL AGMG_NOCALL('BLACS_GRIDEXIT')
           root%gridinit_done = .FALSE.
        END IF
        root%CNTXT_BLACS = COMM_ROOT
        CALL AGMG_NOCALL('BLACS_GRIDINIT')
        root%gridinit_done = .TRUE.
        CALL AGMG_NOCALL('BLACS_GRIDINFO')
        IF ( root%MYROW .NE. -1 ) THEN
          root%yes = .true.
        ELSE
          root%yes = .false.
        END IF
        root%LPIV = 0
      ELSE
        root%yes = .FALSE.
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_164
      SUBROUTINE DAGMG_MUMPS_165( N, root, FILS, IROOT, INFO )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE ( DAGMG_MUMPS_ROOT_STRUC ):: root
      INTEGER N, IROOT, INFO(40)
      INTEGER FILS( N )
      INTEGER INODE, I, allocok
      IF ( associated( root%RG2L_ROW ) ) DEALLOCATE( root%RG2L_ROW )
      IF ( associated( root%RG2L_COL ) ) DEALLOCATE( root%RG2L_COL )
      ALLOCATE( root%RG2L_ROW( N ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        RETURN
      ENDIF
      ALLOCATE( root%RG2L_COL( N ), stat = allocok )
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        RETURN
      ENDIF
      INODE = IROOT
      I = 1
      DO WHILE ( INODE .GT. 0 )
        root%RG2L_ROW( INODE ) = I
        root%RG2L_COL( INODE ) = I
        I = I + 1
        INODE = FILS( INODE )
      END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_165
      SUBROUTINE DAGMG_MUMPS_99( NPROCS, NPROW, NPCOL, SIZE, K50 )
      IMPLICIT NONE
      INTEGER NPROCS, NPROW, NPCOL, SIZE, K50
      INTEGER NPROWtemp, NPCOLtemp, NPROCSused, FLATNESS
      LOGICAL KEEPIT
      IF ( K50 .EQ. 1 ) THEN
        FLATNESS = 2
      ELSE
        FLATNESS = 3
      ENDIF
      NPROW  = int(sqrt(dble(NPROCS)))
      NPROWtemp = NPROW
      NPCOL  = int(NPROCS / NPROW)
      NPCOLtemp = NPCOL
      NPROCSused = NPROWtemp * NPCOLtemp
   10 CONTINUE
      IF ( NPROWtemp >= NPCOLtemp/FLATNESS .AND. NPROWtemp > 1) THEN
        NPROWtemp = NPROWtemp - 1
        NPCOLtemp = int(NPROCS / NPROWtemp)
        KEEPIT=.FALSE.
        IF ( NPROWtemp * NPCOLtemp .GE. NPROCSused ) THEN
          IF ( ( K50 .NE. 1 .AND. NPROWtemp >= NPCOLtemp/FLATNESS)      &
     &         .OR. NPROWtemp * NPCOLtemp .GT. NPROCSused )             &
     &         KEEPIT=.TRUE.
        END IF
        IF ( KEEPIT ) THEN
          NPROW = NPROWtemp
          NPCOL = NPCOLtemp
          NPROCSused = NPROW * NPCOL
        END IF
        GO TO 10
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_99
      SUBROUTINE DAGMG_MUMPS_290(MYID, M, N, ASEQ,                           &
     &                    LOCAL_M, LOCAL_N,                             &
     &                    MBLOCK, NBLOCK,                               &
     &                    APAR,                                         &
     &                    MASTER_ROOT,                                  &
     &                    NPROW, NPCOL,                                 &
     &                    COMM)
      IMPLICIT NONE
      INTEGER MYID, MASTER_ROOT, COMM
      INTEGER M, N
      INTEGER NPROW, NPCOL
      INTEGER LOCAL_M, LOCAL_N
      INTEGER MBLOCK, NBLOCK
      DOUBLE PRECISION APAR( LOCAL_M, LOCAL_N )
      DOUBLE PRECISION ASEQ( M, N )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I, J, SIZE_IBLOCK, SIZE_JBLOCK, IDEST, IROW, ICOL
      INTEGER IBLOCK, JBLOCK, II, JJ, KK
      INTEGER IAPAR, JAPAR, IERR
      INTEGER STATUS(AGMG_MPF_STATUS_SIZE)
      DOUBLE PRECISION WK( MBLOCK * NBLOCK )
      LOGICAL JUPDATE
        IAPAR = 1
        JAPAR = 1
        DO J = 1, N, NBLOCK
          SIZE_JBLOCK = NBLOCK
          IF ( J + NBLOCK > N ) THEN
            SIZE_JBLOCK = N - J + 1
          END IF
          JUPDATE = .FALSE.
          DO I = 1, M, MBLOCK
            SIZE_IBLOCK = MBLOCK
            IF ( I + MBLOCK > M ) THEN
              SIZE_IBLOCK = M - I + 1
            END IF
            IBLOCK = I / MBLOCK
            JBLOCK = J / NBLOCK
            IROW = mod ( IBLOCK, NPROW )
            ICOL = mod ( JBLOCK, NPCOL )
            IDEST = IROW * NPCOL + ICOL
            IF ( IDEST .NE. MASTER_ROOT ) THEN
              IF ( MYID .EQ. MASTER_ROOT ) THEN
                KK=1
                DO JJ=J,J+SIZE_JBLOCK-1
                DO II=I,I+SIZE_IBLOCK-1
                  WK(KK)=ASEQ(II,JJ)
                  KK=KK+1
                END DO
                END DO
                CALL AGMG_NOCALL('MPI_SSEND')
              ELSE IF ( MYID .EQ. IDEST ) THEN
                CALL AGMG_NOCALL('MPI_RECV')
                KK=1
                DO JJ=JAPAR,JAPAR+SIZE_JBLOCK-1
                DO II=IAPAR,IAPAR+SIZE_IBLOCK-1
                  APAR(II,JJ)=WK(KK)
                  KK=KK+1
                END DO
                END DO
                JUPDATE = .TRUE.
                IAPAR = IAPAR + SIZE_IBLOCK
              END IF
            ELSE IF ( MYID.EQ. MASTER_ROOT ) THEN
              APAR( IAPAR:IAPAR+SIZE_IBLOCK-1,                          &
     &              JAPAR:JAPAR+SIZE_JBLOCK-1 )                         &
     &        = ASEQ(I:I+SIZE_IBLOCK-1,J:J+SIZE_JBLOCK-1)
              JUPDATE = .TRUE.
              IAPAR = IAPAR + SIZE_IBLOCK
            END IF
          END DO
          IF ( JUPDATE ) THEN
            IAPAR = 1
            JAPAR = JAPAR + SIZE_JBLOCK
          END IF
        END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_290
      SUBROUTINE DAGMG_MUMPS_156(MYID, M, N, ASEQ,                           &
     &                    LOCAL_M, LOCAL_N,                             &
     &                    MBLOCK, NBLOCK,                               &
     &                    APAR,                                         &
     &                    MASTER_ROOT,                                  &
     &                    NPROW, NPCOL,                                 &
     &                    COMM)
      IMPLICIT NONE
      INTEGER MYID, MASTER_ROOT, COMM
      INTEGER M, N
      INTEGER NPROW, NPCOL
      INTEGER LOCAL_M, LOCAL_N
      INTEGER MBLOCK, NBLOCK
      DOUBLE PRECISION APAR( LOCAL_M, LOCAL_N )
      DOUBLE PRECISION ASEQ( M, N )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER I, J, SIZE_IBLOCK, SIZE_JBLOCK, ISOUR, IROW, ICOL
      INTEGER IBLOCK, JBLOCK, II, JJ, KK
      INTEGER IAPAR, JAPAR, IERR
      INTEGER STATUS(AGMG_MPF_STATUS_SIZE)
      DOUBLE PRECISION WK( MBLOCK * NBLOCK )
      LOGICAL JUPDATE
        IAPAR = 1
        JAPAR = 1
        DO J = 1, N, NBLOCK
          SIZE_JBLOCK = NBLOCK
          IF ( J + NBLOCK > N ) THEN
            SIZE_JBLOCK = N - J + 1
          END IF
          JUPDATE = .FALSE.
          DO I = 1, M, MBLOCK
            SIZE_IBLOCK = MBLOCK
            IF ( I + MBLOCK > M ) THEN
              SIZE_IBLOCK = M - I + 1
            END IF
            IBLOCK = I / MBLOCK
            JBLOCK = J / NBLOCK
            IROW = mod ( IBLOCK, NPROW )
            ICOL = mod ( JBLOCK, NPCOL )
            ISOUR = IROW * NPCOL + ICOL
            IF ( ISOUR .NE. MASTER_ROOT ) THEN
              IF ( MYID .EQ. MASTER_ROOT ) THEN
                CALL AGMG_NOCALL('MPI_RECV')
                KK=1
                DO JJ=J,J+SIZE_JBLOCK-1
                DO II=I,I+SIZE_IBLOCK-1
                  ASEQ(II,JJ)=WK(KK)
                  KK=KK+1
                END DO
                END DO
              ELSE IF ( MYID .EQ. ISOUR ) THEN
                KK=1
                DO JJ=JAPAR,JAPAR+SIZE_JBLOCK-1
                DO II=IAPAR,IAPAR+SIZE_IBLOCK-1
                  WK(KK)=APAR(II,JJ)
                  KK=KK+1
                END DO
                END DO
                CALL AGMG_NOCALL('MPI_SSEND')
                JUPDATE = .TRUE.
                IAPAR = IAPAR + SIZE_IBLOCK
              END IF
            ELSE IF ( MYID.EQ. MASTER_ROOT ) THEN
              ASEQ(I:I+SIZE_IBLOCK-1,J:J+SIZE_JBLOCK-1)                 &
     &        = APAR( IAPAR:IAPAR+SIZE_IBLOCK-1,                        &
     &                JAPAR:JAPAR+SIZE_JBLOCK-1 )
              JUPDATE = .TRUE.
              IAPAR = IAPAR + SIZE_IBLOCK
            END IF
          END DO
          IF ( JUPDATE ) THEN
            IAPAR = 1
            JAPAR = JAPAR + SIZE_JBLOCK
          END IF
        END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_156
      SUBROUTINE DAGMG_MUMPS_284(root, IROOT, N,                             &
     &                  IW, LIW, A, LA,                                 &
     &                  FILS, MYID, PTRAIW, PTRARW, INTARR, DBLARR,     &
     &                  LRLU, IPTRLU,                                   &
     &                  IWPOS, IWPOSCB, PTRIST, PTRAST,                 &
     &                  STEP, PIMASTER, PAMASTER, ITLOC,                &
     &                  COMP, LRLUS, IFLAG, KEEP,KEEP8, IERROR )
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      INTEGER MYID
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      TYPE (DAGMG_MUMPS_ROOT_STRUC ) :: root
      INTEGER(8) :: LA, LRLU, IPTRLU, LRLUS
      INTEGER IROOT, LIW, N, IWPOS, IWPOSCB
      INTEGER IW( LIW )
      DOUBLE PRECISION A( LA )
      INTEGER PTRIST(KEEP(28)), STEP(N)
      INTEGER(8) :: PTRAST(KEEP(28)), PAMASTER(KEEP(28))
      INTEGER PIMASTER(KEEP(28))
      INTEGER ITLOC( N )
      INTEGER COMP, IFLAG, IERROR
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER FILS( N ), PTRAIW(N), PTRARW( N )
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      INTEGER NUMROC_FOOL
      EXTERNAL NUMROC_FOOL
      INTEGER(8) :: LREQA_ROOT
      INTEGER LREQI_ROOT, LOCAL_M, LOCAL_N
            LOCAL_M = NUMROC_FOOL( root%ROOT_SIZE, root%MBLOCK,              &
     &                root%MYROW, 0, root%NPROW )
            LOCAL_M = max( 1, LOCAL_M )
            LOCAL_N = NUMROC_FOOL( root%ROOT_SIZE, root%NBLOCK,              &
     &                root%MYCOL, 0, root%NPCOL )
            LREQI_ROOT = 2 + KEEP(IXSZ)
            LREQA_ROOT = int(LOCAL_M,8) * int(LOCAL_N,8)
            IF (LREQA_ROOT.EQ.0_8) THEN
              PTRIST(STEP(IROOT)) = -9999999
              RETURN
            ENDIF
            CALL DAGMG_MUMPS_22(.FALSE.,0_8,.FALSE.,.FALSE.,                 &
     &                     MYID,N,KEEP,KEEP8,IW,LIW,A,LA,               &
     &                     LRLU, IPTRLU,                                &
     &                     IWPOS, IWPOSCB, PTRIST, PTRAST,              &
     &                     STEP, PIMASTER, PAMASTER, ITLOC, LREQI_ROOT, &
     &                     LREQA_ROOT, IROOT, S_NOTFREE, .TRUE., COMP,  &
     &                     LRLUS, IFLAG, IERROR                         &
     &           )
            IF ( IFLAG .LT. 0 ) RETURN
            PTRIST  ( STEP(IROOT) ) = IWPOSCB + 1
            PAMASTER( STEP(IROOT) ) = IPTRLU  + 1_8
            IW( IWPOSCB + 1 + KEEP(IXSZ)) = - LOCAL_N
            IW( IWPOSCB + 2 + KEEP(IXSZ)) =   LOCAL_M
      RETURN
      END SUBROUTINE DAGMG_MUMPS_284
      SUBROUTINE DAGMG_MUMPS_35( N, root, IROOT,                             &
     &   VALROOT, LOCAL_M, LOCAL_N, FILS,                               &
     &       PTRAIW, PTRARW,                                            &
     &       INTARR, DBLARR,                                            &
     &       KEEP,KEEP8,                                                &
     &       MYID)
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE (DAGMG_MUMPS_ROOT_STRUC) :: root
      INTEGER N, MYID, IROOT, LOCAL_M, LOCAL_N, KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER FILS( N ), PTRARW( N ), PTRAIW( N )
      INTEGER INTARR(max(1,KEEP(14)))
      DOUBLE PRECISION VALROOT(LOCAL_M,LOCAL_N)
      DOUBLE PRECISION DBLARR(max(1,KEEP(13)))
      DOUBLE PRECISION VAL
      INTEGER IORG, IBROT, NUMORG, JJ, J1,JK, J2,J3, J4,                &
     &        IROW, JCOL, AINPUT
      INTEGER IPOSROOT, JPOSROOT, IROW_GRID, JCOL_GRID
      INTEGER ILOCROOT, JLOCROOT
      NUMORG = root%ROOT_SIZE
      IBROT  = IROOT
      DO IORG = 1, NUMORG
        JK = PTRAIW(IBROT)
        AINPUT = PTRARW(IBROT)
        IBROT = FILS(IBROT)
        JJ = JK + 1
        J1 = JJ + 1
        J2 = J1 + INTARR(JK)
        J3 = J2 + 1
        J4 = J2 - INTARR(JJ)
        JCOL = INTARR(J1)
        DO JJ = J1, J2
         IROW = INTARR(JJ)
         VAL  = DBLARR(AINPUT)
         AINPUT = AINPUT + 1
         IPOSROOT = root%RG2L_ROW( IROW )
         JPOSROOT = root%RG2L_COL( JCOL )
         IROW_GRID  = mod( ( IPOSROOT - 1 ) / root%MBLOCK, root%NPROW )
         JCOL_GRID  = mod( ( JPOSROOT - 1 ) / root%NBLOCK, root%NPCOL )
         IF ( IROW_GRID .EQ. root%MYROW .AND.                           &
     &        JCOL_GRID .EQ. root%MYCOL ) THEN
            ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /               &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
            JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /               &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
            VALROOT( ILOCROOT, JLOCROOT ) = VAL
         END IF
        END DO
        IF (J3 .LE. J4) THEN
         IROW =  INTARR(J1)
         DO JJ= J3,J4
          JCOL = INTARR(JJ)
          VAL  = DBLARR(AINPUT)
          AINPUT = AINPUT + 1
          IPOSROOT = root%RG2L_ROW( IROW )
          JPOSROOT = root%RG2L_COL( JCOL )
          IROW_GRID= mod( ( IPOSROOT - 1 )/root%MBLOCK, root%NPROW)
          JCOL_GRID= mod( ( JPOSROOT - 1 )/root%NBLOCK, root%NPCOL)
          IF ( IROW_GRID .EQ. root%MYROW .AND.                          &
     &        JCOL_GRID .EQ. root%MYCOL ) THEN
            ILOCROOT = root%MBLOCK * ( ( IPOSROOT - 1 ) /               &
     &                 ( root%MBLOCK * root%NPROW ) )                   &
     &               + mod( IPOSROOT - 1, root%MBLOCK ) + 1
            JLOCROOT = root%NBLOCK * ( ( JPOSROOT - 1 ) /               &
     &                 ( root%NBLOCK * root%NPCOL ) )                   &
     &               + mod( JPOSROOT - 1, root%NBLOCK ) + 1
            VALROOT( ILOCROOT, JLOCROOT ) = VAL
          END IF
         END DO
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_35
      INTEGER FUNCTION DAGMG_MUMPS_IXAMAX(n,x,incx)
      DOUBLE PRECISION x(*)
      DOUBLE PRECISION smax
      integer i,incx,ix,n
      DOUBLE PRECISION zdum
      INTEGER IDAMAX
      DAGMG_MUMPS_IXAMAX = IDAMAX(n,x,incx)
      return
      END FUNCTION DAGMG_MUMPS_IXAMAX
      SUBROUTINE DAGMG_MUMPS_XSYR( UPLO, N, ALPHA, X, INCX, A, LDA )
      CHARACTER          UPLO
      INTEGER            INCX, LDA, N
      DOUBLE PRECISION            ALPHA
      DOUBLE PRECISION            A( LDA, * ), X( * )
      CALL DSYR( UPLO, N, ALPHA, X, INCX, A, LDA )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_XSYR
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_635(N,KEEP,ICNTL,MPG)
      IMPLICIT NONE
          INTEGER N, KEEP(500), ICNTL(40), MPG
          KEEP(19)=0
          RETURN
      END SUBROUTINE DAGMG_MUMPS_635
      SUBROUTINE DAGMG_MUMPS_634(KEEP,ICNTL,MPG)
      IMPLICIT NONE
      INTEGER ICNTL(40), KEEP(500), MPG
      KEEP(111)=ICNTL(25)
      IF (KEEP(111) < -1 .OR.                                           &
     &      KEEP(111).GT.KEEP(112)+KEEP(17)) THEN
          KEEP(111)=0
      ENDIF
      IF (KEEP(19).EQ.0.AND.KEEP(110).EQ.0) THEN
        IF(KEEP(111).NE.0.AND.MPG.GT.0) THEN
          WRITE( MPG,'(A)')                                             &
     &'** Warning: ICNTL(25) option disabled because'
          WRITE( MPG,'(A)')                                             &
     &'** null space was not required during factorization'
        ENDIF
        KEEP(111)=0
      ENDIF
      IF (ICNTL(9).NE.1) THEN
        IF (KEEP(111).NE.0.AND. MPG.GT.0) THEN
          WRITE(MPG,'(A)')                                              &
     &'** Warning: ICNTL(25) option disabled because'
          WRITE( MPG,'(A)')                                             &
     &'** it is not available for the transposed system'
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_634
      SUBROUTINE DAGMG_MUMPS_637(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE (DAGMG_MUMPS_STRUC) id
      NULLIFY(id%root%QR_TAU)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_637
      SUBROUTINE DAGMG_MUMPS_636(id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE (DAGMG_MUMPS_STRUC) id
      IF (associated(id%root%QR_TAU))  THEN
        DEALLOCATE(id%root%QR_TAU)
        NULLIFY(id%root%QR_TAU)
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_636
      SUBROUTINE DAGMG_MUMPS_279( PHASE, MBLOCK, NBLOCK,                     &
     &           SIZE_ROOT_ARG,                                         &
     &           LOCAL_M, LOCAL_N, ROOT_OWNER, KEEP,KEEP8,              &
     &           LIWK_RR, LWK_RR )
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: PHASE, SIZE_ROOT_ARG
      INTEGER, INTENT(IN) :: MBLOCK, NBLOCK, LOCAL_M, LOCAL_N
      LOGICAL, INTENT(IN) :: ROOT_OWNER
      INTEGER, INTENT(IN) :: KEEP(500)
      INTEGER*8, INTENT(IN) :: KEEP8(150)
      INTEGER, INTENT(OUT):: LIWK_RR, LWK_RR
      INTEGER SIZE_ROOT
      INTEGER NBPOSPONED_ESTIM
      PARAMETER (NBPOSPONED_ESTIM=2000)
      INTEGER QR,PAR_ROOT
      QR      =KEEP(19)
      PAR_ROOT=KEEP(38)
      LIWK_RR = 0
      LWK_RR = 0
      IF (PAR_ROOT.EQ.0) THEN
        IF(ROOT_OWNER) THEN
          IF(QR.EQ.1) THEN
            IF (PHASE.EQ.0) THEN
              SIZE_ROOT=SIZE_ROOT_ARG+NBPOSPONED_ESTIM
            ELSE
              SIZE_ROOT=SIZE_ROOT_ARG
            ENDIF
              LWK_RR=5*SIZE_ROOT+1
          END IF
        END IF
      ENDIF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_279
      SUBROUTINE DAGMG_MUMPS_333(N,PERM,X,RN01)
      INTEGER N,PERM(N),I
      DOUBLE PRECISION RN01(N),X(N)
      DO 100 I=1,N
      RN01(PERM(I))=X(I)
  100 END DO
      DO 200 I=1,N
      X(I)=RN01(I)
  200 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_333
      SUBROUTINE DAGMG_MUMPS_334(N,PERM,X,RN01)
      INTEGER N,PERM(N),I
      DOUBLE PRECISION RN01(N),X(N)
      DO 100 I=1,N
      RN01(I)=X(PERM(I))
  100 END DO
      DO 200 I=1,N
      X(I)=RN01(I)
  200 END DO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_334
      SUBROUTINE DAGMG_MUMPS_117(N,ALPHA,DX,INCX)
      INTEGER N,INCX
      DOUBLE PRECISION ALPHA,DX(*)
      INTEGER I,IX,M,MP1
      INTRINSIC MOD
      IF(N.LE.0) RETURN
      IF(INCX.NE.1) THEN
        IX=1
        IF(INCX.LT.0) IX=(-N+1)*INCX+1
        DO I=1,N
          DX(IX)=ALPHA
          IX=IX+INCX
        END DO
        RETURN
      ELSE
        M=MOD(N,7)
        IF(M.NE.0) THEN
          DO I=1,M
            DX(I)=ALPHA
          END DO
          IF(N.LT.7) RETURN
        END IF
        MP1=M+1
        DO I=MP1,N,7
          DX(I)=ALPHA
          DX(I+1)=ALPHA
          DX(I+2)=ALPHA
          DX(I+3)=ALPHA
          DX(I+4)=ALPHA
          DX(I+5)=ALPHA
          DX(I+6)=ALPHA
        END DO
        RETURN
      END IF
      END SUBROUTINE DAGMG_MUMPS_117
      SUBROUTINE DAGMG_MUMPS_146( MYID, root, N, IROOT,                      &
     &           COMM, IW, LIW, IFREE,                                  &
     &           A, LA, PTRAST, PTLUST_S, PTRFAC,                       &
     &           STEP, INFO, LDLT, QR,                                  &
     &           WK, LWK, KEEP,KEEP8)
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      TYPE ( DAGMG_MUMPS_ROOT_STRUC ) :: root
      INTEGER N, IROOT, COMM, LIW, MYID, LIWK, IFREE
      INTEGER(8) :: LA
      INTEGER(8) :: LWK
      DOUBLE PRECISION WK( LWK )
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER(8) :: PTRAST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER PTLUST_S(KEEP(28)), STEP(N), IW( LIW )
      INTEGER INFO( 2 ), LDLT, QR
      DOUBLE PRECISION A( LA )
      INTEGER IOLDPS
      INTEGER(8) :: IAPOS
      INTEGER LOCAL_M, LOCAL_N, LPIV, IERR, allocok,i
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
        IF ( .NOT. root%yes ) RETURN
        IF ( KEEP(60) .NE. 0 ) THEN
          IF ((LDLT == 1 .OR. LDLT == 2) .AND. KEEP(60) == 3 ) THEN
            CALL DAGMG_MUMPS_320( WK, root%MBLOCK,                           &
     &      root%MYROW, root%MYCOL, root%NPROW, root%NPCOL,             &
     &      root%SCHUR_POINTER(1),                                      &
     &      root%SCHUR_LLD, root%SCHUR_NLOC,                            &
     &      root%TOT_ROOT_SIZE, MYID, COMM )
          ENDIF
        RETURN
        ENDIF
        IOLDPS  = PTLUST_S(STEP(IROOT))+KEEP(IXSZ)
        IAPOS   = PTRAST(STEP(IROOT))
        LOCAL_M = IW( IOLDPS + 2 )
        LOCAL_N = IW( IOLDPS + 1 )
        IAPOS = PTRFAC(IW ( IOLDPS + 4 ))
        IF ( LDLT.EQ.0 .OR. LDLT.EQ.2 .OR. QR.ne.0 ) THEN
         LPIV = LOCAL_M + root%MBLOCK
        ELSE
         LPIV = 1
        END IF
        IF (associated( root%IPIV )) DEALLOCATE(root%IPIV)
        root%LPIV = LPIV
        ALLOCATE( root%IPIV( LPIV ), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1) = -13
          INFO(2) = LPIV
          WRITE(*,*) MYID,': problem allocating IPIV(',LPIV,') in root'
          CALL AGMG_MUMPS_ABORT()
        END IF
        CALL AGMG_NOCALL('DESCINIT')
        IF ( LDLT.EQ.2 ) THEN
            IF(root%MBLOCK.NE.root%NBLOCK) THEN
              WRITE(*,*) ' Error: symmetrization only works for'
              WRITE(*,*) ' square block sizes, MBLOCK/NBLOCK=',         &
     &        root%MBLOCK, root%NBLOCK
              CALL AGMG_MUMPS_ABORT()
            END IF
            IF ( LWK .LT. min(                                          &
     &           int(root%MBLOCK,8) * int(root%NBLOCK,8),               &
     &           int(root%TOT_ROOT_SIZE,8)* int(root%TOT_ROOT_SIZE,8 )  &
     &         )) THEN
               WRITE(*,*) 'Not enough workspace for symmetrization.'
               CALL AGMG_MUMPS_ABORT()
            END IF
            CALL DAGMG_MUMPS_320( WK, root%MBLOCK,                           &
     &      root%MYROW, root%MYCOL, root%NPROW, root%NPCOL,             &
     &      A( IAPOS ), LOCAL_M, LOCAL_N,                               &
     &      root%TOT_ROOT_SIZE, MYID, COMM )
        END IF
        IF (LDLT.EQ.0.OR.LDLT.EQ.2) THEN
          CALL AGMG_NOCALL('PDGETRF')
          IF ( IERR .GT. 0 ) THEN
              INFO(1)=-10
              INFO(2)=IERR-1
          END IF
        ELSE
          CALL AGMG_NOCALL('PDPOTRF')
            IF ( IERR .GT. 0 ) THEN
              INFO(1)=-40
              INFO(2)=IERR-1
            END IF
        END IF
        RETURN
      END SUBROUTINE DAGMG_MUMPS_146
      SUBROUTINE DAGMG_MUMPS_556(                                            &
     &     N,PIV,FRERE,FILS,NFSIZ,IKEEP,                                &
     &     NCST,KEEP,KEEP8,id)
      USE DAGMG_MUMPS_STRUC_DEF
      IMPLICIT NONE
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER N,NCST
      INTEGER PIV(N),FRERE(N),FILS(N),NFSIZ(N),IKEEP(N,3)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER I,P11,P1,P2,K1,K2,NLOCKED
      LOGICAL V1,V2
      NCST = 0
      NLOCKED = 0
      P11 = KEEP(93)
      DO I=KEEP(93)-1,1,-2
         P1 = PIV(I)
         P2 = PIV(I+1)
         K1 = IKEEP(P1,1)
         IF(K1 .GT. 0) THEN
            V1 = (abs(id%A(K1))*(id%ROWSCA(P1)**2).GE.1.0D-1)
         ELSE
            V1 = .FALSE.
         ENDIF
         K2 = IKEEP(P2,1)
         IF(K2 .GT. 0) THEN
            V2 = (abs(id%A(K2))*(id%ROWSCA(P2)**2).GE.1.0D-1)
         ELSE
            V2 = .FALSE.
         ENDIF
         IF(V1 .AND. V2) THEN
            PIV(P11) = P1
            P11 = P11 - 1
            PIV(P11) = P2
            P11 = P11 - 1
         ELSE IF(V1) THEN
            NCST = NCST+1
            FRERE(NCST) = P1
            NCST = NCST+1
            FRERE(NCST) = P2
         ELSE IF(V2) THEN
            NCST = NCST+1
            FRERE(NCST) = P2
            NCST = NCST+1
            FRERE(NCST) = P1
         ELSE
            NLOCKED = NLOCKED + 1
            FILS(NLOCKED) = P1
            NLOCKED = NLOCKED + 1
            FILS(NLOCKED) = P2
         ENDIF
      ENDDO
      DO I=1,NLOCKED
         PIV(I) = FILS(I)
      ENDDO
      KEEP(94) = KEEP(94) + KEEP(93) - NLOCKED
      KEEP(93) = NLOCKED
      DO I=1,NCST
         NLOCKED = NLOCKED + 1
         PIV(NLOCKED) = FRERE(I)
      ENDDO
      DO I=1,KEEP(93)/2
         NFSIZ(I) = 0
      ENDDO
      DO I=(KEEP(93)/2)+1,(KEEP(93)/2)+NCST,2
         NFSIZ(I) = I+1
         NFSIZ(I+1) = -1
      ENDDO
      DO I=(KEEP(93)/2)+NCST+1,(KEEP(93)/2)+KEEP(94)
         NFSIZ(I) = 0
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_556
      SUBROUTINE DAGMG_MUMPS_550(N,NCMP,N11,N22,PIV,                         &
     &     INVPERM,PERM)
      IMPLICIT NONE
      INTEGER N11,N22,N,NCMP
      INTEGER, intent(in) :: PIV(N),PERM(N)
      INTEGER, intent (out):: INVPERM(N)
      INTEGER CMP_POS,EXP_POS,I,J,N2,K
      N2 = N22/2
      EXP_POS = 1
      DO CMP_POS=1,NCMP
         J = PERM(CMP_POS)
         IF(J .LE. N2) THEN
            K = 2*J-1
            I = PIV(K)
            INVPERM(I) = EXP_POS
            EXP_POS = EXP_POS+1
            K = K+1
            I = PIV(K)
            INVPERM(I) = EXP_POS
            EXP_POS = EXP_POS+1
         ELSE
            K = N2 + J
            I = PIV(K)
            INVPERM(I) = EXP_POS
            EXP_POS = EXP_POS+1
         ENDIF
      ENDDO
      DO K=N22+N11+1,N
         I = PIV(K)
         INVPERM(I) = EXP_POS
         EXP_POS = EXP_POS+1
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_550
      SUBROUTINE DAGMG_MUMPS_547(                                            &
     &     N,NZ, IRN, ICN, PIV,                                         &
     &     NCMP, IW, LW, IPE, LEN, IQ,                                  &
     &     FLAG, ICMP, IWFR,                                            &
     &     IERROR, KEEP,KEEP8, ICNTL)
      IMPLICIT NONE
      INTEGER N,NZ,NCMP,LW,IWFR,IERROR
      INTEGER ICNTL(40),KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER IRN(NZ),ICN(NZ),IW(LW),PIV(N),IPE(N+1)
      INTEGER LEN(N),IQ(N),FLAG(N),ICMP(N)
      INTEGER MP,N11,N22,NDUP
      INTEGER I,K,J,N1,LAST,K1,K2,L
      MP = ICNTL(2)
      IERROR = 0
      N22 = KEEP(93)
      N11 = KEEP(94)
      NCMP = N22/2 + N11
      DO I=1,NCMP
         IPE(I) = 0
      ENDDO
      K = 1
      DO I=1,N22/2
         J = PIV(K)
         ICMP(J) = I
         K = K + 1
         J = PIV(K)
         ICMP(J) = I
         K = K + 1
      ENDDO
      K = N22/2 + 1
      DO I=N22+1,N22+N11
         J = PIV(I)
         ICMP(J) = K
         K = K + 1
      ENDDO
      DO I=N11+N22+1,N
         J = PIV(I)
         ICMP(J) = 0
      ENDDO
      DO K=1,NZ
         I = IRN(K)
         J = ICN(K)
         I = ICMP(I)
         J = ICMP(J)
         IF ((I.GT.N).OR.(J.GT.N).OR.(I.LT.1)                           &
     &        .OR.(J.LT.1)) THEN
            IERROR = IERROR + 1
         ELSE
            IF (I.NE.J) THEN
               IPE(I) = IPE(I) + 1
               IPE(J) = IPE(J) + 1
            ENDIF
         ENDIF
      ENDDO
      IQ(1) = 1
      N1 = NCMP - 1
      IF (N1.GT.0) THEN
         DO I=1,N1
            IQ(I+1) = IPE(I) + IQ(I)
         ENDDO
      ENDIF
      LAST = max(IPE(NCMP)+IQ(NCMP)-1,IQ(NCMP))
      DO I = 1,NCMP
         FLAG(I) = 0
         IPE(I)  = IQ(I)
      ENDDO
      DO K=1,LAST
        IW(K) = 0
      ENDDO
      IWFR = LAST + 1
      DO K=1,NZ
         I = IRN(K)
         J = ICN(K)
         I = ICMP(I)
         J = ICMP(J)
         IF (I.NE.J) THEN
          IF (I.LT.J) THEN
            IF ((I.GE.1).AND.(J.LE.N)) THEN
             IW(IQ(I)) = -J
             IQ(I)     = IQ(I) + 1
            ENDIF
          ELSE
            IF ((J.GE.1).AND.(I.LE.N)) THEN
             IW(IQ(J)) = -I
             IQ(J)     = IQ(J) + 1
            ENDIF
          ENDIF
         ENDIF
      ENDDO
      NDUP = 0
      DO I=1,NCMP
         K1 = IPE(I)
         K2 = IQ(I) -1
         IF (K1.GT.K2) THEN
            LEN(I) = 0
            IQ(I)  = 0
         ELSE
            DO K=K1,K2
               J     = -IW(K)
               IF (J.LE.0) GO TO 250
               L     = IQ(J)
               IQ(J) = L + 1
               IF (FLAG(J).EQ.I) THEN
                  NDUP = NDUP + 1
                  IW(L) = 0
                  IW(K) = 0
               ELSE
                  IW(L)   = I
                  IW(K)   = J
                  FLAG(J) = I
               ENDIF
            ENDDO
  250       IQ(I) = IQ(I) - IPE(I)
            IF (NDUP.EQ.0) LEN(I) = IQ(I)
         ENDIF
      ENDDO
      IF (NDUP.NE.0) THEN
         IWFR = 1
         DO I=1,NCMP
            K1 = IPE(I)
            IF (IQ(I).EQ.0) THEN
               LEN(I) = 0
               IPE(I) = IWFR
               CYCLE
            ENDIF
            K2 = K1 + IQ(I) - 1
            L = IWFR
            IPE(I) = IWFR
            DO K=K1,K2
               IF (IW(K).NE.0) THEN
                  IW(IWFR) = IW(K)
                  IWFR     = IWFR + 1
               ENDIF
            ENDDO
            LEN(I) = IWFR - L
         ENDDO
      ENDIF
      IPE(NCMP+1) = IPE(NCMP) + LEN(NCMP)
      IWFR = IPE(NCMP+1)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_547
      SUBROUTINE DAGMG_MUMPS_551(                                            &
     &     N, NE, IP, IRN, SCALING,LSC,CPERM, DIAG,                     &
     &     ICNTL, WEIGHT,MARKED,FLAG,                                   &
     &     PIV_OUT, INFO)
      IMPLICIT NONE
      INTEGER N, NE, ICNTL(10), INFO(10),LSC,LWEIGHT
      INTEGER CPERM(N),PIV_OUT(N),IP(N+1),IRN(NE), DIAG(N)
      DOUBLE PRECISION SCALING(LSC),WEIGHT(N+2)
      INTEGER MARKED(N),FLAG(N)
      INTEGER NUM1,NUM2,NUMTOT,PATH_LENGTH,NLAST
      INTEGER I,J,K,L,CUR_EL,CUR_EL_PATH,CUR_EL_PATH_NEXT,BEST_BEG
      INTEGER L1,L2,PTR_SET1,PTR_SET2,TUP,T22,INTER,MERGE
      DOUBLE PRECISION BEST_SCORE,CUR_VAL,TMP,VAL
      DOUBLE PRECISION INITSCORE, DAGMG_MUMPS_739,                           &
     &     DAGMG_MUMPS_740, DAGMG_MUMPS_741
      LOGICAL VRAI,FAUX,MAX_CARD_DIAG,USE_SCALING
      INTEGER JOB_DEF,DONE
      INTEGER SUM,PROD,STRUCT,MA47,MAGNITUDE
      DOUBLE PRECISION ZERO,ONE
      PARAMETER (JOB_DEF = 5, DONE = -1,                                &
     &     SUM = 1, PROD = 2, STRUCT=1, MA47=2, MAGNITUDE=3,            &
     &     VRAI = .TRUE., FAUX = .FALSE.)
      PARAMETER(ZERO = 0.0D0, ONE = 1.0D0)
      MAX_CARD_DIAG = .TRUE.
      NUM1 = 0
      NUM2 = 0
      NUMTOT = 0
      NLAST = N
      INFO = 0
      MARKED = 1
      FLAG = 0
      VAL = ONE
      IF(LSC .GT. 1) THEN
         USE_SCALING = .TRUE.
      ELSE
         USE_SCALING = .FALSE.
      ENDIF
      TUP = ICNTL(2)
      IF(TUP .EQ. SUM) THEN
        INITSCORE = ZERO
      ELSE
        INITSCORE = ONE
      ENDIF
      IF(ICNTL(2) .GT. 2 .OR. ICNTL(2) .LE. 0) THEN
         WRITE(*,*)                                                     &
     &        'ERROR: WRONG VALUE FOR ICNTL(2) = ',ICNTL(2)
         INFO(1) = -1
         RETURN
      ENDIF
      T22 = ICNTL(1)
      IF(ICNTL(1) .LT. 0 .OR. ICNTL(1) .GT. 2) THEN
         WRITE(*,*)                                                     &
     &        'ERROR: WRONG VALUE FOR ICNTL(1) = ',ICNTL(1)
         INFO(1) = -1
         RETURN
      ENDIF
      DO CUR_EL=1,N
         IF(MARKED(CUR_EL) .LE. 0) THEN
            CYCLE
         ENDIF
         IF(CPERM(CUR_EL) .LT. 0) THEN
            MARKED(CUR_EL) = -1
            CYCLE
         ENDIF
         PATH_LENGTH = 2
         CUR_EL_PATH = CPERM(CUR_EL)
         IF(CUR_EL_PATH .EQ. CUR_EL) THEN
            MARKED(CUR_EL) = -1
            CYCLE
         ENDIF
         MARKED(CUR_EL) = 0
         WEIGHT(1) = INITSCORE
         WEIGHT(2) = INITSCORE
         L1 = IP(CUR_EL+1)-IP(CUR_EL)
         L2 = IP(CUR_EL_PATH+1)-IP(CUR_EL_PATH)
         PTR_SET1 = IP(CUR_EL)
         PTR_SET2 = IP(CUR_EL_PATH)
         IF(USE_SCALING) THEN
            VAL = -SCALING(CUR_EL_PATH) - SCALING(CUR_EL+N)
         ENDIF
         CUR_VAL = DAGMG_MUMPS_741(                                          &
     &        CUR_EL,CUR_EL_PATH,                                       &
     &        IRN(PTR_SET1),IRN(PTR_SET2),                              &
     &        L1,L2,                                                    &
     &        VAL,DIAG,N,FLAG,FAUX,T22)
         WEIGHT(PATH_LENGTH+1) =                                        &
     &        DAGMG_MUMPS_739(WEIGHT(1),CUR_VAL,TUP)
         DO
            IF(CUR_EL_PATH .EQ. CUR_EL) EXIT
            PATH_LENGTH = PATH_LENGTH+1
            MARKED(CUR_EL_PATH) = 0
            CUR_EL_PATH_NEXT = CPERM(CUR_EL_PATH)
            L1 = IP(CUR_EL_PATH+1)-IP(CUR_EL_PATH)
            L2 = IP(CUR_EL_PATH_NEXT+1)-IP(CUR_EL_PATH_NEXT)
            PTR_SET1 = IP(CUR_EL_PATH)
            PTR_SET2 = IP(CUR_EL_PATH_NEXT)
            IF(USE_SCALING) THEN
               VAL = -SCALING(CUR_EL_PATH_NEXT)                         &
     &              - SCALING(CUR_EL_PATH+N)
            ENDIF
            CUR_VAL = DAGMG_MUMPS_741(                                       &
     &           CUR_EL_PATH,CUR_EL_PATH_NEXT,                          &
     &           IRN(PTR_SET1),IRN(PTR_SET2),                           &
     &           L1,L2,                                                 &
     &           VAL,DIAG,N,FLAG,VRAI,T22)
            WEIGHT(PATH_LENGTH+1) =                                     &
     &           DAGMG_MUMPS_739(WEIGHT(PATH_LENGTH-1),CUR_VAL,TUP)
            CUR_EL_PATH = CUR_EL_PATH_NEXT
         ENDDO
         IF(mod(PATH_LENGTH,2) .EQ. 1) THEN
            IF(WEIGHT(PATH_LENGTH+1) .GE. WEIGHT(PATH_LENGTH)) THEN
               CUR_EL_PATH = CPERM(CUR_EL)
            ELSE
               CUR_EL_PATH = CUR_EL
            ENDIF
            DO I=1,(PATH_LENGTH-1)/2
               NUM2 = NUM2+1
               PIV_OUT(NUM2) = CUR_EL_PATH
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
               NUM2 = NUM2+1
               PIV_OUT(NUM2) = CUR_EL_PATH
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
            ENDDO
            NUMTOT = NUMTOT + PATH_LENGTH - 1
         ELSE
            IF(MAX_CARD_DIAG) THEN
               CUR_EL_PATH = CPERM(CUR_EL)
               IF(DIAG(CUR_EL) .NE. 0) THEN
                  BEST_BEG = CUR_EL_PATH
                  GOTO 1000
               ENDIF
               DO I=1,(PATH_LENGTH/2)
                  CUR_EL_PATH_NEXT = CPERM(CUR_EL_PATH)
                  IF(DIAG(CUR_EL_PATH) .NE. 0) THEN
                     BEST_BEG = CUR_EL_PATH_NEXT
                     GOTO 1000
                  ENDIF
               ENDDO
            ENDIF
            BEST_BEG = CUR_EL
            BEST_SCORE = WEIGHT(PATH_LENGTH-1)
            CUR_EL_PATH = CPERM(CUR_EL)
            DO I=1,(PATH_LENGTH/2)-1
               TMP = DAGMG_MUMPS_739(WEIGHT(PATH_LENGTH),                    &
     &              WEIGHT(2*I-1),TUP)
               TMP = DAGMG_MUMPS_740(TMP,WEIGHT(2*I),TUP)
               IF(TMP .GT. BEST_SCORE) THEN
                  BEST_SCORE = TMP
                  BEST_BEG = CUR_EL_PATH
               ENDIF
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
               TMP = DAGMG_MUMPS_739(WEIGHT(PATH_LENGTH+1),                  &
     &              WEIGHT(2*I),TUP)
               TMP = DAGMG_MUMPS_740(TMP,WEIGHT(2*I+1),TUP)
               IF(TMP .GT. BEST_SCORE) THEN
                  BEST_SCORE = TMP
                  BEST_BEG = CUR_EL_PATH
               ENDIF
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
            ENDDO
 1000       CUR_EL_PATH = BEST_BEG
            DO I=1,(PATH_LENGTH/2)-1
               NUM2 = NUM2+1
               PIV_OUT(NUM2) = CUR_EL_PATH
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
               NUM2 = NUM2+1
               PIV_OUT(NUM2) = CUR_EL_PATH
               CUR_EL_PATH = CPERM(CUR_EL_PATH)
            ENDDO
            NUMTOT = NUMTOT + PATH_LENGTH - 2
            MARKED(CUR_EL_PATH) = -1
         ENDIF
      ENDDO
      DO I=1,N
         IF(MARKED(I) .LT. 0) THEN
            IF(DIAG(I) .EQ. 0) THEN
               PIV_OUT(NLAST) = I
               NLAST = NLAST - 1
            ELSE
               NUM1 = NUM1 + 1
               PIV_OUT(NUM2+NUM1) = I
               NUMTOT = NUMTOT + 1
            ENDIF
         ENDIF
      ENDDO
      INFO(2) = NUMTOT
      INFO(3) = NUM1
      INFO(4) = NUM2
      RETURN
      END SUBROUTINE DAGMG_MUMPS_551
      FUNCTION DAGMG_MUMPS_739(A,B,T)
      IMPLICIT NONE
      DOUBLE PRECISION DAGMG_MUMPS_739
      DOUBLE PRECISION A,B
      INTEGER T
      INTEGER SUM,PROD
      PARAMETER(SUM = 1,PROD = 2)
      IF(T .EQ. SUM) THEN
         DAGMG_MUMPS_739 = A+B
      ELSE
         DAGMG_MUMPS_739 = A*B
      ENDIF
      END FUNCTION DAGMG_MUMPS_739
      FUNCTION DAGMG_MUMPS_740(A,B,T)
      IMPLICIT NONE
      DOUBLE PRECISION DAGMG_MUMPS_740
      DOUBLE PRECISION A,B
      INTEGER T
      INTEGER SUM,PROD
      PARAMETER(SUM = 1,PROD = 2)
      IF(T .EQ. SUM) THEN
         DAGMG_MUMPS_740 = A-B
      ELSE
         DAGMG_MUMPS_740 = A/B
      ENDIF
      END FUNCTION DAGMG_MUMPS_740
      FUNCTION DAGMG_MUMPS_741(CUR_EL,CUR_EL_PATH,                           &
     &     SET1,SET2,L1,L2,VAL,DIAG,N,FLAG,FLAGON,T)
      IMPLICIT NONE
      DOUBLE PRECISION DAGMG_MUMPS_741
      INTEGER CUR_EL,CUR_EL_PATH,L1,L2,N
      INTEGER SET1(L1),SET2(L2),DIAG(N),FLAG(N)
      DOUBLE PRECISION VAL
      LOGICAL FLAGON
      INTEGER T
      INTEGER I,INTER,MERGE
      INTEGER STRUCT,MA47,MAGNITUDE
      PARAMETER(STRUCT=0,MA47=1,MAGNITUDE=2)
      IF(T .EQ. STRUCT) THEN
         IF(.NOT. FLAGON) THEN
            DO I=1,L1
               FLAG(SET1(I)) = CUR_EL
            ENDDO
         ENDIF
         INTER = 0
         DO I=1,L2
            IF(FLAG(SET2(I)) .EQ. CUR_EL) THEN
               INTER = INTER + 1
               FLAG(SET2(I)) = CUR_EL_PATH
            ENDIF
         ENDDO
         MERGE = L1 + L2 - INTER
         DAGMG_MUMPS_741 = dble(INTER) / dble(MERGE)
      ELSE IF (T .EQ. MA47) THEN
         MERGE = 3
         IF(DIAG(CUR_EL) .NE. 0) MERGE = 2
         IF(DIAG(CUR_EL_PATH) .NE. 0) MERGE = MERGE - 2
         IF(MERGE .EQ. 0) THEN
            DAGMG_MUMPS_741 = dble(L1+L2-2)
            DAGMG_MUMPS_741 = -(DAGMG_MUMPS_741**2)/2.0D0
         ELSE IF(MERGE .EQ. 1) THEN
            DAGMG_MUMPS_741 = - dble(L1+L2-4) * dble(L1-2)
         ELSE IF(MERGE .EQ. 2) THEN
            DAGMG_MUMPS_741 = - dble(L1+L2-4) * dble(L2-2)
         ELSE
            DAGMG_MUMPS_741 = - dble(L1-2) * dble(L2-2)
         ENDIF
      ELSE
         DAGMG_MUMPS_741 = VAL
      ENDIF
      RETURN
      END FUNCTION
      SUBROUTINE DAGMG_MUMPS_622(NA, NCMP,                                   &
     &      INVPERM,PERM,                                               &
     &      LISTVAR_SCHUR, SIZE_SCHUR, AOTOA)
      IMPLICIT NONE
      INTEGER, INTENT(IN):: SIZE_SCHUR, LISTVAR_SCHUR(SIZE_SCHUR)
      INTEGER, INTENT(IN):: NA, NCMP
      INTEGER, INTENT(IN):: AOTOA(NCMP), PERM(NCMP)
      INTEGER, INTENT(OUT):: INVPERM(NA)
      INTEGER CMP_POS, IO, I, K, IPOS
      DO CMP_POS=1, NCMP
        IO              = PERM(CMP_POS)
        INVPERM(AOTOA(IO)) = CMP_POS
      ENDDO
      IPOS = NCMP
      DO K =1,  SIZE_SCHUR
        I       = LISTVAR_SCHUR(K)
        IPOS    = IPOS+1
        INVPERM(I) = IPOS
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_622
      SUBROUTINE DAGMG_MUMPS_623                                             &
     & (NA,N,NZ, IRN, ICN, IW, LW, IPE, LEN,                            &
     & IQ, FLAG, IWFR,                                                  &
     & NRORM, NIORM, IFLAG,IERROR, ICNTL,                               &
     & symmetry, SYM, MedDens, NBQD, AvgDens,                           &
     & LISTVAR_SCHUR, SIZE_SCHUR, ATOAO, AOTOA)
      IMPLICIT NONE
      INTEGER, INTENT(IN)  :: NA,N,NZ,LW
      INTEGER, INTENT(IN)  :: SIZE_SCHUR, LISTVAR_SCHUR(SIZE_SCHUR)
      INTEGER, INTENT(IN)  :: IRN(NZ), ICN(NZ)
      INTEGER, INTENT(IN)  :: ICNTL(40), SYM
      INTEGER, INTENT(INOUT) :: IFLAG
      INTEGER, INTENT(OUT) :: IERROR,NRORM,NIORM,IWFR
      INTEGER, INTENT(OUT) :: AOTOA(N)
      INTEGER, INTENT(OUT) :: ATOAO(NA)
      INTEGER, INTENT(OUT) :: LEN(N), IPE(N+1)
      INTEGER, INTENT(OUT) :: symmetry,                                 &
     &                        MedDens, NBQD, AvgDens
      INTEGER, INTENT(OUT)  :: FLAG(N), IW(LW), IQ(N)
      INTEGER MP, MPG, NAO
      INTEGER I,K,J,N1,LAST,NDUP,K1,K2,L
      INTEGER NBERR, THRESH, IAO
      INTEGER NZOFFA, NDIAGA
      DOUBLE PRECISION RSYM
      INTRINSIC nint
      ATOAO(1:NA) = 0
      DO I = 1, SIZE_SCHUR
        ATOAO(LISTVAR_SCHUR(I)) = -1
      ENDDO
      IAO = 0
      DO I= 1, NA
        IF (ATOAO(I).LT.0) CYCLE
        IAO = IAO +1
        ATOAO(I)   = IAO
        AOTOA(IAO) = I
      ENDDO
      MP = ICNTL(2)
      MPG= ICNTL(3)
      NIORM  = 3*N
      NDIAGA = 0
      IERROR = 0
      IPE(1:N+1) = 0
      DO K=1,NZ
        I = IRN(K)
        J = ICN(K)
        IF ((I.GT.NA).OR.(J.GT.NA).OR.(I.LT.1)                          &
     &                          .OR.(J.LT.1)) THEN
           IERROR = IERROR + 1
        ELSE
          I = ATOAO(I)
          J = ATOAO(J)
          IF ((I.LT.0).OR.(J.LT.0)) CYCLE
          IF (I.NE.J) THEN
           IPE(I) = IPE(I) + 1
           IPE(J) = IPE(J) + 1
           NIORM  = NIORM + 1
          ELSE
           NDIAGA = NDIAGA + 1
          ENDIF
        ENDIF
      ENDDO
      NZOFFA  = NIORM - 3*N
      IF (IERROR.GE.1) THEN
         NBERR  = 0
         IF (mod(IFLAG,2).EQ.0) IFLAG  = IFLAG+1
         IF ((MP.GT.0).AND.(ICNTL(4).GE.2))  THEN
          WRITE (MP,99999)
          DO 70 K=1,NZ
           I = IRN(K)
           J = ICN(K)
           IF ((I.GT.NA).OR.(J.GT.NA).OR.(I.LT.1)                       &
     &                            .OR.(J.LT.1)) THEN
            NBERR = NBERR + 1
            IF (NBERR.LE.10)  THEN
               IF (mod(K,10).GT.3 .OR. mod(K,10).EQ.0 .OR.              &
     &             (10.LE.K .AND. K.LE.20)) THEN
                 WRITE (MP,'(I8,A,I8,A,I8,A)')                          &
     &             K,'th entry (in row',I,' and column',J,') ignored'
               ELSE
                 IF (mod(K,10).EQ.1) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'st entry (in row',I,' and column',J,') ignored'
                 IF (mod(K,10).EQ.2) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'nd entry (in row',I,' and column',J,') ignored'
                 IF (mod(K,10).EQ.3) WRITE(MP,'(I8,A,I8,A,I8,A)')       &
     &             K,'rd entry (in row',I,' and column',J,') ignored'
               ENDIF
            ELSE
               GO TO 100
            ENDIF
           ENDIF
   70     CONTINUE
         ENDIF
      ENDIF
  100 NRORM = NIORM - 2*N
      IQ(1) = 1
      N1 = N - 1
      IF (N1.GT.0) THEN
        DO 110 I=1,N1
            IQ(I+1) = IPE(I) + IQ(I)
  110   CONTINUE
      ENDIF
      LAST = max(IPE(N)+IQ(N)-1,IQ(N))
      FLAG(1:N) = 0
      IPE(1:N)  = IQ(1:N)
      IW(1:LAST) = 0
      IWFR = LAST + 1
      DO 200 K=1,NZ
         I = IRN(K)
         J = ICN(K)
         IF ((I.GT.NA).OR.(J.GT.NA).OR.(I.LT.1)                         &
     &                          .OR.(J.LT.1)) CYCLE
         I = ATOAO(I)
         J = ATOAO(J)
         IF ((I.LT.0).OR.(J.LT.0)) CYCLE
         IF (I.NE.J) THEN
          IF (I.LT.J) THEN
             IW(IQ(I)) = -J
             IQ(I)     = IQ(I) + 1
          ELSE
             IW(IQ(J)) = -I
             IQ(J)     = IQ(J) + 1
          ENDIF
         ENDIF
  200 END DO
      NDUP = 0
      DO 260 I=1,N
        K1 = IPE(I)
        K2 = IQ(I) -1
        IF (K1.GT.K2) THEN
         LEN(I) = 0
         IQ(I)  = 0
        ELSE
         DO 240 K=K1,K2
           J     = -IW(K)
           IF (J.LE.0) GO TO 250
           L     = IQ(J)
           IQ(J) = L + 1
           IF (FLAG(J).EQ.I) THEN
            NDUP = NDUP + 1
            IW(L) = 0
            IW(K) = 0
           ELSE
            IW(L)   = I
            IW(K)   = J
            FLAG(J) = I
           ENDIF
  240    CONTINUE
  250    IQ(I) = IQ(I) - IPE(I)
         IF (NDUP.EQ.0) LEN(I) = IQ(I)
        ENDIF
  260 END DO
      IF (NDUP.NE.0) THEN
       IWFR = 1
       DO 280 I=1,N
         IF (IQ(I).EQ.0) THEN
             LEN(I) = 0
            IPE(I) = IWFR
            GOTO 280
         ENDIF
         K1 = IPE(I)
         K2 = K1 + IQ(I) - 1
         L = IWFR
         IPE(I) = IWFR
         DO 270 K=K1,K2
           IF (IW(K).NE.0) THEN
            IW(IWFR) = IW(K)
            IWFR     = IWFR + 1
           ENDIF
  270    CONTINUE
         LEN(I) = IWFR - L
  280  CONTINUE
      ENDIF
      IPE(N+1) = IPE(N) + LEN(N)
      IWFR = IPE(N+1)
      IF (SYM.EQ.0) THEN
      RSYM =  dble(NDIAGA+2*NZOFFA - (IWFR-1))/                         &
     &            dble(NZOFFA+NDIAGA)
      symmetry = nint (100.0D0*RSYM)
         IF (MPG .GT. 0)                                                &
     &  write(MPG,'(A,I5)')                                             &
     &  ' ... Structural symmetry (in percent)=', symmetry
        IF (MP.GT.0 .AND. MPG.NE.MP)                                    &
     &  write(MP,'(A,I5)')                                              &
     &  ' ... Structural symmetry (in percent)=', symmetry
      ELSE
       symmetry = 100
      ENDIF
      AvgDens = nint(dble(IWFR-1)/dble(N))
      THRESH  = AvgDens*50 - AvgDens/10 + 1
      NBQD    = 0
      IF (N.GT.2) THEN
        IQ(1:N) = 0
        DO I= 1, N
          K = max(LEN(I),1)
          IQ(K) = IQ(K) + 1
          IF (K.GT.THRESH) NBQD = NBQD+1
        ENDDO
        K = 0
        MedDens = 0
        DO WHILE (K .LT. (N/2))
         MedDens = MedDens + 1
         K       = K+IQ(MedDens)
        ENDDO
      ELSE
        MedDens = AvgDens
      ENDIF
         IF (MPG .GT. 0)                                                &
     &  write(MPG,'(A,3I5)')                                            &
     &  ' Density: NBdense, Average, Median   =',                       &
     &  NBQD, AvgDens, MedDens
        IF (MP.GT.0 .AND. MPG.NE.MP)                                    &
     &  write(MP,'(A,3I5)')                                             &
     &  ' Density: NBdense, Average, Median   =',                       &
     &  NBQD, AvgDens, MedDens
      RETURN
99999 FORMAT (/'*** Warning message from analysis routine ***')
      END SUBROUTINE DAGMG_MUMPS_623
      SUBROUTINE DAGMG_MUMPS_549(N,PE,INVPERM,NFILS,WORK)
      IMPLICIT NONE
      INTEGER N
      INTEGER PE(N),INVPERM(N),NFILS(N),WORK(N)
      INTEGER I,FATHER,STKLEN,STKPOS,PERMPOS,CURVAR
      NFILS = 0
      DO I=1,N
         FATHER = -PE(I)
         IF(FATHER .NE. 0) NFILS(FATHER) = NFILS(FATHER) + 1
      ENDDO
      STKLEN = 0
      PERMPOS = 1
      DO I=1,N
         IF(NFILS(I) .EQ. 0) THEN
            STKLEN = STKLEN + 1
            WORK(STKLEN) = I
            INVPERM(I) = PERMPOS
            PERMPOS = PERMPOS + 1
         ENDIF
      ENDDO
      DO STKPOS = 1,STKLEN
         CURVAR = WORK(STKPOS)
         FATHER = -PE(CURVAR)
         DO
            IF(FATHER .EQ. 0) EXIT
            IF(NFILS(FATHER) .EQ. 1) THEN
               INVPERM(FATHER) = PERMPOS
               FATHER = -PE(FATHER)
               PERMPOS = PERMPOS + 1
            ELSE
               NFILS(FATHER) = NFILS(FATHER) - 1
               EXIT
            ENDIF
         ENDDO
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_549
      SUBROUTINE DAGMG_MUMPS_548(N,PE,NV,WORK)
      IMPLICIT NONE
      INTEGER N
      INTEGER PE(N),NV(N),WORK(N)
      INTEGER I,FATHER,LEN,K,NEWSON,NEWFATHER
      DO I=1,N
         IF(NV(I) .GT. 0) CYCLE
         LEN = 1
         WORK(LEN) = I
         FATHER = -PE(I)
         DO
            IF(NV(FATHER) .GT. 0) THEN
               NEWSON = FATHER
               EXIT
            ENDIF
            LEN = LEN + 1
            WORK(LEN) = FATHER
            NV(FATHER) = 1
            FATHER = -PE(FATHER)
         ENDDO
         NEWFATHER = -PE(FATHER)
         PE(WORK(LEN)) = -NEWFATHER
         PE(NEWSON) = -WORK(1)
      ENDDO
      END SUBROUTINE DAGMG_MUMPS_548
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      SUBROUTINE DAGMG_MUMPS_301( id)
      USE DAGMG_MUMPS_STRUC_DEF
      USE DAGMG_MUMPS_COMM_BUFFER
      USE DAGMG_MUMPS_OOC
      USE TOOLS_COMMON
      IMPLICIT NONE
      INTERFACE
      SUBROUTINE DAGMG_MUMPS_710( id, NB_INT,NB_dble )
      USE DAGMG_MUMPS_STRUC_DEF
      TYPE (DAGMG_MUMPS_STRUC) :: id
      INTEGER*8        :: NB_INT,NB_dble
      END SUBROUTINE DAGMG_MUMPS_710
      END INTERFACE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER MASTER, IERR
      PARAMETER( MASTER = 0 )
      TYPE (DAGMG_MUMPS_STRUC), TARGET :: id
      INTEGER MP,LP, MPG
      LOGICAL PROK, PROKG
      INTEGER MTYPE, ICNTL20, ICNTL21
      LOGICAL LSCAL, ERANAL, GIVSOL
      INTEGER ICNTL10, ICNTL11
      INTEGER I,K,JPERM, J, II
      INTEGER IZ, NZ_THIS_BLOCK, IRHS_PTR_BEG, SHIFT_PTR
      INTEGER LIW,LIWW
      INTEGER(8) :: LA, LA_PASSED
      INTEGER LIW_PASSED
      INTEGER LWCB_MIN, LWCB
      INTEGER(8) :: TMP_LWCB8
      INTEGER DAGMG_MUMPS_LBUF, DAGMG_MUMPS_LBUF_INT
      INTEGER IBEG_ROOT_DEF, IEND_ROOT_DEF,                             &
     &        IBEG_GLOB_DEF, IEND_GLOB_DEF,                             &
     &        IROOT_DEF_RHS_COL1
      INTEGER NITREF, NOITER, SOLVET, KASE, JOBIREF
      DOUBLE PRECISION RSOL(1)
      LOGICAL INTERLEAVE_PAR, DO_PERMUT_RHS
      DOUBLE PRECISION ZERO, ONE
      PARAMETER( ZERO = 0.0D0, ONE = 1.0D0 )
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS_AGMG_MUMPS
      DOUBLE PRECISION, DIMENSION(:), POINTER :: WORK_WCB
      DOUBLE PRECISION, ALLOCATABLE :: SAVERHS(:), C_RW1(:),            &
     &                                 C_RW2(:),                        &
     &                                 SRW3(:), C_Y(:),                 &
     &                                 C_W(:)
      DOUBLE PRECISION, ALLOCATABLE :: CWORK(:)
      DOUBLE PRECISION, ALLOCATABLE :: R_RW1(:), R_Y(:), D(:)
      DOUBLE PRECISION, ALLOCATABLE :: R_W(:)
      DOUBLE PRECISION,    ALLOCATABLE, DIMENSION(:) :: R_LOCWK54
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: C_LOCWK54
      INTEGER, DIMENSION(:), ALLOCATABLE :: UNS_PERM_INV,               &
     &                                      POSINRHSCOMP_N
      INTEGER LIWK_SOLVE, LIWCB
      INTEGER, ALLOCATABLE :: IW1(:), IWK_SOLVE(:), IWCB(:)
      INTEGER, POINTER :: N, NZ
      INTEGER(8)       :: MAXS
      INTEGER, POINTER :: NRHS, LRHS
      DOUBLE PRECISION, DIMENSION(:), POINTER :: CNTL
      INTEGER, DIMENSION (:), POINTER :: KEEP,ICNTL,INFO
      INTEGER*8, DIMENSION (:), POINTER :: KEEP8
      INTEGER, DIMENSION (:), POINTER :: IS
      DOUBLE PRECISION, DIMENSION(:),POINTER::   RINFOG
      type scaling_data_t
        SEQUENCE
        DOUBLE PRECISION, dimension(:), pointer :: SCALING
        DOUBLE PRECISION, dimension(:), pointer :: SCALING_LOC
      end type scaling_data_t
      type (scaling_data_t) :: scaling_data
      DOUBLE PRECISION ARRET
      DOUBLE PRECISION C_DUMMY(1)
      DOUBLE PRECISION R_DUMMY(1)
      INTEGER IDUMMY(1), JDUMMY(1), KDUMMY(1), JJ, WHAT
      INTEGER allocok, PERLU
      INTEGER NBRHS, NBRHS_EFF, BEG_RHS,                                &
     &        IBEG, LD_RHS, KDEC,                                       &
     &        MASTER_ROOT, MASTER_ROOT_IN_COMM
      INTEGER IPT_RHS_ROOT, SIZE_ROOT, LD_REDRHS
      INTEGER IBEG_REDRHS, IBEG_RHSCOMP, LD_RHSCOMP, LENRHSCOMP
      INTEGER NB_K133, IRANK, TSIZE
      LOGICAL WORKSPACE_MINIMAL_PREFERRED, WK_USER_PROVIDED
      INTEGER*8  NB_BYTES
      INTEGER*8  NB_BYTES_MAX
      INTEGER*8 NB_INT, NB_dble, K34_8, K35_8, NB_BYTES_ON_ENTRY
      INTEGER*8 K16_8, ITMP8
      INTEGER, DIMENSION(:), POINTER :: IRHS_SPARSE_COPY
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RHS_SPARSE_COPY
      LOGICAL I_AM_SLAVE, BUILD_POSINRHSCOMP
      LOGICAL WORK_WCB_ALLOCATED
      INTEGER  MTYPE_LOC
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      NULLIFY(RHS_AGMG_MUMPS)
      NULLIFY(IRHS_SPARSE_COPY)
      NULLIFY(RHS_SPARSE_COPY)
      NULLIFY(WORK_WCB)
      WORK_WCB_ALLOCATED=.FALSE.
      N    =>id%N
      NZ   =>id%NZ
      NRHS =>id%NRHS
      LRHS =>id%LRHS
      CNTL =>id%CNTL
      KEEP =>id%KEEP
      KEEP8=>id%KEEP8
      IS   =>id%IS
      ICNTL=>id%ICNTL
      INFO =>id%INFO
      RINFOG =>id%RINFOG
      MP  = ICNTL( 2 )
      MPG = ICNTL( 3 )
      LP  = ICNTL( 1 )
      PROK  = (MP.GT.0)
      PROKG = (MPG.GT.0 .and. id%MYID.eq.MASTER)
      IF ( PROK  ) WRITE(MP,100)
      IF ( PROKG ) WRITE(MPG,100)
      NB_BYTES     = 0_8
      NB_BYTES_MAX = 0_8
      K34_8    = int(KEEP(34), 8)
      K35_8    = int(KEEP(35), 8)
      K16_8    = int(KEEP(16), 8)
      LSCAL              = .FALSE.
      WORK_WCB_ALLOCATED = .FALSE.
      ICNTL20  = 0
      ICNTL21  = 0
      I_AM_SLAVE = ( id%MYID .ne. MASTER  .OR.                          &
     &             ( id%MYID .eq. MASTER .AND.                          &
     &               KEEP(46) .eq. 1 ) )
       CALL DAGMG_MUMPS_710(id, NB_INT,NB_dble  )
       NB_BYTES = NB_BYTES + NB_INT * K34_8 + NB_dble * K35_8
       NB_BYTES_ON_ENTRY = NB_BYTES
       NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
      INTERLEAVE_PAR   =.FALSE.
      DO_PERMUT_RHS    =.FALSE.
      WK_USER_PROVIDED = .FALSE.
      BUILD_POSINRHSCOMP = .TRUE.
      SIZE_ROOT   = -33333
      IF ( KEEP( 38 ) .ne. 0 ) THEN
            MASTER_ROOT = AGMG_MUMPS_275(id%STEP( KEEP(38)),                 &
     &                    id%PROCNODE_STEPS, id%NSLAVES )
            IF (id%MYID_NODES .eq. MASTER_ROOT) THEN
              SIZE_ROOT = id%root%TOT_ROOT_SIZE
            ELSE IF ((id%MYID.EQ.MASTER).AND.KEEP(60).NE.0) THEN
              SIZE_ROOT=id%SIZE_SCHUR
            ENDIF
      ELSE IF (KEEP( 20 ) .ne. 0 ) THEN
            MASTER_ROOT = AGMG_MUMPS_275(id%STEP(KEEP(20)),                  &
     &                    id%PROCNODE_STEPS, id%NSLAVES )
            IF (id%MYID_NODES .eq. MASTER_ROOT) THEN
              SIZE_ROOT = id%IS(                                        &
     &               id%PTLUST_S(id%STEP(KEEP(20)))+KEEP(IXSZ))
            ELSE IF ((id%MYID.EQ.MASTER).AND.KEEP(60).NE.0) THEN
              SIZE_ROOT=id%SIZE_SCHUR
            ENDIF
      ELSE
            MASTER_ROOT = -44444
      END IF
      IF (id%MYID.EQ.MASTER) THEN
        CALL DAGMG_MUMPS_634(KEEP,ICNTL,MPG)
        IF (KEEP(111).eq.-1 .AND. NRHS .NE. KEEP(112)+KEEP(17))THEN
                INFO(1)=-32
                INFO(2)=NRHS
         ENDIF
         IF (KEEP(111).gt.0 .AND. NRHS .NE. 1) THEN
                INFO(1)=-32
                INFO(2)=1
         ENDIF
         IF (( KEEP(111) .LT. -1 ) .OR.                                 &
     &     (KEEP(111).GT.KEEP(112)+KEEP(17)) .OR.                       &
     &     (KEEP(111) .EQ.-1 .AND. KEEP(112)+KEEP(17).EQ.0))            &
     &     THEN
                INFO(1)=-36
                INFO(2)=KEEP(111)
         ENDIF
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1) < 0) RETURN
      CALL AGMG_SETIERR(IERR)
      IF (id%MYID .eq. MASTER) THEN
        KEEP(84) = ICNTL(27)
        IF (KEEP(201) .EQ. 0 .OR. KEEP(84) .GT. 0) THEN
          NBRHS = abs(KEEP(84))
        ELSE
          NBRHS = -2*KEEP(84)
        END IF
        IF (NBRHS .GT. NRHS ) NBRHS = NRHS
      ENDIF
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      IF (KEEP(201).NE.0) THEN
          WORKSPACE_MINIMAL_PREFERRED = .FALSE.
          IF (id%MYID .eq. MASTER) THEN
             KEEP(107) = max(0,KEEP(107))
             IF ((KEEP(107).EQ.0).AND.                                  &
     &            (KEEP(204).EQ.0).AND.(KEEP(211).NE.1) ) THEN
              WORKSPACE_MINIMAL_PREFERRED=.TRUE.
             ENDIF
          ENDIF
          CALL AGMG_SETIERR( IERR )
          CALL AGMG_SETIERR( IERR )
          CALL AGMG_SETIERR( IERR )
          CALL AGMG_SETIERR( IERR )
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        NB_K133     = 3
        IF ( KEEP( 38 ) .NE. 0 .OR. KEEP( 20 ) .NE. 0 ) THEN
          IF ( MASTER_ROOT .eq. id%MYID_NODES ) THEN
            NB_K133 = NB_K133 + 1
          END IF
        ENDIF
        LWCB_MIN = NB_K133*KEEP(133)*NBRHS
        WK_USER_PROVIDED = (id%LWK_USER.NE.0)
        IF (id%LWK_USER.EQ.0) THEN
          ITMP8 = 0_8
        ELSE IF (id%LWK_USER.GT.0) THEN
          ITMP8= int(id%LWK_USER,8)
        ELSE
          ITMP8 = -int(id%LWK_USER,8)* 1000000_8
        ENDIF
        IF (KEEP(201).EQ.0) THEN
          IF (ITMP8.NE.KEEP8(24)) THEN
            INFO(1) = -41
            INFO(2) = id%LWK_USER
            GOTO 99
           ENDIF
        ELSE
          KEEP8(24)=ITMP8
        ENDIF
        MAXS = 0_8
        IF (WK_USER_PROVIDED) THEN
           MAXS = KEEP8(24)
           IF (MAXS.LT. KEEP8(20)) THEN
                  INFO(1)= -11
                  ITMP8  = KEEP8(20)+1_8-MAXS
                  CALL  AGMG_MUMPS_731(ITMP8, INFO(2))
           ENDIF
           IF (INFO(1) .GE. 0 ) id%S => id%WK_USER(1:KEEP8(24))
        ELSE IF (associated(id%S)) THEN
           MAXS = KEEP8(23)
        ELSE
          IF (KEEP(201).EQ.0) THEN
            WRITE(*,*) ' Working array S not allocated ',               &
     &                ' on entry to solve phase (in core) '
            CALL AGMG_MUMPS_ABORT()
          ELSE
            IF ( KEEP(209).EQ.-1 .AND. WORKSPACE_MINIMAL_PREFERRED)     &
     &        THEN
              MAXS = KEEP8(20) + 1_8
            ELSE IF ( KEEP(209) .GE.0 ) THEN
              MAXS = max(int(KEEP(209),8), KEEP8(20) + 1_8)
            ELSE
              MAXS  = id%KEEP8(14)
            ENDIF
            ALLOCATE (id%S(MAXS), stat = allocok)
            KEEP8(23)=MAXS
            IF ( allocok .GT. 0 ) THEN
              WRITE(*,*) ' Problem allocation of S at solve'
              INFO(1) = -13
              CALL AGMG_MUMPS_731(MAXS, INFO(2))
              NULLIFY(id%S)
              KEEP8(23)=0_8
            ENDIF
            NB_BYTES = NB_BYTES + KEEP8(23) * K35_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          ENDIF
        ENDIF
        IF(KEEP(201).EQ.0)THEN
           LA  = KEEP8(31)
        ELSE
           LA = MAXS
           IF(MAXS.GT.KEEP8(31)+KEEP8(20)*int(KEEP(107)+1,8))THEN
             LA=KEEP8(31)+KEEP8(20)*int(KEEP(107)+1,8)
           ENDIF
        ENDIF
        IF ( MAXS-LA .GT. int(LWCB_MIN,8) ) THEN
           TMP_LWCB8 = min( MAXS - LA, int(huge(LWCB),8) )
           LWCB      = int( TMP_LWCB8, kind(LWCB) )
           WORK_WCB => id%S(LA+1_8:LA+TMP_LWCB8)
           WORK_WCB_ALLOCATED=.FALSE.
        ELSE
           LWCB = LWCB_MIN
           ALLOCATE(WORK_WCB(LWCB_MIN), stat = allocok)
           IF (allocok < 0 ) THEN
                   INFO(1)=-13
                   INFO(2)=LWCB_MIN
           ENDIF
           WORK_WCB_ALLOCATED=.TRUE.
           NB_BYTES = NB_BYTES + int(size(WORK_WCB),8)*K35_8
           NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        ENDIF
      ENDIF
   99 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1) < 0) GOTO 90
      IF ( I_AM_SLAVE ) THEN
        IF (KEEP(201).NE.0) THEN
          IF (KEEP(201).EQ.1                                            &
     &                      .AND. KEEP(50).EQ.0) THEN
            OOC_NB_FILE_TYPE=2
          ELSE
            OOC_NB_FILE_TYPE=1
          ENDIF
          CALL DAGMG_MUMPS_590(LA)
          CALL DAGMG_MUMPS_586(id)
        ENDIF
      ENDIF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1) < 0) GOTO 90
      IF (id%MYID .eq. MASTER) THEN
        MTYPE = ICNTL(  9 )
        IF ( PROKG )  THEN
           WRITE( MPG, 150 )                                            &
     &             NRHS, NBRHS, ICNTL(9), ICNTL(10), ICNTL(11),         &
     &             ICNTL(20), ICNTL(21)
           IF (KEEP(111).NE.0) THEN
            WRITE (MPG, 151) KEEP(111)
           ENDIF
           IF (KEEP(221).NE.0) THEN
            WRITE (MPG, 152) KEEP(221)
           ENDIF
        ENDIF
        ICNTL20 = ICNTL(20)
        ICNTL21 = ICNTL(21)
        IF (ICNTL20.ne.0.and.ICNTL20.ne.1) ICNTL20=0
        IF (ICNTL20 .NE.0.AND.KEEP(111).NE.0) THEN
          IF (PROKG) WRITE(MPG,'(A)')                                   &
     &    ' WARNING: ICNTL(20) treated as if set to 0 (null space)'
          ICNTL20 = 0
        ENDIF
        IF (ICNTL21.ne.0.and.ICNTL21.ne.1) ICNTL21=0
        LSCAL = (((KEEP(52) .GT. 0) .AND. (KEEP(52) .LE. 8)) .OR. (     &
     &    KEEP(52) .EQ. -1) .OR. KEEP(52) .EQ. -2)
        ERANAL = ((ICNTL(11) .GT. 0) .OR. (ICNTL(10) .GT. 0))
        IF ( (KEEP(55).eq.0) .AND. KEEP(54).eq.0 .AND.                  &
     &      .NOT.associated(id%A) ) THEN
          ICNTL10 = 0
          ICNTL11 = 0
          ERANAL = .FALSE.
        ELSE
          ICNTL10 = ICNTL(10)
          ICNTL11 = ICNTL(11)
        ENDIF
        IF (KEEP(111).NE.0) THEN
          IF (ICNTL10 .GT. 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &    ' WARNING: ICNTL(10) treated as if set to 0 (null space)'
          ENDIF
          IF (ICNTL11 .GT. 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &    ' WARNING: ICNTL(11) treated as if set to 0 (null space)'
          ENDIF
          ICNTL10 = 0
          ICNTL11 = 0
          ERANAL = .FALSE.
        END IF
        IF (KEEP(221).NE.0) THEN
          IF (ICNTL10 .GT. 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &    ' WARNING: ICNTL(10) treated as if set to 0 (reduced RHS))'
          ENDIF
          IF (ICNTL11 .GT. 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &    ' WARNING: ICNTL(11) treated as if set to 0 (reduced RHS)'
          ENDIF
          ICNTL10 = 0
          ICNTL11 = 0
          ERANAL = .FALSE.
        END IF
        IF ((ERANAL .AND. NBRHS > 1) .OR. ICNTL(21) > 0) THEN
          IF (ICNTL11 > 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &     ' WARNING: ICNTL(11) treated as if set to zero'
            ICNTL11=0
          ENDIF
          IF (ICNTL10 > 0) THEN
            IF (PROKG) WRITE(MPG,'(A)')                                 &
     &     ' WARNING: ICNTL(10) treated as if set to zero'
            ICNTL10=0
          ENDIF
          ERANAL = .FALSE.
        ENDIF
        IF (ERANAL) THEN
            ALLOCATE(SAVERHS(N*NBRHS),stat = allocok)
            IF ( allocok .GT. 0 ) THEN
              WRITE(*,*) ' Problem in solve: error allocating SAVERHS'
              INFO(1) = -13
              INFO(2) = N*NBRHS
              GOTO 111
            END IF
            NB_BYTES = NB_BYTES + int(size(SAVERHS),8)*K35_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        ENDIF
      END IF
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
      CALL AGMG_SETIERR(IERR)
        id%LBUFR_BYTES =   ( ( 20 + KEEP(133) ) * KEEP(34) +            &
     &                      KEEP(133) * NBRHS * KEEP(35) )
        TSIZE = MIN(10*id%LBUFR_BYTES, 10000000)
        id%LBUFR_BYTES = MAX(id%LBUFR_BYTES,TSIZE)
        id%LBUFR = ( id%LBUFR_BYTES + KEEP(34) - 1 ) / KEEP(34)
        IF ( associated (id%BUFR) ) THEN
          NB_BYTES = NB_BYTES - int(size(id%BUFR),8)*K34_8
          DEALLOCATE(id%BUFR)
        ENDIF
        ALLOCATE (id%BUFR(id%LBUFR),stat=allocok)
        IF ( allocok .GT. 0 ) THEN
            IF (LP.GT.0)                                                &
     &      WRITE(LP,*) id%MYID,                                        &
     &      ' Problem in solve: error allocating BUFR'
            INFO(1) = -13
            INFO(2) = id%LBUFR
            GOTO 111
        ENDIF
        NB_BYTES = NB_BYTES + int(size(id%BUFR),8)*K34_8
        NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
      IF ( I_AM_SLAVE ) THEN
        DAGMG_MUMPS_LBUF_INT = ( 20 + id%NSLAVES * id%NSLAVES  * 4 )         &
     &                 * KEEP(34)
        DAGMG_MUMPS_LBUF = id%LBUFR_BYTES * id%NSLAVES + 3 * KEEP(34)
        CALL DAGMG_MUMPS_55( DAGMG_MUMPS_LBUF_INT, IERR )
        IF ( IERR .NE. 0 ) THEN
          INFO(1) = -13
          INFO(2) = DAGMG_MUMPS_LBUF_INT
          IF ( LP .GT. 0 ) THEN
            WRITE(LP,*) id%MYID,                                        &
     &      ':Error allocating small Send buffer:IERR=',IERR
          END IF
          GOTO 111
        END IF
        CALL DAGMG_MUMPS_53( DAGMG_MUMPS_LBUF, IERR )
        IF ( IERR .NE. 0 ) THEN
          INFO(1) = -13
          INFO(2) = DAGMG_MUMPS_LBUF
          IF ( LP .GT. 0 ) THEN
            WRITE(LP,*) id%MYID,                                        &
     &      ':Error allocating Send buffer:IERR=', IERR
          END IF
          GOTO 111
        END IF
      ENDIF
      IF (                                                              &
     &  ( id%MYID .NE. MASTER )                                         &
     &     .or.                                                         &
     &    (id%MYID .EQ. MASTER .AND. ICNTL21 .NE.0 .AND.                &
     &       ( ICNTL20.ne.0 .OR. KEEP(111).NE.0 ) )                     &
     &    ) THEN
        IF ( I_AM_SLAVE ) THEN
          ALLOCATE(RHS_AGMG_MUMPS(N*NBRHS),stat=IERR)
          NB_BYTES = NB_BYTES + int(size(RHS_AGMG_MUMPS),8)*K35_8
          NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        ENDIF
        IF ( IERR .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=N*NBRHS
          IF (LP > 0)                                                   &
     &      WRITE(LP,*) 'ERREUR while allocating RHS on a slave'
          GOTO 111
        END IF
      ELSE
        RHS_AGMG_MUMPS=>id%RHS
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        LD_RHSCOMP = max(KEEP(89),1)
        IF (id%MYID.EQ.MASTER) THEN
            LD_RHSCOMP = MAX (LD_RHSCOMP, KEEP(247))
        ENDIF
        IF (KEEP(221).EQ.2) THEN
           IF (.NOT.associated(id%RHSCOMP)) THEN
             INFO(1) = -35
             INFO(2) = 1
             GOTO 111
           ENDIF
           IF (.NOT.associated(id%POSINRHSCOMP)) THEN
             INFO(1) = -35
             INFO(2) = 2
             GOTO 111
           ENDIF
           LENRHSCOMP = SIZE(id%RHSCOMP)
        ELSE IF (KEEP(221).EQ.1) THEN
          IF (associated(id%RHSCOMP)) THEN
            NB_BYTES = NB_BYTES - int(size(id%RHSCOMP),8)*K35_8
            DEALLOCATE(id%RHSCOMP)
          ENDIF
          LENRHSCOMP = LD_RHSCOMP*NRHS
          ALLOCATE (id%RHSCOMP(LENRHSCOMP))
          NB_BYTES = NB_BYTES + int(size(id%RHSCOMP),8)*K35_8
          IF (associated(id%POSINRHSCOMP)) THEN
            NB_BYTES = NB_BYTES - int(size(id%POSINRHSCOMP),8)*K34_8
            DEALLOCATE(id%POSINRHSCOMP)
          ENDIF
          ALLOCATE (id%POSINRHSCOMP(KEEP(28)) )
          NB_BYTES = NB_BYTES + int(size(id%POSINRHSCOMP),8)*K34_8
          NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        ELSE
          LENRHSCOMP = LD_RHSCOMP*NBRHS
          IF (associated(id%RHSCOMP)) THEN
           NB_BYTES = NB_BYTES - int(size(id%RHSCOMP),8)*K35_8
           DEALLOCATE(id%RHSCOMP)
           NULLIFY(id%RHSCOMP)
          ENDIF
          ALLOCATE (id%RHSCOMP(LENRHSCOMP))
          NB_BYTES = NB_BYTES + int(size(id%RHSCOMP),8)*K35_8
          IF (associated(id%POSINRHSCOMP)) THEN
            NB_BYTES = NB_BYTES - int(size(id%POSINRHSCOMP),8)*K34_8
            DEALLOCATE(id%POSINRHSCOMP)
          ENDIF
          ALLOCATE (id%POSINRHSCOMP(KEEP(28)) )
          NB_BYTES = NB_BYTES + int(size(id%POSINRHSCOMP),8)*K34_8
          NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        ENDIF
        LIWK_SOLVE = 4 * KEEP(28) + 1
        IF (KEEP(201).EQ.1) THEN
          LIWK_SOLVE = LIWK_SOLVE + KEEP(228) + 1
        ELSE
          LIWK_SOLVE = LIWK_SOLVE + 1
        ENDIF
        ALLOCATE ( IWK_SOLVE( LIWK_SOLVE), stat = allocok )
        IF (allocok .GT. 0 ) THEN
         INFO(1)=-13
         INFO(2)=LIWK_SOLVE
         GOTO 111
        END IF
        NB_BYTES = NB_BYTES + int(LIWK_SOLVE,8)*K34_8
        NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        LIWCB =  20*NB_K133*2 + KEEP(133)
        ALLOCATE ( IWCB( LIWCB), stat = allocok )
        IF (allocok .GT. 0 ) THEN
         INFO(1)=-13
         INFO(2)=LIWCB
         GOTO 111
        END IF
        NB_BYTES = NB_BYTES + int(LIWCB,8)*K34_8
        NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        LIW = KEEP(32)
        ALLOCATE(SRW3(KEEP(133)), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=KEEP(133)
          GOTO 111
        END IF
        NB_BYTES = NB_BYTES + int(size(SRW3),8)*K35_8
        NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        IF ( (KEEP(111).NE.0) .OR. (ICNTL20.NE.0) ) THEN
          ALLOCATE(POSINRHSCOMP_N(id%N), stat=allocok)
          IF ( allocok .GT. 0 ) THEN
            IF (LP.GT.0) WRITE(LP,*)                                    &
     &     ' ERROR in DMUMPS_301: allocating POSINRHSCOMP_N'
            INFO(1) = -13
            INFO(2) = N
            GOTO 111
          END IF
          NB_BYTES = NB_BYTES + int(size(POSINRHSCOMP_N),8)*K34_8
          NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
        END IF
      ELSE
        LIW=0
      END IF
  111 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1) .LT.0 ) GOTO 90
      IF ( ICNTL21==1 ) THEN
        IF (LSCAL) THEN
          IF (id%MYID.NE.MASTER) THEN
            IF (MTYPE == 1) THEN
              ALLOCATE(id%COLSCA(id%N),stat=allocok)
            ELSE
              ALLOCATE(id%ROWSCA(id%N),stat=allocok)
            ENDIF
            IF (allocok > 0) THEN
              IF (LP > 0) THEN
               WRITE(LP,*) 'Error allocating temporary scaling array'
              ENDIF
              INFO(1)=-13
              INFO(2)=id%N
              GOTO 40
            ENDIF
            NB_BYTES = NB_BYTES + int(id%N,8)*K16_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          ENDIF
          IF (MTYPE == 1) THEN
              CALL AGMG_SETIERR(IERR)
              scaling_data%SCALING=>id%COLSCA
          ELSE
              CALL AGMG_SETIERR(IERR)
              scaling_data%SCALING=>id%ROWSCA
          ENDIF
          IF (I_AM_SLAVE) THEN
            ALLOCATE(scaling_data%SCALING_LOC(id%KEEP(89)),             &
     &               stat=allocok)
            IF (allocok > 0) THEN
              IF (LP > 0) THEN
                WRITE(LP,*) 'Error allocating local scaling array'
              ENDIF
              INFO(1)=-13
              INFO(2)=id%KEEP(89)
              GOTO 40
            ENDIF
            NB_BYTES = NB_BYTES + int(id%KEEP(89),8)*K16_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          ENDIF
        ENDIF
        IF ( I_AM_SLAVE ) THEN
          LIW_PASSED=max(1,LIW)
          IF (KEEP(89) .GT. 0) THEN
            CALL DAGMG_MUMPS_535( MTYPE, id%ISOL_LOC(1),                     &
     &               id%LSOL_LOC, id%PTLUST_S(1),                       &
     &               id%KEEP(1),id%KEEP8(1),                            &
     &               id%IS(1), LIW_PASSED,id%MYID_NODES,                &
     &               id%N, id%STEP(1), id%PROCNODE_STEPS(1),            &
     &               id%NSLAVES, scaling_data, LSCAL )
          ENDIF
          IF (id%MYID.NE.MASTER .AND. LSCAL) THEN
            IF (MTYPE == 1) THEN
              DEALLOCATE(id%COLSCA)
              NULLIFY(id%COLSCA)
            ELSE
              DEALLOCATE(id%ROWSCA)
              NULLIFY(id%ROWSCA)
            ENDIF
            NB_BYTES = NB_BYTES - int(id%N,8)*K16_8
          ENDIF
        ENDIF
        IF (KEEP(23) .NE. 0 .AND. MTYPE==1) THEN
          IF (id%MYID.NE.MASTER) THEN
            ALLOCATE(id%UNS_PERM(id%N),stat=allocok)
            IF (allocok > 0) THEN
              INFO(1)=-13
              INFO(2)=id%N
              GOTO 40
            ENDIF
          ENDIF
        ENDIF
   40   CONTINUE
        CALL AGMG_MUMPS_276( ICNTL, INFO,                                    &
     &                   id%COMM,id%MYID)
        IF (INFO(1) .LT.0 ) GOTO 90
        IF (KEEP(23) .NE. 0 .AND. MTYPE==1) THEN
          CALL AGMG_SETIERR(IERR)
          IF (I_AM_SLAVE) THEN
            DO I=1, KEEP(89)
              id%ISOL_LOC(I) = id%UNS_PERM(id%ISOL_LOC(I))
            ENDDO
          ENDIF
          IF (id%MYID.NE.MASTER) THEN
            DEALLOCATE(id%UNS_PERM)
            NULLIFY(id%UNS_PERM)
          ENDIF
        ENDIF
      ENDIF
      IF ( ( KEEP(221) .EQ. 1 ) .OR.                                    &
     &     ( KEEP(221) .EQ. 2 )                                         &
     &   ) THEN
         IF (KEEP(46).EQ.1) THEN
             MASTER_ROOT_IN_COMM=MASTER_ROOT
         ELSE
             MASTER_ROOT_IN_COMM =MASTER_ROOT+1
         ENDIF
         IF ( id%MYID .EQ. MASTER ) THEN
             IF (NRHS.EQ.1) THEN
               LD_REDRHS = id%SIZE_SCHUR
             ELSE
               LD_REDRHS = id%LREDRHS
             ENDIF
         ENDIF
         IF (MASTER.NE.MASTER_ROOT_IN_COMM) THEN
            IF ( id%MYID .EQ. MASTER ) THEN
             CALL AGMG_NOCALL('MPI_SEND')
            ELSEIF ( id%MYID.EQ.MASTER_ROOT_IN_COMM) THEN
             CALL AGMG_NOCALL('MPI_RECV')
            ENDIF
         ENDIF
      ENDIF
       BEG_RHS=1
       DO WHILE (BEG_RHS.LE.NRHS)
        NBRHS_EFF    = min(NRHS-BEG_RHS+1, NBRHS)
        IF (  .NOT.                                                     &
     &        ( (ICNTL20 .ne. 0 .OR.KEEP(111).NE.0)                     &
     &        .and. ICNTL21.ne.0 )                                      &
     &      )                                                           &
     &      THEN
          IF (id%MYID .eq. MASTER) THEN
            IF (NRHS.GT.1) THEN
              LD_RHS    = LRHS
            ELSE
              LD_RHS    = N
            ENDIF
            IBEG      = (BEG_RHS-1) * LD_RHS + 1
          ELSE
            LD_RHS    = N
            IBEG      = 1
          END IF
        ELSE
          LD_RHS = N
          IBEG   = 1
        ENDIF
        IF (id%MYID.EQ.MASTER .AND. KEEP(221).NE.0) THEN
          IBEG_REDRHS= (BEG_RHS-1)*LD_REDRHS + 1
        ELSE
          IBEG_REDRHS=-142424
        ENDIF
        IF ( I_AM_SLAVE ) THEN
          IF ( KEEP(221).EQ.0 ) THEN
             IBEG_RHSCOMP= 1
          ELSE
             IBEG_RHSCOMP= (BEG_RHS-1)*LD_RHSCOMP + 1
          ENDIF
        ELSE
          IBEG_RHSCOMP=-152525
        ENDIF
      IF (id%MYID .eq. MASTER) THEN
        IF (ICNTL20==1) THEN
          NZ_THIS_BLOCK=id%IRHS_PTR(BEG_RHS+NBRHS_EFF)-                 &
     &                    id%IRHS_PTR(BEG_RHS)
          IF (KEEP(23) .NE. 0 .and. MTYPE .NE. 1) THEN
            ALLOCATE(IRHS_SPARSE_COPY(NZ_THIS_BLOCK),stat=allocok)
            if (allocok .GT.0 ) THEN
              INFO(1)=-13
              INFO(2)=NZ_THIS_BLOCK
              GOTO 30
            endif
            NB_BYTES = NB_BYTES + int(NZ_THIS_BLOCK,8)*K34_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          ELSE
            IRHS_SPARSE_COPY                                            &
     &      =>                                                          &
     &            id%IRHS_SPARSE(id%IRHS_PTR(BEG_RHS):                  &
     &                        id%IRHS_PTR(BEG_RHS)+NZ_THIS_BLOCK-1)
          ENDIF
          IF (LSCAL.OR.DO_PERMUT_RHS.OR.INTERLEAVE_PAR) THEN
            ALLOCATE(RHS_SPARSE_COPY(NZ_THIS_BLOCK), stat=allocok)
            if (allocok .GT.0 ) THEN
              INFO(1)=-13
              INFO(2)=NZ_THIS_BLOCK
              GOTO 30
            endif
            NB_BYTES = NB_BYTES + int(NZ_THIS_BLOCK,8)*K35_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          ELSE
              RHS_SPARSE_COPY                                           &
     &           => id%RHS_SPARSE(id%IRHS_PTR(BEG_RHS):                 &
     &                       id%IRHS_PTR(BEG_RHS)+NZ_THIS_BLOCK-1)
          ENDIF
        ENDIF
        IF (KEEP(23) .NE. 0) THEN
          IF (MTYPE .NE. 1) THEN
            IF (ICNTL20==0) THEN
              ALLOCATE( C_RW2( N ),stat =allocok )
              IF ( allocok .GT. 0 ) THEN
                INFO(1)=-13
                INFO(2)=N
                IF ( LP .GT. 0 ) THEN
                  WRITE(LP,*) id%MYID,                                  &
     &            ':Error allocating C_RW2 in DMUMPS_SOLVE_DRIVE'
                END IF
                GOTO 30
              END IF
              DO K = 1, NBRHS_EFF
               KDEC = IBEG+(K-1)*LD_RHS
               DO I = 1, N
                C_RW2(I)=RHS_AGMG_MUMPS(I-1+KDEC)
               END DO
               DO I = 1, N
                JPERM = id%UNS_PERM(I)
                RHS_AGMG_MUMPS(I-1+KDEC) = C_RW2(JPERM)
               END DO
              END DO
              DEALLOCATE(C_RW2)
            ELSE
              ALLOCATE(UNS_PERM_INV(N),stat=allocok)
              if (allocok .GT.0 ) THEN
                INFO(1)=-13
                INFO(2)=N
                GOTO 30
              endif
              DO I = 1, N
                UNS_PERM_INV(id%UNS_PERM(I))=I
              ENDDO
               DO I = id%IRHS_PTR(BEG_RHS),                             &
     &                 id%IRHS_PTR(BEG_RHS+NBRHS_EFF)-1
                  JPERM = UNS_PERM_INV(id%IRHS_SPARSE(I))
               ENDDO
              DEALLOCATE(UNS_PERM_INV)
            ENDIF
          ENDIF
        ENDIF
        IF (ERANAL) THEN
         IF ( ICNTL20 == 0 ) THEN
          DO K = 1, NBRHS_EFF
            KDEC = IBEG+(K-1)*LD_RHS
            DO I = 1, N
              SAVERHS(I+(K-1)*N) = RHS_AGMG_MUMPS(KDEC+I-1)
            END DO
          ENDDO
         ENDIF
        ENDIF
        IF (LSCAL) THEN
         IF (ICNTL20==0) THEN
          IF (MTYPE .EQ. 1) THEN
            DO K =1, NBRHS_EFF
             KDEC = (K-1) * LD_RHS + IBEG - 1
             DO I = 1, N
              RHS_AGMG_MUMPS(KDEC+I) = RHS_AGMG_MUMPS(KDEC+I) *                   &
     &                            dble(id%ROWSCA(I))
             END DO
            ENDDO
          ELSE
            DO K =1, NBRHS_EFF
             KDEC = (K-1) * LD_RHS + IBEG - 1
             DO I = 1, N
              RHS_AGMG_MUMPS(KDEC+I) = RHS_AGMG_MUMPS(KDEC+I) *                   &
     &                            dble(id%COLSCA(I))
             END DO
            ENDDO
          ENDIF
         ELSE
          KDEC=id%IRHS_PTR(BEG_RHS)
            IF (MTYPE .eq. 1) THEN
             DO IZ=1,NZ_THIS_BLOCK
              I=IRHS_SPARSE_COPY(IZ)
              RHS_SPARSE_COPY(IZ)=id%RHS_SPARSE(KDEC+IZ-1)*             &
     &                            dble(id%ROWSCA(I))
             ENDDO
            ELSE
             DO IZ=1,NZ_THIS_BLOCK
              I=IRHS_SPARSE_COPY(IZ)
              RHS_SPARSE_COPY(IZ)=id%RHS_SPARSE(KDEC+IZ-1)*             &
     &                            dble(id%COLSCA(I))
             ENDDO
            ENDIF
         ENDIF
        END IF
      ENDIF
   30 CONTINUE
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1) .LT.0 ) GOTO 90
      IF ( I_AM_SLAVE ) THEN
       IF ( (KEEP(111).NE.0) .OR. (ICNTL20.NE.0) ) THEN
         IF (BUILD_POSINRHSCOMP) THEN
           IF (KEEP(111).NE.0) THEN
             WHAT      = 2
             MTYPE_LOC = 1
           ELSE
             WHAT      = 1
             MTYPE_LOC = MTYPE
           ENDIF
           LIW_PASSED=max(1,LIW)
           CALL DAGMG_MUMPS_639(id%NSLAVES,id%N,                             &
     &           id%MYID_NODES, id%PTLUST_S(1),                         &
     &           id%KEEP(1),id%KEEP8(1),                                &
     &           id%PROCNODE_STEPS(1), id%IS(1), LIW_PASSED,            &
     &           id%STEP(1),                                            &
     &           id%POSINRHSCOMP(1), POSINRHSCOMP_N(1),                 &
     &           id%N, MTYPE_LOC,                                       &
     &           WHAT )
           BUILD_POSINRHSCOMP = .FALSE.
         ENDIF
       ENDIF
      ENDIF
      IF (KEEP(111).eq.0) THEN
        IF (ICNTL20 == 0) THEN
          IF ( .NOT.I_AM_SLAVE ) THEN
            CALL DAGMG_MUMPS_638(id%NSLAVES,id%N, id%MYID, id%COMM,          &
     &          MTYPE, RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,              &
     &          JDUMMY, id%KEEP(1), id%KEEP8(1), id%PROCNODE_STEPS(1),  &
     &          IDUMMY, 1,                                              &
     &          id%STEP(1), KDUMMY, 1, BUILD_POSINRHSCOMP,              &
     &          id%ICNTL(1),id%INFO(1))
            BUILD_POSINRHSCOMP=.FALSE.
          ELSE
            LIW_PASSED = max( LIW, 1 )
            CALL DAGMG_MUMPS_638(id%NSLAVES,id%N, id%MYID, id%COMM,          &
     &          MTYPE, RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,              &
     &          id%PTLUST_S(1), id%KEEP(1), id%KEEP8(1),                &
     &          id%PROCNODE_STEPS(1),                                   &
     &          IS(1), LIW_PASSED,                                      &
     &          id%STEP(1), id%POSINRHSCOMP(1), KEEP(28),               &
     &          BUILD_POSINRHSCOMP,                                     &
     &          id%ICNTL(1),id%INFO(1))
            BUILD_POSINRHSCOMP=.FALSE.
          ENDIF
          IF (INFO(1).LT.0) GOTO 90
        ELSE
         CALL AGMG_SETIERR(IERR)
         IF (id%MYID==MASTER) THEN
           IRHS_PTR_BEG=BEG_RHS
         ELSE
           IF (associated(IRHS_SPARSE_COPY))                            &
     &                      DEALLOCATE(IRHS_SPARSE_COPY)
           IF  (associated(IRHS_SPARSE_COPY))                           &
     &                      DEALLOCATE(IRHS_SPARSE_COPY)
           ALLOCATE(IRHS_SPARSE_COPY(NZ_THIS_BLOCK))
           ALLOCATE(RHS_SPARSE_COPY(NZ_THIS_BLOCK))
           NB_BYTES = NB_BYTES + int(NZ_THIS_BLOCK,8)*(K34_8+K35_8)
           NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
             ALLOCATE(id%IRHS_PTR(NBRHS_EFF+1))
           NB_BYTES = NB_BYTES + int(size(id%IRHS_PTR),8)*K34_8
           NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
           IRHS_PTR_BEG=1
         ENDIF
         CALL AGMG_SETIERR(IERR)
         CALL AGMG_SETIERR(IERR)
         CALL AGMG_SETIERR(IERR)
         SHIFT_PTR=id%IRHS_PTR(IRHS_PTR_BEG)-1
         IF ( I_AM_SLAVE ) THEN
           DO K = 1, NBRHS_EFF
            KDEC = (K-1) * LD_RHS + IBEG - 1
            RHS_AGMG_MUMPS(KDEC+1:KDEC+id%N)=dble(ZERO)
            DO IZ=id%IRHS_PTR(IRHS_PTR_BEG+K-1)-SHIFT_PTR,              &
     &          id%IRHS_PTR(IRHS_PTR_BEG+K)-1-SHIFT_PTR
              I=IRHS_SPARSE_COPY(IZ)
                IF (POSINRHSCOMP_N(I).NE.0) THEN
                 RHS_AGMG_MUMPS(KDEC+I)= RHS_SPARSE_COPY(IZ)
                ENDIF
            ENDDO
           ENDDO
         END IF
         IF (id%MYID .ne. MASTER) THEN
           NB_BYTES = NB_BYTES - int(size(IRHS_SPARSE_COPY),8)*K34_8 -  &
     &               int(size(RHS_SPARSE_COPY),8)*K35_8 -               &
     &               int(size(id%IRHS_PTR),8)*K34_8
           DEALLOCATE(IRHS_SPARSE_COPY)
           DEALLOCATE(RHS_SPARSE_COPY)
           DEALLOCATE(id%IRHS_PTR)
           NULLIFY(IRHS_SPARSE_COPY)
           NULLIFY(RHS_SPARSE_COPY)
           NULLIFY(id%IRHS_PTR)
         ELSE
           IF (KEEP(23).ne.0 .and. MTYPE.ne.1) THEN
             NB_BYTES = NB_BYTES - int(size(IRHS_SPARSE_COPY),8)*K34_8
             DEALLOCATE(IRHS_SPARSE_COPY)
           ENDIF
           NULLIFY(IRHS_SPARSE_COPY)
           IF (LSCAL.OR.DO_PERMUT_RHS.OR.INTERLEAVE_PAR) THEN
             NB_BYTES = NB_BYTES - int(size(RHS_SPARSE_COPY),8)*K35_8
             DEALLOCATE(RHS_SPARSE_COPY)
             NULLIFY(RHS_SPARSE_COPY)
           ENDIF
         ENDIF
      ENDIF
      ELSE IF (I_AM_SLAVE) THEN
        IF (KEEP(111).GT.0) THEN
          IBEG_GLOB_DEF = KEEP(111)
          IEND_GLOB_DEF = KEEP(111)
        ELSE
          IBEG_GLOB_DEF = BEG_RHS
          IEND_GLOB_DEF = BEG_RHS+NBRHS_EFF-1
        ENDIF
        DO K=1, NBRHS_EFF
          KDEC = (K-1) *LD_RHSCOMP
          id%RHSCOMP(KDEC+1:KDEC+LD_RHSCOMP)=dble(ZERO)
        END DO
        DO I=max(IBEG_GLOB_DEF,KEEP(220)),                              &
     &       min(IEND_GLOB_DEF,KEEP(220)+KEEP(109)-1)
          JJ= POSINRHSCOMP_N(id%PIVNUL_LIST(I-KEEP(220)+1))
          IF (JJ.GT.0)                                                  &
     &     id%RHSCOMP(IBEG_RHSCOMP -1+ (I-IBEG_GLOB_DEF)*LD_RHSCOMP     &
     &                + JJ) =  dble(ONE)
        ENDDO
        IF ( KEEP(17).NE.0 .and. id%MYID_NODES.EQ.MASTER_ROOT) THEN
            IBEG_ROOT_DEF  = max(IBEG_GLOB_DEF,KEEP(112)+1)
            IEND_ROOT_DEF  = min(IEND_GLOB_DEF,KEEP(112)+KEEP(17))
            IROOT_DEF_RHS_COL1 = IBEG_ROOT_DEF-IBEG_GLOB_DEF + 1
            IBEG_ROOT_DEF = IBEG_ROOT_DEF-KEEP(112)
            IEND_ROOT_DEF = IEND_ROOT_DEF-KEEP(112)
        ELSE
            IBEG_ROOT_DEF = -90999
            IEND_ROOT_DEF = -90999
        ENDIF
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        IF ( id%MYID_NODES .EQ. MASTER_ROOT ) THEN
          IPT_RHS_ROOT = LWCB - NBRHS_EFF * SIZE_ROOT + 1
        ELSE
          IPT_RHS_ROOT = LWCB
        ENDIF
      ENDIF
      IF (KEEP(221) .EQ. 2 ) THEN
         IF ( ( id%MYID .EQ. MASTER_ROOT_IN_COMM ) .AND.                &
     &        ( id%MYID .EQ. MASTER ) ) THEN
            II = IPT_RHS_ROOT-1
            DO K=1, NBRHS_EFF
             KDEC = IBEG_REDRHS+(K-1)*LD_REDRHS -1
             DO I = 1, SIZE_ROOT
              WORK_WCB(II+I) = id%REDRHS(KDEC+I)
             ENDDO
             II = II+SIZE_ROOT
            ENDDO
         ELSE
          IF ( id%MYID .EQ. MASTER) THEN
            IF (LD_REDRHS.EQ.SIZE_ROOT) THEN
               KDEC = IBEG_REDRHS
               CALL AGMG_NOCALL('MPI_SEND')
            ELSE
              DO K=1, NBRHS_EFF
                KDEC = IBEG_REDRHS+(K-1)*LD_REDRHS
                CALL AGMG_NOCALL('MPI_SEND')
              ENDDO
            ENDIF
          ELSE IF ( id%MYID .EQ. MASTER_ROOT_IN_COMM ) THEN
            II = IPT_RHS_ROOT
            IF (LD_REDRHS.EQ.SIZE_ROOT) THEN
               CALL AGMG_NOCALL('MPI_RECV')
            ELSE
             DO K=1, NBRHS_EFF
              CALL AGMG_NOCALL('MPI_RECV')
              II = II + SIZE_ROOT
             ENDDO
            ENDIF
          ENDIF
         ENDIF
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        LIW_PASSED = max( LIW, 1 )
        LA_PASSED  = max( LA, 1_8 )
        CALL DAGMG_MUMPS_245(id%root, N, id%S(1), LA_PASSED,                 &
     &    IS(1), LIW_PASSED,                                            &
     &    WORK_WCB, LWCB,                                               &
     &    IWCB, LIWCB,                                                  &
     &    RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,                           &
     &    id%NA,id%LNA,id%NE_STEPS(1), SRW3, MTYPE,                     &
     &    ICNTL, id%STEP(1), id%FRERE_STEPS(1),                         &
     &    id%DAD_STEPS(1), id%FILS(1),                                  &
     &    id%PTLUST_S(1), id%PTRFAC(1),                                 &
     &    IWK_SOLVE, LIWK_SOLVE,                                        &
     &    id%PROCNODE_STEPS,                                            &
     &    id%NSLAVES, INFO, KEEP,KEEP8,                                 &
     &    id%COMM, id%COMM_NODES, id%MYID,                              &
     &    id%MYID_NODES,                                                &
     &    id%BUFR,                                                      &
     &    id%LBUFR, id%LBUFR_BYTES,                                     &
     &    id%ISTEP_TO_INIV2(1), id%TAB_POS_IN_PERE(1,1),                &
     &    IBEG_ROOT_DEF, IEND_ROOT_DEF,                                 &
     &    IROOT_DEF_RHS_COL1,                                           &
     &    IPT_RHS_ROOT, SIZE_ROOT, MASTER_ROOT,                         &
     &    id%RHSCOMP(IBEG_RHSCOMP), LD_RHSCOMP,                         &
     &    id%POSINRHSCOMP(1), BUILD_POSINRHSCOMP                        &
     &          )
      END IF
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF (INFO(1).eq.-2) then
        INFO(1)=-11
        IF (LP.GT.0)                                                    &
     &  write(LP,*)                                                     &
     &   ' WARNING : -11 error code obtained in solve'
      END IF
      IF (INFO(1).eq.-3) then
        INFO(1)=-14
        IF (LP.GT.0)                                                    &
     &  write(LP,*)                                                     &
     &    ' WARNING : -14 error code obtained in solve'
      END IF
      IF (INFO(1).LT.0) GO TO 90
      IF ( KEEP(221) .EQ. 1 ) THEN
         IF ( ( id%MYID .EQ. MASTER_ROOT_IN_COMM ) .AND.                &
     &        ( id%MYID .EQ. MASTER ) ) THEN
            II = IPT_RHS_ROOT-1
            DO K=1, NBRHS_EFF
             KDEC = IBEG_REDRHS+(K-1)*LD_REDRHS -1
             DO I = 1, SIZE_ROOT
              id%REDRHS(KDEC+I) = WORK_WCB(II+I)
             ENDDO
             II = II+SIZE_ROOT
            ENDDO
         ELSE
          IF ( id%MYID .EQ. MASTER ) THEN
            IF (LD_REDRHS.EQ.SIZE_ROOT) THEN
               KDEC = IBEG_REDRHS
               CALL AGMG_NOCALL('MPI_RECV')
            ELSE
             DO K=1, NBRHS_EFF
               KDEC = IBEG_REDRHS+(K-1)*LD_REDRHS
               CALL AGMG_NOCALL('MPI_RECV')
             ENDDO
            ENDIF
          ELSE IF ( id%MYID .EQ. MASTER_ROOT_IN_COMM ) THEN
            II = IPT_RHS_ROOT
            IF (LD_REDRHS.EQ.SIZE_ROOT) THEN
               CALL AGMG_NOCALL('MPI_SEND')
            ELSE
             DO K=1, NBRHS_EFF
              CALL AGMG_NOCALL('MPI_SEND')
              II = II + SIZE_ROOT
             ENDDO
            ENDIF
          ENDIF
         ENDIF
      ENDIF
      IF ( KEEP(221) .NE. 1 ) THEN
       IF (ICNTL21 == 0) THEN
        LIW_PASSED = max( LIW, 1 )
        IF ( .NOT.I_AM_SLAVE ) THEN
          ALLOCATE( CWORK(KEEP(247)) )
          CALL DAGMG_MUMPS_521(id%NSLAVES,id%N,                              &
     &          id%MYID, id%COMM,                                       &
     &          MTYPE, RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,              &
     &          JDUMMY, id%KEEP(1), id%KEEP8(1), id%PROCNODE_STEPS(1),  &
     &          IDUMMY, 1,                                              &
     &          id%STEP(1), id%BUFR(1), id%LBUFR, id%LBUFR_BYTES,       &
     &          CWORK(1), KEEP(247))
          DEALLOCATE( CWORK )
        ELSE
        CALL DAGMG_MUMPS_521(id%NSLAVES,id%N, id%MYID, id%COMM,              &
     &          MTYPE, RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,              &
     &          id%PTLUST_S(1), id%KEEP(1), id%KEEP8(1),                &
     &          id%PROCNODE_STEPS(1),                                   &
     &          IS(1), LIW_PASSED,                                      &
     &          id%STEP(1), id%BUFR(1), id%LBUFR, id%LBUFR_BYTES,       &
     &          id%RHSCOMP(1), LENRHSCOMP)
        ENDIF
        IF ( id%MYID.eq.MASTER .AND. LSCAL ) THEN
          IF (MTYPE .EQ. 1) THEN
             DO K= 1, NBRHS_EFF
              KDEC = (K-1) * LD_RHS + IBEG - 1
              DO I = 1, N
                RHS_AGMG_MUMPS(KDEC+ I) = RHS_AGMG_MUMPS(KDEC+ I) *               &
     &                               dble(id%COLSCA(I))
              END DO
             END DO
          ELSE
             DO K= 1, NBRHS_EFF
              KDEC = (K-1) * LD_RHS + IBEG - 1
              DO I = 1, N
                RHS_AGMG_MUMPS(KDEC+I) = RHS_AGMG_MUMPS(KDEC+I) *                 &
     &                              dble(id%ROWSCA(I))
              END DO
             END DO
          ENDIF
        END IF
       ELSE
        IF ( I_AM_SLAVE ) THEN
         LIW_PASSED = max( LIW, 1 )
         IF ( KEEP(89) .GT. 0 ) THEN
           CALL DAGMG_MUMPS_532(id%NSLAVES,                                  &
     &          id%N, id%MYID_NODES,                                    &
     &          MTYPE, RHS_AGMG_MUMPS(IBEG), LD_RHS, NBRHS_EFF,              &
     &          id%ISOL_LOC(1),                                         &
     &          id%SOL_LOC(1), BEG_RHS, id%LSOL_LOC,                    &
     &          id%PTLUST_S(1), id%PROCNODE_STEPS(1),                   &
     &          id%KEEP(1),id%KEEP8(1),                                 &
     &          IS(1), LIW_PASSED,                                      &
     &          id%STEP(1), scaling_data, LSCAL )
         ENDIF
        ENDIF
       ENDIF
      ENDIF
      IF ( ICNTL10 > 0 .AND. NBRHS_EFF > 1 ) THEN
        DO I = 1, ICNTL10
          write(*,*) 'FIXME: to be implemented'
        END DO
      END IF
      IF (ERANAL) THEN
        IF ((ICNTL10 .GT. 0) .AND. (ICNTL11 .GT. 0)) THEN
          IF (id%MYID .EQ. MASTER) THEN
            GIVSOL = .FALSE.
            IF (MP .GT. 0) WRITE( MP, 170 )
            ALLOCATE(R_RW1(N),stat=allocok)
            if (allocok .GT.0 ) THEN
              INFO(1)=-13
              INFO(2)=N
              GOTO 776
            ENDIF
            ALLOCATE(C_RW2(N),stat=allocok)
            IF (allocok .GT.0) THEN
              INFO(1)=-13
              INFO(2)=N
              GOTO 776
            ENDIF
            NB_BYTES = NB_BYTES + int(N,8)*K35_8 + int(N,8)*K16_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
          END IF
  776     CONTINUE
          CALL AGMG_MUMPS_276( ICNTL, INFO,                                  &
     &                  id%COMM,id%MYID)
          IF ( INFO(1) .LT. 0 ) GOTO 90
          IF ( KEEP(54) .eq. 0 ) THEN
            IF (id%MYID .EQ. MASTER) THEN
              IF (KEEP(55).EQ.0) THEN
                CALL DAGMG_MUMPS_278( ICNTL(9), N, NZ, id%A(1),              &
     &             id%IRN(1), id%JCN(1),                                &
     &             RHS_AGMG_MUMPS(IBEG), SAVERHS, R_RW1, C_RW2, KEEP,KEEP8 )
              ELSE
                CALL DAGMG_MUMPS_121( ICNTL(9), N,                           &
     &          id%NELT, id%ELTPTR,                                     &
     &          id%LELTVAR, id%ELTVAR,                                  &
     &          id%NA_ELT, id%A_ELT,                                    &
     &          RHS_AGMG_MUMPS(IBEG), SAVERHS, R_RW1, C_RW2, KEEP,KEEP8 )
              ENDIF
            END IF
          ELSE
            CALL AGMG_SETIERR( IERR )
            ALLOCATE( C_LOCWK54( N ), stat =allocok )
            if (allocok .GT.0 ) THEN
              INFO(1)=-13
              INFO(2)=N
            endif
            CALL AGMG_MUMPS_276(ICNTL, INFO, id%COMM, id%MYID)
            IF ( INFO(1) .LT. 0 ) GOTO 90
            NB_BYTES     = NB_BYTES + int(N,8)*K35_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
            IF ( I_AM_SLAVE .and.                                       &
     &           id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_192( id%N, id%NZ_loc,                         &
     &        id%IRN_loc, id%JCN_loc, id%A_loc,                         &
     &        RHS_AGMG_MUMPS(IBEG), C_LOCWK54, KEEP(50), MTYPE )
            ELSE
              C_LOCWK54 = dble(ZERO)
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( C_LOCWK54, C_RW2,                      id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
              C_RW2 = SAVERHS - C_RW2
            ELSE
              CALL AGMG_COPY( C_LOCWK54, C_DUMMY,                    id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
            NB_BYTES = NB_BYTES - int(size(C_LOCWK54),8)*K35_8
            DEALLOCATE( C_LOCWK54 )
            ALLOCATE( R_LOCWK54( N ), stat =allocok )
            if (allocok .GT.0 ) THEN
              INFO(1)=-13
              INFO(2)=N
            endif
            CALL AGMG_MUMPS_276(ICNTL, INFO, id%COMM, id%MYID)
            IF ( INFO(1) .LT. 0 ) GOTO 90
            NB_BYTES = NB_BYTES + int(N,8)*K16_8
            NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
            IF ( I_AM_SLAVE .AND. id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_207(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%IRN_loc, id%JCN_loc,                                 &
     &          R_LOCWK54, id%KEEP,id%KEEP8)
            ELSE
              R_LOCWK54 = ZERO
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( R_LOCWK54, R_RW1,                      id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            ELSE
              CALL AGMG_COPY( R_LOCWK54, R_DUMMY,                    id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
            NB_BYTES = NB_BYTES - int(size(R_LOCWK54),8)*K16_8
            DEALLOCATE( R_LOCWK54 )
          END IF
          IF ( id%MYID .EQ. MASTER )  THEN
            CALL DAGMG_MUMPS_205(ICNTL(9),INFO(1),N,NZ,                      &
     &        RHS_AGMG_MUMPS(IBEG), SAVERHS,R_RW1,C_RW2,GIVSOL,              &
     &        RSOL,RINFOG(4),RINFOG(5),RINFOG(6),MP,ICNTL,              &
     &        KEEP,KEEP8)
            NB_BYTES = NB_BYTES - int(size(R_RW1),8)*K16_8              &
     &                          - int(size(C_RW2),8)*K35_8
            DEALLOCATE(R_RW1)
            DEALLOCATE(C_RW2)
          END IF
        END IF
      IF ( PROK  .AND. ICNTL10 .GT. 0 ) WRITE( MP, 270 )
      IF ( PROKG .AND. ICNTL10 .GT. 0 ) WRITE( MPG, 270 )
      ALLOCATE(R_Y(N), stat = allocok)
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        GOTO 777
      ENDIF
      NB_BYTES = NB_BYTES + int(N,8)*K16_8
      ALLOCATE(C_Y(N), stat = allocok)
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        GOTO 777
      ENDIF
      NB_BYTES = NB_BYTES + int(N,8)*K35_8
      IF ( id%MYID .EQ. MASTER ) THEN
        ALLOCATE( IW1( 2 * N ),stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=2 * N
          GOTO 777
        ENDIF
        NB_BYTES = NB_BYTES + int(2*N,8)*K34_8
        ALLOCATE( D(N),stat =allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=N
          GOTO 777
        ENDIF
        NB_BYTES = NB_BYTES + int(N,8)*K35_8
        ALLOCATE( C_W(N), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=N
          GOTO 777
        ENDIF
        NB_BYTES = NB_BYTES + int(N,8)*K35_8
        ALLOCATE( R_W(2*N), stat = allocok )
        IF ( allocok .GT. 0 ) THEN
          INFO(1)=-13
          INFO(2)=N
          GOTO 777
        ENDIF
        NB_BYTES = NB_BYTES + int(2*N,8)*K16_8
        NITREF = ICNTL10
        JOBIREF= ICNTL11
        IF ( PROKG .AND. ICNTL10 .GT. 0 )                               &
     &    WRITE( MPG, 240) 'MAXIMUM NUMBER OF STEPS =', NITREF
        DO I = 1, N
          D( I ) = ONE
        END DO
      END IF
      ALLOCATE(C_LOCWK54(N),stat = allocok)
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        GOTO 777
      ENDIF
      NB_BYTES = NB_BYTES + int(N,8)*K35_8
      ALLOCATE(R_LOCWK54(N),stat = allocok)
      IF ( allocok .GT. 0 ) THEN
        INFO(1)=-13
        INFO(2)=N
        GOTO 777
      ENDIF
      NB_BYTES = NB_BYTES + int(N,8)*K16_8
      KASE = 0
  777 CONTINUE
      NB_BYTES_MAX = max(NB_BYTES_MAX,NB_BYTES)
      CALL AGMG_MUMPS_276( ICNTL, INFO,                                      &
     &                   id%COMM,id%MYID)
      IF ( INFO(1) .LT. 0 ) GOTO 90
   22   CONTINUE
        IF ( KEEP(54) .eq. 0 ) THEN
          IF ( id%MYID .eq. MASTER ) THEN
            IF ( KASE .eq. 0 ) THEN
              IF (KEEP(55).NE.0) THEN
               CALL DAGMG_MUMPS_119(MTYPE, N,                                &
     &           id%NELT, id%ELTPTR(1),                                 &
     &           id%LELTVAR, id%ELTVAR(1),                              &
     &           id%NA_ELT, id%A_ELT,                                   &
     &           R_W(N+1), KEEP,KEEP8 )
              ELSE
               IF ( MTYPE .eq. 1 ) THEN
                 CALL DAGMG_MUMPS_207                                        &
     &   ( id%A(1), NZ, N, id%IRN(1), id%JCN(1), R_W(N+1), KEEP,KEEP8)
               ELSE
                 CALL DAGMG_MUMPS_207                                        &
     &   ( id%A(1), NZ, N, id%JCN(1), id%IRN(1), R_W(N+1), KEEP,KEEP8)
               END IF
              ENDIF
            ENDIF
          END IF
        ELSE
          IF ( KASE .eq. 0 ) THEN
            IF ( I_AM_SLAVE .and.                                       &
     &           id%NZ_loc .NE. 0 ) THEN
              IF ( MTYPE .eq. 1 ) THEN
              CALL DAGMG_MUMPS_207(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%IRN_loc, id%JCN_loc,                                 &
     &          R_LOCWK54, id%KEEP,id%KEEP8 )
              ELSE
              CALL DAGMG_MUMPS_207(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%JCN_loc, id%IRN_loc,                                 &
     &          R_LOCWK54, id%KEEP,id%KEEP8 )
              END IF
            ELSE
              R_LOCWK54 = ZERO
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( R_LOCWK54, R_W(N+1:N+id%N),                                id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            ELSE
              CALL AGMG_COPY( R_LOCWK54, R_DUMMY,                      id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
          END IF
        END IF
        IF ( id%MYID .eq. MASTER ) THEN
            ARRET = CNTL(2)
            IF (ARRET .LT. 0.0D0) THEN
              ARRET = sqrt(epsilon(0.0D0))
            END IF
            CALL DAGMG_MUMPS_206(NZ,N,SAVERHS,RHS_AGMG_MUMPS(IBEG),               &
     &      C_Y, D, R_W, C_W,                                           &
     &      IW1, KASE,RINFOG(7),                                        &
     &      RINFOG(9), JOBIREF, RINFOG(10), NITREF, NOITER, MP,         &
     &      KEEP,KEEP8, ARRET )
        END IF
        IF ( KEEP(54) .ne. 0 ) THEN
          CALL AGMG_SETIERR( IERR )
        END IF
        IF ( KEEP(54) .eq. 0 ) THEN
          IF ( id%MYID .eq. MASTER ) THEN
            IF ( KASE .eq. 14 ) THEN
              IF (KEEP(55).NE.0) THEN
               CALL DAGMG_MUMPS_122( MTYPE, N,                               &
     &            id%NELT, id%ELTPTR, id%LELTVAR,                       &
     &            id%ELTVAR, id%NA_ELT, id%A_ELT,                       &
     &            SAVERHS, RHS_AGMG_MUMPS(IBEG),                             &
     &            C_Y, R_W, KEEP(50))
              ELSE
                 IF ( MTYPE .eq. 1 ) THEN
                   CALL DAGMG_MUMPS_208                                      &
     &    (id%A(1), NZ, N, id%IRN(1), id%JCN(1), SAVERHS,               &
     &    RHS_AGMG_MUMPS(IBEG), C_Y, R_W, KEEP,KEEP8)
                 ELSE
                   CALL DAGMG_MUMPS_208                                      &
     &    (id%A(1), NZ, N, id%JCN(1), id%IRN(1), SAVERHS,               &
     &    RHS_AGMG_MUMPS(IBEG), C_Y, R_W, KEEP,KEEP8)
                 END IF
              ENDIF
              GOTO 22
            END IF
          END IF
        ELSE
          IF ( KASE.eq.14 ) THEN
            CALL AGMG_SETIERR( IERR )
            IF ( I_AM_SLAVE .and.                                       &
     &           id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_192( id%N, id%NZ_loc,                         &
     &        id%IRN_loc, id%JCN_loc, id%A_loc,                         &
     &        RHS_AGMG_MUMPS(IBEG), C_LOCWK54, KEEP(50), MTYPE )
            ELSE
              C_LOCWK54 = dble(ZERO)
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( C_LOCWK54, C_Y,                          id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
              C_Y = SAVERHS - C_Y
            ELSE
              CALL AGMG_COPY( C_LOCWK54, C_DUMMY,                      id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
            IF ( I_AM_SLAVE .and. id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_193( id%N, id%NZ_loc,                         &
     &        id%IRN_loc, id%JCN_loc, id%A_loc,                         &
     &        RHS_AGMG_MUMPS(IBEG), R_LOCWK54, KEEP(50), MTYPE )
            ELSE
              R_LOCWK54 = ZERO
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( R_LOCWK54, R_W,                          id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            ELSE
              CALL AGMG_COPY( R_LOCWK54, R_DUMMY,                      id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
            GOTO 22
          END IF
        END IF
      IF ( id%MYID .eq. MASTER ) THEN
        IF ( KASE .GT. 0 ) THEN
          IF ( MTYPE .EQ. 1 ) THEN
            SOLVET = KASE - 1
          ELSE
            SOLVET = KASE
          END IF
          IF ( LSCAL ) THEN
            IF ( SOLVET .EQ. 1 ) THEN
              DO K = 1, N
                C_Y( K ) = C_Y( K ) * id%ROWSCA( K )
              END DO
            ELSE
              DO K = 1, N
                C_Y( K ) = C_Y( K ) * id%COLSCA( K )
              END DO
            END IF
          END IF
        END IF
      END IF
      CALL AGMG_SETIERR( IERR)
      CALL AGMG_SETIERR( IERR)
      IF ( KASE .GT. 0 ) THEN
        CALL AGMG_SETIERR( IERR )
        IF ( id%MYID_NODES .EQ. MASTER_ROOT ) THEN
          IPT_RHS_ROOT = LWCB - NBRHS_EFF * SIZE_ROOT + 1
        ELSE
          IPT_RHS_ROOT = LWCB
        ENDIF
        IF ( I_AM_SLAVE ) THEN
          LIW_PASSED = max( LIW, 1 )
          LA_PASSED = max( LA, 1_8 )
          CALL DAGMG_MUMPS_245( id%root, N,                                  &
     &    id%S(1), LA_PASSED, id%IS( 1 ),                               &
     &    LIW_PASSED, WORK_WCB, LWCB,                                   &
     &    IWCB, LIWCB,                                                  &
     &    C_Y, N, NBRHS_EFF, id%NA, id%LNA, id%NE_STEPS(1),             &
     &    SRW3, SOLVET, ICNTL,                                          &
     &    id%STEP(1), id%FRERE_STEPS(1), id%DAD_STEPS(1),               &
     &    id%FILS(1),                                                   &
     &    id%PTLUST_S(1), id%PTRFAC(1),                                 &
     &    IWK_SOLVE, LIWK_SOLVE,                                        &
     &    id%PROCNODE_STEPS, id%NSLAVES, INFO, KEEP,KEEP8,              &
     &    id%COMM,                                                      &
     &    id%COMM_NODES,                                                &
     &    id%MYID, id%MYID_NODES,                                       &
     &    id%BUFR, id%LBUFR, id%LBUFR_BYTES ,                           &
     &    id%ISTEP_TO_INIV2(1), id%TAB_POS_IN_PERE(1,1),                &
     &    IBEG_ROOT_DEF, IEND_ROOT_DEF,                                 &
     &    IROOT_DEF_RHS_COL1,                                           &
     &    IPT_RHS_ROOT, SIZE_ROOT, MASTER_ROOT,                         &
     &    id%RHSCOMP(IBEG_RHSCOMP), LD_RHSCOMP,                         &
     &    id%POSINRHSCOMP(1), BUILD_POSINRHSCOMP                        &
     &    )
        END IF
        CALL AGMG_MUMPS_276( ICNTL, INFO,                                    &
     &                   id%COMM,id%MYID)
        IF (INFO(1).eq.-2) INFO(1)=-12
        IF (INFO(1).eq.-3) INFO(1)=-15
        IF (INFO(1).LT.0) GO TO 90
        LIW_PASSED = max( LIW, 1 )
        IF ( .NOT. I_AM_SLAVE ) THEN
          ALLOCATE( CWORK(KEEP(247)) )
          CALL DAGMG_MUMPS_521(id%NSLAVES,id%N,                              &
     &          id%MYID, id%COMM,                                       &
     &          MTYPE, C_Y, LD_RHS, NBRHS_EFF,                          &
     &          JDUMMY, id%KEEP(1),id%KEEP8(1), id%PROCNODE_STEPS(1),   &
     &          IDUMMY, 1,                                              &
     &          id%STEP(1), id%BUFR(1), id%LBUFR, id%LBUFR_BYTES,       &
     &          CWORK, KEEP(247))
          DEALLOCATE( CWORK )
        ELSE
          CALL DAGMG_MUMPS_521(id%NSLAVES,id%N,                              &
     &          id%MYID, id%COMM,                                       &
     &          MTYPE, C_Y, LD_RHS, NBRHS_EFF,                          &
     &          id%PTLUST_S(1), id%KEEP(1),id%KEEP8(1),                 &
     &          id%PROCNODE_STEPS(1),                                   &
     &          IS(1), LIW_PASSED,                                      &
     &          id%STEP(1), id%BUFR(1), id%LBUFR, id%LBUFR_BYTES,       &
     &          id%RHSCOMP(1), LENRHSCOMP)
        ENDIF
        IF ( id%MYID.eq.MASTER) THEN
          IF (LSCAL) THEN
            IF (SOLVET .EQ. 1) THEN
               DO K = 1, N
                 C_Y(K) = C_Y(K) * id%COLSCA(K)
               END DO
            ELSE
               DO K = 1, N
                 C_Y(K) = C_Y(K) * id%ROWSCA(K)
               END DO
            ENDIF
          END IF
        END IF
        GO TO 22
      ELSEIF ( KASE .LT. 0 ) THEN
           INFO( 1 ) = INFO( 1 ) + 8
      END IF
      IF ( id%MYID .eq. MASTER ) THEN
         NB_BYTES = NB_BYTES - int(size(R_W),8)*K16_8                   &
     &                       - int(size(D  ),8)*K16_8                   &
     &                       - int(size(IW1),8)*K34_8
        DEALLOCATE(R_W,D)
        DEALLOCATE(IW1)
      ENDIF
      IF ( PROKG ) THEN
        IF (NITREF.GT.0) THEN
        WRITE( MPG, 81 )
        WRITE( MPG, 141 ) 'NUMBER OF STEPS OF ITERATIVE REFINEMENTS     &
     &=', NOITER
       ENDIF
      ENDIF
      IF ( id%MYID .EQ. MASTER ) THEN
       IF ( NITREF .GT. 0 ) THEN
        id%INFOG(15) = NOITER
       END IF
      END IF
      IF ( PROK .AND. ICNTL10 .GT.0 ) WRITE( MP, 131 )
      IF (ICNTL11 .GT. 0) THEN
        IF ( KEEP(54) .eq. 0 ) THEN
          IF (id%MYID .EQ. MASTER) THEN
            IF (KEEP(55).EQ.0) THEN
              CALL DAGMG_MUMPS_278( MTYPE, N, NZ, id%A(1),                   &
     &          id%IRN(1), id%JCN(1),                                   &
     &          RHS_AGMG_MUMPS(IBEG), SAVERHS, R_Y, C_W, KEEP,KEEP8 )
            ELSE
              CALL DAGMG_MUMPS_121( MTYPE, N,                                &
     &          id%NELT, id%ELTPTR,                                     &
     &          id%LELTVAR, id%ELTVAR,                                  &
     &          id%NA_ELT, id%A_ELT,                                    &
     &          RHS_AGMG_MUMPS(IBEG), SAVERHS, R_Y, C_W, KEEP,KEEP8 )
            ENDIF
          END IF
        ELSE
            CALL AGMG_SETIERR( IERR )
            IF ( I_AM_SLAVE .and.                                       &
     &           id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_192( id%N, id%NZ_loc,                         &
     &        id%IRN_loc, id%JCN_loc, id%A_loc,                         &
     &        RHS_AGMG_MUMPS(IBEG), C_LOCWK54, KEEP(50), MTYPE )
            ELSE
              C_LOCWK54 = dble(ZERO)
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( C_LOCWK54, C_W,                        id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
              C_W = SAVERHS - C_W
            ELSE
              CALL AGMG_COPY( C_LOCWK54, C_DUMMY,                    id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
            IF ( I_AM_SLAVE .and.                                       &
     &           id%NZ_loc .NE. 0 ) THEN
              CALL DAGMG_MUMPS_207(id%A_loc,                                 &
     &          id%NZ_loc, id%N,                                        &
     &          id%IRN_loc, id%JCN_loc,                                 &
     &          R_LOCWK54, id%KEEP,id%KEEP8 )
            ELSE
              R_LOCWK54 = ZERO
            END IF
            IF ( id%MYID .eq. MASTER ) THEN
              CALL AGMG_COPY( R_LOCWK54, R_Y,                        id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            ELSE
              CALL AGMG_COPY( R_LOCWK54, R_DUMMY,                    id%N, AGMG_MPF_DOUBLE_PRECISION, IERR)
            END IF
        END IF
        IF (id%MYID .EQ. MASTER) THEN
         IF ((MPG .GT. 0) .AND. (NITREF .GT. 0)) WRITE( MPG, 65 )
         IF ((MPG .GT. 0) .AND. (NITREF .LE. 0)) WRITE( MPG, 170 )
         GIVSOL = .FALSE.
         CALL DAGMG_MUMPS_205(MTYPE,INFO(1),N,NZ,RHS_AGMG_MUMPS(IBEG),            &
     &        SAVERHS,R_Y,C_W,GIVSOL,                                   &
     &        RSOL,RINFOG(4),RINFOG(5),RINFOG(6),MPG,ICNTL,             &
     &        KEEP,KEEP8)
         IF ( MPG .GT. 0 ) THEN
          WRITE( MPG, 115 )                                             &
     &'RINFOG(7):COMPONENTWISE SCALED RESIDUAL(W1)=', RINFOG(7)
          WRITE( MPG, 115 )                                             &
     &'------(8):---------------------------- (W2)=', RINFOG(8)
          WRITE( MPG, 115 )                                             &
     &'------(9):Upper bound ERROR ...............=', RINFOG(9)
          WRITE( MPG, 115 )                                             &
     &'-----(10):CONDITION NUMBER (1) ............=', RINFOG(10)
          WRITE( MPG, 115 )                                             &
     &'-----(11):CONDITION NUMBER (2) ............=', RINFOG(11)
         END IF
        END IF
      END IF
      IF (id%MYID == MASTER) THEN
         NB_BYTES = NB_BYTES - int(size(C_W),8)*K35_8
         DEALLOCATE(C_W)
      ENDIF
      NB_BYTES = NB_BYTES -                                             &
     &   (int(size(R_Y),8)+int(size(R_LOCWK54),8))*K16_8
      NB_BYTES = NB_BYTES -                                             &
     &   (int(size(C_Y),8)+int(size(C_LOCWK54),8))*K35_8
      DEALLOCATE(R_Y)
      DEALLOCATE(C_Y)
      DEALLOCATE(R_LOCWK54)
      DEALLOCATE(C_LOCWK54)
      END IF
      IF ( id%MYID .EQ. MASTER .AND. ICNTL21==0                         &
     &     .AND. KEEP(23) .NE. 0) THEN
        IF ((KEEP(221).NE.1 .AND. ICNTL(9) .EQ. 1)                      &
     &     .OR. KEEP(111) .NE.0) THEN
          ALLOCATE( C_RW1( N ),stat =allocok )
          IF ( allocok .GT. 0 ) THEN
            INFO(1)=-13
            INFO(2)=N
            WRITE(*,*) 'could not allocate ', N, 'integers.'
            CALL AGMG_MUMPS_ABORT()
          END IF
          DO K = 1, NBRHS_EFF
           KDEC = (K-1)*LD_RHS+IBEG-1
           DO 70 I = 1, N
            C_RW1(I) = RHS_AGMG_MUMPS(KDEC+I)
   70      CONTINUE
           DO 80 I = 1, N
            JPERM = id%UNS_PERM(I)
            RHS_AGMG_MUMPS( KDEC+JPERM ) = C_RW1( I )
   80      CONTINUE
          END DO
          DEALLOCATE( C_RW1 )
        END IF
      END IF
      IF (id%MYID.EQ.MASTER .and.ICNTL21==0.and.KEEP(221).NE.1) THEN
        IF ( INFO(1) .GE. 0 .AND. ICNTL(4).GE.3 .AND. ICNTL(3).GT.0)    &
     &    THEN
          K = min0(10, N)
          IF (ICNTL(4) .eq. 4 ) K = N
          J = min0(10,NBRHS_EFF)
          IF (ICNTL(4) .eq. 4 ) J = NBRHS_EFF
          DO II=1, J
            WRITE(ICNTL(3),110) BEG_RHS+II-1
            WRITE(ICNTL(3),160)                                         &
     &    (RHS_AGMG_MUMPS(IBEG+(II-1)*LRHS+I-1),I=1,K)
          ENDDO
        END IF
      END IF
      BEG_RHS = BEG_RHS + NBRHS
      ENDDO
      id%INFO(26) = int(NB_BYTES_MAX / 1000000_8, 4)
      CALL AGMG_MUMPS_243( id%MYID, id%COMM,                                 &
     &                           id%INFO(26), id%INFOG(30), IRANK )
      IF ( PROKG ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Rank of processor needing largest memory in solve     :',  &
     &  IRANK
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Space in MBYTES used by this processor for solve      :',  &
     &  id%INFOG(30)
        IF ( KEEP(46) .eq. 0 ) THEN
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Avg. Space in MBYTES per working proc during solve    :',  &
     &  ( id%INFOG(31)-id%INFO(26) ) / id%NSLAVES
        ELSE
        WRITE( MPG,'(A,I10) ')                                          &
     &  ' ** Avg. Space in MBYTES per working proc during solve    :',  &
     &  id%INFOG(31) / id%NSLAVES
        END IF
      END IF
      IF (PROKG) WRITE( MPG, 120 ) id%INFOG(1), id%INFOG(2)
   90 CONTINUE
      IF (INFO(1) .LT.0 ) THEN
      ENDIF
      IF (KEEP(201).NE.0)THEN
        IF (I_AM_SLAVE) THEN
          CALL DAGMG_MUMPS_582(IERR)
          IF (IERR.LT.0 .AND. INFO(1) .GE. 0) INFO(1) = IERR
        ENDIF
        CALL AGMG_MUMPS_276( ICNTL, INFO,                                    &
     &         id%COMM,id%MYID)
      ENDIF
      IF (associated(id%BUFR)) THEN
          NB_BYTES = NB_BYTES - int(size(id%BUFR),8)*K34_8
          DEALLOCATE(id%BUFR)
          NULLIFY(id%BUFR)
      ENDIF
      IF ( I_AM_SLAVE ) THEN
        IF (allocated(IWK_SOLVE)) THEN
          NB_BYTES = NB_BYTES - int(size(IWK_SOLVE),8)*K34_8
          DEALLOCATE( IWK_SOLVE )
        ENDIF
        IF (allocated(IWCB)) THEN
          NB_BYTES = NB_BYTES - int(size(IWCB),8)*K34_8
          DEALLOCATE( IWCB )
        ENDIF
        CALL DAGMG_MUMPS_57( IERR )
        CALL DAGMG_MUMPS_59( IERR )
      END IF
      IF ( id%MYID .eq. MASTER ) THEN
        IF (allocated(SAVERHS)) THEN
         NB_BYTES = NB_BYTES - int(size(SAVERHS),8)*K35_8
         DEALLOCATE( SAVERHS)
        ENDIF
        IF (                                                            &
     &       ( (ICNTL20 .ne. 0 .OR.KEEP(111).NE.0)                      &
     &        .and. ICNTL21.ne.0 )                                      &
     &     )                                                            &
     &    THEN
          IF ( I_AM_SLAVE ) THEN
           IF (ASSOCIATED(RHS_AGMG_MUMPS) ) THEN
            NB_BYTES = NB_BYTES - int(size(RHS_AGMG_MUMPS),8)*K35_8
            DEALLOCATE(RHS_AGMG_MUMPS)
           ENDIF
          ENDIF
        ENDIF
        NULLIFY(RHS_AGMG_MUMPS)
      ELSE
        IF (associated(RHS_AGMG_MUMPS)) THEN
          NB_BYTES = NB_BYTES - int(size(RHS_AGMG_MUMPS),8)*K35_8
          DEALLOCATE(RHS_AGMG_MUMPS)
          NULLIFY(RHS_AGMG_MUMPS)
        END IF
      END IF
      IF (I_AM_SLAVE) THEN
        IF (allocated(SRW3)) THEN
          NB_BYTES = NB_BYTES - int(size(SRW3),8)*K35_8
          DEALLOCATE(SRW3)
        ENDIF
        IF (allocated(POSINRHSCOMP_N)) THEN
          NB_BYTES = NB_BYTES - int(size(POSINRHSCOMP_N),8)*K34_8
          DEALLOCATE(POSINRHSCOMP_N)
        ENDIF
        IF (LSCAL .AND. ICNTL21==1) THEN
          NB_BYTES = NB_BYTES -                                         &
     &              int(size(scaling_data%SCALING_LOC),8)*K16_8
          DEALLOCATE(scaling_data%SCALING_LOC)
          NULLIFY(scaling_data%SCALING_LOC)
        ENDIF
        IF (WK_USER_PROVIDED) THEN
          NULLIFY(id%S)
        ELSE IF (associated(id%S).AND.KEEP(201).GT.0) THEN
          NB_BYTES = NB_BYTES - KEEP8(23)*K35_8
          id%KEEP8(23)=0_8
          DEALLOCATE(id%S)
          NULLIFY(id%S)
        ENDIF
        IF (KEEP(221).NE.1) THEN
         IF (ASSOCIATED(id%RHSCOMP)) THEN
            NB_BYTES = NB_BYTES - int(size(id%RHSCOMP),8)*K35_8
            DEALLOCATE(id%RHSCOMP)
            NULLIFY(id%RHSCOMP)
         ENDIF
         IF (ASSOCIATED(id%POSINRHSCOMP)) THEN
            NB_BYTES = NB_BYTES - int(size(id%POSINRHSCOMP),8)*K34_8
            DEALLOCATE(id%POSINRHSCOMP)
            NULLIFY(id%POSINRHSCOMP)
         ENDIF
        ENDIF
        IF ( WORK_WCB_ALLOCATED ) THEN
          NB_BYTES = NB_BYTES - int(size(WORK_WCB),8)*K35_8
          DEALLOCATE( WORK_WCB )
        ENDIF
        NULLIFY( WORK_WCB )
      ENDIF
      RETURN
   65 FORMAT (//' ERROR ANALYSIS AFTER ITERATIVE REFINEMENT')
  100 FORMAT(//' ****** SOLVE & CHECK STEP ********'/)
  110 FORMAT (//' VECTOR SOLUTION FOR COLUMN ',I12)
  115 FORMAT(1X, A44,1P,D9.2)
  120 FORMAT(//' LEAVING SOLVER WITH:  INFOG(1) ............ =',I12/    &
     &         '                       INFOG(2) ............ =',I12)
  150 FORMAT (/' STATISTICS PRIOR SOLVE PHASE     ...........'/         &
     &        ' NUMBER OF RIGHT-HAND-SIDES                    =',I12/   &
     &        ' BLOCKING FACTOR FOR MULTIPLE RHS              =',I12/   &
     &        ' ICNTL (9)                                     =',I12/   &
     &        '  --- (10)                                     =',I12/   &
     &        '  --- (11)                                     =',I12/   &
     &        '  --- (20)                                     =',I12/   &
     &        '  --- (21)                                     =',I12)
  151 FORMAT ('  --- (25)                                     =',I12)
  152 FORMAT ('  --- (26)                                     =',I12)
  160 FORMAT (' RHS'/(1X,1P,5D14.6))
  170 FORMAT (//' ERROR ANALYSIS' )
  240 FORMAT (1X, A42,I4)
  270 FORMAT (//' BEGIN ITERATIVE REFINEMENT' )
   81 FORMAT (/' STATISTICS AFTER ITERATIVE REFINEMENT ')
  131 FORMAT (/' END   ITERATIVE REFINEMENT ')
  141 FORMAT(1X, A42,I4)
      END SUBROUTINE DAGMG_MUMPS_301
      SUBROUTINE DAGMG_MUMPS_245(root, N, A, LA, IW, LIW, W, LWC,            &
     & IWCB,LIWW,RHS,LRHS,NRHS,NA,LNA,NE_STEPS, W2,                     &
     & MTYPE, ICNTL,                                                    &
     & STEP, FRERE, DAD, FILS, PTRIST, PTRFAC, IW1,LIW1,                &
     & PROCNODE_STEPS, SLAVEF,                                          &
     & INFO, KEEP,KEEP8, COMM, COMM_NODES, MYID,                        &
     & MYID_NODES,                                                      &
     & BUFR, LBUFR, LBUFR_BYTES,                                        &
     & ISTEP_TO_INIV2, TAB_POS_IN_PERE,                                 &
     & IBEG_ROOT_DEF, IEND_ROOT_DEF,                                    &
     & IROOT_DEF_RHS_COL1, IPT_RHS_ROOT, SIZE_ROOT, MASTER_ROOT,        &
     & RHSCOMP, LRHSCOMP, POSINRHSCOMP, BUILD_POSINRHSCOMP              &
     & )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
!
      TYPE DAGMG_MUMPS_ROOT_STRUC
        SEQUENCE
        INTEGER MBLOCK, NBLOCK, NPROW, NPCOL
        INTEGER MYROW, MYCOL
        INTEGER ROOT_SIZE, TOT_ROOT_SIZE
        INTEGER :: CNTXT_BLACS, truc
        INTEGER, DIMENSION(:), POINTER :: RG2L_ROW
        INTEGER, DIMENSION(:), POINTER :: RG2L_COL
        INTEGER , DIMENSION(:), POINTER :: IPIV
        INTEGER, DIMENSION( 9 ) :: DESCRIPTOR, DESCB
        LOGICAL yes, gridinit_done
        INTEGER LPIV, brol
!       Used to access Schur easily from root structure
        DOUBLE PRECISION, DIMENSION(:), POINTER :: SCHUR_POINTER
        INTEGER SCHUR_MLOC, SCHUR_NLOC, SCHUR_LLD, machin
!
!      Data for nullspace/QR
!
        DOUBLE PRECISION, DIMENSION(:), POINTER :: QR_TAU
        DOUBLE PRECISION     QR_RCOND
!
!      Givens rotations
!
        INTEGER MAXG, GIND
        DOUBLE PRECISION, DIMENSION(:),POINTER::GROW, GCOS, GSIN
!
!      RRRLU data
!
        INTEGER ELG_MAX,NULL_MAX
        INTEGER ELIND,EUIND,NLUPDATE,NUUPDATE
        INTEGER,DIMENSION(:),POINTER::PERM_ROW,PERM_COL
        INTEGER,DIMENSION(:),POINTER::ELROW, EUROW, PTREL, PTREU
        DOUBLE PRECISION, DIMENSION(:), POINTER :: ELELG, EUELG, DL
!
      END TYPE DAGMG_MUMPS_ROOT_STRUC
      TYPE ( DAGMG_MUMPS_ROOT_STRUC ) :: root
      INTEGER(8) :: LA
      INTEGER LWC,N,LIW,MTYPE,LIW1,LIWW,LNA
      INTEGER ICNTL(40),INFO(40), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER IW(LIW),IW1(LIW1),NA(LNA),NE_STEPS(KEEP(28)),IWCB(LIWW)
      INTEGER STEP(N), FRERE(KEEP(28)), FILS(N), PTRIST(KEEP(28)),      &
     &        DAD(KEEP(28))
      INTEGER(8) ::  PTRFAC(KEEP(28))
      INTEGER LRHS, NRHS, LRHSCOMP
      DOUBLE PRECISION    A(LA), W(LWC), RHS(LRHS,NRHS),                &
     &        W2(KEEP(133)),                                            &
     &        RHSCOMP(LRHSCOMP,NRHS)
      INTEGER SLAVEF, COMM, COMM_NODES, MYID, MYID_NODES
      INTEGER PROCNODE_STEPS(KEEP(28)), POSINRHSCOMP(KEEP(28))
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR(LBUFR)
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER IBEG_ROOT_DEF, IEND_ROOT_DEF, IROOT_DEF_RHS_COL1
      INTEGER NRHS_LOC
      INTEGER IPT_RHS_ROOT, SIZE_ROOT, MASTER_ROOT
      LOGICAL BUILD_POSINRHSCOMP
      INTEGER MP, LP, LDIAG, LWC_LOC
      INTEGER K,I
      INTEGER LPOOL,MYLEAF,LPANEL_POS
      INTEGER NSTK_S,IPOOL,IPANEL_POS,PTRICB,PTRACB
      INTEGER POOLSS, MTYPE_LOC
      INTEGER IDUMMY(1), LIDUMMY, DUMMY, WHAT
      INTEGER IPT_RHS_ROOT_LOC
      INTEGER IERR
      INTEGER(8) :: IAPOS
      INTEGER       IOLDPS,                                             &
     &              LOCAL_M,                                            &
     &              LOCAL_N
      INTEGER INODE, IPOS, LIELL, NPIV,J1,JJ
      INTEGER IZERO
      LOGICAL DOFORWARD, DOROOT, DOBACKWARD
      LOGICAL I_WORKED_ON_ROOT
      INTEGER IROOT
      LOGICAL DOROOT_FWD_OOC, DOROOT_BWD_PANEL
      LOGICAL DUMMY_BOOL
      PARAMETER (IZERO = 0 )
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      EXTERNAL DAGMG_MUMPS_248, DAGMG_MUMPS_249
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      MYLEAF = -1
      LP      = ICNTL(1)
      MP      = ICNTL(2)
      LDIAG   = ICNTL(4)
      LIDUMMY  = 1
      DUMMY    = -9998
      NSTK_S   = 1
      PTRICB = NSTK_S + KEEP(28)
      PTRACB = PTRICB + KEEP(28)
      IPOOL  = PTRACB + KEEP(28)
      LPOOL  = KEEP(28)+1
      IPANEL_POS = IPOOL + LPOOL
      IF (KEEP(201).EQ.1) THEN
        LPANEL_POS = KEEP(228)+1
      ELSE
        LPANEL_POS = 1
      ENDIF
      IF (IPANEL_POS + LPANEL_POS -1 .ne. LIW1 )  THEN
         WRITE(*,*)  MYID, ": Internal Error in DAGMG_MUMPS_245",            &
     &   IPANEL_POS, LPANEL_POS, LIW1
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      LWC_LOC = LWC
      IF ( MASTER_ROOT .EQ. MYID_NODES ) THEN
        LWC_LOC = IPT_RHS_ROOT - 1
      ELSE
        LWC_LOC = LWC
      ENDIF
      DOFORWARD = .TRUE.
      DOBACKWARD= .TRUE.
      IF ( KEEP(111).NE.0 ) THEN
        DOFORWARD = .FALSE.
      ENDIF
      IF (KEEP(221).eq.1) DOBACKWARD = .FALSE.
      IF (KEEP(221).eq.2) DOFORWARD  = .FALSE.
      IF ( KEEP(60).EQ.0 .AND.                                          &
     &    (                                                             &
     &      (KEEP(38).NE.0 .AND.  root%yes)                             &
     &  .OR.                                                            &
     &      (KEEP(20).NE.0 .AND. MYID_NODES.EQ.MASTER_ROOT))            &
     &   )                                                              &
     &THEN
        DOROOT = .TRUE.
      ELSE
        DOROOT = .FALSE.
      ENDIF
      DOROOT_BWD_PANEL = DOROOT .AND. MTYPE.NE.1 .AND. KEEP(50).EQ.0    &
     &                     .AND. KEEP(201).EQ.1
      DOROOT_FWD_OOC = DOROOT .AND. .NOT.DOROOT_BWD_PANEL
      IF (KEEP(201).NE.0) THEN
        IF (DOFORWARD .OR. DOROOT_FWD_OOC) THEN
           CALL DAGMG_MUMPS_583(PTRFAC,KEEP(28),MTYPE,                       &
     &                                A,LA,DOFORWARD,IERR)
          IF(IERR.LT.0)THEN
            INFO(1)=IERR
            INFO(2)=0
            CALL AGMG_MUMPS_ABORT()
          ENDIF
        ENDIF
      ENDIF
      IF (DOFORWARD) THEN
        IF ( KEEP( 50 ) .eq. 0 ) THEN
          MTYPE_LOC = MTYPE
        ELSE
          MTYPE_LOC = 1
        ENDIF
        CALL DAGMG_MUMPS_248(N, A(1), LA, IW(1), LIW, W(1),                  &
     &           LWC_LOC, RHS, LRHS, NRHS,                              &
     &           IW1(PTRICB), IWCB, LIWW,                               &
     &           RHSCOMP,LRHSCOMP,POSINRHSCOMP,BUILD_POSINRHSCOMP,      &
     &           NE_STEPS, NA, LNA, STEP, FRERE,DAD,FILS,               &
     &           IW1(NSTK_S),IW1(IPOOL),LPOOL,PTRIST,PTRFAC,            &
     &           MYLEAF,INFO,                                           &
     &           KEEP,KEEP8,                                            &
     &           PROCNODE_STEPS, SLAVEF, COMM_NODES, MYID_NODES,        &
     &           BUFR, LBUFR, LBUFR_BYTES,                              &
     &           W( IPT_RHS_ROOT ), MTYPE_LOC,                          &
     &           ISTEP_TO_INIV2, TAB_POS_IN_PERE                        &
     &           )
         BUILD_POSINRHSCOMP = .FALSE.
      ENDIF
      CALL AGMG_MUMPS_276(ICNTL, INFO, COMM_NODES, MYID )
      IF ( INFO(1) .LT. 0 ) THEN
        IF ( LP .GT. 0 ) THEN
          WRITE(LP,*) MYID,                                             &
     &    ': ** ERROR RETURN FROM DMUMPS_248,INFO(1:2)=',               &
     &    INFO(1:2)
        END IF
        RETURN
      END IF
      CALL AGMG_SETIERR( IERR )
      IF(KEEP(201).EQ.1.AND.DOROOT_BWD_PANEL) THEN
         I_WORKED_ON_ROOT = .FALSE.
         CALL DAGMG_MUMPS_584(PTRFAC,KEEP(28),MTYPE,                         &
     &   I_WORKED_ON_ROOT, IROOT, A, LA, IERR)
         IF (IERR .LT. 0) THEN
           INFO(1) = -90
           INFO(2) = IERR
         ENDIF
      ENDIF
      IF (KEEP(201).EQ.1) THEN
         CALL AGMG_MUMPS_276(ICNTL, INFO, COMM_NODES, MYID )
         IF ( INFO(1) .LT. 0 ) RETURN
      ENDIF
      IF ( KEEP( 38 ) .NE. 0 ) THEN
        IF ( KEEP(60) == 0 ) THEN
          IF ( root%yes ) THEN
        IOLDPS = PTRIST(STEP(KEEP(38)))
        LOCAL_M = IW( IOLDPS + 2 + KEEP(IXSZ))
        LOCAL_N = IW( IOLDPS + 1 + KEEP(IXSZ))
         IF (KEEP(201).NE.0) THEN
            CALL DAGMG_MUMPS_643(                                            &
     &           KEEP(38),PTRFAC,KEEP,A,LA,                             &
     &           STEP,KEEP8,N,DUMMY_BOOL,IERR)
          IF(IERR.LT.0)THEN
             INFO(1)=IERR
             INFO(2)=0
      WRITE(*,*) '** ERROR after DMUMPS_643',                           &
     & INFO(1)
                call AGMG_MUMPS_ABORT()
          ENDIF
         ENDIF
         IAPOS   = PTRFAC(IW( IOLDPS + 4 + KEEP(IXSZ)))
          CALL AGMG_NOCALL('DESCINIT')
          IF (IERR.NE.0) THEN
            WRITE(*,*) 'After DESCINIT, IERR = ', IERR
            CALL AGMG_MUMPS_ABORT()
          END IF
          CALL DAGMG_MUMPS_286( NRHS, root%DESCRIPTOR, root%DESCB,           &
     &       root%CNTXT_BLACS, LOCAL_M, LOCAL_N,                        &
     &       root%MBLOCK, root%NBLOCK,                                  &
     &       root%IPIV, root%LPIV, MASTER_ROOT, MYID_NODES,             &
     &       COMM_NODES,                                                &
     &       W( IPT_RHS_ROOT ),                                         &
     &       root%TOT_ROOT_SIZE, A( IAPOS ),                            &
     &       INFO(1), MTYPE, KEEP(50))
          IF(KEEP(201).NE.0)THEN
             CALL DAGMG_MUMPS_598(KEEP(38),                                  &
     &             PTRFAC,KEEP(28),A,LA,.FALSE.,IERR)
             IF(IERR.LT.0)THEN
                 INFO(1)=IERR
                 INFO(2)=0
      WRITE(*,*) '** ERROR after DMUMPS_598 ',                          &
     & INFO(1)
                call AGMG_MUMPS_ABORT()
             ENDIF
          ENDIF
        ENDIF
      ELSE
        IF (                                                            &
     &       (KEEP(221).EQ.0) .AND.                                     &
     &       ( MYID_NODES .eq.  AGMG_MUMPS_275( STEP(KEEP(38)),              &
     &         PROCNODE_STEPS, SLAVEF ) )                               &
     &     )  THEN
           W( IPT_RHS_ROOT:IPT_RHS_ROOT+NRHS*SIZE_ROOT- 1)              &
     &     = dble(0.0D0)
        ENDIF
      ENDIF
      ELSE IF ( KEEP(20) .NE. 0 ) THEN
        IF ( MYID_NODES .eq.  AGMG_MUMPS_275( STEP(KEEP(20)),                &
     &        PROCNODE_STEPS, SLAVEF ) ) THEN
           IF (KEEP(221).EQ.0)                                          &
     &     W( IPT_RHS_ROOT:IPT_RHS_ROOT+NRHS*SIZE_ROOT- 1)              &
     &     = dble(0.0D0)
        END IF
      END IF
      CALL AGMG_MUMPS_276(ICNTL, INFO, COMM_NODES, MYID )
      IF ( INFO(1) .LT. 0 ) RETURN
      IF (DOBACKWARD) THEN
        IF (BUILD_POSINRHSCOMP) THEN
          WHAT = 0
          CALL DAGMG_MUMPS_639                                               &
     &           (SLAVEF, N, MYID_NODES,                                &
     &           PTRIST,                                                &
     &           KEEP,KEEP8, PROCNODE_STEPS, IW, LIW, STEP,             &
     &           POSINRHSCOMP, IDUMMY, LIDUMMY, DUMMY, WHAT)
          BUILD_POSINRHSCOMP=.FALSE.
        ENDIF
        IF ( KEEP(201).NE.0 .AND.  .NOT. DOROOT_BWD_PANEL )             &
     &    THEN
          I_WORKED_ON_ROOT = DOROOT
          IROOT = max(KEEP(20),KEEP(38))
          CALL DAGMG_MUMPS_584(PTRFAC,KEEP(28),MTYPE,                        &
     &         I_WORKED_ON_ROOT, IROOT, A, LA, IERR)
        ENDIF
        IF ( KEEP( 50 ) .eq. 0 ) THEN
          MTYPE_LOC = MTYPE
        ELSE
          MTYPE_LOC = IZERO
        ENDIF
           CALL DAGMG_MUMPS_249( N, A, LA, IW, LIW, W(1), LWC_LOC,           &
     &          RHS, LRHS, NRHS,                                        &
     &          RHSCOMP, LRHSCOMP, POSINRHSCOMP,                        &
     &          IW1(PTRICB),IW1(PTRACB),IWCB,LIWW,                      &
     &          W2, NE_STEPS, NA, LNA, STEP, FRERE,FILS,                &
     &          IW1(IPOOL),LPOOL,PTRIST,PTRFAC,MYLEAF,INFO,             &
     &          PROCNODE_STEPS, SLAVEF, COMM_NODES,MYID_NODES,          &
     &          BUFR, LBUFR, LBUFR_BYTES, KEEP,KEEP8,                   &
     &          W( IPT_RHS_ROOT ),                                      &
     &          MTYPE_LOC,                                              &
     &          ISTEP_TO_INIV2, TAB_POS_IN_PERE, IW1(IPANEL_POS),       &
     &          LPANEL_POS)
      ENDIF
      IF (LDIAG.GT.2 .AND. MP.GT.0) THEN
        IF (DOFORWARD) THEN
        K = min0(10,N)
        IF (LDIAG.EQ.4) K = N
        WRITE (MP,99992)
        IF (N.GT.0) WRITE (MP,99993) (RHS(I,1),I=1,K)
        IF (N.GT.0.and.NRHS>1)                                          &
     &              WRITE (MP,99994) (RHS(I,2),I=1,K)
        ENDIF
      ENDIF
      RETURN
  444 FORMAT (I3,': Time for  Forward=',F10.4,'[s]')
  555 FORMAT (I3,': Time for Backward=',F10.4,'[s]')
99993 FORMAT (' RHS    (first column)'/(1X,1P,5D14.6))
99994 FORMAT (' RHS    (2 nd  column)'/(1X,1P,5D14.6))
99992 FORMAT (//' LEAVING SOLVE (MPI41C) WITH')
      END SUBROUTINE DAGMG_MUMPS_245
      SUBROUTINE DAGMG_MUMPS_521(NSLAVES, N, MYID, COMM,                     &
     &           MTYPE, RHS, LRHS, NRHS, PTRIST,                        &
     &           KEEP,KEEP8, PROCNODE_STEPS, IW, LIW, STEP, BUFFER,     &
     &           SIZE_BUF, SIZE_BUF_BYTES, CWORK, LCWORK )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER NSLAVES, N, MYID, COMM, LIW, MTYPE
      INTEGER NRHS, LRHS, LCWORK
      DOUBLE PRECISION RHS   (LRHS, NRHS)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      DOUBLE PRECISION ::  CWORK(LCWORK)
      INTEGER PTRIST(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER IW(LIW), STEP(N)
      INTEGER SIZE_BUF, SIZE_BUF_BYTES
      INTEGER BUFFER(SIZE_BUF)
      INTEGER I, II, J, J1, ISTEP, MASTER,                              &
     &        MYID_NODES, TYPE_PARAL, N2RECV
      INTEGER LIELL, IPOS, NPIV, MAXNPIV_estim, MAXSurf
      INTEGER MSGSOU, STATUS(AGMG_MPF_STATUS_SIZE), IERR
      PARAMETER(MASTER=0)
      LOGICAL I_AM_SLAVE
      INTEGER RECORD_SIZE_P_1, SIZE1, SIZE2
      INTEGER POS_BUF, N2SEND
      INTEGER SK38, SK20
      INTEGER, PARAMETER :: FIN = -1
      INTEGER, PARAMETER :: yes =  1
      INTEGER, PARAMETER :: no  = 0
      INTEGER, ALLOCATABLE, DIMENSION(:) :: IROWlist(:)
      INTEGER :: ONE_PACK
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      TYPE_PARAL = KEEP(46)
      I_AM_SLAVE = MYID .ne. 0 .OR. TYPE_PARAL .eq. 1
      IF ( TYPE_PARAL == 1 ) THEN
        MYID_NODES = MYID
      ELSE
        MYID_NODES = MYID-1
      ENDIF
      IF (NSLAVES.EQ.1 .AND. TYPE_PARAL.EQ.1) RETURN
      IF (NSLAVES.EQ.1 .AND. TYPE_PARAL.EQ.0) THEN
        DO J=1, NRHS
           IF ( MYID .EQ. 1 ) THEN
             CALL AGMG_NOCALL('MPI_SEND')
           ELSE
             CALL AGMG_NOCALL('MPI_RECV')
           ENDIF
        ENDDO
        RETURN
      ENDIF
      MAXNPIV_estim = max(KEEP(246), KEEP(247))
      MAXSurf       = MAXNPIV_estim*NRHS
      IF (LCWORK .GE. MAXSurf) THEN
        ONE_PACK = yes
      ELSE IF (LCWORK .GE. MAXNPIV_estim) THEN
        ONE_PACK = no
      ELSE
        WRITE(*,*)                                                      &
     &  "Internal error 2 in DAGMG_MUMPS_521:",                              &
     &  TYPE_PARAL, LCWORK, KEEP(247), NRHS
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (ONE_PACK .EQ. no .AND. I_AM_SLAVE) THEN
          WRITE(*,*)                                                    &
     &    "Internal error 1 in DAGMG_MUMPS_521:",                            &
     &    TYPE_PARAL, LCWORK, KEEP(246),KEEP(247), NRHS
          CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (TYPE_PARAL .EQ. 0)                                            &
     &CALL AGMG_SETIERR( IERR)
      IF (MYID.EQ.MASTER) THEN
        ALLOCATE(IROWlist(KEEP(247)))
      ENDIF
      IF (NSLAVES .EQ. 1 .AND. TYPE_PARAL .EQ. 1) THEN
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      SIZE1=0
      CALL AGMG_NOCALL('MPI_PACK_SIZE')
      SIZE2=0
      CALL AGMG_NOCALL('MPI_PACK_SIZE')
      RECORD_SIZE_P_1= SIZE1+SIZE2
      IF (RECORD_SIZE_P_1.GT.SIZE_BUF_BYTES) THEN
         write(6,*) MYID,                                               &
     &    ' Internal error 3 in  DMUMPS_521 '
         write(6,*) MYID, ' RECORD_SIZE_P_1, SIZE_BUF_BYTES=',          &
     &                 RECORD_SIZE_P_1, SIZE_BUF_BYTES
         CALL AGMG_MUMPS_ABORT()
      ENDIF
      N2SEND   =0
      N2RECV   =N
      POS_BUF  =0
      IF (KEEP(38).NE.0) THEN
        SK38=STEP(KEEP(38))
      ELSE
        SK38=0
      ENDIF
      IF (KEEP(20).NE.0) THEN
        SK20=STEP(KEEP(20))
      ELSE
        SK20=0
      ENDIF
      IF (I_AM_SLAVE) THEN
        POS_BUF = 0
        DO ISTEP = 1, KEEP(28)
          IF (MYID_NODES == AGMG_MUMPS_275(ISTEP,                            &
     &          PROCNODE_STEPS,NSLAVES)) THEN
              IF ( ISTEP.EQ.SK38 .OR. ISTEP.EQ.SK20 ) THEN
                    IPOS = PTRIST(ISTEP)
                    LIELL = IW(IPOS+3+KEEP(IXSZ))
                    NPIV = LIELL
                    IPOS= PTRIST(ISTEP)+5+KEEP(IXSZ)
              ELSE
                  IPOS = PTRIST(ISTEP) + 2+ KEEP(IXSZ)
                  LIELL = IW(IPOS-2)+IW(IPOS+1)
                  IPOS= IPOS+1
                  NPIV = IW(IPOS)
                  IPOS= IPOS+1
                  IPOS= IPOS+1+IW( PTRIST(ISTEP) + 5 +KEEP(IXSZ))
              END IF
              IF (MTYPE.eq.1 .AND. KEEP(50).EQ.0) THEN
                   J1=IPOS+1+LIELL
              ELSE
                   J1=IPOS+1
              END IF
              IF (MYID .EQ. MASTER) THEN
                   N2RECV=N2RECV-NPIV
              ELSE
                   IF (NPIV.GT.0)                                       &
     &             CALL DAGMG_MUMPS_522( ONE_PACK )
              ENDIF
          ENDIF
        ENDDO
        CALL DAGMG_MUMPS_523()
      ENDIF
      IF ( MYID .EQ. MASTER ) THEN
       DO WHILE (N2RECV .NE. 0)
        CALL AGMG_NOCALL('MPI_RECV')
        POS_BUF = 0
        CALL AGMG_NOCALL('MPI_UNPACK')
        DO WHILE (NPIV.NE.FIN)
          CALL AGMG_NOCALL('MPI_UNPACK')
          IF (ONE_PACK.EQ.yes) THEN
            CALL AGMG_NOCALL('MPI_UNPACK')
            DO J=1, NRHS
                DO I=1,NPIV
                  RHS(IROWlist(I),J)=                                   &
     &              CWORK(I+(J-1)*NPIV)
                ENDDO
            END DO
          ELSE
            DO J=1,NRHS
              CALL AGMG_NOCALL('MPI_UNPACK')
              DO I=1,NPIV
                RHS(IROWlist(I),J)=CWORK(I)
              ENDDO
            ENDDO
          ENDIF
          N2RECV=N2RECV-NPIV
          CALL AGMG_NOCALL('MPI_UNPACK')
        ENDDO
       ENDDO
       DEALLOCATE(IROWlist)
      ENDIF
      RETURN
      CONTAINS
        SUBROUTINE DAGMG_MUMPS_522( ONE_PACK )
        INTEGER ONE_PACK
        INTEGER III
        DO II=1,NPIV
              I=IW(J1+II-1)
              DO J=1, NRHS
                CWORK(II+(J-1)*NPIV) = RHS(I,J)
              ENDDO
        ENDDO
        CALL AGMG_NOCALL('MPI_PACK')
        CALL AGMG_NOCALL('MPI_PACK')
        IF (ONE_PACK.EQ.yes) THEN
           CALL AGMG_NOCALL('MPI_PACK')
        ELSE
         III = 1
         DO J=1,NRHS
           CALL AGMG_NOCALL('MPI_PACK')
           III =III+NPIV
         ENDDO
        ENDIF
        N2SEND=N2SEND+NPIV
        IF ( POS_BUF + RECORD_SIZE_P_1 > SIZE_BUF_BYTES ) THEN
          CALL DAGMG_MUMPS_523()
        END IF
        RETURN
        END SUBROUTINE DAGMG_MUMPS_522
        SUBROUTINE DAGMG_MUMPS_523()
        IF (N2SEND .NE. 0) THEN
         CALL AGMG_NOCALL('MPI_PACK')
         CALL AGMG_NOCALL('MPI_SEND')
        ENDIF
        POS_BUF=0
        N2SEND=0
        RETURN
        END SUBROUTINE DAGMG_MUMPS_523
      END SUBROUTINE DAGMG_MUMPS_521
      SUBROUTINE DAGMG_MUMPS_535(MTYPE, ISOL_LOC,                            &
     &             LSOL_LOC, PTRIST, KEEP,KEEP8,                        &
     &             IW, LIW_PASSED, MYID_NODES, N, STEP,                 &
     &             PROCNODE, NSLAVES, scaling_data, LSCAL)
      IMPLICIT NONE
      INTEGER MTYPE, LSOL_LOC, MYID_NODES, N, NSLAVES
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER PTRIST(KEEP(28)), PROCNODE(KEEP(28))
      INTEGER ISOL_LOC(LSOL_LOC)
      INTEGER LIW_PASSED
      INTEGER IW(LIW_PASSED)
      INTEGER STEP(N)
      LOGICAL LSCAL
      type scaling_data_t
        SEQUENCE
        DOUBLE PRECISION, dimension(:), pointer :: SCALING
        DOUBLE PRECISION, dimension(:), pointer :: SCALING_LOC
      end type scaling_data_t
      type (scaling_data_t) :: scaling_data
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      INTEGER ISTEP, K
      INTEGER J1, IPOS, LIELL, NPIV, JJ
      LOGICAL ROOT
      INTEGER SK38,SK20
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IF (KEEP(38).NE.0) THEN
        SK38=STEP(KEEP(38))
      ELSE
        SK38=0
      ENDIF
      IF (KEEP(20).NE.0) THEN
        SK20=STEP(KEEP(20))
      ELSE
        SK20=0
      ENDIF
      K=0
      DO ISTEP=1, KEEP(28)
          IF ( MYID_NODES == AGMG_MUMPS_275( ISTEP,                          &
     &         PROCNODE, NSLAVES)) THEN
              IF ( ISTEP.EQ.SK38 .OR. ISTEP.EQ.SK20 ) THEN
                    IPOS = PTRIST(ISTEP)+KEEP(IXSZ)
                    LIELL = IW(IPOS+3)
                    NPIV = LIELL
                    IPOS= PTRIST(ISTEP)+5+KEEP(IXSZ)
              ELSE
                  IPOS = PTRIST(ISTEP) + 2 + KEEP(IXSZ)
                  LIELL = IW(IPOS-2)+IW(IPOS+1)
                  IPOS= IPOS+1
                  NPIV = IW(IPOS)
                  IPOS= IPOS+1
                  IPOS= IPOS+1+IW( PTRIST(ISTEP) + 5 + KEEP(IXSZ))
              END IF
              IF (MTYPE.eq.1 .AND. KEEP(50).EQ.0) THEN
                   J1=IPOS+1+LIELL
              ELSE
                   J1=IPOS+1
              END IF
              DO JJ=J1,J1+NPIV-1
                  K=K+1
                  ISOL_LOC(K)=IW(JJ)
                  IF (LSCAL) THEN
                    scaling_data%SCALING_LOC(K)=                        &
     &              scaling_data%SCALING(IW(JJ))
                  ENDIF
              ENDDO
          ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_535
      SUBROUTINE DAGMG_MUMPS_532(                                            &
     &           SLAVEF, N, MYID_NODES,                                 &
     &           MTYPE, RHS, LD_RHS, NRHS,                              &
     &           ISOL_LOC, SOL_LOC, BEG_RHS, LSOL_LOC,                  &
     &           PTRIST,                                                &
     &           PROCNODE_STEPS, KEEP,KEEP8, IW, LIW, STEP,             &
     &           scaling_data, LSCAL)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      type scaling_data_t
        SEQUENCE
        DOUBLE PRECISION, dimension(:), pointer :: SCALING
        DOUBLE PRECISION, dimension(:), pointer :: SCALING_LOC
      end type scaling_data_t
      TYPE (scaling_data_t) :: scaling_data
      LOGICAL LSCAL
      INTEGER SLAVEF, N, MYID_NODES, LIW, MTYPE, NRHS, LD_RHS
      INTEGER LSOL_LOC, BEG_RHS
      INTEGER ISOL_LOC(LSOL_LOC)
      DOUBLE PRECISION SOL_LOC( LSOL_LOC, BEG_RHS+NRHS-1)
      DOUBLE PRECISION RHS(  LD_RHS , NRHS)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER PTRIST(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER IW(LIW), STEP(N)
      INTEGER JJ, J1, ISTEP, K
      INTEGER IPOS, LIELL, NPIV
      LOGICAL ROOT
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      K=0
        DO ISTEP = 1, KEEP(28)
            IF (MYID_NODES == AGMG_MUMPS_275(ISTEP,                          &
     &          PROCNODE_STEPS,SLAVEF)) THEN
              ROOT=.false.
              IF (KEEP(38).ne.0) ROOT = STEP(KEEP(38))==ISTEP
              IF (KEEP(20).ne.0) ROOT = STEP(KEEP(20))==ISTEP
              IF ( ROOT ) THEN
                    IPOS = PTRIST(ISTEP) + KEEP(IXSZ)
                    LIELL = IW(IPOS+3)
                    NPIV = LIELL
                    IPOS= PTRIST(ISTEP)+5+KEEP(IXSZ)
              ELSE
                  IPOS = PTRIST(ISTEP) + 2 +KEEP(IXSZ)
                  LIELL = IW(IPOS-2)+IW(IPOS+1)
                  IPOS= IPOS+1
                  NPIV = IW(IPOS)
                  IPOS= IPOS+1
                  IPOS= IPOS+1+IW( PTRIST(ISTEP) + 5 +KEEP(IXSZ))
              END IF
              IF (MTYPE.eq.1 .AND. KEEP(50).EQ.0) THEN
                   J1=IPOS+1+LIELL
              ELSE
                   J1=IPOS+1
              END IF
              DO JJ=J1,J1+NPIV-1
                K=K+1
                IF (LSCAL) THEN
                  SOL_LOC(K,BEG_RHS:BEG_RHS+NRHS-1) =                   &
     &            dble(scaling_data%SCALING_LOC(K))*RHS(IW(JJ),1:NRHS)
                ELSE
                  SOL_LOC(K,BEG_RHS:BEG_RHS+NRHS-1) =                   &
     &            RHS(IW(JJ),1:NRHS)
                ENDIF
              ENDDO
            ENDIF
        ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_532
      SUBROUTINE DAGMG_MUMPS_638                                             &
     &           (NSLAVES, N, MYID, COMM,                               &
     &           MTYPE, RHS, LRHS, NRHS, PTRIST,                        &
     &           KEEP,KEEP8, PROCNODE_STEPS, IW, LIW, STEP,             &
     &           POSINRHSCOMP, LENPOSINRHSCOMP,                         &
     &           BUILD_POSINRHSCOMP, ICNTL, INFO)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER NSLAVES, N, MYID, COMM, LIW, MTYPE
      INTEGER NRHS, LRHS, LENPOSINRHSCOMP
      INTEGER ICNTL(40), INFO(40)
      DOUBLE PRECISION RHS   (LRHS, NRHS)
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER PTRIST(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER IW(LIW), STEP(N), POSINRHSCOMP(LENPOSINRHSCOMP)
      LOGICAL BUILD_POSINRHSCOMP
      INTEGER BUF_MAXSIZE
      PARAMETER (BUF_MAXSIZE=2000)
      INTEGER, ALLOCATABLE, DIMENSION(:) :: BUF_INDX
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) :: BUF_RHS
      INTEGER ENTRIES_2_PROCESS, PROC_WHO_ASKS, BUF_EFFSIZE
      INTEGER INDX
      INTEGER allocok
      DOUBLE PRECISION ZERO
      PARAMETER(ZERO=0.0D0)
      INTEGER I, J, K, JJ, J1, ISTEP, MASTER,                           &
     &        MYID_NODES, TYPE_PARAL, N2RECV
      INTEGER LIELL, IPOS, NPIV
      INTEGER MSGSOU, STATUS(AGMG_MPF_STATUS_SIZE), IERR
      PARAMETER(MASTER=0)
      LOGICAL I_AM_SLAVE
      INTEGER SK38, SK20, IPOSINRHSCOMP
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      TYPE_PARAL = KEEP(46)
      IF (KEEP(38).NE.0) THEN
        SK38=STEP(KEEP(38))
      ELSE
        SK38=0
      ENDIF
      IF (KEEP(20).NE.0) THEN
        SK20=STEP(KEEP(20))
      ELSE
        SK20=0
      ENDIF
      I_AM_SLAVE = MYID .ne. 0 .OR. TYPE_PARAL .eq. 1
      IF ( TYPE_PARAL == 1 ) THEN
        MYID_NODES = MYID
      ELSE
        MYID_NODES = MYID-1
      ENDIF
      BUF_EFFSIZE = 0
      ALLOCATE (BUF_INDX(BUF_MAXSIZE),                                  &
     &          BUF_RHS(NRHS,BUF_MAXSIZE),                              &
     &          stat=allocok)
      IF (allocok .GT. 0) THEN
        INFO(1)=-13
        INFO(2)=BUF_MAXSIZE*(NRHS+1)
      ENDIF
      CALL AGMG_MUMPS_276(ICNTL, INFO, COMM, MYID )
      IF (INFO(1).LT.0) RETURN
      IF (MYID.EQ.MASTER) THEN
        ENTRIES_2_PROCESS = N - KEEP(89)
        DO WHILE ( ENTRIES_2_PROCESS .NE. 0)
          CALL AGMG_NOCALL('MPI_RECV')
          CALL AGMG_NOCALL('MPI_GET_COUNT')
          PROC_WHO_ASKS = STATUS(AGMG_MPF_SOURCE)
          DO I = 1, BUF_EFFSIZE
              INDX = BUF_INDX( I )
            DO K = 1, NRHS
              BUF_RHS( K, I ) = RHS( INDX, K )
              RHS( BUF_INDX(I), K ) = dble( ZERO )
            ENDDO
          ENDDO
          CALL AGMG_NOCALL('MPI_SEND')
          ENTRIES_2_PROCESS = ENTRIES_2_PROCESS - BUF_EFFSIZE
        ENDDO
        BUF_EFFSIZE= 0
      ENDIF
      IF (I_AM_SLAVE) THEN
        IF (BUILD_POSINRHSCOMP) THEN
           IPOSINRHSCOMP = 1
           POSINRHSCOMP = -9678
        ENDIF
        IF (MYID.NE.MASTER) RHS = dble(ZERO)
        DO ISTEP = 1, KEEP(28)
          IF (MYID_NODES == AGMG_MUMPS_275(ISTEP,                            &
     &          PROCNODE_STEPS,NSLAVES)) THEN
              IF ( ISTEP.EQ.SK38 .OR. ISTEP.EQ.SK20 ) THEN
                  IPOS = PTRIST(ISTEP)
                  LIELL = IW(IPOS+3+KEEP(IXSZ))
                  NPIV = LIELL
                  IPOS= PTRIST(ISTEP)+5+KEEP(IXSZ)
              ELSE
                  IPOS = PTRIST(ISTEP) + 2+ KEEP(IXSZ)
                  LIELL = IW(IPOS-2)+IW(IPOS+1)
                  IPOS= IPOS+1
                  NPIV = IW(IPOS)
                  IPOS= IPOS+1
                  IPOS= IPOS+1+IW( PTRIST(ISTEP) + 5 +KEEP(IXSZ))
              END IF
              IF (MTYPE.eq.1 .OR. KEEP(50).NE.0) THEN
                   J1=IPOS+1
              ELSE
                   J1=IPOS+1+LIELL
              END IF
              IF (BUILD_POSINRHSCOMP) THEN
                 POSINRHSCOMP(ISTEP) = IPOSINRHSCOMP
                 IPOSINRHSCOMP       = IPOSINRHSCOMP + NPIV
              ENDIF
              IF (MYID.NE.MASTER) THEN
                DO JJ=J1,J1+NPIV-1
                  BUF_EFFSIZE = BUF_EFFSIZE + 1
                  BUF_INDX(BUF_EFFSIZE) = IW(JJ)
                  IF (BUF_EFFSIZE + 1 .GT. BUF_MAXSIZE) THEN
                   CALL DAGMG_MUMPS_640()
                  ENDIF
                ENDDO
              ENDIF
          ENDIF
        ENDDO
        IF ( BUF_EFFSIZE .NE. 0 .AND. MYID.NE.MASTER )                  &
     &              CALL DAGMG_MUMPS_640()
      ENDIF
      DEALLOCATE (BUF_INDX, BUF_RHS)
      RETURN
      CONTAINS
                  SUBROUTINE DAGMG_MUMPS_640()
                  CALL AGMG_NOCALL('MPI_SEND')
                  CALL AGMG_NOCALL('MPI_RECV')
                  DO I = 1, BUF_EFFSIZE
                    INDX = BUF_INDX(I)
                    DO K = 1, NRHS
                      RHS( INDX, K ) = BUF_RHS( K, I )
                    ENDDO
                  ENDDO
                  BUF_EFFSIZE = 0
                  RETURN
                  END SUBROUTINE DAGMG_MUMPS_640
      END SUBROUTINE DAGMG_MUMPS_638
      SUBROUTINE DAGMG_MUMPS_639                                             &
     &           (NSLAVES, N, MYID_NODES,                               &
     &           PTRIST,                                                &
     &           KEEP,KEEP8, PROCNODE_STEPS, IW, LIW, STEP,             &
     &           POSINRHSCOMP, POSINRHSCOMP_N, LPIRC_N, MTYPE,          &
     &           WHAT )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER NSLAVES, N, MYID_NODES, LIW
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER PTRIST(KEEP(28)), PROCNODE_STEPS(KEEP(28))
      INTEGER IW(LIW), STEP(N), POSINRHSCOMP(KEEP(28))
      INTEGER LPIRC_N, WHAT, MTYPE
      INTEGER POSINRHSCOMP_N(LPIRC_N)
      INTEGER ISTEP
      INTEGER NPIV
      INTEGER SK38, SK20, IPOS, LIELL
      INTEGER JJ, J1
      INTEGER IPOSINRHSCOMP
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      IF (WHAT .NE. 0.AND. WHAT.NE.1.AND.WHAT.NE.2) THEN
        WRITE(*,*) "Internal error in DAGMG_MUMPS_639"
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      IF (KEEP(38).NE.0) THEN
        SK38=STEP(KEEP(38))
      ELSE
        SK38=0
      ENDIF
      IF (KEEP(20).NE.0) THEN
        SK20=STEP(KEEP(20))
      ELSE
        SK20=0
      ENDIF
      IPOSINRHSCOMP   = 1
      POSINRHSCOMP = -9678
      IF (WHAT .NE. 0) THEN
        POSINRHSCOMP_N = 0
      ENDIF
      DO ISTEP = 1, KEEP(28)
        IF (MYID_NODES == AGMG_MUMPS_275(ISTEP,                              &
     &     PROCNODE_STEPS,NSLAVES)) THEN
           IPOS = PTRIST(ISTEP)
           NPIV = IW(IPOS+3+KEEP(IXSZ))
           POSINRHSCOMP(ISTEP) = IPOSINRHSCOMP
           IF (WHAT .NE. 0) THEN
              IF ( ISTEP.EQ.SK38 .OR. ISTEP.EQ.SK20 ) THEN
                  IPOS = PTRIST(ISTEP)
                  LIELL = IW(IPOS+3+KEEP(IXSZ))
                  NPIV = LIELL
                  IPOS= PTRIST(ISTEP)+5+KEEP(IXSZ)
              ELSE
                  IPOS = PTRIST(ISTEP) + 2+ KEEP(IXSZ)
                  LIELL = IW(IPOS-2)+IW(IPOS+1)
                  IPOS= IPOS+1
                  NPIV = IW(IPOS)
                  IPOS= IPOS+1
                  IPOS= IPOS+1+IW( PTRIST(ISTEP) + 5 +KEEP(IXSZ))
              ENDIF
              IF (MTYPE.eq.1 .OR. KEEP(50).NE.0) THEN
                   J1=IPOS+1
              ELSE
                   J1=IPOS+1+LIELL
              END IF
              DO JJ = J1, J1+NPIV-1
                POSINRHSCOMP_N(IW(JJ)) = IPOSINRHSCOMP+JJ-J1
              END DO
           ENDIF
           IPOSINRHSCOMP       = IPOSINRHSCOMP + NPIV
        ENDIF
      ENDDO
      RETURN
      END SUBROUTINE DAGMG_MUMPS_639
      SUBROUTINE DAGMG_MUMPS_248(N, A, LA, IW, LIW, WCB, LWCB,               &
     &    RHS, LRHS, NRHS,                                              &
     &    PTRICB, IWCB, LIWCB,                                          &
     &    RHSCOMP, LRHSCOMP, POSINRHSCOMP, BUILD_POSINRHSCOMP,          &
     &    NE_STEPS, NA, LNA, STEP,                                      &
     &    FRERE, DAD, FILS,                                             &
     &    NSTK_S, IPOOL, LPOOL, PTRIST, PTRFAC, MYLEAF, INFO,           &
     &    KEEP,KEEP8,                                                   &
     &    PROCNODE_STEPS,                                               &
     &    SLAVEF, COMM, MYID, BUFR, LBUFR, LBUFR_BYTES,                 &
     &    RHS_ROOT, MTYPE,                                              &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE                               &
     &    )
      USE DAGMG_MUMPS_OOC
      IMPLICIT NONE
      INTEGER MTYPE
      INTEGER(8) :: LA
      INTEGER N, LIW, LWCB, LPOOL, LIWCB, LNA
      INTEGER SLAVEF, MYLEAF, COMM, MYID
      INTEGER INFO( 40 ), KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER PROCNODE_STEPS( KEEP(28) )
      INTEGER LRHS, NRHS
      DOUBLE PRECISION A( LA ), RHS( LRHS, NRHS ), WCB( LWCB )
      DOUBLE PRECISION RHS_ROOT( * )
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER NA( LNA ), NE_STEPS( KEEP(28) )
      INTEGER STEP( N ), FRERE( KEEP(28) ), FILS( N ),                  &
     &        DAD( KEEP(28) )
      INTEGER NSTK_S(KEEP(28)), IPOOL( LPOOL )
      INTEGER PTRIST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER PTRICB( KEEP(28) )
      INTEGER IW( LIW ), IWCB( LIWCB )
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER POSINRHSCOMP(KEEP(28)), LRHSCOMP
      LOGICAL BUILD_POSINRHSCOMP
      DOUBLE PRECISION RHSCOMP( LRHSCOMP, NRHS )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER MSGTAG, MSGSOU, DUMMY(1)
      LOGICAL FLAG
      INTEGER NBFIN, MYROOT
      INTEGER POSIWCB,POSWCB,PLEFTWCB
      INTEGER INODE
      INTEGER RHSCOMPFREEPOS
      INTEGER I, K, J
      INTEGER III, NBROOT,NBLEAF,LEAF
      LOGICAL BLOQ
      EXTERNAL AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_275
      DOUBLE PRECISION ZERO
      PARAMETER( ZERO = 0.0D0 )
      POSIWCB = LIWCB
      POSWCB  = LWCB
      PLEFTWCB= 1
      IF (BUILD_POSINRHSCOMP) RHSCOMPFREEPOS= 1
      DO I = 1, KEEP(28)
        NSTK_S(I)   = NE_STEPS(I)
      ENDDO
      PTRICB = 0
      CALL AGMG_MUMPS_362(N, LEAF, NBROOT, MYROOT, MYID,                     &
     &     SLAVEF, NA, LNA, KEEP,KEEP8, STEP,                           &
     &     PROCNODE_STEPS, IPOOL, LPOOL)
      NBFIN = SLAVEF
      IF ( MYROOT .EQ. 0 ) THEN
        NBFIN = NBFIN - 1
        DUMMY(1) = 1
        CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM,              &
     &       RACINE_SOLVE, SLAVEF)
      END IF
      MYLEAF = LEAF - 1
      III    = 1
   50 CONTINUE
      IF (SLAVEF .EQ. 1) THEN
         CALL DAGMG_MUMPS_574                                                &
     &        ( IPOOL(1), LPOOL, III, LEAF, INODE,                      &
     &          KEEP(208) )
        GOTO 60
      ENDIF
      BLOQ = ( ( III .EQ. LEAF )                                        &
     &     )
      CALL DAGMG_MUMPS_303( BLOQ, FLAG,                                      &
     &     BUFR, LBUFR, LBUFR_BYTES,                                    &
     &     MYID, SLAVEF, COMM,                                          &
     &     N, NRHS, IPOOL, LPOOL, III, LEAF,                            &
     &     NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST, PTRFAC,               &
     &     IWCB, LIWCB,                                                 &
     &     WCB, LWCB, POSWCB,                                           &
     &     PLEFTWCB, POSIWCB,                                           &
     &     PTRICB, INFO, KEEP,KEEP8, STEP,                              &
     &     PROCNODE_STEPS,                                              &
     &     RHS, LRHS                                                    &
     &     )
      IF ( INFO( 1 ) .LT. 0 .OR. NBFIN .EQ. 0 ) GOTO 260
      IF (.not. FLAG) THEN
         IF (III .NE. LEAF) THEN
            CALL DAGMG_MUMPS_574                                             &
     &           (IPOOL(1), LPOOL, III, LEAF, INODE,                    &
     &           KEEP(208) )
            GOTO 60
         ENDIF
      ENDIF
      GOTO 50
   60 CONTINUE
      CALL DAGMG_MUMPS_302( INODE, BUFR, LBUFR, LBUFR_BYTES,                 &
     &        MSGTAG, MSGSOU, MYID, SLAVEF, COMM,  N,                   &
     &        IPOOL, LPOOL, III, LEAF, NBFIN, NSTK_S,                   &
     &        IWCB, LIWCB, WCB, LWCB, A, LA,                            &
     &        IW, LIW, RHS, LRHS, NRHS,                                 &
     &        POSWCB, PLEFTWCB, POSIWCB,                                &
     &        PTRICB, PTRIST, PTRFAC, PROCNODE_STEPS,                   &
     &        FILS, STEP, FRERE, DAD,                                   &
     &        MYROOT, INFO, KEEP,KEEP8, RHS_ROOT, MTYPE,                &
     &        RHSCOMP, LRHSCOMP, POSINRHSCOMP,                          &
     &        RHSCOMPFREEPOS, BUILD_POSINRHSCOMP,                       &
     &        ISTEP_TO_INIV2, TAB_POS_IN_PERE                           &
     &     )
      IF ( INFO( 1 ) .LT. 0 .OR. NBFIN .EQ. 0 ) GOTO 260
      GOTO 50
  260 CONTINUE
      CALL DAGMG_MUMPS_150( MYID,COMM,BUFR,                                  &
     &                            LBUFR,LBUFR_BYTES )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_248
      RECURSIVE SUBROUTINE DAGMG_MUMPS_323                                   &
     &     ( BUFR, LBUFR, LBUFR_BYTES,                                  &
     &     MSGTAG, MSGSOU, MYID, SLAVEF, COMM,                          &
     &     N, NRHS, IPOOL, LPOOL, III, LEAF,                            &
     &     NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST,                       &
     &     PTRFAC, IWCB, LIWCB,                                         &
     &     WCB, LWCB, POSWCB,                                           &
     &     PLEFTWCB, POSIWCB,                                           &
     &     PTRICB,                                                      &
     &     INFO, KEEP,KEEP8, STEP, PROCNODE_STEPS,                      &
     &     RHS, LRHS                                                    &
     &     )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER MSGTAG, MSGSOU, MYID, SLAVEF, COMM
      INTEGER LIW
      INTEGER(8) :: LA
      INTEGER N, NRHS, LPOOL, III, LEAF, NBFIN
      INTEGER LIWCB, LWCB, POSWCB, PLEFTWCB, POSIWCB
      INTEGER INFO( 40 ), KEEP( 500)
      INTEGER*8 KEEP8(150)
      INTEGER BUFR( LBUFR )
      INTEGER IPOOL( LPOOL ),  NSTK_S( N )
      INTEGER IWCB( LIWCB )
      INTEGER IW( LIW )
      INTEGER PTRICB(KEEP(28)),PTRIST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER STEP(N)
      INTEGER PROCNODE_STEPS(KEEP(28))
      DOUBLE PRECISION WCB( LWCB ), A( LA )
      INTEGER LRHS
      DOUBLE PRECISION RHS(LRHS, NRHS)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR, K, JJ
      INTEGER FINODE, FPERE, LONG, NCB, POSITION, NCV, NPIV
      INTEGER PTRX, PTRY, PDEST, I
      INTEGER(8) :: APOS
      INTEGER LIWFAC, PANEL_SIZE, TYPEF
      LOGICAL DUMMY
      LOGICAL FLAG
      EXTERNAL AGMG_MUMPS_275
      INTEGER  AGMG_MUMPS_275
      DOUBLE PRECISION ALPHA, ONE
      PARAMETER (ONE = 1.0D0, ALPHA=-1.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      IF ( MSGTAG .EQ. RACINE_SOLVE ) THEN
         NBFIN = NBFIN - 1
         IF ( NBFIN .eq. 0 ) GOTO 270
      ELSE  IF (MSGTAG .EQ. ContVec ) THEN
         POSITION = 0
         CALL AGMG_NOCALL('MPI_UNPACK')
         CALL AGMG_NOCALL('MPI_UNPACK')
         CALL AGMG_NOCALL('MPI_UNPACK')
         CALL AGMG_NOCALL('MPI_UNPACK')
          IF ( NCB .eq. 0 ) THEN
             PTRICB(STEP(FINODE)) = -1
             NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
             IF ( NSTK_S(STEP(FPERE)) .EQ. 0 ) THEN
                   IPOOL( LEAF ) = FPERE
                LEAF = LEAF + 1
                IF ( LEAF > LPOOL ) THEN
                   WRITE(*,*) 'Internal error 41r2 : Pool is too small.'
                   CALL AGMG_MUMPS_ABORT()
                END IF
             END IF
          ELSE
             IF ( PTRICB(STEP(FINODE)) .EQ. 0 ) THEN
                PTRICB(STEP(FINODE)) = NCB + 1
             END IF
             IF ( ( POSIWCB - LONG ) .LT. 0 ) THEN
                INFO( 1 ) = -14
                INFO( 2 ) = LONG
                GOTO 260
             END IF
             IF ( POSWCB - PLEFTWCB + 1 .LT. LONG * NRHS) THEN
                INFO( 1 ) = -11
                INFO( 2 ) = PLEFTWCB - POSWCB - 1 + LONG * NRHS
                GOTO 260
             END IF
             IF (LONG .GT. 0) THEN
                CALL AGMG_NOCALL('MPI_UNPACK')
                DO K = 1, NRHS
                   CALL AGMG_NOCALL('MPI_UNPACK')
                   DO I = 1, LONG
                      RHS(IWCB(I),K) = RHS(IWCB(I),K) +WCB(PLEFTWCB+I-1)
                   ENDDO
                END DO
                PTRICB(STEP(FINODE)) = PTRICB(STEP(FINODE)) - LONG
             ENDIF
             IF ( PTRICB(STEP(FINODE)) == 1 ) THEN
                NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
             END IF
             IF ( NSTK_S(STEP(FPERE)) .EQ. 0 ) THEN
                   IPOOL( LEAF ) = FPERE
                LEAF = LEAF + 1
                IF ( LEAF > LPOOL ) THEN
                   WRITE(*,*) 'Internal error 41r2 : Pool is too small.'
                   CALL AGMG_MUMPS_ABORT()
                END IF
             ENDIF
          END IF
       ELSEIF ( MSGTAG .EQ. Master2Slave ) THEN
          POSITION = 0
          CALL AGMG_NOCALL('MPI_UNPACK')
          CALL AGMG_NOCALL('MPI_UNPACK')
          CALL AGMG_NOCALL('MPI_UNPACK')
          CALL AGMG_NOCALL('MPI_UNPACK')
          PTRY = PLEFTWCB
          PTRX = PLEFTWCB + NCV * NRHS
          PLEFTWCB = PLEFTWCB + (NPIV + NCV) * NRHS
          IF ( POSWCB - PLEFTWCB + 1 .LT. 0 ) THEN
             INFO(1) = -11
             INFO(2) = -POSWCB + PLEFTWCB -1
             GO TO 260
          END IF
          DO K=1, NRHS
             CALL AGMG_NOCALL('MPI_UNPACK')
          ENDDO
          IF ( NPIV .GT. 0 ) THEN
             DO K=1, NRHS
                CALL AGMG_NOCALL('MPI_UNPACK')
             END DO
          END IF
          IF (KEEP(201).NE.0) THEN
             CALL DAGMG_MUMPS_643(                                           &
     &            FINODE,PTRFAC,KEEP,A,LA,STEP,                         &
     &            KEEP8,N,DUMMY,IERR)
             IF(IERR.LT.0)THEN
                INFO(1)=IERR
                INFO(2)=0
                GOTO 260
             ENDIF
          ENDIF
          APOS = PTRFAC(STEP(FINODE))
          IF (KEEP(201).EQ.1) THEN
             IF ( NRHS == 1 ) THEN
                CALL DGEMV( 'N', NCV, NPIV, ALPHA, A(APOS), NCV,        &
     &               WCB( PTRX ), 1, ONE,                               &
     &               WCB( PTRY ), 1 )
             ELSE
                CALL DGEMM( 'N', 'N', NCV, NRHS, NPIV, ALPHA,           &
     &               A(APOS), NCV,                                      &
     &               WCB( PTRX), NPIV, ONE,                             &
     &               WCB( PTRY), NCV )
             ENDIF
          ELSE
             IF ( NRHS == 1 ) THEN
                CALL DGEMV( 'T', NPIV, NCV, ALPHA, A(APOS), NPIV,       &
     &               WCB( PTRX ), 1, ONE,                               &
     &               WCB( PTRY ), 1 )
             ELSE
                CALL DGEMM( 'T', 'N', NCV, NRHS, NPIV, ALPHA,           &
     &               A(APOS), NPIV,                                     &
     &               WCB( PTRX), NPIV, ONE,                             &
     &               WCB( PTRY), NCV )
             ENDIF
          ENDIF
          IF (KEEP(201).NE.0) THEN
             CALL DAGMG_MUMPS_598(FINODE,PTRFAC,                             &
     &            KEEP(28),A,LA,.TRUE.,IERR)
             IF(IERR.LT.0)THEN
                INFO(1)=IERR
                INFO(2)=0
                GOTO 260
             ENDIF
          ENDIF
          PLEFTWCB = PLEFTWCB - NPIV * NRHS
          PDEST = AGMG_MUMPS_275( STEP(FPERE),                               &
     &         PROCNODE_STEPS, SLAVEF )
          IF ( PDEST .EQ. MYID ) THEN
             IF ( PTRICB(STEP(FINODE)) .EQ. 0 ) THEN
                NCB = IW( PTRIST(STEP(FINODE)) + 2 + KEEP(IXSZ) )
                PTRICB(STEP(FINODE)) = NCB + 1
             END IF
             DO I = 1, NCV
                JJ=IW(PTRIST(STEP(FINODE))+3+I+ KEEP(IXSZ) )
                DO K=1, NRHS
                   RHS(JJ,K)= RHS(JJ,K) + WCB(PTRY+I-1+(K-1)*NCV)
                ENDDO
             END DO
             PTRICB(STEP(FINODE)) =                                     &
     &            PTRICB(STEP(FINODE)) - NCV
             IF ( PTRICB( STEP( FINODE ) ) == 1 ) THEN
                NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
             END IF
             IF ( NSTK_S(STEP(FPERE)) .EQ. 0 ) THEN
                   IPOOL( LEAF ) = FPERE
                LEAF = LEAF + 1
                IF ( LEAF > LPOOL ) THEN
                   WRITE(*,*) 'INTERNAL Error 41r: Pool is too small.'
                   CALL AGMG_MUMPS_ABORT()
                END IF
             ENDIF
          ELSE
  210        CONTINUE
             CALL DAGMG_MUMPS_78( NRHS, FINODE, FPERE,                       &
     &            IW(PTRIST(STEP( FINODE )) + 2 + KEEP(IXSZ) ), NCV,NCV,&
     &            IW(PTRIST(STEP(FINODE))+4+ KEEP(IXSZ) ),              &
     &            WCB( PTRY ), PDEST, ContVec, COMM, IERR )
             IF ( IERR .EQ. -1 ) THEN
                CALL DAGMG_MUMPS_303( .FALSE., FLAG,                         &
     &               BUFR, LBUFR, LBUFR_BYTES,                          &
     &               MYID, SLAVEF, COMM,                                &
     &               N, NRHS, IPOOL, LPOOL, III, LEAF,                  &
     &               NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST, PTRFAC,     &
     &               IWCB, LIWCB,                                       &
     &               WCB, LWCB, POSWCB, PLEFTWCB, POSIWCB,              &
     &               PTRICB, INFO, KEEP,KEEP8, STEP,                    &
     &               PROCNODE_STEPS,                                    &
     &               RHS, LRHS                                          &
     &               )
                IF ( INFO( 1 )  .LT. 0 )  GOTO 270
                GOTO 210
             ELSE IF ( IERR .EQ. -2 ) THEN
                INFO( 1 ) = -17
                INFO( 2 ) = ( NCV + 4 ) * KEEP( 34 ) +                  &
     &               NCV * KEEP( 35 )
                GOTO 260
             ELSE IF ( IERR .EQ. -3 ) THEN
                INFO( 1 ) = -20
                INFO( 2 ) = ( NCV + 4 ) * KEEP( 34 ) +                  &
     &               NCV * KEEP( 35 )
             END IF
          END IF
          PLEFTWCB = PLEFTWCB - NCV * NRHS
       ELSEIF ( MSGTAG .EQ. TERREUR ) THEN
          INFO(1) = -001
          INFO(2) = MSGSOU
          GOTO 270
       ELSE IF ( (MSGTAG.EQ.UPDATE_LOAD).OR.                            &
     &         (MSGTAG.EQ.TAG_DUMMY) ) THEN
          GO TO 270
       ELSE
          INFO(1)=-100
          INFO(2)=MSGTAG
          GO TO 260
       ENDIF
       GO TO 270
  260  CONTINUE
       CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  270  CONTINUE
       RETURN
       END SUBROUTINE DAGMG_MUMPS_323
      SUBROUTINE DAGMG_MUMPS_302( INODE,                                     &
     &     BUFR, LBUFR, LBUFR_BYTES,                                    &
     &     MSGTAG, MSGSOU, MYID, SLAVEF, COMM,                          &
     &     N, IPOOL, LPOOL, III, LEAF,                                  &
     &     NBFIN, NSTK_S,                                               &
     &     IWCB, LIWCB,                                                 &
     &     WCB, LWCB, A, LA, IW, LIW,                                   &
     &     RHS, LRHS, NRHS, POSWCB,                                     &
     &     PLEFTWCB, POSIWCB,                                           &
     &     PTRICB, PTRIST, PTRFAC, PROCNODE_STEPS,                      &
     &     FILS, STEP, FRERE, DAD,                                      &
     &     MYROOT,                                                      &
     &     INFO, KEEP,KEEP8, RHS_ROOT, MTYPE,                           &
     &     RHSCOMP, LRHSCOMP, POSINRHSCOMP,                             &
     &     RHSCOMPFREEPOS, BUILD_POSINRHSCOMP,                          &
     &     ISTEP_TO_INIV2, TAB_POS_IN_PERE                              &
     &            )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER MTYPE
      INTEGER INODE, LBUFR, LBUFR_BYTES
      INTEGER MSGTAG, MSGSOU, MYID, SLAVEF, COMM
      INTEGER LIWCB, LWCB, LIW, POSWCB, PLEFTWCB, POSIWCB
      INTEGER(8) :: LA
      INTEGER N, LPOOL, III, LEAF, NBFIN
      INTEGER MYROOT
      INTEGER INFO( 40 ), KEEP( 500)
      INTEGER*8 KEEP8(150)
      INTEGER BUFR( LBUFR )
      INTEGER IPOOL( LPOOL ), NSTK_S(KEEP(28))
      INTEGER IWCB( LIWCB ), IW( LIW )
      INTEGER LRHS, NRHS
      DOUBLE PRECISION WCB( LWCB ), A( LA )
      DOUBLE PRECISION RHS(LRHS, NRHS ), RHS_ROOT( * )
      INTEGER PTRICB(KEEP(28)), PTRIST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER FILS( N ), STEP( N ), FRERE(KEEP(28)), DAD(KEEP(28))
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &     TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER POSINRHSCOMP(KEEP(28)), LRHSCOMP, RHSCOMPFREEPOS
      DOUBLE PRECISION RHSCOMP(LRHSCOMP, NRHS)
      LOGICAL BUILD_POSINRHSCOMP
      EXTERNAL DGEMV, DTRSV, DGEMM, DTRSM, AGMG_MUMPS_275
      INTEGER AGMG_MUMPS_275
      DOUBLE PRECISION ALPHA,ONE,ZERO
      PARAMETER (ZERO=0.0D0, ONE = 1.0D0, ALPHA=-1.0D0)
      INTEGER(8) :: APOS, APOS1, APOS2, APOSOFF
      INTEGER I, J, K, IPOS, NSLAVES, J1, J2, J3, FPERE, NPIV, NCB,     &
     &     IERR,                                                        &
     &     IF, IFR, IPOSCB, APOSCB, LIELL, IN, JJ,                      &
     &     NELIM, PLEFT, PCB_COURANT, PPIV_COURANT
      INTEGER IPOSINRHSCOMP
      INTEGER Effective_CB_Size, NUPDATE, ISLAVE, PDEST, FirstIndex
      LOGICAL FLAG
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER POSWCB1,POSWCB2, JJ1, JJ2
      INTEGER(8) :: APOSDEB
      INTEGER TempNROW, TempNCOL, PANEL_SIZE, LIWFAC,                   &
     &     JFIN, NBJ, NUPDATE_PANEL,                                    &
     &     PPIV_PANEL, PCB_PANEL, NBK, TYPEF
      INTEGER LD_WCBPIV
      INTEGER LD_WCBCB
      INTEGER LDAJ, LDAJ_FIRST_PANEL
      INTEGER TMP_NBPANELS,                                             &
     &     I_PIVRPTR, I_PIVR, IPANEL
      INTEGER INODE_STATE
      LOGICAL MUST_BE_PERMUTED
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER DUMMY( 1 )
      IF ( INODE .eq. KEEP(38 ) .OR. INODE .eq.KEEP( 20 ) ) THEN
         LIELL = IW( PTRIST( STEP(INODE)) + 3 + KEEP(IXSZ))
         NPIV  = LIELL
         NELIM = 0
         NSLAVES = 0
         IPOS = PTRIST( STEP(INODE)) + 5 + KEEP(IXSZ)
      ELSE
        IPOS = PTRIST(STEP(INODE)) + 2 + KEEP(IXSZ)
        LIELL = IW(IPOS-2)+IW(IPOS+1)
        NELIM = IW(IPOS-1)
        NSLAVES = IW( PTRIST(STEP(INODE)) + 5 + KEEP(IXSZ) )
        IPOS = IPOS + 1
        NPIV = IW(IPOS)
        IPOS = IPOS + 1
        IF (KEEP(201).NE.0) THEN
           CALL DAGMG_MUMPS_643(                                             &
     &          INODE,PTRFAC,KEEP,A,LA,STEP,                            &
     &          KEEP8,N,MUST_BE_PERMUTED,IERR)
           IF(IERR.LT.0)THEN
              INFO(1)=IERR
              INFO(2)=0
              GOTO 260
           ENDIF
           IF (KEEP(201).EQ.1 .AND. KEEP(50).NE.1) THEN
           CALL DAGMG_MUMPS_755(                                             &
     &                 IW(IPOS+1+2*LIELL+1+NSLAVES),                    &
     &                 MUST_BE_PERMUTED )
           ENDIF
        ENDIF
        NSLAVES = IW( PTRIST(STEP(INODE)) + 5 + KEEP(IXSZ))
        IPOS = IPOS + 1 + NSLAVES
      END IF
      IF ( MTYPE .EQ. 1 .OR. KEEP(50) .NE. 0 ) THEN
         J1 = IPOS + 1
         J2 = IPOS + LIELL
         J3 = IPOS + NPIV
      ELSE
         J1 = IPOS + LIELL + 1
         J2 = IPOS + 2 * LIELL
         J3 = IPOS + LIELL + NPIV
      END IF
      NCB = LIELL-NPIV
      IF ( INODE .eq. KEEP( 38 ) .OR. INODE .eq. KEEP(20) ) THEN
         IFR = 0
         DO JJ = J1, J3
            J = IW( JJ )
            IFR = IFR + 1
            DO K=1,NRHS
               RHS_ROOT(IFR+NPIV*(K-1)) = RHS(J,K)
            END DO
         END DO
         IF ( NPIV .LT. LIELL ) THEN
            WRITE(*,*) ' Internal error in SOLVE_NODE for Root node'
            CALL AGMG_MUMPS_ABORT()
         END IF
         MYROOT = MYROOT - 1
         IF ( MYROOT .EQ. 0 ) THEN
            NBFIN = NBFIN - 1
            IF (SLAVEF .GT. 1) THEN
               DUMMY (1) = 1
               CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID,             &
     &              COMM, RACINE_SOLVE, SLAVEF)
            ENDIF
         END IF
         GO TO 270
      END IF
      APOS = PTRFAC(STEP(INODE))
      IF (KEEP(201).EQ.1) THEN
        IF (MTYPE.EQ.1) THEN
            IF ((MTYPE.EQ.1).AND.NSLAVES.NE.0) THEN
              TempNROW= NPIV+NELIM
              TempNCOL= NPIV
              LDAJ_FIRST_PANEL=TempNROW
            ELSE
              TempNROW= LIELL
              TempNCOL= NPIV
              LDAJ_FIRST_PANEL=TempNROW
            ENDIF
            TYPEF=TYPEF_L
        ELSE
            TempNCOL= LIELL
            TempNROW= NPIV
            LDAJ_FIRST_PANEL=TempNCOL
            TYPEF= TYPEF_U
        ENDIF
        LIWFAC =  IW(PTRIST(STEP(INODE))+XXI)
        PANEL_SIZE = DAGMG_MUMPS_690( LDAJ_FIRST_PANEL )
      ENDIF
      PLEFT    = PLEFTWCB
      PPIV_COURANT = PLEFTWCB
      PLEFTWCB = PLEFTWCB + LIELL * NRHS
      IF ( POSWCB - PLEFTWCB + 1 .LT. 0 ) THEN
         INFO(1) = -11
         INFO(2) = PLEFTWCB - POSWCB - 1
         GO TO 260
      END IF
      IF (KEEP(201).EQ.1) THEN
         LD_WCBPIV = LIELL
         LD_WCBCB  = LIELL
         PCB_COURANT = PPIV_COURANT + NPIV
         DO K=1, NRHS
            IFR = PPIV_COURANT + (K-1)*LIELL - 1
            DO JJ = J1, J3
               J = IW(JJ)
               IFR = IFR + 1
               WCB(IFR) = RHS(J,K)
            ENDDO
            IF (NCB.GT.0) THEN
               DO JJ = J3+1, J2
                  J = IW(JJ)
                  IFR = IFR + 1
                  WCB(IFR) = RHS(J,K)
                  RHS (J,K) = ZERO
               ENDDO
            ENDIF
         END DO
      ELSE
         LD_WCBPIV = NPIV
         LD_WCBCB  = NCB
         PCB_COURANT = PPIV_COURANT + NPIV*NRHS
         IFR = PPIV_COURANT - 1
         DO 130 JJ = J1, J3
            J = IW(JJ)
            IFR = IFR + 1
            DO K=1, NRHS
               WCB(IFR+(K-1)*NPIV) = RHS(J,K)
            END DO
  130    CONTINUE
         IFR = PCB_COURANT - 1
         IF (NPIV .LT. LIELL) THEN
            DO 140 JJ = J3 + 1, J2
               J = IW(JJ)
               IFR = IFR + 1
               DO K=1, NRHS
                  WCB(IFR+(K-1)*NCB) = RHS(J,K)
                  RHS(J,K)=ZERO
               ENDDO
  140       CONTINUE
         ENDIF
      ENDIF
      IF ( NPIV .NE. 0 ) THEN
         IF (KEEP(201).EQ.1) THEN
        APOSDEB = APOS
        J = 1
        IPANEL = 0
   10   CONTINUE
          IPANEL = IPANEL + 1
          JFIN    = min(J+PANEL_SIZE-1, NPIV)
          IF (IW(IPOS+ LIELL + JFIN) < 0) THEN
            JFIN=JFIN+1
          ENDIF
          NBJ     = JFIN-J+1
          LDAJ    = LDAJ_FIRST_PANEL-J+1
          IF ( (KEEP(50).NE.1).AND. MUST_BE_PERMUTED ) THEN
           CALL DAGMG_MUMPS_667(TYPEF, TMP_NBPANELS,                         &
     &            I_PIVRPTR, I_PIVR, IPOS+1+2*LIELL, IW, LIW)
               IF (NPIV.EQ.(IW(I_PIVRPTR+IPANEL-1)-1)) THEN
                  MUST_BE_PERMUTED=.FALSE.
               ELSE
                  CALL DAGMG_MUMPS_698(                                      &
     &                 IW( I_PIVR+ IW(I_PIVRPTR+IPANEL-1)-              &
     &                 IW(I_PIVRPTR)),                                  &
     &                 NPIV-IW(I_PIVRPTR+IPANEL-1)+1,                   &
     &                 IW(I_PIVRPTR+IPANEL-1)-1,                        &
     &                 A(APOSDEB),                                      &
     &                 LDAJ, NBJ, J-1 )
               ENDIF
            ENDIF
            NUPDATE_PANEL = LDAJ - NBJ
            PPIV_PANEL = PPIV_COURANT+J-1
            PCB_PANEL  = PPIV_PANEL+NBJ
            APOS1 = APOSDEB+int(NBJ,8)
            IF  (MTYPE.EQ.1) THEN
               IF ( NRHS == 1 ) THEN
                  CALL DTRSV( 'L', 'N', 'U', NBJ, A(APOSDEB), LDAJ,     &
     &                 WCB(PPIV_PANEL), 1 )
                  IF (NUPDATE_PANEL.GT.0) THEN
                     CALL DGEMV('N', NUPDATE_PANEL,NBJ,ALPHA, A(APOS1), &
     &                    LDAJ,  WCB(PPIV_PANEL), 1, ONE,               &
     &                    WCB(PCB_PANEL), 1)
                  ENDIF
               ELSE
                  CALL DTRSM( 'L','L','N','U', NBJ, NRHS, ONE,          &
     &                 A(APOSDEB), LDAJ, WCB(PPIV_PANEL),               &
     &                 LIELL )
                  IF (NUPDATE_PANEL.GT.0) THEN
                     CALL DGEMM('N', 'N', NUPDATE_PANEL, NRHS, NBJ,     &
     &                    ALPHA,                                        &
     &                    A(APOS1), LDAJ, WCB(PPIV_PANEL), LIELL, ONE,  &
     &                    WCB(PCB_PANEL), LIELL)
                  ENDIF
               ENDIF
            ELSE
               IF (NRHS == 1) THEN
                  CALL DTRSV( 'L', 'N', 'N', NBJ, A(APOSDEB), LDAJ,     &
     &                 WCB(PPIV_PANEL), 1 )
                  IF (NUPDATE_PANEL.GT.0) THEN
                     CALL DGEMV('N',NUPDATE_PANEL, NBJ, ALPHA, A(APOS1),&
     &                    LDAJ, WCB(PPIV_PANEL), 1,                     &
     &                    ONE, WCB(PCB_PANEL), 1 )
                  ENDIF
               ELSE
                  CALL DTRSM('L','L','N','N',NBJ, NRHS, ONE,            &
     &                 A(APOSDEB), LDAJ, WCB(PPIV_PANEL),               &
     &                 LIELL)
                  IF (NUPDATE_PANEL.GT.0) THEN
                     CALL DGEMM('N', 'N', NUPDATE_PANEL, NRHS, NBJ,     &
     &                    ALPHA,                                        &
     &                    A(APOS1), LDAJ, WCB(PPIV_PANEL), LIELL, ONE,  &
     &             WCB(PCB_PANEL), LIELL)
                  ENDIF
               ENDIF
            ENDIF
            APOSDEB = APOSDEB+int(LDAJ,8)*int(NBJ,8)
            J=JFIN+1
            IF ( J .LE. NPIV ) GOTO 10
         ELSE
            IF (KEEP(50).NE.0) THEN
               IF ( NRHS == 1 ) THEN
                  CALL DTRSV( 'U', 'T', 'U', NPIV, A(APOS), NPIV,       &
     &                   WCB(PPIV_COURANT), 1 )
               ELSE
                  CALL DTRSM( 'L','U','T','U', NPIV, NRHS, ONE,         &
     &                   A(APOS), NPIV, WCB(PPIV_COURANT),              &
     &                   NPIV )
               ENDIF
            ELSE
               IF ( MTYPE .eq. 1 ) THEN
                  IF ( NRHS == 1)  THEN
                     CALL DTRSV( 'U', 'T', 'U', NPIV, A(APOS), LIELL,   &
     &                    WCB(PPIV_COURANT), 1 )
                  ELSE
                     CALL DTRSM( 'L','U','T','U', NPIV, NRHS, ONE,      &
     &                    A(APOS), LIELL, WCB(PPIV_COURANT),            &
     &                    NPIV )
                  ENDIF
               ELSE
                  IF (NRHS == 1) THEN
                     CALL DTRSV( 'L', 'N', 'N', NPIV, A(APOS), LIELL,   &
     &                    WCB(PPIV_COURANT), 1 )
                  ELSE
                     CALL DTRSM('L','L','N','N',NPIV, NRHS, ONE,        &
     &                    A(APOS), LIELL, WCB(PPIV_COURANT),            &
     &                    NPIV)
                  ENDIF
               END IF
            END IF
         END IF
      END IF
      NCB   = LIELL - NPIV
      IF ( MTYPE .EQ. 1 ) THEN
         IF ( KEEP(50) .eq. 0 ) THEN
            APOS1 = APOS  + int(NPIV,8) * int(LIELL,8)
         ELSE
            APOS1 = APOS + int(NPIV,8) * int(NPIV,8)
         END IF
         IF ( NSLAVES .EQ. 0 .OR. NPIV .eq. 0 ) THEN
            NUPDATE = NCB
         ELSE
            NUPDATE = NELIM
         END IF
      ELSE
         APOS1 = APOS + int(NPIV,8)
         NUPDATE = NCB
      END IF
      IF (KEEP(201).NE.1) THEN
         IF ( NPIV .NE. 0 .AND. NUPDATE.NE.0 ) THEN
            IF ( MTYPE .eq. 1 ) THEN
               IF ( NRHS == 1 ) THEN
                  CALL DGEMV('T', NPIV, NUPDATE, ALPHA, A(APOS1),       &
     &            NPIV,  WCB(PPIV_COURANT), 1, ONE,                     &
     &            WCB(PCB_COURANT), 1)
               ELSE
                  CALL DGEMM('T', 'N', NUPDATE, NRHS, NPIV, ALPHA,      &
     &            A(APOS1), NPIV, WCB(PPIV_COURANT), NPIV, ONE,         &
     &            WCB(PCB_COURANT), NCB)
               END IF
            ELSE
               IF ( NRHS == 1 ) THEN
                  CALL DGEMV('N',NUPDATE, NPIV, ALPHA, A(APOS1),        &
     &                 LIELL, WCB(PPIV_COURANT), 1,                     &
     &                 ONE, WCB(PCB_COURANT), 1 )
               ELSE
                  CALL DGEMM('N', 'N', NUPDATE, NRHS, NPIV, ALPHA,      &
     &                 A(APOS1), LIELL, WCB(PPIV_COURANT), NPIV, ONE,   &
     &                 WCB(PCB_COURANT), NCB)
               END IF
            END IF
         END IF
      END IF
      IF (BUILD_POSINRHSCOMP) THEN
         POSINRHSCOMP(STEP(INODE)) =  RHSCOMPFREEPOS
         RHSCOMPFREEPOS            = RHSCOMPFREEPOS + NPIV
      ENDIF
      IPOSINRHSCOMP =  POSINRHSCOMP(STEP(INODE))
      IF ( KEEP(50) .eq. 0 ) THEN
         DO K=1,NRHS
            IFR =  PPIV_COURANT + (K-1)*LD_WCBPIV
            RHSCOMP(IPOSINRHSCOMP:IPOSINRHSCOMP+NPIV-1, K) =            &
     &           WCB(IFR:IFR+NPIV-1)
         ENDDO
      ELSE
         IFR = PPIV_COURANT - 1
         IF (KEEP(201).EQ.1) THEN
            LDAJ = TempNROW
         ELSE
            LDAJ = NPIV
         ENDIF
         APOS1 = APOS
         JJ    = J1
         IF (KEEP(201).EQ.1) THEN
            NBK   = 0
         ENDIF
         DO
            IF(JJ .GT. J3) EXIT
            IFR = IFR + 1
            IF(IW(JJ+LIELL) .GT. 0) THEN
               DO K=1, NRHS
                  RHSCOMP(IPOSINRHSCOMP+JJ-J1 , K ) =                   &
     &                 WCB( IFR+(K-1)*LD_WCBPIV ) * A( APOS1 )
               END DO
            IF (KEEP(201).EQ.1) THEN
              NBK = NBK+1
              IF (NBK.EQ.PANEL_SIZE) THEN
                NBK = 0
                LDAJ = LDAJ - PANEL_SIZE
              ENDIF
            ENDIF
            APOS1 = APOS1 + int(LDAJ + 1,8)
            JJ = JJ+1
         ELSE
            IF (KEEP(201).EQ.1) THEN
              NBK = NBK+1
            ENDIF
            APOS2 = APOS1+int(LDAJ+1,8)
            IF (KEEP(201).EQ.1) THEN
              APOSOFF = APOS1+int(LDAJ,8)
            ELSE
              APOSOFF=APOS1+1_8
            ENDIF
               DO K=1, NRHS
                  POSWCB1 = IFR+(K-1)*LD_WCBPIV
                  POSWCB2 = POSWCB1+1
                  RHSCOMP(IPOSINRHSCOMP+JJ-J1,K) = WCB(POSWCB1)*A(APOS1)&
     &                 + WCB(POSWCB2)*A(APOSOFF)
                  RHSCOMP(IPOSINRHSCOMP+JJ-J1+1,K) =                    &
     &                 WCB(POSWCB1)*A(APOSOFF)                          &
     &                 + WCB(POSWCB2)*A(APOS2)
               END DO
               IF (KEEP(201).EQ.1) THEN
                  NBK = NBK+1
                  IF (NBK.GE.PANEL_SIZE) THEN
                     LDAJ = LDAJ - NBK
                     NBK = 0
                  ENDIF
               ENDIF
               APOS1 = APOS2 + int(LDAJ + 1,8)
               JJ = JJ+2
               IFR = IFR+1
            ENDIF
         ENDDO
      END IF
      IF (KEEP(201).NE.0) THEN
         CALL DAGMG_MUMPS_598(INODE,PTRFAC,KEEP(28),                         &
     &        A,LA,.TRUE.,IERR)
         IF(IERR.LT.0)THEN
            INFO(1)=IERR
            INFO(2)=0
            GOTO 260
         ENDIF
      END IF
      FPERE = DAD(STEP(INODE))
      IF ( FPERE .EQ. 0 ) THEN
         MYROOT = MYROOT - 1
         PLEFTWCB = PLEFTWCB - LIELL *NRHS
         IF ( MYROOT .EQ. 0 ) THEN
            NBFIN = NBFIN - 1
            IF (SLAVEF .GT. 1) THEN
               DUMMY (1) = 1
               CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID,             &
     &             COMM, RACINE_SOLVE, SLAVEF)
            ENDIF
         END IF
         GO TO 270
      ENDIF
      IF ( NUPDATE .NE. 0 .OR. NCB.eq.0 ) THEN
         IF (AGMG_MUMPS_275(STEP(FPERE),PROCNODE_STEPS,                      &
     &        SLAVEF) .EQ. MYID) THEN
            IF ( NCB .ne. 0 ) THEN
               PTRICB(STEP(INODE)) = NCB + 1
               DO 190 I = 1, NUPDATE
                  DO K=1, NRHS
                     RHS( IW(J3 + I), K ) = RHS( IW(J3 + I), K )        &
     &                    + WCB(PCB_COURANT + I-1 +(K-1)*LD_WCBCB)
                  ENDDO
  190          CONTINUE
               PTRICB(STEP( INODE )) = PTRICB(STEP( INODE )) - NUPDATE
               IF ( PTRICB(STEP(INODE)) == 1 ) THEN
                  NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
                  IF (NSTK_S(STEP(FPERE)) .EQ. 0) THEN
                        IPOOL( LEAF ) = FPERE
                     LEAF = LEAF + 1
                  ENDIF
               END IF
            ELSE
               PTRICB(STEP( INODE )) = -1
               NSTK_S(STEP(FPERE)) = NSTK_S(STEP(FPERE)) - 1
               IF (NSTK_S(STEP(FPERE)) .EQ. 0) THEN
                     IPOOL( LEAF ) = FPERE
                  LEAF = LEAF + 1
               ENDIF
            ENDIF
         ELSE
  210       CONTINUE
            CALL DAGMG_MUMPS_78( NRHS, INODE, FPERE, NCB, LD_WCBCB,          &
     &           NUPDATE,                                               &
     &           IW( J3 + 1 ), WCB( PCB_COURANT ),                      &
     &           AGMG_MUMPS_275(STEP(FPERE),                                 &
     &           PROCNODE_STEPS,SLAVEF),                                &
     &           ContVec,                                               &
     &           COMM, IERR )
            IF ( IERR .EQ. -1 ) THEN
               CALL DAGMG_MUMPS_303( .FALSE., FLAG,                          &
     &              BUFR, LBUFR, LBUFR_BYTES,                           &
     &              MYID, SLAVEF, COMM,                                 &
     &              N, NRHS, IPOOL, LPOOL, III, LEAF,                   &
     &              NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST, PTRFAC,      &
     &              IWCB, LIWCB,                                        &
     &              WCB, LWCB, POSWCB, PLEFTWCB, POSIWCB,               &
     &              PTRICB, INFO, KEEP,KEEP8, STEP,                     &
     &              PROCNODE_STEPS,                                     &
     &              RHS, LRHS                                           &
     &              )
               IF ( INFO( 1 )  .LT. 0 )  GOTO 270
               GOTO 210
            ELSE IF ( IERR .EQ. -2 ) THEN
               INFO( 1 ) = -17
               INFO( 2 ) = NUPDATE * KEEP( 35 ) +                       &
     &              ( NUPDATE + 3 ) * KEEP( 34 )
               GOTO 260
            ELSE IF ( IERR .EQ. -3 ) THEN
               INFO( 1 ) = -20
               INFO( 2 ) = NUPDATE * KEEP( 35 ) +                       &
     &              ( NUPDATE + 3 ) * KEEP( 34 )
               GOTO 260
            END IF
         ENDIF
      END IF
      IF ( NSLAVES .NE. 0 .AND. MTYPE .eq. 1                            &
     &     .and. NPIV .NE. 0 ) THEN
         DO ISLAVE = 1, NSLAVES
            PDEST = IW( PTRIST(STEP(INODE)) + 5 + ISLAVE +KEEP(IXSZ))
            CALL AGMG_MUMPS_49(                                              &
     &           KEEP,KEEP8, INODE, STEP, N, SLAVEF,                    &
     &           ISTEP_TO_INIV2, TAB_POS_IN_PERE,                       &
     &           ISLAVE, NCB - NELIM,                                   &
     &           NSLAVES,                                               &
     &           Effective_CB_Size, FirstIndex )
  222       CALL DAGMG_MUMPS_72( NRHS,                                       &
     &           INODE, FPERE,                                          &
     &           Effective_CB_Size, LD_WCBCB, LD_WCBPIV, NPIV,          &
     &           WCB( PCB_COURANT + NELIM + FirstIndex - 1 ),           &
     &           WCB( PPIV_COURANT ),                                   &
     &           PDEST, COMM, IERR )
            IF ( IERR .EQ. -1 ) THEN
               CALL DAGMG_MUMPS_303( .FALSE., FLAG,                          &
     &              BUFR, LBUFR, LBUFR_BYTES,                           &
     &              MYID, SLAVEF, COMM,                                 &
     &              N, NRHS, IPOOL, LPOOL, III, LEAF,                   &
     &              NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST,PTRFAC,       &
     &              IWCB, LIWCB,                                        &
     &              WCB, LWCB, POSWCB, PLEFTWCB, POSIWCB,               &
     &              PTRICB, INFO, KEEP,KEEP8, STEP,                     &
     &              PROCNODE_STEPS,                                     &
     &              RHS, LRHS                                           &
     &              )
               IF ( INFO( 1 )  .LT. 0 )  GOTO 270
               GOTO 222
            ELSE IF ( IERR .EQ. -2 ) THEN
               INFO( 1 ) = -17
               INFO( 2 ) = (NPIV+Effective_CB_Size)*NRHS*KEEP(35) +     &
     &              ( Effective_CB_Size + 4 ) * KEEP( 34 )
               GOTO 260
            ELSE IF ( IERR .EQ. -3 ) THEN
               INFO( 1 ) = -20
               INFO( 2 ) = (NPIV+Effective_CB_Size)*NRHS*KEEP(35) +     &
     &              ( Effective_CB_Size + 4 ) * KEEP( 34 )
               GOTO 260
            END IF
         END DO
      END IF
      PLEFTWCB = PLEFTWCB - LIELL*NRHS
  270 CONTINUE
      RETURN
  260 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_302
      RECURSIVE SUBROUTINE DAGMG_MUMPS_303( BLOQ, FLAG,                      &
     &           BUFR, LBUFR, LBUFR_BYTES,                              &
     &           MYID, SLAVEF, COMM,                                    &
     &           N, NRHS, IPOOL, LPOOL, III, LEAF,                      &
     &           NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST,PTRFAC,          &
     &           IWCB, LIWCB,                                           &
     &           WCB, LWCB, POSWCB,                                     &
     &           PLEFTWCB, POSIWCB,                                     &
     &           PTRICB, INFO, KEEP,KEEP8, STEP, PROCNODE_STEPS,        &
     &           RHS, LRHS                                              &
     &            )
      IMPLICIT NONE
      LOGICAL BLOQ
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER MYID, SLAVEF, COMM
      INTEGER N, NRHS, LPOOL, III, LEAF, NBFIN
      INTEGER LIWCB, LWCB, POSWCB, PLEFTWCB, POSIWCB
      INTEGER LIW
      INTEGER(8) :: LA
      INTEGER INFO( 40 ), KEEP( 500)
      INTEGER*8 KEEP8(150)
      INTEGER BUFR( LBUFR ), IPOOL(LPOOL)
      INTEGER NSTK_S( KEEP(28) )
      INTEGER IWCB( LIWCB )
      INTEGER IW( LIW )
      DOUBLE PRECISION WCB( LWCB ), A( LA )
      INTEGER PTRICB(KEEP(28)), PTRIST(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER STEP(N)
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER LRHS
      DOUBLE PRECISION RHS(LRHS, NRHS)
      LOGICAL FLAG
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER IERR, STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER MSGSOU, MSGTAG, MSGLEN
      FLAG = .FALSE.
      IF ( BLOQ ) THEN
        CALL AGMG_NOCALL('MPI_PROBE')
        FLAG = .TRUE.
      ELSE
        CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG, COMM,             &
     &                   FLAG, STATUS, IERR )
      END IF
      IF ( FLAG ) THEN
         MSGSOU = STATUS( AGMG_MPF_SOURCE )
         MSGTAG = STATUS( AGMG_MPF_TAG )
         CALL AGMG_NOCALL('MPI_GET_COUNT')
         IF ( MSGLEN .GT. LBUFR_BYTES ) THEN
           INFO(1) = -20
           INFO(2) = MSGLEN
           CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
         ELSE
           CALL AGMG_NOCALL('MPI_RECV')
           CALL DAGMG_MUMPS_323( BUFR, LBUFR, LBUFR_BYTES,                   &
     &          MSGTAG, MSGSOU, MYID, SLAVEF, COMM,                     &
     &          N, NRHS, IPOOL, LPOOL, III, LEAF,                       &
     &          NBFIN, NSTK_S, IW, LIW, A, LA, PTRIST, PTRFAC,          &
     &          IWCB, LIWCB,                                            &
     &          WCB, LWCB, POSWCB,                                      &
     &          PLEFTWCB, POSIWCB,                                      &
     &          PTRICB, INFO, KEEP,KEEP8, STEP,                         &
     &          PROCNODE_STEPS,                                         &
     &          RHS, LRHS                                               &
     &          )
         END IF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_303
      SUBROUTINE DAGMG_MUMPS_249(N, A, LA, IW, LIW, W, LWC,                  &
     &    RHS, LRHS, NRHS,                                              &
     &    RHSCOMP, LRHSCOMP, POSINRHSCOMP,                              &
     &    PTRICB, PTRACB, IWCB, LIWW, W2,                               &
     &    NE_STEPS, NA, LNA, STEP,                                      &
     &    FRERE, FILS, IPOOL, LPOOL, PTRIST, PTRFAC, MYLEAF, INFO,      &
     &    PROCNODE_STEPS,                                               &
     &    SLAVEF, COMM,MYID, BUFR, LBUFR, LBUFR_BYTES,                  &
     &    KEEP,KEEP8, RHS_ROOT, MTYPE,                                  &
     &    ISTEP_TO_INIV2, TAB_POS_IN_PERE, PANEL_POS, LPANEL_POS        &
     &    )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER MTYPE
      INTEGER(8) :: LA
      INTEGER N,LIW,LIWW,LWC,LPOOL,LNA
      INTEGER SLAVEF,MYLEAF,COMM,MYID
      INTEGER LPANEL_POS
      INTEGER KEEP( 500 )
      INTEGER*8 KEEP8(150)
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER NA(LNA),NE_STEPS(KEEP(28))
      INTEGER IPOOL(LPOOL)
      INTEGER PANEL_POS(LPANEL_POS)
      INTEGER INFO(40)
      INTEGER PTRIST(KEEP(28)),                                         &
     &        PTRICB(KEEP(28)),PTRACB(KEEP(28))
      INTEGER(8) :: PTRFAC(KEEP(28))
      INTEGER LRHS, NRHS
      DOUBLE PRECISION A(LA), RHS(LRHS,NRHS), W(LWC)
      DOUBLE PRECISION W2(KEEP(133))
      INTEGER IW(LIW),IWCB(LIWW)
      INTEGER STEP(N), FRERE(KEEP(28)),FILS(N)
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR(LBUFR)
      INTEGER ISTEP_TO_INIV2(KEEP(71)),                                 &
     &        TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER LRHSCOMP, POSINRHSCOMP(KEEP(28))
      DOUBLE PRECISION RHSCOMP(LRHSCOMP,NRHS)
      DOUBLE PRECISION RHS_ROOT( * )
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR
      LOGICAL FLAG
      INTEGER POSIWCB,POSWCB,K
      INTEGER(8) :: APOS, IST
      INTEGER APOSCB,NPIV
      INTEGER IPOS,IPOSCB,LIELL,NELIM,IFR,JJ,I
      INTEGER J1,J2,J,NCB,NBFINF
      INTEGER NBLEAF,INODE,NBROOT,NROOT,NBFILS
      INTEGER IN,IF,LONG,POOL_FIRST_POS,TMP
      INTEGER III,IIPOOL,MYLEAFE
      INTEGER NSLAVES
      DOUBLE PRECISION ALPHA,ONE,ZERO
      PARAMETER (ZERO=0.0D0, ONE = 1.0D0, ALPHA=-1.0D0)
      LOGICAL BLOQ,DEBUT
      INTEGER PROCDEST, DEST
      INTEGER SSII,POSII, POSINDICES, IPOSINRHSCOMP
      INTEGER DUMMY(1)
      INTEGER PLEFTW, LDA, PTWCB
      INTEGER Offset, EffectiveSize, ISLAVE, FirstIndex
      LOGICAL LTLEVEL2, IN_SUBTREE
      INTEGER TYPENODE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER TMPNODE
      LOGICAL BLOCK_SEQUENCE
      INTEGER TMP_NBPANELS, I_PIVRPTR, I_PIVR
      LOGICAL MUST_BE_PERMUTED
      LOGICAL SKIP
      LOGICAL DEJA_SEND( 0:SLAVEF-1 )
      INTEGER(8) :: APOSDEB, APOSTEMP, NBENTRIES_ALLPANELS
      INTEGER LDAJ, NBJ, LIWFAC,                                        &
     &        NBJLAST, NPIV_LAST, PANEL_SIZE,                           &
     &        PTWCB_PANEL, NCB_PANEL, TYPEF
      INTEGER BEG_PANEL
      LOGICAL TWOBYTWO
      INTEGER NPANELS, IPANEL
      LOGICAL AGMG_MUMPS_283, AGMG_MUMPS_170
      INTEGER AGMG_MUMPS_330
      EXTERNAL DGEMV, DTRSV, DTRSM, DGEMM,                              &
     &         AGMG_MUMPS_283, AGMG_MUMPS_330,                                    &
     &         AGMG_MUMPS_170
      PLEFTW = 1
      POSIWCB = LIWW
      POSWCB = LWC
      NROOT = 0
      NBLEAF = NA(1)
      NBROOT = NA(2)
      DO I = NBROOT, 1, -1
        INODE = NA(NBLEAF+I+2)
        IF (AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,                       &
     &      SLAVEF) .EQ. MYID) THEN
          NROOT = NROOT + 1
          IPOOL(NROOT) = INODE
        ENDIF
      END DO
      III = 1
      IIPOOL = NROOT + 1
      BLOCK_SEQUENCE = .FALSE.
      IF (MYLEAF .EQ. -1) THEN
        MYLEAF = 0
        DO I=1, NBLEAF
          INODE=NA(I+2)
          IF (AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,                     &
     &         SLAVEF) .EQ. MYID) THEN
            MYLEAF = MYLEAF + 1
          ENDIF
        ENDDO
      ENDIF
      MYLEAFE=MYLEAF
      NBFINF = SLAVEF
      IF (MYLEAFE .EQ. 0) THEN
        CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM, FEUILLE,     &
     &                  SLAVEF)
        NBFINF = NBFINF - 1
        IF (NBFINF .EQ. 0) THEN
          GOTO 340
        ENDIF
      ENDIF
   50 CONTINUE
      BLOQ = ( (  III .EQ. IIPOOL  )                                    &
     &     )
      CALL DAGMG_MUMPS_41( BLOQ, FLAG, BUFR, LBUFR,                          &
     &     LBUFR_BYTES, MYID, SLAVEF, COMM,                             &
     &     N, IWCB, LIWW, POSIWCB,                                      &
     &     W, LWC, POSWCB,                                              &
     &     IIPOOL, NBFINF, PTRICB, PTRACB, INFO,                        &
     &     IPOOL, LPOOL, PANEL_POS, LPANEL_POS,                         &
     &     STEP,  FRERE, FILS, PROCNODE_STEPS,                          &
     &     PLEFTW, KEEP,KEEP8,                                          &
     &     PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,                 &
     &     RHS, LRHS, NRHS, MTYPE,                                      &
     &     RHSCOMP, LRHSCOMP, POSINRHSCOMP                              &
     &     )
      IF ( INFO(1) .LT. 0 ) GOTO 340
      IF ( .NOT. FLAG ) THEN
        IF (III .NE. IIPOOL) THEN
          INODE = IPOOL(IIPOOL-1)
          IIPOOL = IIPOOL - 1
          GO TO 60
        ENDIF
      END IF
      IF ( NBFINF .eq. 0 ) GOTO 340
      GOTO 50
   60 CONTINUE
      IF ( INODE .EQ. KEEP( 38 ) .OR. INODE .EQ. KEEP( 20 ) ) THEN
         IPOS = PTRIST(STEP(INODE))+KEEP(IXSZ)
         LIELL = IW(IPOS+3)
         NPIV  = LIELL
         IPOS =  PTRIST(STEP(INODE)) + 5 + KEEP(IXSZ)
         IF ( MTYPE .EQ. 1 .AND. KEEP(50) .EQ. 0) THEN
            J1   = IPOS + LIELL + 1
            J2   = IPOS + LIELL + NPIV
         ELSE
            J1   = IPOS + 1
            J2   = IPOS + NPIV
         END IF
         IFR  = 0
         DO JJ = J1, J2
            J  = IW( JJ )
            IFR = IFR + 1
            DO K=1,NRHS
               RHS(J,K) = RHS_ROOT(IFR+NPIV*(K-1))
            END DO
         END DO
         IN = INODE
  270    IN = FILS(IN)
         IF (IN .GT. 0) GOTO 270
         IF (IN .EQ. 0) THEN
            MYLEAFE = MYLEAFE - 1
            IF (MYLEAFE .EQ. 0) THEN
               CALL DAGMG_MUMPS_242( DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM,      &
     &              FEUILLE, SLAVEF )
               NBFINF = NBFINF - 1
               IF (NBFINF .EQ. 0) GOTO 340
            ENDIF
            GOTO 50
         ENDIF
         IF   = -IN
         LONG = NPIV
         NBFILS = NE_STEPS(STEP(INODE))
         DEBUT = .TRUE.
         DO I = 0, SLAVEF - 1
            DEJA_SEND( I ) = .FALSE.
         END DO
         POOL_FIRST_POS=IIPOOL
         DO I = 1, NBFILS
            IF (AGMG_MUMPS_275(STEP(IF),PROCNODE_STEPS,SLAVEF)               &
     &           .EQ. MYID) THEN
                  IPOOL(IIPOOL) = IF
                  IIPOOL = IIPOOL + 1
            ELSE
               PROCDEST = AGMG_MUMPS_275(STEP(IF),PROCNODE_STEPS,            &
     &              SLAVEF)
               IF (.NOT. DEJA_SEND( PROCDEST ))  THEN
  600             CALL DAGMG_MUMPS_78( NRHS, IF, 0, 0,                       &
     &                 LONG, LONG, IW( J1 ),                            &
     &                 RHS_ROOT( 1 ), PROCDEST,                         &
     &                 NOEUD, COMM, IERR )
                  IF ( IERR .EQ. -1 ) THEN
                     CALL DAGMG_MUMPS_41(                                    &
     &                    .FALSE., FLAG,                                &
     &                    BUFR, LBUFR, LBUFR_BYTES,                     &
     &                    MYID, SLAVEF, COMM,                           &
     &                    N, IWCB, LIWW, POSIWCB,                       &
     &                    W, LWC, POSWCB,                               &
     &                    IIPOOL, NBFINF, PTRICB, PTRACB, INFO,         &
     &                    IPOOL, LPOOL, PANEL_POS, LPANEL_POS,          &
     &                    STEP, FRERE, FILS, PROCNODE_STEPS,            &
     &                    PLEFTW, KEEP,KEEP8,                           &
     &                    PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,  &
     &                    RHS, LRHS, NRHS, MTYPE,                       &
     &                    RHSCOMP, LRHSCOMP, POSINRHSCOMP               &
     &                    )
                     IF ( INFO( 1 ) .LT. 0 ) GOTO 340
                     GOTO 600
                  ELSE IF ( IERR .EQ. -2 ) THEN
                     INFO( 1 ) = -17
                     INFO( 2 ) = LONG * KEEP(35) +                      &
     &                    ( LONG + 2 ) * KEEP(34)
                     GOTO 330
                  ELSE IF ( IERR .EQ. -3 ) THEN
                     INFO( 1 ) = -20
                     INFO( 2 ) = LONG * KEEP(35) +                      &
     &                    ( LONG + 2 ) * KEEP(34)
                     GOTO 330
                  END IF
                  DEJA_SEND( PROCDEST ) = .TRUE.
               END IF
               IF ( IERR .NE. 0 ) CALL AGMG_MUMPS_ABORT()
            ENDIF
            IF = FRERE(STEP(IF))
         ENDDO
            IF (IIPOOL.NE.POOL_FIRST_POS) THEN
               DO I=1,(IIPOOL-POOL_FIRST_POS)/2
                  TMP=IPOOL(POOL_FIRST_POS+I-1)
                  IPOOL(POOL_FIRST_POS+I-1)=IPOOL(IIPOOL-I)
                  IPOOL(IIPOOL-I)=TMP
               ENDDO
            ENDIF
         GOTO 50
      END IF
      IN_SUBTREE = AGMG_MUMPS_170(                                           &
     &          STEP (INODE),                                           &
     &          PROCNODE_STEPS, SLAVEF )
      TYPENODE = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,                  &
     &         SLAVEF)
      LTLEVEL2= (                                                       &
     &   (TYPENODE .eq.2 ) .AND.                                        &
     &   (MTYPE.NE.1)   )
      NPIV = IW(PTRIST(STEP(INODE))+2+KEEP(IXSZ)+1)
      IF ((NPIV.NE.0).AND.(LTLEVEL2)) THEN
            IPOS  = PTRIST(STEP(INODE)) + 2 + KEEP(IXSZ)
            LIELL = IW(IPOS-2)+IW(IPOS+1)
            NELIM = IW(IPOS-1)
            IPOS  = IPOS + 1
            NPIV  = IW(IPOS)
            NCB   = LIELL - NPIV - NELIM
            IPOS  = IPOS + 2
            NSLAVES = IW( IPOS )
            Offset = 0
            IPOS = IPOS + NSLAVES
            IW(PTRIST(STEP(INODE))+XXS)= C_FINI+NSLAVES
           IF ( POSIWCB - 2 .LT. 0 .or.                                 &
     &          POSWCB - NCB*NRHS .LT. PLEFTW - 1 ) THEN
             CALL DAGMG_MUMPS_95( NRHS, N, KEEP(28), IWCB, LIWW, W, LWC,     &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
             IF ( POSWCB - NCB*NRHS .LT. PLEFTW - 1 ) THEN
               INFO( 1 ) = -11
               INFO( 2 ) = NCB * NRHS - POSWCB - PLEFTW + 1
               GOTO 330
             END IF
             IF ( POSIWCB - 2 .LT. 0 ) THEN
               INFO( 1 ) = -14
               INFO( 2 ) = 2 - POSIWCB
               GO TO 330
             END IF
           END IF
           POSIWCB = POSIWCB - 2
           POSWCB  = POSWCB - NCB*NRHS
           PTRICB(STEP( INODE )) = POSIWCB + 1
           PTRACB(STEP( INODE )) = POSWCB  + 1
           IWCB( PTRICB(STEP( INODE ))     ) = NCB
           IWCB( PTRICB(STEP( INODE )) + 1 ) = 1
           IF ( MTYPE.EQ.1 .AND. KEEP(50).EQ.0 ) THEN
              POSINDICES = IPOS + LIELL + 1
           ELSE
              POSINDICES = IPOS + 1
           END IF
           IF ( NCB.EQ.0 ) THEN
             write(6,*) ' Internal Error type 2 node with no CB '
             CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF ( MTYPE .EQ. 1 .AND. KEEP(50).EQ.0 ) THEN
               J1 = IPOS + LIELL + NPIV + NELIM +1
               J2 = IPOS + 2 * LIELL
           ELSE
               J1 = IPOS + NPIV + NELIM +1
               J2 = IPOS + LIELL
           END IF
           IFR = PTRACB(STEP( INODE )) - 1
           DO JJ = J1, J2
               J = IW(JJ)
               IFR = IFR + 1
               DO K=1, NRHS
                 W(IFR+(K-1)*NCB) = RHS(J,K)
               ENDDO
           ENDDO
           DO ISLAVE = 1, NSLAVES
              CALL AGMG_MUMPS_49(                                            &
     &                KEEP,KEEP8, INODE, STEP, N, SLAVEF,               &
     &                ISTEP_TO_INIV2, TAB_POS_IN_PERE,                  &
     &                ISLAVE, NCB,                                      &
     &                NSLAVES,                                          &
     &                EffectiveSize,                                    &
     &                FirstIndex )
  500        DEST = IW( PTRIST(STEP(INODE))+5+ISLAVE+KEEP(IXSZ))
             CALL DAGMG_MUMPS_63(NRHS, INODE,                                &
     &             W(Offset+PTRACB(STEP(INODE))), EffectiveSize,        &
     &             NCB, DEST,                                           &
     &             BACKSLV_MASTER2SLAVE,                                &
     &             COMM, IERR )
              IF ( IERR .EQ. -1 ) THEN
                 CALL DAGMG_MUMPS_41(                                        &
     &                .FALSE., FLAG,                                    &
     &                BUFR, LBUFR, LBUFR_BYTES,                         &
     &                MYID, SLAVEF, COMM,                               &
     &                N, IWCB, LIWW, POSIWCB,                           &
     &                W, LWC, POSWCB,                                   &
     &                IIPOOL, NBFINF, PTRICB, PTRACB, INFO,             &
     &                IPOOL, LPOOL, PANEL_POS, LPANEL_POS,              &
     &                STEP, FRERE, FILS,                                &
     &                PROCNODE_STEPS, PLEFTW, KEEP,KEEP8,               &
     &                PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,      &
     &                RHS, LRHS, NRHS, MTYPE,                           &
     &                RHSCOMP, LRHSCOMP, POSINRHSCOMP                   &
     &                )
                IF ( INFO( 1 ) .LT. 0 ) GOTO 340
                GOTO 500
              ELSE IF ( IERR .EQ. -2 ) THEN
                INFO( 1 ) = -17
                INFO( 2 ) = EffectiveSize * KEEP(35) +                  &
     &                            2 * KEEP(34)
                GOTO 330
              ELSE IF ( IERR .EQ. -3 ) THEN
                INFO( 1 ) = -20
                INFO( 2 ) = EffectiveSize * KEEP(35) +                  &
     &                            2 * KEEP(34)
                GOTO 330
              END IF
              Offset = Offset + EffectiveSize
           END DO
           IWCB( PTRICB(STEP( INODE )) + 1 ) = 0
           CALL DAGMG_MUMPS_151(NRHS,N, KEEP(28), IWCB, LIWW, W, LWC,        &
     &             POSWCB,POSIWCB,PTRICB,PTRACB)
           GOTO 50
      ENDIF
      IPOS = PTRIST(STEP(INODE)) + 2 + KEEP(IXSZ)
      LIELL = IW(IPOS-2)+IW(IPOS+1)
      NELIM = IW(IPOS-1)
      IPOS = IPOS + 1
      NPIV = IW(IPOS)
      IPOS = IPOS + 1
      IF (KEEP(201).NE.0) THEN
         CALL DAGMG_MUMPS_643(                                               &
     &        INODE,PTRFAC,KEEP,A,LA,STEP,                              &
     &        KEEP8,N,MUST_BE_PERMUTED,IERR)
         IF(IERR.LT.0)THEN
            INFO(1)=IERR
            INFO(2)=0
            GOTO 330
         ENDIF
      ENDIF
      APOS = PTRFAC(IW(IPOS))
      NSLAVES = IW( PTRIST(STEP(INODE)) + 5 + KEEP(IXSZ) )
      IPOS = IPOS + 1 + NSLAVES
      IF (KEEP(201).EQ.1) THEN
           LIWFAC =  IW(PTRIST(STEP(INODE))+XXI)
           IF (MTYPE.NE.1) THEN
            TYPEF = TYPEF_L
           ELSE
            TYPEF = TYPEF_U
           ENDIF
           PANEL_SIZE =  DAGMG_MUMPS_690( LIELL )
           IF (KEEP(50).NE.1) THEN
             CALL DAGMG_MUMPS_755(                                           &
     &                   IW(IPOS+1+2*LIELL),                            &
     &                   MUST_BE_PERMUTED )
           ENDIF
      ENDIF
      LONG = 0
      IF ( MTYPE .EQ. 1 .OR. KEEP(50) .NE. 0 ) THEN
        J1 = IPOS + 1
        J2 = IPOS + NPIV
      ELSE
        J1 = IPOS + LIELL + 1
        J2 = IPOS + NPIV + LIELL
      END IF
      IF (IN_SUBTREE) THEN
        PTWCB = PLEFTW
        IF ( POSWCB .LT. LIELL*NRHS ) THEN
          CALL DAGMG_MUMPS_95( NRHS, N, KEEP(28), IWCB, LIWW, W, LWC,        &
     &                 POSWCB, POSIWCB, PTRICB, PTRACB)
          IF ( POSWCB .LT. LIELL*NRHS ) THEN
            INFO(1) = -11
            INFO(2) = LIELL*NRHS - POSWCB
            GOTO 330
          END IF
        END IF
      ELSE
        IF ( POSIWCB - 2 .LT. 0 .or.                                    &
     &     POSWCB - LIELL*NRHS .LT. PLEFTW - 1 ) THEN
          CALL DAGMG_MUMPS_95( NRHS, N, KEEP(28), IWCB, LIWW, W, LWC,        &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
          IF ( POSWCB - LIELL*NRHS .LT. PLEFTW - 1 ) THEN
            INFO( 1 ) = -11
            INFO( 2 ) = LIELL * NRHS - POSWCB - PLEFTW + 1
            GOTO 330
          END IF
          IF ( POSIWCB - 2 .LT. 0 ) THEN
            INFO( 1 ) = -14
            INFO( 2 ) = 2 - POSIWCB
            GO TO 330
          END IF
        END IF
        POSIWCB = POSIWCB - 2
        POSWCB  = POSWCB - LIELL*NRHS
        PTRICB(STEP( INODE )) = POSIWCB + 1
        PTRACB(STEP( INODE )) = POSWCB  + 1
        IWCB( PTRICB(STEP( INODE ))     ) = LIELL
        IWCB( PTRICB(STEP( INODE )) + 1 ) = 1
        IF ( MTYPE.EQ.1 .AND. KEEP(50).EQ.0 ) THEN
           POSINDICES = IPOS + LIELL + 1
        ELSE
           POSINDICES = IPOS + 1
        END IF
        PTWCB = PTRACB(STEP( INODE ))
      ENDIF
      IPOSINRHSCOMP =  POSINRHSCOMP(STEP(INODE))
      DO K=1, NRHS
        DO JJ = J1, J2
          W(PTWCB+JJ-J1+(K-1)*LIELL) = RHSCOMP(IPOSINRHSCOMP+JJ-J1,K)
        ENDDO
      END DO
      IFR   = PTWCB + NPIV - 1
      IF ( LIELL .GT. NPIV ) THEN
        IF ( MTYPE .EQ. 1 .AND. KEEP(50).EQ.0 ) THEN
          J1 = IPOS + LIELL + NPIV + 1
          J2 = IPOS + 2 * LIELL
        ELSE
          J1 = IPOS + NPIV + 1
          J2 = IPOS + LIELL
        END IF
        DO JJ = J1, J2
          J = IW(JJ)
          IFR = IFR + 1
          DO K=1, NRHS
            W(IFR+(K-1)*LIELL) = RHS(J,K)
          ENDDO
        ENDDO
        NCB = LIELL - NPIV
        IF (NPIV .EQ. 0) GOTO 160
      ENDIF
      IF (KEEP(201).EQ.1) THEN
       J = NPIV / PANEL_SIZE
       TWOBYTWO = KEEP(50).EQ.2 .AND.                                   &
     & ((TYPENODE.EQ.1.AND.KEEP(103).GT.0) .OR.                         &
     &  (TYPENODE.EQ.2.AND.KEEP(105).GT.0))
       IF (TWOBYTWO) THEN
         CALL DAGMG_MUMPS_641(PANEL_SIZE, PANEL_POS, LPANEL_POS,             &
     &        IW(IPOS+1+LIELL), NPIV, NPANELS, LIELL,                   &
     &        NBENTRIES_ALLPANELS)
       ELSE
         IF (NPIV.EQ.J*PANEL_SIZE) THEN
           NPIV_LAST = NPIV
           NBJLAST   = PANEL_SIZE
           NPANELS   = J
         ELSE
           NPIV_LAST = (J+1)* PANEL_SIZE
           NBJLAST   = NPIV-J*PANEL_SIZE
           NPANELS   = J+1
         ENDIF
            NBENTRIES_ALLPANELS =                                       &
     &  int(LIELL,8) * int(NPIV,8)                                      &
     &  - int( ( J * ( J - 1 ) ) / 2,8 )                                &
     &    * int(PANEL_SIZE,8) * int(PANEL_SIZE,8)                       &
     &  - int(J,8)                                                      &
     &    * int(MOD(NPIV, PANEL_SIZE),8)                                &
     &    * int(PANEL_SIZE,8)
         JJ=NPIV_LAST
       ENDIF
       APOSDEB = APOS + NBENTRIES_ALLPANELS
       DO IPANEL = NPANELS, 1, -1
            IF (TWOBYTWO) THEN
              NBJ = PANEL_POS(IPANEL+1)-PANEL_POS(IPANEL)
              BEG_PANEL = PANEL_POS(IPANEL)
            ELSE
              IF (JJ.EQ.NPIV_LAST) THEN
                NBJ = NBJLAST
              ELSE
                NBJ = PANEL_SIZE
              ENDIF
              BEG_PANEL = JJ- PANEL_SIZE+1
            ENDIF
            LDAJ    = LIELL-BEG_PANEL+1
            APOSDEB = APOSDEB - int(NBJ,8)*int(LDAJ,8)
            PTWCB_PANEL = PTWCB + BEG_PANEL - 1
            NCB_PANEL   = LDAJ - NBJ
            IF (KEEP(50).NE.1 .AND. MUST_BE_PERMUTED) THEN
              CALL DAGMG_MUMPS_667(TYPEF, TMP_NBPANELS,                      &
     &        I_PIVRPTR, I_PIVR, IPOS + 1 + 2 * LIELL, IW, LIW)
              IF (NPIV.EQ.(IW(I_PIVRPTR)-1)) THEN
                MUST_BE_PERMUTED=.FALSE.
              ELSE
               CALL DAGMG_MUMPS_698(                                         &
     &         IW(I_PIVR + IW(I_PIVRPTR+IPANEL-1)-IW(I_PIVRPTR)),       &
     &         NPIV-IW(I_PIVRPTR+IPANEL-1)+1,                           &
     &         IW(I_PIVRPTR+IPANEL-1)-1,                                &
     &         A(APOSDEB),                                              &
     &         LDAJ, NBJ, BEG_PANEL-1)
              ENDIF
            ENDIF
            IF ( NRHS == 1 ) THEN
              IF (NCB_PANEL.NE.0) THEN
                CALL DGEMV( 'T', NCB_PANEL, NBJ, ALPHA,                 &
     &                A( APOSDEB + int(NBJ,8) ), LDAJ,                  &
     &                W( NBJ + PTWCB_PANEL ),                           &
     &                1, ONE,                                           &
     &                W(PTWCB_PANEL), 1 )
              ENDIF
              IF (MTYPE.NE.1) THEN
               CALL DTRSV('L','T','U', NBJ, A(APOSDEB), LDAJ,           &
     &              W(PTWCB_PANEL), 1)
              ELSE
               CALL DTRSV('L','T','N', NBJ, A(APOSDEB), LDAJ,           &
     &              W(PTWCB_PANEL), 1)
              ENDIF
            ELSE
              IF (NCB_PANEL.NE.0) THEN
                 CALL DGEMM( 'T', 'N', NBJ, NRHS, NCB_PANEL, ALPHA,     &
     &              A(APOSDEB +int(NBJ,8)), LDAJ,                       &
     &              W(NBJ+PTWCB_PANEL),LIELL,                           &
     &              ONE, W(PTWCB_PANEL),LIELL)
              ENDIF
              IF (MTYPE.NE.1) THEN
               CALL DTRSM('L','L','T','U',NBJ, NRHS, ONE,               &
     &           A(APOSDEB),                                            &
     &           LDAJ, W(PTWCB_PANEL), LIELL)
              ELSE
               CALL DTRSM('L','L','T','N',NBJ, NRHS, ONE,               &
     &           A(APOSDEB),                                            &
     &           LDAJ, W(PTWCB_PANEL), LIELL)
              ENDIF
            ENDIF
            IF (.NOT. TWOBYTWO) JJ=BEG_PANEL-1
       ENDDO
      ENDIF
      IF (KEEP(201).EQ.0.OR.KEEP(201).EQ.2)THEN
       IF ( LIELL .GT. NPIV ) THEN
        IF ( MTYPE .eq. 1 ) THEN
          IST = APOS + int(NPIV,8)
          IF (NRHS == 1) THEN
            CALL DGEMV( 'T', NCB, NPIV, ALPHA, A(IST), LIELL,           &
     &              W(NPIV + PTWCB), 1,                                 &
     &              ONE,                                                &
     &              W(PTWCB), 1 )
          ELSE
            CALL DGEMM('T','N', NPIV, NRHS, NCB, ALPHA, A(IST), LIELL,  &
     &              W(NPIV+PTWCB), LIELL, ONE,                          &
     &              W(PTWCB), LIELL)
          ENDIF
        ELSE
          IF ( KEEP(50) .eq. 0 ) THEN
            IST = APOS + int(NPIV,8) * int(LIELL,8)
          ELSE
            IST = APOS + int(NPIV,8) * int(NPIV,8)
          END IF
            IF ( NRHS == 1 ) THEN
              CALL DGEMV( 'N', NPIV, NCB, ALPHA, A( IST ), NPIV,        &
     &                W( NPIV + PTWCB ),                                &
     &                1, ONE,                                           &
     &                W(PTWCB), 1 )
            ELSE
                CALL DGEMM( 'N', 'N', NPIV, NRHS, NCB, ALPHA,           &
     &                A(IST), NPIV, W(NPIV+PTWCB),LIELL,                &
     &                ONE, W(PTWCB),LIELL)
            END IF
        END IF
       ENDIF
       IF ( MTYPE .eq. 1 ) THEN
        IF ( NRHS == 1 ) THEN
          CALL DTRSV('L', 'T', 'N', NPIV, A(APOS), LIELL,               &
     &              W(PTWCB), 1)
        ELSE
          CALL DTRSM('L','L','T','N', NPIV, NRHS, ONE, A(APOS),         &
     &              LIELL, W(PTWCB), LIELL)
        ENDIF
       ELSE
        IF ( KEEP(50) .EQ. 0 ) THEN
          IF ( NRHS == 1 ) THEN
            CALL DTRSV('U','N','U', NPIV, A(APOS), LIELL,               &
     &              W(PTWCB), 1)
          ELSE
            CALL DTRSM('L','U','N','U', NPIV, NRHS, ONE, A(APOS),       &
     &                 LIELL,W(PTWCB),LIELL)
          END IF
        ELSE
          IF ( NRHS == 1 ) THEN
            CALL DTRSV('U','N','U', NPIV, A(APOS), NPIV,                &
     &              W(PTWCB), 1)
          ELSE
            CALL DTRSM('L','U','N','U',NPIV, NRHS, ONE, A(APOS),        &
     &           NPIV, W(PTWCB), LIELL)
          END IF
        END IF
       END IF
      ENDIF
      IF ( MTYPE .EQ. 1 .AND. KEEP(50).EQ.0) THEN
        J1 = IPOS + LIELL + 1
      ELSE
        J1 = IPOS + 1
      END IF
      DO 150 I = 1, NPIV
        JJ = IW(J1 + I - 1)
        DO K=1, NRHS
          RHS(JJ, K) = W(PTWCB+I-1+(K-1)*LIELL)
        ENDDO
  150 END DO
  160 CONTINUE
      IF (KEEP(201).NE.0) THEN
         CALL DAGMG_MUMPS_598(INODE,PTRFAC,KEEP(28),                         &
     &        A,LA,.TRUE.,IERR)
         IF(IERR.LT.0)THEN
            INFO(1)=IERR
            INFO(2)=0
            GOTO 330
         ENDIF
      ENDIF
      IN = INODE
  170 IN = FILS(IN)
      IF (IN .GT. 0) GOTO 170
      IF (IN .EQ. 0) THEN
        MYLEAFE = MYLEAFE - 1
        IF (MYLEAFE .EQ. 0) THEN
          CALL DAGMG_MUMPS_242( DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM,           &
     &                     FEUILLE, SLAVEF )
          NBFINF = NBFINF - 1
          IF (NBFINF .EQ. 0) GOTO 340
        ENDIF
        GOTO 50
      ENDIF
      IF = -IN
      NBFILS = NE_STEPS(STEP(INODE))
      IF (IN_SUBTREE) THEN
         DO I = 1, NBFILS
               IPOOL((IIPOOL-I+1)+NBFILS-I) = IF
               IIPOOL = IIPOOL + 1
            IF = FRERE(STEP(IF))
         ENDDO
      ELSE
        DEBUT = .TRUE.
        DO I = 0, SLAVEF - 1
          DEJA_SEND( I ) = .FALSE.
        END DO
        POOL_FIRST_POS=IIPOOL
        DO 190 I = 1, NBFILS
          IF (AGMG_MUMPS_275(STEP(IF),PROCNODE_STEPS,                        &
     &      SLAVEF) .EQ. MYID) THEN
                IPOOL(IIPOOL) = IF
                IIPOOL = IIPOOL + 1
            IF = FRERE(STEP(IF))
          ELSE
            PROCDEST = AGMG_MUMPS_275(STEP(IF),PROCNODE_STEPS,SLAVEF)
            IF (.not. DEJA_SEND( PROCDEST ))  THEN
  400         CONTINUE
              CALL DAGMG_MUMPS_78( NRHS, IF, 0, 0, LIELL,                    &
     &         LIELL,                                                   &
     &         IW( POSINDICES ),                                        &
     &         W   ( PTRACB(STEP( INODE ))), PROCDEST,                  &
     &         NOEUD, COMM, IERR )
              IF ( IERR .EQ. -1 ) THEN
                CALL DAGMG_MUMPS_41(                                         &
     &          .FALSE., FLAG,                                          &
     &          BUFR, LBUFR, LBUFR_BYTES,                               &
     &          MYID, SLAVEF, COMM,                                     &
     &          N, IWCB, LIWW, POSIWCB,                                 &
     &          W, LWC, POSWCB,                                         &
     &          IIPOOL, NBFINF, PTRICB, PTRACB, INFO,                   &
     &          IPOOL, LPOOL, PANEL_POS, LPANEL_POS,                    &
     &          STEP, FRERE, FILS, PROCNODE_STEPS,                      &
     &          PLEFTW, KEEP,KEEP8,                                     &
     &          PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,            &
     &          RHS, LRHS, NRHS, MTYPE,                                 &
     &          RHSCOMP, LRHSCOMP, POSINRHSCOMP                         &
     &                )
                IF ( INFO( 1 ) .LT. 0 ) GOTO 340
                GOTO 400
              ELSE IF ( IERR .EQ. -2 ) THEN
                INFO( 1 ) = -17
                INFO( 2 ) = NPIV * KEEP(35) + 2 * KEEP(34)
                GOTO 330
              ELSE IF ( IERR .EQ. -3 ) THEN
                INFO( 1 ) = -20
                INFO( 2 ) = NPIV * KEEP(35) + 2 * KEEP(34)
                GOTO 330
              END IF
              DEJA_SEND( PROCDEST ) = .TRUE.
            END IF
            IF = FRERE(STEP(IF))
          ENDIF
  190   CONTINUE
           DO I=1,(IIPOOL-POOL_FIRST_POS)/2
              TMP=IPOOL(POOL_FIRST_POS+I-1)
              IPOOL(POOL_FIRST_POS+I-1)=IPOOL(IIPOOL-I)
              IPOOL(IIPOOL-I)=TMP
           ENDDO
        IWCB(PTRICB(STEP(INODE))+1) = IWCB(PTRICB(STEP(INODE))+1)-1
        CALL DAGMG_MUMPS_151(NRHS,N, KEEP(28), IWCB, LIWW,                   &
     &     W, LWC,                                                      &
     &     POSWCB,POSIWCB,PTRICB,PTRACB)
      ENDIF
      GOTO 50
  330 CONTINUE
      CALL DAGMG_MUMPS_242(DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM, TERREUR,       &
     & SLAVEF)
  340 CONTINUE
      CALL DAGMG_MUMPS_150( MYID,COMM,BUFR,                                  &
     &                            LBUFR,LBUFR_BYTES )
      RETURN
      END SUBROUTINE DAGMG_MUMPS_249
      RECURSIVE SUBROUTINE DAGMG_MUMPS_41(                                   &
     &     BLOQ, FLAG,                                                  &
     &     BUFR, LBUFR, LBUFR_BYTES,                                    &
     &     MYID, SLAVEF, COMM,                                          &
     &     N, IWCB, LIWW, POSIWCB,                                      &
     &     W, LWC, POSWCB,                                              &
     &     IIPOOL, NBFINF, PTRICB, PTRACB, INFO,                        &
     &     IPOOL, LPOOL, PANEL_POS, LPANEL_POS,                         &
     &     STEP, FRERE, FILS, PROCNODE_STEPS,                           &
     &     PLEFTW, KEEP,KEEP8,                                          &
     &     PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE, RHS,            &
     &     LRHS, NRHS, MTYPE,                                           &
     &     RHSCOMP, LRHSCOMP, POSINRHSCOMP                              &
     &     )
      IMPLICIT NONE
      LOGICAL BLOQ, FLAG
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER MYID, SLAVEF, COMM
      INTEGER N, LIWW
      INTEGER IWCB( LIWW )
      INTEGER LWC
      DOUBLE PRECISION W( LWC )
      INTEGER POSIWCB, POSWCB
      INTEGER IIPOOL, LPOOL
      INTEGER IPOOL( LPOOL )
      INTEGER LPANEL_POS
      INTEGER PANEL_POS( LPANEL_POS )
      INTEGER NBFINF, INFO(40)
      INTEGER PLEFTW, KEEP( 500)
      INTEGER*8 KEEP8(150)
      INTEGER PROCNODE_STEPS( KEEP(28) ), FRERE( KEEP(28) )
      INTEGER PTRICB(KEEP(28)), PTRACB(KEEP(28)), STEP( N ), FILS( N )
      INTEGER LIW
      INTEGER(8) :: LA
      INTEGER PTRIST(KEEP(28)), IW( LIW )
      INTEGER (8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION A( LA ), W2( KEEP(133) )
      INTEGER LRHS, NRHS
      DOUBLE PRECISION RHS(LRHS, NRHS)
      INTEGER MYLEAFE, MTYPE
      INTEGER LRHSCOMP, POSINRHSCOMP(KEEP(28))
      DOUBLE PRECISION RHSCOMP(LRHSCOMP,NRHS)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER MSGSOU, MSGTAG, MSGLEN
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE ), IERR
      FLAG = .FALSE.
      IF ( BLOQ ) THEN
        CALL AGMG_NOCALL('MPI_PROBE')
        FLAG = .TRUE.
      ELSE
        CALL AGMG_MPF_IPROBE( AGMG_MPF_ANY_SOURCE, AGMG_MPF_ANY_TAG, COMM,             &
     &                   FLAG, STATUS, IERR )
      END IF
      IF (FLAG) THEN
         MSGSOU=STATUS(AGMG_MPF_SOURCE)
         MSGTAG=STATUS(AGMG_MPF_TAG)
         CALL AGMG_NOCALL('MPI_GET_COUNT')
         IF ( MSGLEN .GT. LBUFR_BYTES ) THEN
           INFO(1) = -20
           INFO(2) = MSGLEN
           CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
         ELSE
           CALL AGMG_NOCALL('MPI_RECV')
           CALL DAGMG_MUMPS_42( MSGTAG, MSGSOU,                              &
     &                BUFR, LBUFR, LBUFR_BYTES,                         &
     &                MYID, SLAVEF, COMM,                               &
     &                N, IWCB, LIWW, POSIWCB,                           &
     &                W, LWC, POSWCB,                                   &
     &                IIPOOL, NBFINF, PTRICB, PTRACB, INFO,             &
     &                IPOOL, LPOOL, PANEL_POS, LPANEL_POS, STEP,        &
     &                FRERE, FILS, PROCNODE_STEPS, PLEFTW,              &
     &                KEEP,KEEP8,                                       &
     &                PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,      &
     &                RHS, LRHS, NRHS, MTYPE,                           &
     &                RHSCOMP, LRHSCOMP, POSINRHSCOMP                   &
     &          )
         END IF
      END IF
      RETURN
      END SUBROUTINE DAGMG_MUMPS_41
      RECURSIVE SUBROUTINE DAGMG_MUMPS_42(                                   &
     &                MSGTAG, MSGSOU,                                   &
     &                BUFR, LBUFR, LBUFR_BYTES,                         &
     &                MYID, SLAVEF, COMM,                               &
     &                N, IWCB, LIWW, POSIWCB,                           &
     &                W, LWC, POSWCB,                                   &
     &                IIPOOL, NBFINF, PTRICB, PTRACB, INFO,             &
     &                IPOOL, LPOOL, PANEL_POS, LPANEL_POS, STEP,        &
     &                FRERE, FILS, PROCNODE_STEPS, PLEFTW, KEEP,KEEP8,  &
     &                PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,      &
     &                RHS, LRHS, NRHS, MTYPE,                           &
     &                RHSCOMP, LRHSCOMP, POSINRHSCOMP                   &
     &           )
      USE DAGMG_MUMPS_OOC
      USE DAGMG_MUMPS_COMM_BUFFER
      IMPLICIT NONE
      INTEGER MSGTAG, MSGSOU
      INTEGER LBUFR, LBUFR_BYTES
      INTEGER BUFR( LBUFR )
      INTEGER MYID, SLAVEF, COMM
      INTEGER N, LIWW
      INTEGER IWCB( LIWW )
      INTEGER LWC
      DOUBLE PRECISION W( LWC )
      INTEGER POSIWCB, POSWCB
      INTEGER IIPOOL, LPOOL, LPANEL_POS
      INTEGER IPOOL( LPOOL )
      INTEGER PANEL_POS( LPANEL_POS )
      INTEGER NBFINF, INFO(40)
      INTEGER PLEFTW, KEEP( 500)
      INTEGER*8 KEEP8(150)
      INTEGER PTRICB(KEEP(28)), PTRACB(KEEP(28)), STEP( N ), FILS( N )
      INTEGER FRERE(KEEP(28))
      INTEGER PROCNODE_STEPS(KEEP(28))
      INTEGER LIW
      INTEGER(8) :: LA
      INTEGER IW( LIW ), PTRIST( KEEP(28) )
      INTEGER(8) :: PTRFAC(KEEP(28))
      DOUBLE PRECISION A( LA ), W2( KEEP(133) )
      INTEGER LRHS, NRHS
      DOUBLE PRECISION  RHS(LRHS, NRHS)
      INTEGER MYLEAFE, MTYPE
      INTEGER LRHSCOMP, POSINRHSCOMP(KEEP(28))
      DOUBLE PRECISION RHSCOMP(LRHSCOMP,NRHS)
      INTEGER TMP_NBPANELS, I_PIVRPTR, I_PIVR
      LOGICAL MUST_BE_PERMUTED
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER ARROWHEAD, ARR_INT, ARR_REAL, ELT_INT, ELT_REAL
      PARAMETER ( ARROWHEAD = 20,                                       &
     &            ARR_INT = 29,                                         &
     &            ARR_REAL = 30,                                        &
     &            ELT_INT = 31,                                         &
     &            ELT_REAL = 32 )
      INTEGER COLLECT_NZ, COLLECT_IRN, COLLECT_JCN
      PARAMETER( COLLECT_NZ  = 35,                                      &
     &           COLLECT_IRN = 36,                                      &
     &           COLLECT_JCN = 37 )
      INTEGER RACINE,                                                   &
     &        NOEUD,                                                    &
     &        TERREUR,                                                  &
     &        MAITRE_DESC_BANDE,                                        &
     &        MAITRE2,                                                  &
     &        BLOC_FACTO,                                               &
     &        CONTRIB_TYPE2,                                            &
     &        MAPLIG,                                                   &
     &        FACTOR
      PARAMETER ( RACINE            = 2,                                &
     &            NOEUD             = 3,                                &
     &            MAITRE_DESC_BANDE = 4,                                &
     &            MAITRE2           = 5,                                &
     &            BLOC_FACTO        = 6,                                &
     &            CONTRIB_TYPE2     = 7,                                &
     &            MAPLIG            = 8,                                &
     &            FACTOR            = 9,                                &
     &            TERREUR           = 99 )
      INTEGER ROOT_NELIM_INDICES,                                       &
     &        ROOT_CONT_STATIC,                                         &
     &        ROOT_NON_ELIM_CB,                                         &
     &        ROOT_2SLAVE,                                              &
     &        ROOT_2SON
       PARAMETER( ROOT_NELIM_INDICES = 15,                              &
     &        ROOT_CONT_STATIC       = 16,                              &
     &        ROOT_NON_ELIM_CB       = 17,                              &
     &        ROOT_2SLAVE            = 18,                              &
     &        ROOT_2SON              = 19 )
      INTEGER RACINE_SOLVE,                                             &
     &        ContVec,                                                  &
     &        Master2Slave,                                             &
     &        GatherSol,                                                &
     &        ScatterRhsI,                                              &
     &        ScatterRhsR
      PARAMETER( RACINE_SOLVE = 10,                                     &
     &           ContVec      = 11,                                     &
     &           Master2Slave = 12,                                     &
     &           GatherSol    = 13,                                     &
     &           ScatterRhsI  = 54,                                     &
     &           ScatterRhsR  = 55)
      INTEGER FEUILLE,                                                  &
     &        BACKSLV_UPDATERHS,                                        &
     &        BACKSLV_MASTER2SLAVE
      PARAMETER( FEUILLE = 21,                                          &
     &           BACKSLV_UPDATERHS = 22,                                &
     &           BACKSLV_MASTER2SLAVE = 23 )
      INTEGER SYMMETRIZE
      PARAMETER ( SYMMETRIZE = 24 )
      INTEGER BLOC_FACTO_SYM,                                           &
     &        BLOC_FACTO_SYM_SLAVE, END_NIV2_LDLT
      PARAMETER ( BLOC_FACTO_SYM = 25,                                  &
     &            BLOC_FACTO_SYM_SLAVE = 26 ,                           &
     &            END_NIV2_LDLT = 33 )
      INTEGER UPDATE_LOAD
      PARAMETER ( UPDATE_LOAD = 27 )
      INTEGER DEFIC_TAG
      PARAMETER(  DEFIC_TAG = 28 )
      INTEGER TAG_SCHUR
      PARAMETER( TAG_SCHUR = 38 )
      INTEGER TAG_DUMMY
      PARAMETER( TAG_DUMMY = 39 )
      INTEGER ZERO_PIV
      PARAMETER( ZERO_PIV = 40 )
      INTEGER POSITION, IF, INODE, IERR, LONG, DUMMY(1)
      INTEGER P_UPDATE, P_SOL_MAS, LIELL, K
      INTEGER(8) :: APOS, IST
      INTEGER NPIV, NROW_L, IPOS, NROW_RECU
      INTEGER I, JJ, IN, PROCDEST, J1, J2, IFR, LDA
      INTEGER NSLAVES, NELIM, J, POSINDICES, INODEPOS,                  &
     &        IPOSINRHSCOMP
      LOGICAL FLAG
      DOUBLE PRECISION ZERO, ALPHA, ONE
      PARAMETER (ZERO=0.0D0, ONE = 1.0D0, ALPHA=-1.0D0)
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER POOL_FIRST_POS, TMP
      LOGICAL DEJA_SEND( 0:SLAVEF-1 )
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275, DTRSV, DTRSM, DGEMV, DGEMM
      INTEGER(8) :: APOSDEB, NBENTRIES_ALLPANELS
      INTEGER LDAJ, NBJ, LIWFAC,                                        &
     &        NBJLAST, NPIV_LAST, PANEL_SIZE,                           &
     &        PTWCB_PANEL, NCB_PANEL, TYPEF
      LOGICAL TWOBYTWO
      INTEGER BEG_PANEL
      INTEGER IPANEL, NPANELS
      IF (MSGTAG .EQ. FEUILLE) THEN
          NBFINF = NBFINF - 1
      ELSE IF (MSGTAG .EQ. NOEUD) THEN
          POSITION = 0
          CALL AGMG_NOCALL('MPI_UNPACK')
          CALL AGMG_NOCALL('MPI_UNPACK')
          IF (   POSIWCB - LONG - 2 .LT. 0                              &
     &      .OR. POSWCB - PLEFTW + 1 .LT. LONG ) THEN
            CALL DAGMG_MUMPS_95(NRHS, N, KEEP(28), IWCB,                     &
     &      LIWW, W, LWC,                                               &
     &      POSWCB, POSIWCB, PTRICB, PTRACB)
            IF ((POSIWCB - LONG - 2 ) .LT. 0) THEN
              INFO(1)=-14
              INFO(2)=-POSIWCB + LONG + 2
              WRITE(6,*) MYID,' Internal error in bwd solve COMPSO'
              GOTO 260
            END IF
            IF ( POSWCB - PLEFTW + 1 .LT. LONG ) THEN
              INFO(1) = -11
              INFO(2) = LONG + PLEFTW - POSWCB - 1
              WRITE(6,*) MYID,' Internal error in bwd solve COMPSO'
              GOTO 260
            END IF
          ENDIF
          POSIWCB = POSIWCB - LONG
          POSWCB = POSWCB - LONG
          IF (LONG .GT. 0) THEN
            CALL AGMG_NOCALL('MPI_UNPACK')
            DO K=1,NRHS
             CALL AGMG_NOCALL('MPI_UNPACK')
             DO JJ=0, LONG-1
               RHS(IWCB(POSIWCB+1+JJ),K) = W(POSWCB+1+JJ)
             ENDDO
            ENDDO
            POSIWCB = POSIWCB + LONG
            POSWCB = POSWCB + LONG
          ENDIF
          POOL_FIRST_POS = IIPOOL
             IPOOL( IIPOOL ) = INODE
             IIPOOL = IIPOOL + 1
          IF = FRERE( STEP(INODE) )
          DO WHILE ( IF .GT. 0 )
             IF ( AGMG_MUMPS_275(STEP(IF),PROCNODE_STEPS,                    &
     &            SLAVEF) .eq. MYID ) THEN
                   IPOOL( IIPOOL ) = IF
                   IIPOOL = IIPOOL + 1
             END IF
             IF = FRERE( STEP( IF ) )
          END DO
             DO I=1,(IIPOOL-POOL_FIRST_POS)/2
                TMP=IPOOL(POOL_FIRST_POS+I-1)
                IPOOL(POOL_FIRST_POS+I-1)=IPOOL(IIPOOL-I)
                IPOOL(IIPOOL-I)=TMP
             ENDDO
      ELSE IF ( MSGTAG .EQ. BACKSLV_MASTER2SLAVE ) THEN
        POSITION = 0
        CALL AGMG_NOCALL('MPI_UNPACK')
        CALL AGMG_NOCALL('MPI_UNPACK')
        IPOS   = PTRIST( STEP(INODE) ) + KEEP(IXSZ)
        NPIV   = - IW( IPOS     )
        NROW_L =   IW( IPOS + 1 )
        IF (KEEP(201).NE.0) THEN
           CALL DAGMG_MUMPS_643(                                             &
     &     INODE,PTRFAC,KEEP,A,LA,STEP,                                 &
     &     KEEP8,N,MUST_BE_PERMUTED,IERR)
           IF(IERR.LT.0)THEN
              INFO(1)=IERR
              INFO(2)=0
              GOTO 260
           ENDIF
        ENDIF
        APOS   =   PTRFAC(IW( IPOS + 3 ))
        IF ( NROW_L .NE. NROW_RECU ) THEN
          WRITE(*,*) 'Error1 in 41S : NROW L/RECU=',NROW_L, NROW_RECU
          CALL AGMG_MUMPS_ABORT()
        END IF
        LONG = NROW_L + NPIV
        IF ( POSWCB - LONG*NRHS .LT. PLEFTW - 1 ) THEN
           CALL DAGMG_MUMPS_95(NRHS, N, KEEP(28), IWCB,                      &
     &          LIWW, W, LWC,                                           &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
           IF ( POSWCB - LONG*NRHS .LT. PLEFTW - 1 ) THEN
             INFO(1) = -11
             INFO(2) = LONG * NRHS- POSWCB
             WRITE(6,*) MYID,' Internal error in bwd solve COMPSO'
             GOTO 260
           END IF
        END IF
        P_UPDATE  = PLEFTW
        P_SOL_MAS = PLEFTW + NPIV * NRHS
        PLEFTW    = P_SOL_MAS + NROW_L * NRHS
        DO K=1, NRHS
          CALL AGMG_NOCALL('MPI_UNPACK')
        ENDDO
        IF (KEEP(201).EQ.1) THEN
          IF ( NRHS == 1 ) THEN
           CALL DGEMV( 'T', NROW_L, NPIV, ALPHA, A( APOS ), NROW_L,     &
     &              W( P_SOL_MAS ), 1, ZERO,                            &
     &              W( P_UPDATE ), 1 )
          ELSE
           CALL DGEMM( 'T', 'N', NPIV, NRHS, NROW_L, ALPHA, A(APOS),    &
     &           NROW_L, W( P_SOL_MAS ), NROW_L, ZERO, W( P_UPDATE ),   &
     &           NPIV )
          ENDIF
        ELSE
          IF ( NRHS == 1 ) THEN
           CALL DGEMV( 'N', NPIV, NROW_L, ALPHA, A( APOS ), NPIV,       &
     &              W( P_SOL_MAS ), 1, ZERO,                            &
     &              W( P_UPDATE ), 1 )
          ELSE
           CALL DGEMM( 'N', 'N', NPIV, NRHS, NROW_L, ALPHA, A(APOS),    &
     &            NPIV, W( P_SOL_MAS ), NROW_L, ZERO, W( P_UPDATE ),    &
     &            NPIV )
          END IF
        ENDIF
        IF (KEEP(201).NE.0) THEN
         CALL DAGMG_MUMPS_598(INODE,PTRFAC,KEEP(28),                         &
     &          A,LA,.TRUE.,IERR)
         IF(IERR.LT.0)THEN
            INFO(1)=IERR
            INFO(2)=0
            GOTO 260
         ENDIF
        ENDIF
        PLEFTW = PLEFTW - NROW_L * NRHS
  100   CONTINUE
        CALL DAGMG_MUMPS_63( NRHS, INODE, W(P_UPDATE),                       &
     &                               NPIV, NPIV,                        &
     &                                MSGSOU,                           &
     &                                BACKSLV_UPDATERHS,                &
     &                                COMM, IERR )
        IF ( IERR .EQ. -1 ) THEN
          CALL DAGMG_MUMPS_41(                                               &
     &     .FALSE., FLAG,                                               &
     &     BUFR, LBUFR, LBUFR_BYTES,                                    &
     &     MYID, SLAVEF, COMM,                                          &
     &     N, IWCB, LIWW, POSIWCB,                                      &
     &     W, LWC, POSWCB,                                              &
     &     IIPOOL, NBFINF, PTRICB, PTRACB, INFO,                        &
     &     IPOOL, LPOOL, PANEL_POS, LPANEL_POS, STEP,                   &
     &     FRERE, FILS, PROCNODE_STEPS, PLEFTW, KEEP,KEEP8,             &
     &     PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,                 &
     &     RHS, LRHS, NRHS, MTYPE,                                      &
     &     RHSCOMP, LRHSCOMP, POSINRHSCOMP                              &
     &          )
          IF ( INFO( 1 ) .LT. 0 ) GOTO 270
          GOTO 100
        ELSE IF ( IERR .EQ. -2 ) THEN
          INFO( 1 ) = -17
          INFO( 2 ) = NPIV * KEEP(35) + 2 * KEEP(34)
          GOTO 260
        ELSE IF ( IERR .EQ. -3 ) THEN
          INFO( 1 ) = -20
          INFO( 2 ) = NPIV * KEEP(35) + 2 * KEEP(34)
          GOTO 260
        END IF
        PLEFTW = PLEFTW - NPIV * NRHS
      ELSE IF ( MSGTAG .EQ. BACKSLV_UPDATERHS ) THEN
        POSITION = 0
        CALL AGMG_NOCALL('MPI_UNPACK')
        IPOS  = PTRIST(STEP(INODE)) + 2 + KEEP(IXSZ)
        LIELL = IW(IPOS-2)+IW(IPOS+1)
        CALL AGMG_NOCALL('MPI_UNPACK')
          NELIM = IW(IPOS-1)
          IPOS = IPOS + 1
          NPIV = IW(IPOS)
          IPOS = IPOS + 1
          NSLAVES = IW( IPOS + 1 )
          IPOS = IPOS + 1 + NSLAVES
          INODEPOS = PTRIST(STEP(INODE)) + KEEP(IXSZ) + 4
          IF ( KEEP(50) .eq. 0 ) THEN
           LDA = LIELL
          ELSE
           LDA = NPIV
          ENDIF
          IF ( MTYPE .EQ. 1 .OR. KEEP(50) .NE. 0 ) THEN
             J1 = IPOS + 1
             J2 = IPOS + NPIV
          ELSE
             J1 = IPOS + LIELL + 1
             J2 = IPOS + NPIV + LIELL
          END IF
        DO K=1, NRHS
        CALL AGMG_NOCALL('MPI_UNPACK')
         IPOSINRHSCOMP =  POSINRHSCOMP(STEP(INODE))
         I = 1
         DO JJ = J1,J2
            RHSCOMP(IPOSINRHSCOMP+JJ-J1,K) =                            &
     &      RHSCOMP(IPOSINRHSCOMP+JJ-J1,K) + W2(I)
            I = I+1
         ENDDO
        ENDDO
        IW(PTRIST(STEP(INODE))+XXS) =                                   &
     &      IW(PTRIST(STEP(INODE))+XXS) - 1
        IF ( IW(PTRIST(STEP(INODE))+XXS).EQ.C_FINI ) THEN
          IF (KEEP(201).NE.0) THEN
             CALL DAGMG_MUMPS_643(                                           &
     &            INODE,PTRFAC,KEEP,A,LA,STEP,                          &
     &            KEEP8,N,MUST_BE_PERMUTED,IERR)
             IF(IERR.LT.0)THEN
                INFO(1)=IERR
                INFO(2)=0
                GOTO 260
             ENDIF
             IF (KEEP(201).EQ.1 .AND. KEEP(50).NE.1) THEN
               CALL DAGMG_MUMPS_755(                                         &
     &              IW(IPOS+1+2*LIELL),                                 &
     &              MUST_BE_PERMUTED )
             ENDIF
          ENDIF
          APOS = PTRFAC(IW(INODEPOS))
          IF (KEEP(201).EQ.1) THEN
             LIWFAC =  IW(PTRIST(STEP(INODE))+XXI)
             TYPEF = TYPEF_L
             NROW_L   = NPIV+NELIM
             PANEL_SIZE = DAGMG_MUMPS_690(NROW_L)
             IF (PANEL_SIZE.LT.0) THEN
               WRITE(6,*) ' Internal error in bwd solve PANEL_SIZE=',   &
     &         PANEL_SIZE
               CALL AGMG_MUMPS_ABORT()
             ENDIF
          ENDIF
           IF ( POSIWCB - 2 .LT. 0 .or.                                 &
     &         POSWCB - LIELL*NRHS .LT. PLEFTW - 1 ) THEN
            CALL DAGMG_MUMPS_95( NRHS, N, KEEP(28), IWCB,                    &
     &          LIWW, W, LWC,                                           &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
            IF ( POSWCB - LIELL*NRHS .LT. PLEFTW - 1 ) THEN
              INFO( 1 ) = -11
              INFO( 2 ) = LIELL * NRHS - POSWCB - PLEFTW + 1
              GOTO 260
            END IF
            IF ( POSIWCB - 2 .LT. 0 ) THEN
              INFO( 1 ) = -14
              INFO( 2 ) = 2 - POSIWCB
              GO TO 260
            END IF
           END IF
           POSIWCB = POSIWCB - 2
           POSWCB  = POSWCB - LIELL*NRHS
           PTRICB(STEP( INODE )) = POSIWCB + 1
           PTRACB(STEP( INODE )) = POSWCB  + 1
           IWCB( PTRICB(STEP( INODE ))     ) = LIELL
           IWCB( PTRICB(STEP( INODE )) + 1 ) = 1
           IPOS = PTRIST(STEP(INODE)) + KEEP(IXSZ) + 5 + NSLAVES
           IF ( MTYPE.EQ.1 .AND. KEEP(50).EQ.0 ) THEN
             POSINDICES = IPOS + LIELL + 1
           ELSE
             POSINDICES = IPOS + 1
           END IF
           IPOSINRHSCOMP =  POSINRHSCOMP(STEP(INODE))
           IFR = PTRACB(STEP( INODE ))
           DO K=1, NRHS
             DO JJ = J1, J2
               W(IFR+JJ-J1+(K-1)*LIELL) =                               &
     &           RHSCOMP(IPOSINRHSCOMP+JJ-J1,K)
             ENDDO
           END DO
           IFR = PTRACB(STEP(INODE))-1+NPIV
           IF ( MTYPE .EQ. 1 .AND. KEEP(50).EQ.0 ) THEN
             J1 = IPOS + LIELL + NPIV + 1
             J2 = IPOS + 2 * LIELL
           ELSE
             J1 = IPOS + NPIV + 1
             J2 = IPOS + LIELL
           END IF
           DO JJ = J1, J2
              J = IW(JJ)
              IFR = IFR + 1
              DO K=1, NRHS
                W(IFR+(K-1)*LIELL) = RHS(J,K)
              ENDDO
           ENDDO
       IF ( KEEP(201).EQ.1 .AND.                                        &
     &    (( NELIM .GT. 0 ).OR. (MTYPE.NE.1 )))  THEN
          J = NPIV / PANEL_SIZE
          TWOBYTWO = KEEP(50).EQ.2 .AND. KEEP(105).GT.0
          IF (TWOBYTWO) THEN
            CALL DAGMG_MUMPS_641(PANEL_SIZE, PANEL_POS,                      &
     &           LPANEL_POS, IW(IPOS+1+LIELL), NPIV, NPANELS,           &
     &           NROW_L, NBENTRIES_ALLPANELS)
          ELSE
            IF (NPIV.EQ.J*PANEL_SIZE) THEN
              NPIV_LAST = NPIV
              NBJLAST   = PANEL_SIZE
              NPANELS   = J
            ELSE
              NPIV_LAST = (J+1)* PANEL_SIZE
              NBJLAST   = NPIV-J*PANEL_SIZE
              NPANELS   = J+1
            ENDIF
            NBENTRIES_ALLPANELS =                                       &
     &  int(NROW_L,8) * int(NPIV,8)                                     &
     &  - int( ( J * ( J - 1 ) ) / 2,8 )                                &
     &    * int(PANEL_SIZE,8) * int(PANEL_SIZE,8)                       &
     &  - int(J,8)                                                      &
     &    * int(MOD(NPIV, PANEL_SIZE),8)                                &
     &    * int(PANEL_SIZE,8)
            JJ=NPIV_LAST
          ENDIF
          APOSDEB = APOS + NBENTRIES_ALLPANELS
          DO IPANEL=NPANELS,1,-1
            IF (TWOBYTWO) THEN
              NBJ = PANEL_POS(IPANEL+1)-PANEL_POS(IPANEL)
              BEG_PANEL = PANEL_POS(IPANEL)
            ELSE
              IF (JJ.EQ.NPIV_LAST) THEN
                NBJ = NBJLAST
              ELSE
                NBJ = PANEL_SIZE
              ENDIF
              BEG_PANEL = JJ- PANEL_SIZE+1
            ENDIF
            LDAJ    = NROW_L-BEG_PANEL+1
            APOSDEB = APOSDEB - int(NBJ,8)*int(LDAJ,8)
            PTWCB_PANEL =  PTRACB(STEP(INODE)) + BEG_PANEL - 1
            NCB_PANEL   = LDAJ - NBJ
            IF (KEEP(50).NE.1 .AND.MUST_BE_PERMUTED) THEN
              CALL DAGMG_MUMPS_667(TYPEF, TMP_NBPANELS,                      &
     &        I_PIVRPTR, I_PIVR, IPOS + 1 + 2 * LIELL, IW, LIW)
              CALL DAGMG_MUMPS_698(                                          &
     &        IW(I_PIVR + IW(I_PIVRPTR+IPANEL-1)-IW(I_PIVRPTR)),        &
     &        NPIV-IW(I_PIVRPTR+IPANEL-1)+1,                            &
     &        IW(I_PIVRPTR+IPANEL-1)-1,                                 &
     &        A(APOSDEB),                                               &
     &        LDAJ, NBJ, BEG_PANEL-1)
            ENDIF
            IF ( NRHS == 1 ) THEN
              IF (NCB_PANEL.NE.0) THEN
                CALL DGEMV( 'T', NCB_PANEL, NBJ, ALPHA,                 &
     &                A( APOSDEB + int(NBJ,8) ), LDAJ,                  &
     &                W( NBJ + PTWCB_PANEL ),                           &
     &                1, ONE,                                           &
     &                W(PTWCB_PANEL), 1 )
              ENDIF
              CALL DTRSV('L','T','U', NBJ, A(APOSDEB), LDAJ,            &
     &              W(PTWCB_PANEL), 1)
            ELSE
              IF (NCB_PANEL.NE.0) THEN
                CALL DGEMM( 'T', 'N', NBJ, NRHS, NCB_PANEL, ALPHA,      &
     &              A(APOSDEB + int(NBJ,8)), LDAJ,                      &
     &              W(NBJ+PTWCB_PANEL),LIELL,                           &
     &              ONE, W(PTWCB_PANEL),LIELL)
              ENDIF
              CALL DTRSM('L','L','T','U',NBJ, NRHS, ONE,                &
     &           A(APOSDEB),                                            &
     &           LDAJ, W(PTWCB_PANEL), LIELL)
            ENDIF
            IF (.NOT. TWOBYTWO) JJ=BEG_PANEL-1
          ENDDO
        GOTO 1234
       ENDIF
          IF (NELIM .GT.0) THEN
            IF ( KEEP(50) .eq. 0 ) THEN
                IST = APOS + int(NPIV,8) * int(LIELL,8)
            ELSE
                IST = APOS + int(NPIV,8) * int(NPIV,8)
            END IF
            IF ( NRHS == 1 ) THEN
                CALL DGEMV( 'N', NPIV, NELIM, ALPHA,                    &
     &                A( IST ), NPIV,                                   &
     &                W( NPIV + PTRACB(STEP(INODE)) ),                  &
     &                1, ONE,                                           &
     &                W(PTRACB(STEP(INODE))), 1 )
             ELSE
                CALL DGEMM( 'N', 'N', NPIV, NRHS, NELIM, ALPHA,         &
     &                A(IST), NPIV, W(NPIV+PTRACB(STEP(INODE))),LIELL,  &
     &                ONE, W(PTRACB(STEP(INODE))),LIELL)
             END IF
          ENDIF
          IF ( NRHS == 1 ) THEN
              CALL DTRSV( 'U', 'N', 'U', NPIV, A(APOS), LDA,            &
     &                  W(PTRACB(STEP(INODE))),1)
          ELSE
             CALL DTRSM( 'L','U', 'N', 'U', NPIV, NRHS, ONE,            &
     &                   A(APOS), LDA,                                  &
     &                   W(PTRACB(STEP(INODE))),LIELL)
          END IF
 1234     CONTINUE
          IF (KEEP(201).NE.0) THEN
           CALL DAGMG_MUMPS_598(INODE,PTRFAC,KEEP(28),                       &
     &          A,LA,.TRUE.,IERR)
           IF(IERR.LT.0)THEN
              INFO(1)=IERR
              INFO(2)=0
              GOTO 260
           ENDIF
          ENDIF
          IPOS =   PTRIST(STEP(INODE)) +  KEEP(IXSZ) + 6 + NSLAVES
          DO I = 1, NPIV
            JJ = IW( IPOS + I - 1 )
            DO K=1,NRHS
              RHS( JJ, K ) = W( PTRACB(STEP(INODE))+I-1                 &
     &         + (K-1)*LIELL )
            ENDDO
          END DO
          IN = INODE
  200     IN = FILS(IN)
          IF (IN .GT. 0) GOTO 200
          IF (IN .EQ. 0) THEN
            MYLEAFE = MYLEAFE - 1
            IF (MYLEAFE .EQ. 0) THEN
              CALL DAGMG_MUMPS_242( DUMMY, 1, AGMG_MPF_INTEGER, MYID, COMM,       &
     &                       FEUILLE, SLAVEF )
              NBFINF = NBFINF - 1
            ENDIF
            IWCB( PTRICB(STEP(INODE)) + 1 ) = 0
            CALL DAGMG_MUMPS_151(NRHS, N, KEEP(28),                          &
     &          IWCB, LIWW, W, LWC,                                     &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
            GOTO 270
          ENDIF
          DO I = 0, SLAVEF - 1
            DEJA_SEND( I ) = .FALSE.
          END DO
          IN = -IN
          DO WHILE (IN.GT.0)
           POOL_FIRST_POS  = IIPOOL
            IF (AGMG_MUMPS_275(STEP(IN),PROCNODE_STEPS,                      &
     &          SLAVEF) .EQ. MYID) THEN
                  IPOOL(IIPOOL ) = IN
                  IIPOOL = IIPOOL + 1
            ELSE
              PROCDEST = AGMG_MUMPS_275( STEP(IN), PROCNODE_STEPS,           &
     &                   SLAVEF )
              IF ( .NOT. DEJA_SEND( PROCDEST ) ) THEN
  110           CALL DAGMG_MUMPS_78( NRHS, IN, 0, 0,                         &
     &          LIELL, LIELL,                                           &
     &          IW( POSINDICES ) ,                                      &
     &          W( PTRACB(STEP(INODE))),                                &
     &          PROCDEST, NOEUD, COMM, IERR )
                IF ( IERR .EQ. -1 ) THEN
                  CALL DAGMG_MUMPS_41(                                       &
     &            .FALSE., FLAG,                                        &
     &            BUFR, LBUFR, LBUFR_BYTES,                             &
     &            MYID, SLAVEF, COMM,                                   &
     &            N, IWCB, LIWW, POSIWCB,                               &
     &            W, LWC, POSWCB,                                       &
     &            IIPOOL, NBFINF, PTRICB, PTRACB, INFO,                 &
     &            IPOOL, LPOOL, PANEL_POS, LPANEL_POS, STEP,            &
     &            FRERE, FILS, PROCNODE_STEPS, PLEFTW, KEEP,KEEP8,      &
     &            PTRIST, PTRFAC, IW, LIW, A, LA, W2, MYLEAFE,          &
     &            RHS, LRHS, NRHS, MTYPE,                               &
     &            RHSCOMP, LRHSCOMP, POSINRHSCOMP                       &
     &            )
                  IF ( INFO( 1 ) .LT. 0 ) GOTO 270
                  GOTO 110
                ELSE IF ( IERR .eq. -2 ) THEN
                  INFO(1) = -17
                  INFO(2) = LIELL * NRHS * KEEP(35) +                   &
     &                    ( LIELL + 2 ) * KEEP(34)
                  GOTO 260
                ELSE IF ( IERR .eq. -3 ) THEN
                  INFO(1) = -20
                  INFO(2) = LIELL * NRHS * KEEP(35) +                   &
     &                    ( LIELL + 2 ) * KEEP(34)
                  GOTO 260
                END IF
                DEJA_SEND( PROCDEST ) = .TRUE.
              END IF
            END IF
            IN = FRERE( STEP( IN ) )
          END DO
          DO I=1,(IIPOOL-POOL_FIRST_POS)/2
           TMP=IPOOL(POOL_FIRST_POS+I-1)
           IPOOL(POOL_FIRST_POS+I-1)=IPOOL(IIPOOL-I)
           IPOOL(IIPOOL-I)=TMP
          ENDDO
          IWCB( PTRICB(STEP( INODE )) + 1 ) = 0
          CALL DAGMG_MUMPS_151(NRHS, N, KEEP(28),                            &
     &          IWCB, LIWW, W, LWC,                                     &
     &          POSWCB, POSIWCB, PTRICB, PTRACB)
        END IF
      ELSE IF (MSGTAG.EQ.TERREUR) THEN
          INFO(1) = -001
          INFO(2) = MSGSOU
          GO TO 270
       ELSE IF ( (MSGTAG.EQ.UPDATE_LOAD).OR.                            &
     &      (MSGTAG.EQ.TAG_DUMMY) ) THEN
          GO TO 270
      ELSE
          INFO(1) = -100
          INFO(2) = MSGTAG
          GOTO 260
      ENDIF
      GO TO 270
  260 CONTINUE
      CALL DAGMG_MUMPS_44( MYID, SLAVEF, COMM )
  270 CONTINUE
      RETURN
      END SUBROUTINE DAGMG_MUMPS_42
      SUBROUTINE DAGMG_MUMPS_641(PANEL_SIZE, PANEL_POS,                      &
     &                           LEN_PANEL_POS, INDICES, NPIV,          &
     &                           NPANELS, NFRONT_OR_NASS,               &
     &                           NBENTRIES_ALLPANELS)
      IMPLICIT NONE
      INTEGER, intent (in)   :: PANEL_SIZE, NPIV
      INTEGER, intent (in)   :: INDICES(NPIV)
      INTEGER, intent (in)   :: LEN_PANEL_POS
      INTEGER, intent (out)  :: NPANELS
      INTEGER, intent (out)  :: PANEL_POS(LEN_PANEL_POS)
      INTEGER, intent (in)   :: NFRONT_OR_NASS
      INTEGER(8), intent(out):: NBENTRIES_ALLPANELS
      INTEGER NPANELS_MAX, I, NBeff
      INTEGER(8) :: NBENTRIES_THISPANEL
      NBENTRIES_ALLPANELS = 0_8
      NPANELS_MAX = (NPIV+PANEL_SIZE-1)/PANEL_SIZE
      IF (LEN_PANEL_POS .LT. NPANELS_MAX + 1) THEN
        WRITE(*,*) "Error 1 in DAGMG_MUMPS_641",                             &
     &              LEN_PANEL_POS,NPANELS_MAX
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      I = 1
      NPANELS = 0
      IF (I .GT. NPIV) RETURN
   10 CONTINUE
      NPANELS = NPANELS + 1
      PANEL_POS(NPANELS) = I
      NBeff = min(PANEL_SIZE, NPIV-I+1)
      IF ( INDICES(I+NBeff-1) < 0) THEN
        NBeff=NBeff+1
      ENDIF
      NBENTRIES_THISPANEL = int(NFRONT_OR_NASS-I+1,8) * int(NBeff,8)
      NBENTRIES_ALLPANELS = NBENTRIES_ALLPANELS + NBENTRIES_THISPANEL
      I=I+NBeff
      IF ( I .LE. NPIV ) GOTO 10
      PANEL_POS(NPANELS+1)=NPIV+1
      RETURN
      END SUBROUTINE DAGMG_MUMPS_641
      SUBROUTINE DAGMG_MUMPS_286( NRHS, DESCA_PAR, DESCB_PAR,                &
     &  CNTXT_PAR,LOCAL_M,LOCAL_N,MBLOCK,NBLOCK,                        &
     &  IPIV,LPIV,MASTER_ROOT,MYID,COMM,                                &
     &  RHS_SEQ,SIZE_ROOT,A,INFO,MTYPE,LDLT )
      IMPLICIT NONE
      INTEGER NRHS, MTYPE
      INTEGER DESCA_PAR( 9 ), DESCB_PAR( 9 )
      INTEGER LOCAL_M, LOCAL_N, MBLOCK, NBLOCK
      INTEGER CNTXT_PAR, MASTER_ROOT, SIZE_ROOT
      INTEGER MYID, COMM
      INTEGER LPIV, IPIV( LPIV )
      INTEGER INFO(40), LDLT
      DOUBLE PRECISION RHS_SEQ( SIZE_ROOT *NRHS)
      DOUBLE PRECISION A( LOCAL_M, LOCAL_N )
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER STATUS( AGMG_MPF_STATUS_SIZE )
      INTEGER IERR, NPROW, NPCOL, MYROW, MYCOL
      INTEGER LOCAL_N_RHS
      DOUBLE PRECISION, ALLOCATABLE, DIMENSION( :,: ) ::RHS_PAR
      EXTERNAL NUMROC_FOOL
      INTEGER  NUMROC_FOOL
      INTEGER allocok
      CALL AGMG_NOCALL('BLACS_GRIDINFO')
      LOCAL_N_RHS = NUMROC_FOOL(NRHS, NBLOCK, MYCOL, 0, NPCOL)
      LOCAL_N_RHS = max(1,LOCAL_N_RHS)
      ALLOCATE(RHS_PAR(LOCAL_M, LOCAL_N_RHS),stat=allocok)
      IF (allocok > 0 ) THEN
        WRITE(*,*) ' Problem during solve of the root.'
        WRITE(*,*) ' Reduce number of right hand sides.'
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      CALL DAGMG_MUMPS_290( MYID, SIZE_ROOT, NRHS, RHS_SEQ,                  &
     &      LOCAL_M, LOCAL_N_RHS,                                       &
     &      MBLOCK, NBLOCK, RHS_PAR, MASTER_ROOT,                       &
     &      NPROW, NPCOL, COMM )
      IF ( LDLT .eq. 0 .OR. LDLT .eq. 2 ) THEN
        IF ( MTYPE .eq. 1 ) THEN
          CALL AGMG_NOCALL('PDGETRF')
        ELSE
          CALL AGMG_NOCALL('PDGETRF')
        END IF
      ELSE
        CALL AGMG_NOCALL('PDPOTRS')
      END IF
      IF ( IERR .LT. 0 ) THEN
        WRITE(*,*) ' Problem during solve of the root'
        CALL AGMG_MUMPS_ABORT()
      END IF
      CALL DAGMG_MUMPS_156( MYID, SIZE_ROOT, NRHS,                           &
     &    RHS_SEQ, LOCAL_M, LOCAL_N_RHS,                                &
     &    MBLOCK, NBLOCK, RHS_PAR, MASTER_ROOT,                         &
     &    NPROW, NPCOL, COMM )
      DEALLOCATE(RHS_PAR)
      RETURN
      END SUBROUTINE DAGMG_MUMPS_286
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
! $Id$
      SUBROUTINE AGMG_MUMPS_419 (METRIC, JOB, COMPRESS, N, NBBUCK,           &
     &                   IWLEN, PE, PFREE, LEN, IW, NV, ELEN,           &
     &                   LAST, NCMPA, DEGREE,                           &
     &                   WF,                                            &
     &                   NEXT, W, HEAD, AGG4,                           &
     &                   SIZE_COMPLEM_LIST,                             &
     &                   COMPLEM_LIST)
      IMPLICIT NONE
      INTEGER, intent(in) :: METRIC, JOB, N, NBBUCK
      LOGICAL, intent(in) :: COMPRESS
      INTEGER IWLEN, PFREE, LEN(N),                                     &
     &        ELEN(N), LAST(N), NCMPA, DEGREE(N), NEXT(N),              &
     &        W(N)
      INTEGER PE(N), IW(IWLEN), NV(N)
      LOGICAL, intent(in) :: AGG4
      INTEGER, intent(in) :: SIZE_COMPLEM_LIST
      INTEGER, intent(in), optional ::                                  &
     &                     COMPLEM_LIST(max(1,SIZE_COMPLEM_LIST))
      INTEGER HEAD(0:NBBUCK+1), WF(N)
      INTEGER AMD, AMF1, AMF4, AMF4MA41
      PARAMETER (AMD=1, AMF1=2, AMF4=3, AMF4MA41=4)
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X,        &
     &        NBFLAG, LASTD, NELME, N2, PAS
       INTEGER WF3, WF4
       INTEGER*8 HASH, HMOD
       DOUBLE PRECISION RMF, RMF1
       DOUBLE PRECISION dummy
       INTEGER idummy
       LOGICAL SchurON
       LOGICAL NOTDEFINEDAMD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod, huge
      INTEGER TOTEL
        NOTDEFINEDAMD = (METRIC.NE.AMD)
        IF (N.EQ.1) THEN
           ELEN(1) = 1
           LAST(1) = 1
           PE(1) = 0
           NV(1) = 1
           RETURN
        ENDIF
        IF (.NOT.present(COMPLEM_LIST)) SchurON=.FALSE.
        IF ( SIZE_COMPLEM_LIST < 0 .OR. SIZE_COMPLEM_LIST > N ) THEN
          WRITE(*,*) 'Internal MUMPS_419 ', SIZE_COMPLEM_LIST,N
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF (JOB.EQ.2) THEN
          SchurON = .FALSE.
        ENDIF
        IF (JOB.NE.2) THEN
          SchurON   = (SIZE_COMPLEM_LIST > 0)
          IF ((JOB.EQ.1) .AND. (.NOT.SchurON) ) THEN
           WRITE(6,*) ' WARNING MUMPS_419 on Options ', JOB
          ENDIF
        ENDIF
      idummy = huge(idummy) - 1
      dummy = dble(idummy)
      N2 = -NBBUCK-1
      PAS = max((N/8), 1)
      WFLG = 2
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, NBBUCK-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      MINDEG = 0
      LASTD  = 0
      HEAD(0:NBBUCK+1) = 0
      DEGREE(1:N)      = LEN(1:N)
      LAST             = 0
      W(1:N)           = 1
      TOTEL            = N
      IF (.NOT.COMPRESS) THEN
       NV = 1
      ENDIF
      IF (JOB.EQ.2) THEN
        DO I = 1,SIZE_COMPLEM_LIST
             X       = COMPLEM_LIST(I)
             ELEN(X) = -I
             NV(X)   = LEN(X)+1
        ENDDO
        NEL = NEL + SIZE_COMPLEM_LIST
      ELSE
       ELEN(1:N)        = 0
       DO K=1, SIZE_COMPLEM_LIST
        I = COMPLEM_LIST(K)
        DEGREE(I) = N2
        IF ((LEN(I) .EQ.0).OR.(LEN(I).EQ.-N-1)) THEN
         PE (I)     = 0
         LEN(I)     = 0
        ENDIF
        DEG = NBBUCK + 1
        IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
        ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
        ENDIF
       ENDDO
      ENDIF
      IF(COMPRESS) THEN
         TOTEL = 0
         DO I=1,N
            IF (ELEN(I).LT.0) CYCLE
            IF (DEGREE(I).NE.N2) THEN
               TOTEL = TOTEL + NV(I)
               DEGREE(I) = ELEN(I)
               DO J= PE(I)+ELEN(I), PE(I)+LEN(I)-1
                  DEGREE(I) = DEGREE(I) + NV(IW(J))
               ENDDO
            ENDIF
         ENDDO
      ENDIF
      RMF = dble(0)
      DO I = 1, N
        IF (ELEN(I).LT.0) CYCLE
        DEG = DEGREE (I)
        IF (DEG.EQ.N2) CYCLE
        IF (DEG .GT. 0) THEN
          IF (JOB.EQ.2) THEN
            DEG = DEG - ELEN(I)
            NVI = NV(I)
            RMF = dble(0)
            IF (ELEN(I).GT.0) THEN
             DO  J= PE(I), PE(I)+ELEN(I)-1
              DEG = DEG + LEN(IW(J)) - NVI
              IF (NOTDEFINEDAMD) THEN
               RMF1 = dble( LEN(IW(J)))
               RMF1 = (RMF1-dble(NVI))*(RMF1-dble(NVI)-1.0D0)
               RMF = max(RMF, RMF1)
              ENDIF
             ENDDO
              DEG = MIN (DEG, TOTEL-NEL-NV(I))
            ENDIF
          ENDIF
            IF (                                                        &
     &          ( (JOB.EQ.2).AND.NOTDEFINEDAMD)                         &
     &         .OR. (METRIC.EQ.AMF4MA41)                                &
     &         ) THEN
                DEG   = nint (                                          &
     &              ( (dble(DEG)*dble(DEG-1)) - RMF )  / dble(2) )
                DEG = max (DEG,1)
            ENDIF
            IF (NOTDEFINEDAMD) THEN
              WF(I) = DEG
              IF (DEG.GT.N) THEN
               DEG = min(((DEG-N)/PAS) + N , NBBUCK)
              ENDIF
            ELSE
              DEGREE(I) = DEG
            ENDIF
           INEXT = HEAD (DEG)
           IF (INEXT .NE. 0) LAST (INEXT) = I
           NEXT (I) = INEXT
           HEAD (DEG) = I
        ELSE
          NEL = NEL + NV(I)
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
      ENDDO
      NLEFT = TOTEL-NEL
   30 IF ( ((NEL .LT. TOTEL).AND. (JOB.NE.1)) .OR.                      &
     &     ((JOB.EQ.1).AND.(NEL.LT.TOTEL-SIZE_COMPLEM_LIST))            &
     &   ) THEN
        DO 40 DEG = MINDEG, NBBUCK
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF (ME.LE.0) THEN
          NCMPA = -N
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF (DEG.GT.N) THEN
      IF (NOTDEFINEDAMD) THEN
         J = NEXT(ME)
         K = WF(ME)
   55    CONTINUE
         IF (J.GT.0) THEN
          IF (WF(J).LT.K) THEN
           ME = J
           K  = WF(ME)
          ENDIF
          J= NEXT(J)
          GOTO 55
         ENDIF
         ILAST = LAST(ME)
         INEXT = NEXT(ME)
         IF (INEXT .NE. 0) LAST (INEXT) = ILAST
         IF (ILAST .NE. 0) THEN
           NEXT (ILAST) = INEXT
         ELSE
           HEAD (DEG) = INEXT
         ENDIF
      ELSE
           WRITE(6,*) ' Internal error AMD, DEG>N '
           CALL AGMG_MUMPS_ABORT()
      ENDIF
         ELSE
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ENDIF
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).NE.N2) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
               IF (NOTDEFINEDAMD) THEN
                IF (WF(I).GT.N) THEN
                 DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                ELSE
                 DEG = WF(I)
                ENDIF
                HEAD (DEG) = INEXT
               ELSE
                HEAD (DEGREE (I)) = INEXT
               ENDIF
              ENDIF
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
              IF (DEGREE(I).NE.N2) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                 IF (NOTDEFINEDAMD) THEN
                  IF (WF(I).GT.N) THEN
                   DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                  ELSE
                   DEG = WF(I)
                  ENDIF
                  HEAD (DEG) = INEXT
                 ELSE
                  HEAD(DEGREE(I)) = INEXT
                 ENDIF
                ENDIF
              ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max(MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).EQ.N2) GOTO 150
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
                IF (NOTDEFINEDAMD) WF(E) = 0
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).EQ.N2) GOTO 180
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG  = 0
          IF (NOTDEFINEDAMD) THEN
            WF3  = 0
            WF4  = 0
          ENDIF
          NVI  = -NV(I)
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
             IF (NOTDEFINEDAMD) THEN
              IF ( WF(E) .EQ. 0 ) THEN
               WF(E) = DEXT * ( (2 * DEGREE(E))  -  DEXT - 1)
              ENDIF
              WF4 = WF4 + WF(E)
             ENDIF
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E, KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
             IF (.NOT.AGG4) THEN
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
             ELSE
              PE (E) = -ME
              W (E) = 0
             ENDIF
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              IF (NOTDEFINEDAMD) WF3 = WF3 + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEGREE(I).EQ.N2) DEG = N2
          IF ( (AGG4.AND.(DEG .EQ. 0)).OR.                              &
     &       (ELEN(I).EQ.1 .AND. P3.EQ.PN) ) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
                 IF ( DEGREE (I).LT.DEG ) THEN
                  IF (NOTDEFINEDAMD) THEN
                   WF4 = 0
                   WF3 = 0
                  ENDIF
                 ELSE
                   DEGREE(I)  = DEG
                 ENDIF
            IF (NOTDEFINEDAMD) THEN
             WF(I)      = WF4 + 2*NVI*WF3
            ENDIF
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV (I) .LT. 0) .AND. (DEGREE(I).NE.N2) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                IF (NOTDEFINEDAMD) WF(I)  = max(WF(I),WF(J))
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = TOTEL - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).NE.N2) THEN
            DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
       IF (NOTDEFINEDAMD) THEN
            IF(METRIC.EQ.AMF1) THEN
             DEGREE(I) = DEG
             RMF = dble(DEG)*dble(DEG-1)                                &
     &         -  dble(DEGME-NVI)*dble(DEGME-NVI-1)
            ELSE
             IF (DEGREE (I) + DEGME .GT. NLEFT ) THEN
              DEG = DEGREE(I)
              RMF1  = dble(DEG)*dble( (DEG-1) + 2*DEGME )               &
     &              - dble(WF(I))
              DEGREE(I) = NLEFT - NVI
              DEG       = DEGREE(I)
              RMF = dble(DEG)*dble(DEG-1)                               &
     &         -  dble(DEGME-NVI)*dble(DEGME-NVI-1)
              RMF = min(RMF, RMF1)
             ELSE
              DEG = DEGREE(I)
              DEGREE(I) = DEGREE (I) + DEGME - NVI
              RMF  = dble(DEG)*dble( (DEG-1) + 2*DEGME )                &
     &              - dble(WF(I))
             ENDIF
            ENDIF
            IF (METRIC.EQ.AMF4MA41) THEN
                RMF =  RMF / dble(2*NVI)
            ELSE
                 RMF =  RMF / dble(NVI+1)
            ENDIF
            IF (RMF.LT.dummy) THEN
             WF(I) = int ( anint( RMF ))
            ELSEIF (RMF / dble(N) .LT. dummy) THEN
             WF(I) = int ( anint( RMF/dble(N) ))
            ELSE
             WF(I) = idummy
            ENDIF
            WF(I) = max(1,WF(I))
            DEG = WF(I)
            IF (DEG.GT.N) THEN
              DEG = min(((DEG-N)/PAS) + N , NBBUCK)
            ENDIF
       ELSE
            DEGREE(I) = DEG
       ENDIF
            INEXT = HEAD (DEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (DEG) = I
            MINDEG = min (MINDEG, DEG)
              ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
      IF (NEL.LT.TOTEL) THEN
         IF (JOB.EQ.1) THEN
            DO I = 1,SIZE_COMPLEM_LIST
             X       = COMPLEM_LIST(I)
             ELEN(X) = -(N-SIZE_COMPLEM_LIST+I)
             NV(X)   = 1
             PE(X)   = 0
            ENDDO
            NEL = NEL+ SIZE_COMPLEM_LIST
         ELSE
           DO DEG = MINDEG, NBBUCK+1
             ME = HEAD (DEG)
             IF (ME .GT. 0) GO TO 51
           ENDDO
   51      MINDEG = DEG
           NELME    = -(NEL+1)
           DO X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -ME
            ELSEIF (DEGREE(X).EQ.N2) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
           ENDDO
           ELEN(ME) = NELME
           NV(ME)   = SIZE_COMPLEM_LIST
           PE(ME)   = 0
         ENDIF
!    $      ' degree =',(degree(i),i=1,N)
        IF (NEL.NE.N) THEN
         write(*,*) ' Error 2 in HALO AMD NEL, N=', NEL,N
         NCMPA = -N - 1
         CALL AGMG_MUMPS_ABORT()
        ENDIF
      ENDIF
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      IF(COMPRESS) THEN
        LAST(1:N) = 0
        DEGREE(1:TOTEL-N)=0
        DO I = 1, N
          K = abs (ELEN (I))
          IF ( K <= N ) THEN
            LAST (K) = I
          ELSE
            DEGREE(K-N)=I
          ENDIF
        ENDDO
        I = 1
        DO K = 1, N
          IF(LAST (K) .NE. 0) THEN
            LAST(I) = LAST(K)
            ELEN(LAST(K)) = I
            I = I + 1
          ENDIF
        ENDDO
        DO K = N+1, TOTEL
          IF (DEGREE(K-N) .NE. 0) THEN
            LAST(I)=DEGREE(K-N)
            ELEN(DEGREE(K-N)) = I
            I = I + 1
          ENDIF
        END DO
      ELSE
        DO 300 I = 1, N
           K = abs (ELEN (I))
           LAST (K) = I
           ELEN (I) = K
  300   CONTINUE
      ENDIF
  500 PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_419
      SUBROUTINE AGMG_MUMPS_197(N, IWLEN, PE, PFREE, LEN, IW, NV, ELEN,      &
     &                   LAST, NCMPA, DEGREE, HEAD, NEXT, W)
      INTEGER N, IWLEN, PFREE, NCMPA
      INTEGER NEXT(N), LEN(N),                                          &
     &        ELEN(N), LAST(N), DEGREE(N), HEAD(N),                     &
     &        W(N)
      INTEGER IW(IWLEN), NV(N), PE(N)
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
      WFLG = 2
      MINDEG = 1
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      DO 10 I = 1, N
        LAST (I) = 0
        HEAD (I) = 0
        NV (I) = 1
        W (I) = 1
        ELEN (I) = 0
        DEGREE (I) = LEN (I)
   10 END DO
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (DEG .GT. 0) THEN
          INEXT = HEAD (DEG)
          IF (INEXT .NE. 0) LAST (INEXT) = I
          NEXT (I) = INEXT
          HEAD (DEG) = I
        ELSE
          NEL = NEL + 1
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
   30 IF (NEL .LT. N) THEN
        DO 40 DEG = MINDEG, N
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        INEXT = NEXT (ME)
        IF (INEXT .NE. 0) LAST (INEXT) = 0
        HEAD (DEG) = INEXT
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                HEAD (DEGREE (I)) = INEXT
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  HEAD (DEGREE (I)) = INEXT
                ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEG .EQ. 0) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            DEGREE (I) = min (DEGREE (I), DEG)
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF (NV (I) .LT. 0) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = N - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
            INEXT = HEAD (DEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (DEG) = I
            MINDEG = min (MINDEG, DEG)
            DEGREE (I) = DEG
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      DO 300 I = 1, N
        K = abs (ELEN (I))
        LAST (K) = I
        ELEN (I) = K
  300 END DO
      PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_197
      SUBROUTINE AGMG_MUMPS_23(N,IWLEN, PE, PFREE, LEN, IW, NV, ELEN,        &
     &                   LAST, NCMPA, DEGREE, HEAD, NEXT, W)
      INTEGER N, IWLEN, PFREE, NCMPA
      INTEGER PE(N), LEN(N),                                            &
     &        ELEN(N), LAST(N), DEGREE(N), HEAD(N),                     &
     &        W(N)
      INTEGER IW(IWLEN), NV(N), NEXT(N)
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X,        &
     &        NPRINC
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
      WFLG = 2
      MINDEG = 1
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      NPRINC = 0
      DO I = 1, N
        LAST (I) = 0
        HEAD (I) = 0
        NV (I) = 1
        W (I) = 1
        ELEN (I) = 0
      ENDDO
      DO I=1, N
        IF (LEN (I).GE.0) THEN
           DEGREE (I) = LEN (I)
           NPRINC = NPRINC + 1
        ELSE
           J        = -LEN (I)
           DEGREE (I) = - 1
           IF ( PE(I) .NE. 0 ) THEN
             LEN (I) = LEN(J)
           ELSE
             LEN (I) = 0
           ENDIF
           PE (I)   = -J
           NV (J)   = NV (J) + NV (I)
           NV (I)   = 0
           ELEN (I) = 0
        ENDIF
      ENDDO
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (DEG .GT. 0) THEN
          INEXT = HEAD (DEG)
          IF (INEXT .NE. 0) LAST (INEXT) = I
          NEXT (I) = INEXT
          HEAD (DEG) = I
        ELSE IF ( DEG.EQ. 0) THEN
          NEL = NEL + NV(I)
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
   30 IF (NEL .LT. N) THEN
        DO 40 DEG = MINDEG, N
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        INEXT = NEXT (ME)
        IF (INEXT .NE. 0) LAST (INEXT) = 0
        HEAD (DEG) = INEXT
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                HEAD (DEGREE (I)) = INEXT
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  HEAD (DEGREE (I)) = INEXT
                ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEG .EQ. 0) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            DEGREE (I) = min (DEGREE (I), DEG)
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF (NV (I) .LT. 0) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = N - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
            INEXT = HEAD (DEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (DEG) = I
            MINDEG = min (MINDEG, DEG)
            DEGREE (I) = DEG
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      DO 300 I = 1, N
        K = abs (ELEN (I))
        LAST (K) = I
        ELEN (I) = K
  300 END DO
      PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_23
      SUBROUTINE AGMG_MUMPS_162(N, IWLEN, PE, PFREE, LEN, IW, NV, ELEN,      &
     &                   LAST, NCMPA, DEGREE, HEAD, NEXT, W,            &
     &                   LISTVAR_SCHUR, SIZE_SCHUR)
      INTEGER SIZE_SCHUR
      INTEGER LISTVAR_SCHUR(SIZE_SCHUR)
      INTEGER N, IWLEN, PFREE, NCMPA
      INTEGER LEN(N),                                                   &
     &        ELEN(N), LAST(N), DEGREE(N), HEAD(N),                     &
     &        W(N), NEXT(N)
      INTEGER IW(IWLEN), NV(N), PE(N)
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X,        &
     &        NBFLAG, NREAL, LASTD, NELME
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
      WFLG = 2
      MINDEG = 1
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      NBFLAG = 0
      LASTD  = 0
      DO 10 I = 1, N
        LAST (I) = 0
        HEAD (I) = 0
        NV (I) = 1
        W (I) = 1
        ELEN (I) = 0
        DEGREE(I) = LEN(I)
   10 END DO
      NBFLAG = SIZE_SCHUR
      DO K=1,SIZE_SCHUR
       I = LISTVAR_SCHUR(K)
       DEGREE(I) = N+1
       IF ((LEN(I) .EQ.0).OR.(LEN(I).EQ.-N-1)) THEN
         PE (I)     = 0
         LEN(I)     = 0
       ENDIF
       DEG = N
       IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
       ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
       ENDIF
      ENDDO
      NREAL = N - NBFLAG
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (DEG.EQ.N+1)  GOTO 20
        IF (DEG .GT. 0) THEN
          INEXT = HEAD (DEG)
          IF (INEXT .NE. 0) LAST (INEXT) = I
          NEXT (I) = INEXT
          HEAD (DEG) = I
        ELSE
          NEL = NEL + 1
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
      NLEFT = N-NEL
   30 IF (NEL .LT. NREAL) THEN
        DO 40 DEG = MINDEG, N
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF (ME.LE.0) THEN
          write (*,*) ' Error 1 in HALO_AMD '
          NCMPA = -N
          GOTO 500
        ENDIF
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).LE.N) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                HEAD (DEGREE (I)) = INEXT
              ENDIF
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
              IF (DEGREE(I).LE.N) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  HEAD (DEGREE (I)) = INEXT
                ENDIF
              ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEGREE(I).EQ.N+1) DEG = N+1
          IF (DEG .EQ. 0) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            IF (DEGREE(I).NE.N+1) THEN
                 DEG        = min (DEG, NLEFT)
                 DEGREE (I) = min (DEGREE (I), DEG)
            ENDIF
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            IF (DEG.LE.N) THEN
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH, KIND=KIND(LAST))
            ENDIF
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV (I) .LT. 0) .AND. (DEGREE(I) .LE. N) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = N - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).LE.N) THEN
            DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
            INEXT = HEAD (DEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (DEG) = I
            MINDEG = min (MINDEG, DEG)
            DEGREE (I) = DEG
              ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
      IF (NEL.LT.N) THEN
           DO DEG = MINDEG, N
             ME = HEAD (DEG)
             IF (ME .GT. 0) GO TO 51
           ENDDO
   51      MINDEG = DEG
           IF (ME.NE.LISTVAR_SCHUR(1)) THEN
             write(6,*) ' error 1 in MUMPS_162 '
             write(6,*) ' wrong principal var for Schur !!'
             NCMPA = -N - 2
             CALL AGMG_MUMPS_ABORT()
           ENDIF
           NELME    = -(NEL+1)
           DO X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -ME
            ELSEIF (DEGREE(X).EQ.N+1) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
           ENDDO
           ELEN(ME) = NELME
           NV(ME)   = N-NREAL
           PE(ME)   = 0
        IF (NEL.NE.N) THEN
         write(*,*) ' Error 2 in MUMPS_162 NEL, N=', NEL,N
         NCMPA = -N - 1
         CALL AGMG_MUMPS_ABORT()
        ENDIF
      ENDIF
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      DO 300 I = 1, N
        K = abs (ELEN (I))
        LAST (K) = I
        ELEN (I) = K
  300 END DO
  500 PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_162
      SUBROUTINE AGMG_MUMPS_337(N, NBBUCK,                                   &
     &                   IWLEN, PE, PFREE, LEN, IW, NV, ELEN,           &
     &                   LAST, NCMPA, DEGREE, WF, NEXT, W, HEAD)
      IMPLICIT NONE
      INTEGER N, IWLEN, PFREE, LEN(N),                                  &
     &        ELEN(N), LAST(N), NCMPA, DEGREE(N), NEXT(N),              &
     &        W(N)
      INTEGER PE(N), IW(IWLEN), NV(N)
      INTEGER NBBUCK
      INTEGER HEAD(0:NBBUCK+1), WF(N)
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X,        &
     &        NBFLAG, NREAL, LASTD, NELME, WF3, WF4, N2, PAS
       INTEGER*8 HASH, HMOD
       DOUBLE PRECISION RMF, RMF1
       DOUBLE PRECISION dummy
       INTEGER idummy
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod, huge
      INTEGER TOTEL
      LOGICAL COMPRESS
      idummy = huge(idummy) - 1
      dummy = dble(idummy)
      N2 = -NBBUCK-1
      PAS = max((N/8), 1)
      WFLG = 2
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, NBBUCK-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      MINDEG = 0
      NBFLAG = 0
      LASTD  = 0
      HEAD(0:NBBUCK+1) = 0
      DO 10 I = 1, N
        LAST(I) = 0
        W(I) = 1
        ELEN (I) = 0
   10 END DO
      IF(NV(1) .LT. 0) THEN
         COMPRESS = .FALSE.
      ELSE
         COMPRESS = .TRUE.
      ENDIF
      IF(COMPRESS) THEN
         TOTEL = 0
         DO I=1,N
            IF (LEN(I).LT.0) THEN
               DEGREE (I) = N2
               NBFLAG     = NBFLAG +1
               IF (LEN(I).EQ.-N-1) THEN
                  LEN (I)    = 0
                  PE (I)     = 0
               ELSE
                  LEN (I)    = - LEN(I)
               ENDIF
            ELSE
               TOTEL = TOTEL + NV(I)
               DEGREE(I) = 0
               DO J= PE(I) , PE(I)+LEN(I)-1
                  DEGREE(I) = DEGREE(I) + NV(IW(J))
               ENDDO
            ENDIF
         ENDDO
      ELSE
         DO I=1,N
            NV(I) = 1
            IF (LEN(I).LT.0) THEN
               DEGREE (I) = N2
               NBFLAG     = NBFLAG +1
               IF (LEN(I).EQ.-N-1) THEN
                  LEN (I)    = 0
                  PE (I)     = 0
               ELSE
                  LEN (I)    = - LEN(I)
               ENDIF
            ELSE
               DEGREE (I) = LEN (I)
            ENDIF
         ENDDO
         TOTEL = N - NBFLAG
      ENDIF
      NREAL = N - NBFLAG
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (DEG.EQ.N2) THEN
             DEG = NBBUCK + 1
             IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
             ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
             ENDIF
         GOTO 20
        ENDIF
        IF (DEG .GT. 0) THEN
          WF(I) = DEG
           IF (DEG.GT.N) THEN
            DEG = min(((DEG-N)/PAS) + N , NBBUCK)
           ENDIF
           INEXT = HEAD (DEG)
           IF (INEXT .NE. 0) LAST (INEXT) = I
           NEXT (I) = INEXT
           HEAD (DEG) = I
        ELSE
          NEL = NEL + NV(I)
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
      NLEFT = TOTEL-NEL
   30 IF (NEL .LT. TOTEL) THEN
        DO 40 DEG = MINDEG, NBBUCK
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF (ME.LE.0) THEN
          NCMPA = -N
          CALL AGMG_MUMPS_ABORT()
        ENDIF
       IF (DEG.GT.N) THEN
         J = NEXT(ME)
         K = WF(ME)
   55    CONTINUE
         IF (J.GT.0) THEN
          IF (WF(J).LT.K) THEN
           ME = J
           K  = WF(ME)
          ENDIF
          J= NEXT(J)
          GOTO 55
         ENDIF
         ILAST = LAST(ME)
         INEXT = NEXT(ME)
         IF (INEXT .NE. 0) LAST (INEXT) = ILAST
         IF (ILAST .NE. 0) THEN
           NEXT (ILAST) = INEXT
         ELSE
           HEAD (DEG) = INEXT
         ENDIF
        ELSE
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ENDIF
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).NE.N2) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                IF (WF(I).GT.N) THEN
                 DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                ELSE
                 DEG = WF(I)
                ENDIF
                HEAD (DEG) = INEXT
              ENDIF
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
              IF (DEGREE(I).NE.N2) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  IF (WF(I).GT.N) THEN
                   DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                  ELSE
                   DEG = WF(I)
                  ENDIF
                  HEAD (DEG) = INEXT
                ENDIF
              ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
                WF(E) = 0
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG  = 0
          WF3  = 0
          WF4  = 0
          NVI  = -NV(I)
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              IF ( WF(E) .EQ. 0 ) THEN
               WF(E) = DEXT * ( (2 * DEGREE(E))  -  DEXT - 1)
              ENDIF
              WF4 = WF4 + WF(E)
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E, KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              WF3 = WF3 + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEGREE(I).EQ.N2) DEG = N2
          IF (DEG .EQ. 0) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            IF (DEGREE(I).NE.N2) THEN
                 IF ( DEGREE (I).LT.DEG ) THEN
                   WF4 = 0
                   WF3 = 0
                 ELSE
                   DEGREE(I)  = DEG
                 ENDIF
            ENDIF
            WF(I)      = WF4 + 2*NVI*WF3
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            IF (DEG.NE.N2) THEN
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
            ENDIF
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV (I) .LT. 0) .AND. (DEGREE(I).NE.N2) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                WF(I)  = max(WF(I),WF(J))
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = TOTEL - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).NE.N2) THEN
            DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
            IF (DEGREE (I) + DEGME .GT. NLEFT ) THEN
              DEG = DEGREE(I)
              RMF1  = dble(DEG)*dble( (DEG-1) + 2*DEGME )               &
     &              - dble(WF(I))
              DEGREE(I) = NLEFT - NVI
              DEG       = DEGREE(I)
              RMF = dble(DEG)*dble(DEG-1)                               &
     &         -  dble(DEGME-NVI)*dble(DEGME-NVI-1)
              RMF = min(RMF, RMF1)
            ELSE
              DEG = DEGREE(I)
              DEGREE(I) = DEGREE (I) + DEGME - NVI
              RMF  = dble(DEG)*dble( (DEG-1) + 2*DEGME )                &
     &              - dble(WF(I))
            ENDIF
            RMF =  RMF / dble(NVI+1)
            IF (RMF.LT.dummy) THEN
             WF(I) = int ( anint( RMF ))
            ELSEIF (RMF / dble(N) .LT. dummy) THEN
             WF(I) = int ( anint( RMF/dble(N) ))
            ELSE
             WF(I) = idummy
            ENDIF
            WF(I) = max(1,WF(I))
            DEG = WF(I)
            IF (DEG.GT.N) THEN
              DEG = min(((DEG-N)/PAS) + N , NBBUCK)
            ENDIF
            INEXT = HEAD (DEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (DEG) = I
            MINDEG = min (MINDEG, DEG)
              ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
      IF (NEL.LT.N) THEN
           DO DEG = MINDEG, NBBUCK+1
             ME = HEAD (DEG)
             IF (ME .GT. 0) GO TO 51
           ENDDO
   51      MINDEG = DEG
           NELME    = -(NEL+1)
           DO X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -ME
            ELSEIF (DEGREE(X).EQ.N2) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
           ENDDO
           ELEN(ME) = NELME
           NV(ME)   = N-NREAL
           PE(ME)   = 0
        IF (NEL.NE.N) THEN
         NCMPA = -N - 1
         GOTO 500
        ENDIF
      ENDIF
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      IF(COMPRESS) THEN
        LAST(1:N) = 0
        DEGREE(1:TOTEL-N)=0
        DO I = 1, N
          K = abs (ELEN (I))
          IF ( K <= N ) THEN
            LAST (K) = I
          ELSE
            DEGREE(K-N)=I
          ENDIF
        ENDDO
        I = 1
        DO K = 1, N
          IF(LAST (K) .NE. 0) THEN
            LAST(I) = LAST(K)
            ELEN(LAST(K)) = I
            I = I + 1
          ENDIF
        ENDDO
        DO K = N+1, TOTEL
          IF (DEGREE(K-N) .NE. 0) THEN
            LAST(I)=DEGREE(K-N)
            ELEN(DEGREE(K-N)) = I
            I = I + 1
          ENDIF
        END DO
      ELSE
        DO 300 I = 1, N
           K = abs (ELEN (I))
           LAST (K) = I
           ELEN (I) = K
  300   CONTINUE
      ENDIF
  500 PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_337
      SUBROUTINE AGMG_MUMPS_421                                              &
     &                (TOTEL, IVersion, THRESH, NDENSE,                 &
     &                 N, IWLEN, PE, PFREE, LEN, IW, NV,                &
     &                 ELEN, LAST, NCMPA, DEGREE, HEAD, NEXT, W)
      INTEGER TOTEL
      INTEGER N, IWLEN, PE(N), PFREE, LEN(N), IW(IWLEN), NV(N),         &
     &     ELEN(N), NCMPA, DEGREE(N),                                   &
     &     LAST(TOTEL), HEAD(TOTEL), NEXT(N),                           &
     &     W(N)
      INTEGER NDENSE(N)
      INTEGER IVersion, THRESH
      INTEGER THRESM, MINDEN, MAXDEN, NDME
      INTEGER NBD,NBED, NBDM, LASTD, NELME, DEG1
      LOGICAL IDENSE
      DOUBLE PRECISION RELDEN
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
      LOGICAL COMPRESS
      IF (THRESH.GT.0) THEN
         THRESM  = min(N,THRESH)
         DO I=1,N
             THRESM = max(THRESM, LEN(I))
          ENDDO
           RELDEN = dble(PFREE-1)/dble(N)
         THRESM =  int(RELDEN)*10 + (THRESM-int(RELDEN))/10 + 1
      ELSE
         THRESM = TOTEL
      ENDIF
      IF (THRESM.GE.0) THEN
       IF ((THRESM.GT.TOTEL).OR.(THRESM.LT.2)) THEN
          THRESM = TOTEL
       ENDIF
      ENDIF
      LASTD = 0
      NBD   = 0
      NBED  = 0
      NBDM  = 0
      WFLG = 2
      MINDEG = 1
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      DO 10 I = 1, N
        NDENSE(I)= 0
        LAST (I) = 0
        HEAD (I) = 0
        W (I) = 1
        ELEN (I) = 0
   10 END DO
      HEAD(N:TOTEL) = 0
      LAST(N:TOTEL) = 0
      IF(NV(1) .LT. 0) THEN
         COMPRESS = .FALSE.
      ELSE
         COMPRESS = .TRUE.
      ENDIF
      IF(COMPRESS) THEN
         DO I=1,N
            DEGREE(I) = 0
            DO J= PE(I) , PE(I)+LEN(I)-1
               DEGREE(I) = DEGREE(I) + NV(IW(J))
            ENDDO
         ENDDO
      ELSE
         DO I=1,N
            NV(I) = 1
            DEGREE (I) = LEN (I)
         ENDDO
      ENDIF
      DO 20 I = 1, N
         DEG = DEGREE (I)
         IF (DEG .GT. 0) THEN
            IF ( (THRESM.GE.0) .AND.                                    &
     &           (DEG+NV(I).GE.THRESM) ) THEN
               NBD = NBD+1
               IF (DEG+NV(I).NE.TOTEL-NEL) THEN
                  DEGREE(I) = DEGREE(I)+TOTEL+1
                  DEG = TOTEL
                  INEXT = HEAD (DEG)
                  IF (INEXT .NE. 0) LAST (INEXT) = I
                  NEXT (I) = INEXT
                  HEAD (DEG) = I
                  LAST(I)  = 0
                  IF (LASTD.EQ.0) LASTD=I
               ELSE
                  NBED = NBED+1
                  DEGREE(I) = TOTEL+1
                  DEG = TOTEL
                  IF (LASTD.EQ.0) THEN
                     LASTD     = I
                     HEAD(DEG) = I
                     NEXT(I)   = 0
                     LAST(I)   = 0
                  ELSE
                     NEXT(LASTD) = I
                     LAST(I)     = LASTD
                     LASTD       = I
                     NEXT(I)     = 0
                  ENDIF
               ENDIF
            ELSE
               INEXT = HEAD (DEG)
               IF (INEXT .NE. 0) LAST (INEXT) = I
               NEXT (I) = INEXT
               HEAD (DEG) = I
            ENDIF
         ELSE
            NEL = NEL + NV(I)
            ELEN (I) = -NEL
            PE (I) = 0
            W (I) = 0
         ENDIF
   20 END DO
          IF (NBD.EQ.0) THRESM = TOTEL
          NLEFT = TOTEL - NEL
   30     IF (NEL .LT. TOTEL) THEN
        DO 40 DEG = MINDEG, TOTEL
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF (DEG.LT.TOTEL)  THEN
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ELSE
          NBDM = max(NBDM,NBD)
          IF (DEGREE(ME).GT.TOTEL+1) THEN
            MINDEN = NBD
            MAXDEN = 0
            IF (WFLG+NBD+1 .LE. WFLG) THEN
             DO  52 X = 1, N
              IF (W (X) .NE. 0) W (X) = 1
   52        CONTINUE
             WFLG = 2
            ENDIF
            WFLG = WFLG + 1
   51       CONTINUE
            INEXT = NEXT (ME)
            IF (INEXT .NE. 0) THEN
               LAST (INEXT) = 0
            ELSE
               LASTD = 0
            ENDIF
            NDENSE(ME) = 0
            W(ME)      = WFLG
            P1 = PE(ME)
            P2 = P1 + LEN(ME) -1
            LN       = P1
            ELN      = P1
            DO 55 P=P1,P2
              E= IW(P)
              IF (W(E).EQ.WFLG) GOTO 55
              W(E) = WFLG
              IF (PE(E).LT.0) THEN
                X = E
   53           X = -PE(X)
                IF (W(X) .EQ.WFLG) GOTO 55
                W(X) = WFLG
                IF ( PE(X) .LT. 0 ) GOTO 53
                E = X
              ENDIF
              IF (ELEN(E).LT.0) THEN
               NDENSE(E) = NDENSE(E) - NV(ME)
               IW(LN) = IW(ELN)
               IW(ELN) = E
               LN  = LN+1
               ELN = ELN + 1
               PME1 = PE(E)
               DO 54 PME = PME1, PME1+LEN(E)-1
                X = IW(PME)
                IF ((ELEN(X).GE.0).AND.(W(X).NE.WFLG)) THEN
                 NDENSE(ME) = NDENSE(ME) + NV(X)
                 W(X) = WFLG
                ENDIF
   54          CONTINUE
              ELSE
               NDENSE(ME) = NDENSE(ME) + NV(E)
               IW(LN)=E
               LN = LN+1
              ENDIF
   55       CONTINUE
            WFLG     = WFLG + 1
            LEN(ME)  = LN-P1
            ELEN(ME) = ELN- P1
            NDME = NDENSE(ME)+NV(ME)
            MINDEN = min (MINDEN, NDME)
            MAXDEN = max (MAXDEN, NDME)
            IF (NDENSE(ME).EQ.0) NDENSE(ME) =1
            IF (IVersion.EQ.1) THEN
              DEG = max (DEGREE(ME)-(TOTEL+1), 1)
            ELSE
              DEG = NDENSE(ME)
            ENDIF
            DEGREE(ME) = DEG
            MINDEG = min(DEG,MINDEG)
            JNEXT = HEAD(DEG)
            IF (JNEXT.NE. 0) LAST (JNEXT) = ME
            NEXT(ME) = JNEXT
            HEAD(DEG) = ME
            ME    = INEXT
            IF (ME.NE.0) THEN
              IF (DEGREE(ME).GT.(TOTEL+1) ) GOTO 51
            ENDIF
            HEAD (TOTEL) = ME
            IF (IVersion .EQ.1 ) THEN
             THRESM = TOTEL
            ELSE
             THRESM=max(THRESM*2,MINDEN+(MAXDEN-MINDEN)/2)
             THRESM = min(THRESM,NBD)
             IF (THRESM.GE.NBD) THRESM=TOTEL
            ENDIF
            NBD    = NBED
            GOTO 30
          ENDIF
          IF (DEGREE(ME).EQ.TOTEL+1) THEN
           IF (NBD.NE.NBED) THEN
            write(6,*) ' Internal ERROR quasi dense rows remains'
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           NELME    = -(NEL+1)
           DO 59 X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -ME
            ELSEIF (DEGREE(X).EQ.TOTEL+1) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
   59      CONTINUE
           ELEN(ME) = NELME
           NV(ME)   = NBD
           PE(ME)   = 0
           IF (NEL.NE.TOTEL) THEN
            write(6,*) 'Internal ERROR 2 detected in QAMD'
            write(6,*) ' NEL not equal to N: N, NEL =',N,NEL
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           GOTO 265
          ENDIF
        ENDIF
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NDENSE(ME) = 0
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).LE.TOTEL) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                 NEXT (ILAST) = INEXT
              ELSE
                 HEAD (DEGREE (I)) = INEXT
              ENDIF
              ELSE
               NDENSE(ME) = NDENSE(ME) + NVI
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
                IF (DEGREE(I).LE.TOTEL) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                   NEXT (ILAST) = INEXT
                ELSE
                   HEAD (DEGREE (I)) = INEXT
                ENDIF
                ELSE
                 NDENSE(ME) = NDENSE(ME) + NVI
                ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.TOTEL) GOTO 150
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI - NDENSE(E)
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.TOTEL) GOTO 180
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF ((DEXT .EQ. 0) .AND.                                &
     &                (NDENSE(ME).EQ.NBD)) THEN
                PE (E) = -ME
                W (E)  = 0
            ELSE IF (DEXT.EQ.0) THEN
                  IW(PN) = E
                  PN     = PN+1
                  HASH   = HASH + INT(E,KIND=8)
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              IF (DEGREE(J).LE.TOTEL) DEG=DEG+NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF ((DEG .EQ. 0).AND.(NDENSE(ME).EQ.NBD)) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            DEGREE(I) = min (DEG+NBD-NDENSE(ME),                        &
     &                       DEGREE(I))
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV(I).LT.0) .AND. (DEGREE(I).LE.TOTEL) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                PE (J) = -I
                NV (I) = NV (I) + NV (J)
                NV (J) = 0
                ELEN (J) = 0
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        P = PME1
        NLEFT = TOTEL - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).LE.TOTEL) THEN
            DEG = min (DEGREE (I)+ DEGME - NVI, NLEFT - NVI)
            DEGREE (I) = DEG
            IDENSE = .FALSE.
       IF ( (Iversion .NE. 1).AND. (THRESM.GE.0)) THEN
          IF (DEG+NVI .GE. THRESM) THEN
             IF (THRESM.EQ.TOTEL) THEN
                IF ((ELEN(I).LE.2) .AND. ((DEG+NVI).EQ.NLEFT) ) THEN
                   DEGREE(I) = TOTEL+1
                   IDENSE = .TRUE.
                ENDIF
             ELSE
                IDENSE = .TRUE.
                IF ((ELEN(I).LE.2).AND.((DEG+NVI).EQ.NLEFT) ) THEN
                   DEGREE(I) = TOTEL+1
                ELSE
                   DEGREE(I) = TOTEL+1+DEGREE(I)
                ENDIF
             ENDIF
          ENDIF
          IF (IDENSE) THEN
             P1 = PE(I)
             P2 = P1 + ELEN(I) - 1
             IF (P2.GE.P1) THEN
                DO 264 PJ=P1,P2
                   E= IW(PJ)
                   NDENSE (E) = NDENSE(E) + NVI
  264           CONTINUE
             ENDIF
             NBD = NBD+NVI
             DEG = TOTEL
             IF (DEGREE(I).EQ.TOTEL+1) THEN
                NBED = NBED +NVI
                IF (LASTD.EQ.0) THEN
                   LASTD     = I
                   HEAD(DEG) = I
                   NEXT(I)   = 0
                   LAST(I)   = 0
                ELSE
                   NEXT(LASTD) = I
                   LAST(I)     = LASTD
                   LASTD       = I
                   NEXT(I)     = 0
                ENDIF
             ELSE
                INEXT = HEAD(DEG)
                IF (INEXT .NE. 0) LAST (INEXT) = I
                NEXT (I) = INEXT
                HEAD (DEG) = I
                LAST(I)    = 0
                IF (LASTD.EQ.0) LASTD=I
             ENDIF
          ENDIF
       ENDIF
       IF (.NOT.IDENSE) THEN
          INEXT = HEAD (DEG)
          IF (INEXT .NE. 0) LAST (INEXT) = I
          NEXT (I) = INEXT
          LAST (I) = 0
          HEAD (DEG) = I
       ENDIF
       MINDEG = min (MINDEG, DEG)
            ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
  265 CONTINUE
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      IF(COMPRESS) THEN
        LAST(1:N) = 0
        DEGREE(1:TOTEL-N)=0
        DO I = 1, N
          K = abs (ELEN (I))
          IF ( K <= N ) THEN
            LAST (K) = I
          ELSE
            DEGREE(K-N)=I
          ENDIF
        ENDDO
        I = 1
        DO K = 1, N
          IF(LAST (K) .NE. 0) THEN
            LAST(I) = LAST(K)
            ELEN(LAST(K)) = I
            I = I + 1
          ENDIF
        ENDDO
        DO K = N+1, TOTEL
          IF (DEGREE(K-N) .NE. 0) THEN
            LAST(I)=DEGREE(K-N)
            ELEN(DEGREE(K-N)) = I
            I = I + 1
          ENDIF
        END DO
      ELSE
         DO 300 I = 1, N
            K = abs (ELEN (I))
            LAST (K) = I
            ELEN (I) = K
  300    CONTINUE
      ENDIF
      PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_421
      SUBROUTINE AGMG_MUMPS_560(N, NBBUCK,                                   &
     &     IWLEN, PE, PFREE, LEN, IW, NV, ELEN,                         &
     &     LAST, NCMPA, DEGREE, WF, NEXT, W, HEAD,                      &
     &     CONSTRAINT,THESON)
      IMPLICIT NONE
      INTEGER N, IWLEN, PFREE, LEN(N),                                  &
     &        ELEN(N), LAST(N), NCMPA, DEGREE(N), NEXT(N),              &
     &        W(N)
      INTEGER PE(N), IW(IWLEN), NV(N)
      INTEGER NBBUCK
      INTEGER HEAD(0:NBBUCK+1), WF(N)
      INTEGER CONSTRAINT(N),THESON(N)
      INTEGER PREV,TOTO
      LOGICAL TROUVE
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X,        &
     &        NBFLAG, NREAL, LASTD, NELME, WF3, WF4, N2, PAS
       INTEGER*8 HASH, HMOD
       DOUBLE PRECISION    RMF, RMF1
       DOUBLE PRECISION    dummy
       INTEGER idummy
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod, huge
      INTEGER TOTEL
      idummy = huge(idummy) - 1
      dummy = dble(idummy)
      N2 = -NBBUCK-1
      PAS = max((N/8), 1)
      WFLG = 2
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, NBBUCK-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      MINDEG = 0
      NBFLAG = 0
      LASTD  = 0
      HEAD(0:NBBUCK+1) = 0
      DO 10 I = 1, N
         THESON(I) = 0
         LAST (I) = 0
         W (I) = 1
         ELEN (I) = 0
   10 END DO
      TOTEL = 0
      DO I=1,N
         IF (LEN(I).LT.0) THEN
            DEGREE (I) = N2
            NBFLAG     = NBFLAG +1
            IF (LEN(I).EQ.-N-1) THEN
               LEN (I)    = 0
               PE (I)     = 0
            ELSE
               LEN (I)    = - LEN(I)
            ENDIF
         ELSE
            TOTEL = TOTEL + NV(I)
            DEGREE(I) = 0
            DO J= PE(I) , PE(I)+LEN(I)-1
               DEGREE(I) = DEGREE(I) + NV(IW(J))
            ENDDO
         ENDIF
      ENDDO
      NREAL = N - NBFLAG
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (DEG.EQ.N2) THEN
             DEG = NBBUCK + 1
             IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
             ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
             ENDIF
         GOTO 20
        ENDIF
        IF (DEG .GT. 0) THEN
           WF(I) = DEG
           IF (DEG.GT.N) THEN
            DEG = min(((DEG-N)/PAS) + N , NBBUCK)
           ENDIF
           INEXT = HEAD (DEG)
           IF (INEXT .NE. 0) LAST (INEXT) = I
           NEXT (I) = INEXT
           HEAD (DEG) = I
        ELSE
           NEL = NEL + NV(I)
           ELEN (I) = -NEL
           PE (I) = 0
           W (I) = 0
        ENDIF
   20 END DO
      NLEFT = TOTEL-NEL
   30 IF (NEL .LT. TOTEL) THEN
         DO 40 DEG = MINDEG, NBBUCK
            ME = HEAD (DEG)
            IF (ME .GT. 0) GO TO 50
   40    CONTINUE
   50    MINDEG = DEG
         IF (ME.LE.0) THEN
            NCMPA = -N
            CALL AGMG_MUMPS_ABORT()
         ENDIF
         IF (DEG.GT.N) THEN
            J = NEXT(ME)
            K = WF(ME)
            IF(CONSTRAINT(ME) .LT. 0) THEN
               K = -1
            ENDIF
   55       CONTINUE
            IF (J.GT.0) THEN
               IF(CONSTRAINT(J) .GE. 0) THEN
                  IF (WF(J).LT.K .OR. K .LT. 0) THEN
                     ME = J
                     K  = WF(ME)
                  ENDIF
               ENDIF
               J= NEXT(J)
               GOTO 55
            ENDIF
            ILAST = LAST(ME)
            INEXT = NEXT(ME)
            IF (INEXT .NE. 0) LAST (INEXT) = ILAST
            IF (ILAST .NE. 0) THEN
               NEXT (ILAST) = INEXT
            ELSE
               HEAD (DEG) = INEXT
            ENDIF
         ELSE
            IF(CONSTRAINT(ME) .GE. 0) GOTO 59
   56       CONTINUE
            IF(NEXT(ME) .NE. 0) THEN
               ME = NEXT(ME)
               IF(CONSTRAINT(ME) .GE. 0) THEN
                  GOTO 59
               ELSE
                  GOTO 56
               ENDIF
            ELSE
   57          DEG = DEG+1
               ME = HEAD(DEG)
               IF(ME .GT. 0) THEN
                  IF(CONSTRAINT(ME) .GE. 0) THEN
                     GOTO 59
                  ELSE
                     GOTO 56
                  ENDIF
               ELSE
                  GOTO 57
               ENDIF
            ENDIF
   59       PREV = LAST (ME)
            INEXT = NEXT (ME)
            IF(PREV .NE. 0) THEN
               NEXT(PREV) = INEXT
            ELSE
               HEAD (DEG) = INEXT
            ENDIF
            IF (INEXT .NE. 0) LAST (INEXT) = PREV
         ENDIF
         TOTO = ME
 5910    IF(TOTO .NE. 0) THEN
            J = CONSTRAINT(TOTO)
            IF(J .GT. 0) THEN
               CONSTRAINT(J) = 0
            ENDIF
            TOTO = THESON(TOTO)
            GOTO 5910
         ENDIF
            ELENME = ELEN (ME)
            ELEN (ME) = - (NEL + 1)
            NVPIV = NV (ME)
            NEL = NEL + NVPIV
            NV (ME) = -NVPIV
            DEGME = 0
            IF (ELENME .EQ. 0) THEN
               PME1 = PE (ME)
               PME2 = PME1 - 1
               DO 60 P = PME1, PME1 + LEN (ME) - 1
                  I = IW (P)
                  NVI = NV (I)
                  IF (NVI .GT. 0) THEN
                     DEGME = DEGME + NVI
                     NV (I) = -NVI
                     PME2 = PME2 + 1
                     IW (PME2) = I
                     IF (DEGREE(I).NE.N2) THEN
                        ILAST = LAST (I)
                        INEXT = NEXT (I)
                        IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                        IF (ILAST .NE. 0) THEN
                           NEXT (ILAST) = INEXT
                        ELSE
                           IF (WF(I).GT.N) THEN
                              DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                           ELSE
                              DEG = WF(I)
                           ENDIF
                           HEAD (DEG) = INEXT
                        ENDIF
                     ENDIF
                  ENDIF
   60          CONTINUE
               NEWMEM = 0
            ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
              IF (DEGREE(I).NE.N2) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  IF (WF(I).GT.N) THEN
                   DEG = min(((WF(I)-N)/PAS) + N , NBBUCK)
                  ELSE
                   DEG = WF(I)
                  ENDIF
                  HEAD (DEG) = INEXT
                ENDIF
              ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI
                WF(E) = 0
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG  = 0
          WF3  = 0
          WF4  = 0
          NVI  = -NV(I)
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              IF ( WF(E) .EQ. 0 ) THEN
               WF(E) = DEXT * ( (2 * DEGREE(E))  -  DEXT - 1)
              ENDIF
              WF4 = WF4 + WF(E)
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (DEXT .EQ. 0) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              DEG = DEG + NVJ
              WF3 = WF3 + NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (DEGREE(I).EQ.N2) DEG = N2
          IF (DEG .EQ. 0) THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            IF (DEGREE(I).NE.N2) THEN
                 IF ( DEGREE (I).LT.DEG ) THEN
                   WF4 = 0
                   WF3 = 0
                 ELSE
                   DEGREE(I)  = DEG
                 ENDIF
            ENDIF
            WF(I)      = WF4 + 2*NVI*WF3
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            IF (DEG.NE.N2) THEN
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
            ENDIF
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV (I) .LT. 0) .AND. (DEGREE(I).NE.N2) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                 IF(CONSTRAINT(J) .LT. 0                                &
     &                .AND. CONSTRAINT(I) .LT. 0) THEN
                    GOTO 240
                 ENDIF
                 IF(CONSTRAINT(I) .GE. 0) THEN
                    IF(CONSTRAINT(J) .LT. 0) THEN
                       TOTO = I
  221                  IF(TOTO .NE. 0) THEN
                          IF(CONSTRAINT(TOTO) .EQ. J) THEN
                             GOTO 225
                          ENDIF
                          TOTO =THESON(TOTO)
                          GOTO 221
                       ENDIF
                    ELSE
                       GOTO 225
                    ENDIF
                 ELSE
                    IF(CONSTRAINT(J) .GE. 0) THEN
                       TOTO = J
  222                  IF(TOTO .NE. 0) THEN
                          IF(CONSTRAINT(TOTO) .EQ. I) THEN
                             GOTO 225
                          ENDIF
                          TOTO =THESON(TOTO)
                          GOTO 222
                       ENDIF
                    ENDIF
                 ENDIF
                 GOTO 240
  225            CONTINUE
                 IF (LEN (J) .NE. LN) GO TO 240
                 IF (ELEN (J) .NE. ELN) GO TO 240
                 DO 230 P = PE (J) + 1, PE (J) + LN - 1
                    IF (W (IW (P)) .NE. WFLG) GO TO 240
  230            CONTINUE
                 TOTO = I
  231            IF(THESON(TOTO) .NE. 0) THEN
                    TOTO = THESON(TOTO)
                    GOTO 231
                 ENDIF
                 THESON(TOTO) = J
                 IF(CONSTRAINT(I) .LT. 0) THEN
                    CONSTRAINT(I) = 0
                 ENDIF
                 PE (J) = -I
                 WF(I)  = max(WF(I),WF(J))
                 NV (I) = NV (I) + NV (J)
                 NV (J) = 0
                 ELEN (J) = 0
                 J = NEXT (J)
                 NEXT (JLAST) = J
                 GO TO 220
  240            CONTINUE
                 JLAST = J
                 J = NEXT (J)
                 GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
           ENDIF
          ENDIF
  250  CONTINUE
        P = PME1
        NLEFT = TOTEL - NEL
        DO 260 PME = PME1, PME2
           I = IW (PME)
           NVI = -NV (I)
           IF (NVI .GT. 0) THEN
              NV (I) = NVI
              IF (DEGREE(I).NE.N2) THEN
                 DEG = min (DEGREE (I) + DEGME - NVI, NLEFT - NVI)
                 IF (DEGREE (I) + DEGME .GT. NLEFT ) THEN
                  DEG = DEGREE(I)
                  RMF1  = dble(DEG)*dble( (DEG-1) + 2*DEGME )           &
     &                 - dble(WF(I))
                  DEGREE(I) = NLEFT - NVI
                  DEG       = DEGREE(I)
                  RMF = dble(DEG)*dble(DEG-1)                           &
     &                 -  dble(DEGME-NVI)*dble(DEGME-NVI-1)
                  RMF = min(RMF, RMF1)
               ELSE
                  DEG = DEGREE(I)
                  DEGREE(I) = DEGREE (I) + DEGME - NVI
                  RMF  = dble(DEG)*dble( (DEG-1) + 2*DEGME )            &
     &                 - dble(WF(I))
               ENDIF
               RMF =  RMF / dble(NVI+1)
               IF (RMF.LT.dummy) THEN
                  WF(I) = int ( anint( RMF ))
               ELSEIF (RMF / dble(N) .LT. dummy) THEN
                  WF(I) = int ( anint( RMF/dble(N) ))
               ELSE
                  WF(I) = idummy
               ENDIF
               WF(I) = max(1,WF(I))
               DEG = WF(I)
               IF (DEG.GT.N) THEN
                  DEG = min(((DEG-N)/PAS) + N , NBBUCK)
               ENDIF
               INEXT = HEAD (DEG)
               IF (INEXT .NE. 0) LAST (INEXT) = I
               NEXT (I) = INEXT
               LAST (I) = 0
               HEAD (DEG) = I
               MINDEG = min (MINDEG, DEG)
            ENDIF
            IW (P) = I
            P = P + 1
         ENDIF
  260 END DO
      NV (ME) = NVPIV + DEGME
      LEN (ME) = P - PME1
      IF (LEN (ME) .EQ. 0) THEN
         PE (ME) = 0
         W (ME) = 0
      ENDIF
      IF (NEWMEM .NE. 0) THEN
         PFREE = P
         MEM = MEM - NEWMEM + LEN (ME)
      ENDIF
      GO TO 30
      ENDIF
      IF (NEL.LT.N) THEN
           DO DEG = MINDEG, NBBUCK+1
             ME = HEAD (DEG)
             IF (ME .GT. 0) GO TO 51
           ENDDO
   51      MINDEG = DEG
           NELME    = -(NEL+1)
           DO X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -ME
            ELSEIF (DEGREE(X).EQ.N2) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
           ENDDO
           ELEN(ME) = NELME
           NV(ME)   = N-NREAL
           PE(ME)   = 0
        IF (NEL.NE.N) THEN
         NCMPA = -N - 1
         GOTO 500
        ENDIF
      ENDIF
      DO 290 I = 1, N
         IF (ELEN (I) .EQ. 0) THEN
            J = -PE (I)
  270       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
               J = -PE (J)
               GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
               JNEXT = -PE (J)
               PE (J) = -E
               IF (ELEN (J) .EQ. 0) THEN
                  ELEN (J) = K
                  K = K + 1
               ENDIF
               J = JNEXT
               GO TO 280
            ENDIF
            ELEN (E) = -K
         ENDIF
  290 END DO
      IF(.TRUE.) THEN
        LAST(1:N) = 0
        DEGREE(1:TOTEL-N)=0
        DO I = 1, N
          K = abs (ELEN (I))
          IF ( K <= N ) THEN
            LAST (K) = I
          ELSE
            DEGREE(K-N)=I
          ENDIF
        ENDDO
        I = 1
        DO K = 1, N
          IF(LAST (K) .NE. 0) THEN
            LAST(I) = LAST(K)
            ELEN(LAST(K)) = I
            I = I + 1
          ENDIF
        ENDDO
        DO K = N+1, TOTEL
          IF (DEGREE(K-N) .NE. 0) THEN
            LAST(I)=DEGREE(K-N)
            ELEN(DEGREE(K-N)) = I
            I = I + 1
          ENDIF
        END DO
      ELSE
        DO 300 I = 1, N
           K = abs (ELEN (I))
           LAST (K) = I
           ELEN (I) = K
  300   CONTINUE
      ENDIF
  500 PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_560
      SUBROUTINE AGMG_MUMPS_422                                              &
     &                ( THRESH, NDENSE,                                 &
     &                 N, IWLEN, PE, PFREE, LEN, IW, NV,                &
     &                 ELEN, LAST, NCMPA, DEGREE, HEAD, NEXT, W,        &
     &                 PERM, LISTVAR_SCHUR, SIZE_SCHUR, AGG6 )
      IMPLICIT NONE
      INTEGER N, IWLEN, PE(N), PFREE, LEN(N), IW(IWLEN), NV(N),         &
     &        ELEN(N), LAST(N), NCMPA, DEGREE(N), HEAD(N), NEXT(N),     &
     &        W(N), SIZE_SCHUR
      LOGICAL AGG6
      INTEGER NDENSE(N), LISTVAR_SCHUR(max(1,SIZE_SCHUR))
      INTEGER PERM(N)
      INTEGER THRESH
      INTEGER THRESM, NDME, PERMeqN
      INTEGER NBD,NBED, NBDM, LASTD, NELME, DEG1
      LOGICAL IDENSE
      INTEGER FDEG, ThresMin, ThresPrev, IBEGSchur, NbSchur,            &
     &        ThresMinINIT
      LOGICAL SchurON
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
        IF (N.EQ.1) THEN
           ELEN(1) = 1
           LAST(1) = 1
           PE(1) = 0
           NV(1) = 1
           RETURN
        ENDIF
        SIZE_SCHUR = min(N,SIZE_SCHUR)
        SIZE_SCHUR = max(0,SIZE_SCHUR)
        SchurON   = (SIZE_SCHUR > 0)
        IBEGSchur = N-SIZE_SCHUR+1
        IF (THRESH.GT.N) THRESH = N
        IF (THRESH.LT.0) THRESH = 0
        IF ( SchurON )  THEN
           DO I= 1, N
             IF ( PERM(I) .GE. IBEGSchur) THEN
                 PERM(I) = N + 1
                IF (LEN(I) .EQ.0) THEN
                  PE(I) = 0
                ENDIF
             ENDIF
           ENDDO
        ENDIF
        IF (SchurON) THEN
             THRESM    = N
             ThresMin  = N
             ThresPrev = N
        ELSE
             THRESM    = max(int(31*N/32),THRESH)
             THRESM    = max(THRESM,1)
             ThresMin  = max( 3*THRESM / 4, 1)
             ThresPrev = THRESM
        ENDIF
        ThresMinINIT = ThresMin/4
      IF (THRESM.GT.0) THEN
       IF ((THRESM.GT.N).OR.(THRESM.LT.2)) THEN
          THRESM = N
       ENDIF
      ENDIF
      LASTD = 0
      NBD   = 0
      NBED  = 0
      NBDM  = 0
      WFLG = 2
      MINDEG = 1
      NCMPA = 0
      NEL = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM = PFREE - 1
      MAXMEM = MEM
      DO 10 I = 1, N
        NDENSE(I)= 0
        LAST (I) = 0
        HEAD (I) = 0
        NV (I) = 1
        W (I) = 1
        ELEN (I) = 0
        DEGREE (I) = LEN (I)
   10 END DO
      DO 20 I = 1, N
        DEG = DEGREE (I)
        IF (PERM(I).EQ.N) THEN
           PERMeqN = I
           PERM(I) = N-1
        ENDIF
        FDEG = PERM(I)
        IF ( (DEG .GT. 0).OR.(PERM(I).EQ.N+1) ) THEN
          IF ( (THRESM.GT.0) .AND.                                      &
     &         (FDEG .GT.THRESM) ) THEN
            NBD = NBD+1
            IF (FDEG.NE.N+1) THEN
             DEGREE(I) = DEGREE(I)+N+2
             DEG = N
             INEXT = HEAD (DEG)
             IF (INEXT .NE. 0) LAST (INEXT) = I
             NEXT (I) = INEXT
             HEAD (DEG) = I
             LAST(I)  = 0
             IF (LASTD.EQ.0) LASTD=I
            ELSE
             NBED = NBED+1
             DEGREE(I) = N+1
             DEG = N
             IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
             ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
             ENDIF
            ENDIF
          ELSE
            INEXT = HEAD (FDEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            HEAD (FDEG) = I
          ENDIF
        ELSE
          NEL = NEL + 1
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
          IF ((NBD.EQ.0).AND.(THRESM.GT.0)) THRESM = N
   30 IF (NEL .LT. N) THEN
        DO 40 DEG = MINDEG, N
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF ( (DEG.NE.N) .AND.                                           &
     &    (DEG.GT.THRESM+1) .AND. (NBD.GT.0) ) THEN
           MINDEG = N
           GOTO 30
        ENDIF
        IF (DEGREE(ME).LE.N)  THEN
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ELSE
          MINDEG = 1
          NBDM = max(NBDM,NBD)
          IF (DEGREE(ME).GT.N+1) THEN
            IF (WFLG+NBD+1 .LE. WFLG) THEN
             DO  52 X = 1, N
              IF (W (X) .NE. 0) W (X) = 1
   52        CONTINUE
             WFLG = 2
            ENDIF
            WFLG = WFLG + 1
   51       CONTINUE
            INEXT = NEXT (ME)
            IF (INEXT .NE. 0) THEN
               LAST (INEXT) = 0
            ELSE
               LASTD = 0
            ENDIF
            NDENSE(ME) = 0
            W(ME)      = WFLG
            P1 = PE(ME)
            P2 = P1 + LEN(ME) -1
            LN       = P1
            ELN      = P1
            DO 55 P=P1,P2
              E= IW(P)
              IF (W(E).EQ.WFLG) GOTO 55
              W(E) = WFLG
              IF (PE(E).LT.0) THEN
                X = E
   53           X = -PE(X)
                IF (W(X) .EQ.WFLG) GOTO 55
                W(X) = WFLG
                IF ( PE(X) .LT. 0 ) GOTO 53
                E = X
              ENDIF
              IF (ELEN(E).LT.0) THEN
               NDENSE(E) = NDENSE(E) - NV(ME)
               IW(LN) = IW(ELN)
               IW(ELN) = E
               LN  = LN+1
               ELN = ELN + 1
               PME1 = PE(E)
               DO 54 PME = PME1, PME1+LEN(E)-1
                X = IW(PME)
                IF ((ELEN(X).GE.0).AND.(W(X).NE.WFLG)) THEN
                 NDENSE(ME) = NDENSE(ME) + NV(X)
                 W(X) = WFLG
                ENDIF
   54          CONTINUE
              ELSE
               NDENSE(ME) = NDENSE(ME) + NV(E)
               IW(LN)=E
               LN = LN+1
              ENDIF
   55       CONTINUE
            WFLG     = WFLG + 1
            LEN(ME)  = LN-P1
            ELEN(ME) = ELN- P1
            NDME = NDENSE(ME)+NV(ME)
            IF (NDENSE(ME).EQ.0) NDENSE(ME) =1
            DEGREE(ME) = NDENSE(ME)
            DEG = PERM(ME)
            MINDEG = min(DEG,MINDEG)
            JNEXT = HEAD(DEG)
            IF (JNEXT.NE. 0) LAST (JNEXT) = ME
            NEXT(ME) = JNEXT
            HEAD(DEG) = ME
            ME    = INEXT
            IF (ME.NE.0) THEN
              IF (DEGREE(ME).GT.(N+1) ) GOTO 51
            ENDIF
            HEAD (N) = ME
            IF (THRESM.LT.N) THEN
             ThresMin  = max(THRESM+ThresMin,ThresPrev+ThresMin/2+1)
             ThresMin  = min(ThresMin, N)
             ThresPrev = ThresPrev+(N-ThresPrev)/2+ThresMinINIT
             THRESM    = max(                                           &
     &         THRESM + int(sqrt(dble(ThresMin)))+ ThresMinINIT ,       &
     &         ThresPrev)
             THRESM    = min(THRESM,N)
             ThresMin  = min(THRESM, ThresMin)
             ThresPrev = THRESM
            ENDIF
            NBD    = NBED
            GOTO 30
          ENDIF
          IF (DEGREE(ME).EQ.N+1) THEN
           IF (NBD.NE.NBED) THEN
          write(6,*) ' ERROR in MUMPS_422 quasi dense rows remains'
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           NbSchur = 0
           NELME    = -(NEL+1)
           DO 59 X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -LISTVAR_SCHUR(1)
            ELSEIF (DEGREE(X).EQ.N+1) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
             NbSchur = NbSchur+ 1
            ENDIF
   59      CONTINUE
           IF (NbSchur.NE.SIZE_SCHUR) then
             write(6,*) ' Internal error 2 in QAMD :',                  &
     &         ' Schur size expected:',SIZE_SCHUR, 'Real:', NbSchur
             CALL AGMG_MUMPS_ABORT()
           ENDIF
           ELEN(ME) = NELME
           NV(ME)   = NBD
           PE(ME)   = 0
           IF (NEL.NE.N) THEN
            write(6,*) 'Internal ERROR 2 detected in QAMD'
            write(6,*) ' NEL not equal to N: N, NEL =',N,NEL
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF (ME.NE. LISTVAR_SCHUR(1)) THEN
             DO I=1, SIZE_SCHUR
               PE(LISTVAR_SCHUR(I)) = -LISTVAR_SCHUR(1)
             ENDDO
             PE(LISTVAR_SCHUR(1)) = 0
             NV( LISTVAR_SCHUR(1))= NV(ME)
             NV(ME)               = 0
             ELEN( LISTVAR_SCHUR(1)) = ELEN(ME)
             ELEN(ME)             = 0
           ENDIF
           GOTO 265
          ENDIF
        ENDIF
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NDENSE(ME) = 0
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).LE.N) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                HEAD (PERM(I)) = INEXT
              ENDIF
              ELSE
               NDENSE(ME) = NDENSE(ME) + NVI
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
                IF (DEGREE(I).LE.N) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  HEAD (PERM(I)) = INEXT
                ENDIF
                ELSE
                 NDENSE(ME) = NDENSE(ME) + NVI
                ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.N) GOTO 150
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI - NDENSE(E)
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.N) GOTO 180
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (.NOT. AGG6 .AND. DEXT .EQ. 0) THEN
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (AGG6 .AND. (DEXT .EQ. 0) .AND.                     &
     &            ((NDENSE(ME).EQ.NBD).OR.(NDENSE(E).EQ.0))) THEN
                PE (E) = -ME
                W (E)  = 0
             ELSE IF (AGG6 .AND. DEXT.EQ.0) THEN
                  IW(PN) = E
                  PN     = PN+1
                  HASH   = HASH + INT(E,KIND=8)
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              IF (DEGREE(J).LE.N) DEG=DEG+NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (((ELEN(I).EQ.1).AND.(P3.EQ.PN))                           &
     &     .OR.                                                         &
     &         (AGG6.AND.(DEG .EQ. 0).AND.(NDENSE(ME).EQ.NBD))          &
     &       )                                                          &
     &    THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            DEGREE(I) = min (DEG+NBD-NDENSE(ME),                        &
     &                       DEGREE(I))
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV(I).LT.0) .AND. (DEGREE(I).LE.N) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
             X = I
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                IF (PERM(J).GT.PERM(X)) THEN
                  PE (J) = -X
                  NV (X) = NV (X) + NV (J)
                  NV (J) = 0
                  ELEN (J) = 0
                ELSE
                  PE (X) = -J
                  NV (J) = NV (X) + NV (J)
                  NV (X) = 0
                  ELEN (X) = 0
                  X = J
                ENDIF
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        IF ( (THRESM .GT. 0).AND.(THRESM.LT.N) ) THEN
          THRESM = max(ThresMin, THRESM-NVPIV)
        ENDIF
        P = PME1
        NLEFT = N - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).LE.N) THEN
            DEG = min (DEGREE (I)+ DEGME - NVI, NLEFT - NVI)
            DEGREE (I) = DEG
            IDENSE = .FALSE.
            IF (THRESM.GT.0) THEN
             IF (PERM(I) .GT. THRESM) THEN
               IDENSE = .TRUE.
               DEGREE(I) = DEGREE(I)+N+2
             ENDIF
             IF (IDENSE) THEN
               P1 = PE(I)
               P2 = P1 + ELEN(I) - 1
               IF (P2.GE.P1) THEN
               DO 264 PJ=P1,P2
                 E= IW(PJ)
                 NDENSE (E) = NDENSE(E) + NVI
  264          CONTINUE
               ENDIF
               NBD = NBD+NVI
               FDEG = N
               DEG = N
               INEXT = HEAD(DEG)
               IF (INEXT .NE. 0) LAST (INEXT) = I
               NEXT (I) = INEXT
               HEAD (DEG) = I
               LAST(I)    = 0
               IF (LASTD.EQ.0) LASTD=I
             ENDIF
            ENDIF
            IF (.NOT.IDENSE) THEN
            FDEG = PERM(I)
            INEXT = HEAD (FDEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (FDEG) = I
            ENDIF
            MINDEG = min (MINDEG, FDEG)
            ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
  265 CONTINUE
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      DO 300 I = 1, N
        K = abs (ELEN (I))
        LAST (K) = I
        ELEN (I) = K
  300 END DO
      IF (.NOT.SchurON) THEN
        PERM(PERMeqN) = N
      ENDIF
      PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_422
      SUBROUTINE AGMG_MUMPS_276( ICNTL, INFO, COMM, ID )
      INTEGER ICNTL(40), INFO(40), COMM, ID
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IN( 2 ), OUT( 2 )
      INTEGER LP, IERR
      LP      = ICNTL( 1 )
      IN( 1 ) = INFO ( 1 )
      IN( 2 ) = ID
      CALL AGMG_COPY( IN, OUT, 1, AGMG_MPF_2INTEGER, IERR)
      IF ( OUT( 1 ) .LT. 0 .and. INFO(1) .GE. 0 ) THEN
        INFO( 1 ) = -001
        INFO( 2 ) = OUT( 2 )
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_276
      SUBROUTINE AGMG_MUMPS_137( INODE, N, PROCNODE_STEPS,                   &
     &           SLAVEF,                                                &
     &           ND, FILS, FRERE_STEPS, STEP, PIMASTER,                 &
     &           KEEP28, KEEP50,                                        &
     &           FLOP1,                                                 &
     &           IW, LIW, XSIZE )
      IMPLICIT NONE
      INTEGER INODE, N, KEEP50, LIW, SLAVEF, KEEP28
      INTEGER PROCNODE_STEPS(KEEP28), ND(KEEP28),                       &
     &        FILS(N), FRERE_STEPS(KEEP28),                             &
     &        STEP(N),                                                  &
     & PIMASTER(KEEP28),                                                &
     &  IW( LIW )
      INTEGER XSIZE
      DOUBLE PRECISION FLOP1
      INTEGER NUMORG, IN, NASS, IFSON, NUMSTK, NFRONT, NPIV, NCB,       &
     &        LEVEL, ISON
      LOGICAL AGMG_MUMPS_170
      INTEGER AGMG_MUMPS_330
      EXTERNAL AGMG_MUMPS_170, AGMG_MUMPS_330
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      FLOP1 = 0.0D0
      IF (AGMG_MUMPS_170(STEP(INODE),                                        &
     &    PROCNODE_STEPS, SLAVEF) ) RETURN
      IN     = INODE
      NUMORG = 0
   10 NUMORG = NUMORG + 1
      IN = FILS(IN)
      IF (IN .GT. 0) GOTO 10
      NUMSTK = 0
      NASS = 0
      IFSON = -IN
      ISON = IFSON
      IF (ISON .EQ. 0) GOTO 30
   20 NUMSTK = NUMSTK + 1
      NASS = NASS + IW(PIMASTER(STEP(ISON)) + 1 +XSIZE)
      ISON = FRERE_STEPS(STEP(ISON))
      IF (ISON .GT. 0) GOTO 20
   30 NFRONT = ND(STEP(INODE)) + NASS
      NPIV  = NASS + NUMORG
      NCB   = NFRONT - NPIV
      LEVEL = AGMG_MUMPS_330(STEP(INODE),PROCNODE_STEPS,SLAVEF)
      CALL AGMG_MUMPS_511(NFRONT,NPIV,NPIV,KEEP50,LEVEL,FLOP1)
      RETURN
      END SUBROUTINE AGMG_MUMPS_137
      SUBROUTINE AGMG_MUMPS_511(NFRONT,NPIV,NASS,                            &
     &                                 KEEP50,LEVEL,COST)
      IMPLICIT NONE
      INTEGER, intent(in) :: NFRONT,NPIV,KEEP50,LEVEL, NASS
      DOUBLE PRECISION, intent(out) :: COST
      IF (KEEP50.EQ.0) THEN
        IF (LEVEL.EQ.1 .OR. LEVEL.EQ.3) THEN
          COST = dble(2) * dble(NFRONT) * dble(NPIV) *                  &
     &      dble(NFRONT - NPIV - 1) +                                   &
     &      dble(NPIV) * dble(NPIV + 1) * dble(2 * NPIV + 1)            &
     &          / dble(3)
          COST = COST + dble(2 * NFRONT - NPIV - 1)                     &
     &      * dble(NPIV) /dble(2)
        ELSEIF (LEVEL.EQ.2) THEN
          COST = dble(2*NASS)*dble(NFRONT) -                            &
     &          dble(NASS+NFRONT)*dble(NPIV+1)
          COST = dble(NPIV)*COST +                                      &
     &     dble(2 * NASS - NPIV - 1) * dble(NPIV) / dble(2) +           &
     &     dble(NPIV) * dble(NPIV + 1) *                                &
     &     dble(2 * NPIV + 1) /dble(3)
        ENDIF
      ELSE
        IF (LEVEL.EQ.1) THEN
          COST = dble(NPIV) * (                                         &
     &          dble( NFRONT ) * dble( NFRONT ) +                       &
     &          dble( NFRONT ) - (                                      &
     &          dble( NFRONT)*dble(NPIV) + dble(NPIV+1)                 &
     &          )) +( dble(NPIV)*dble(NPIV+1)                           &
     &          *dble(2*NPIV+1))/ dble(6)
        ELSE IF (LEVEL.EQ.3.AND.KEEP50.EQ.2) THEN
          COST = dble(2) * dble(NFRONT) * dble(NPIV) *                  &
     &      dble(NFRONT - NPIV - 1) +                                   &
     &      dble(NPIV) * dble(NPIV + 1) *                               &
     &      dble(2 * NPIV + 1) / dble(3)
          COST = COST + dble(2 * NFRONT - NPIV - 1)                     &
     &         * dble(NPIV) / dble(2)
        ELSE
          COST = dble(NPIV) * (                                         &
     &          dble( NASS ) * dble( NASS ) + dble( NASS )              &
     &        - ( dble( NASS) * dble(NPIV) + dble( NPIV + 1 ) ) )       &
     &        + ( dble(NPIV)*dble(NPIV+1)*dble(2*NPIV+1) )              &
     &        / dble( 6 )
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_511
      SUBROUTINE AGMG_MUMPS_81(MYID, INODE, N, IOLDPS,                       &
     &           HF, NFRONT, NFRONT_EFF,                                &
     &           NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                  &
     &           IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                &
     &           INTARR, ITLOC, FILS, FRERE,                            &
     &           SON_LEVEL2, NIV1, NBPROCFILS, KEEP,KEEP8, IFLAG)
      IMPLICIT NONE
      INTEGER INODE, N, IOLDPS, HF, NFRONT, NASS1, LIW, NASS,           &
     &        NUMSTK, NUMORG, IWPOSCB, IFSON, MYID, IFLAG
      INTEGER KEEP(500), NFRONT_EFF
      INTEGER*8 KEEP8(150)
      INTEGER STEP(N),                                                  &
     & PIMASTER(KEEP(28)),                                              &
     &  PTRAIW(N), IW(LIW),                                             &
     &        ITLOC(N), FILS(N), FRERE(KEEP(28)),                       &
     &        NBPROCFILS(KEEP(28))
      INTEGER INTARR(max(1,KEEP(14)))
      LOGICAL SON_LEVEL2, NIV1
      INTEGER NEWEL, INEW, IOLDP2, INEW1,                               &
     &        IN, NTOTFS, ICT11, NELIM, NPIVS, NSLSON, NCOLS,           &
     &        ITRANS, J, JJ, J1, J2, J3, JT1, ISON, IELL, LSTK,         &
     &        NROWS, HS, IP1, IP2, K1, K2, IBROT, IORG,                 &
     &        I, K
      LOGICAL LEVEL1
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      SON_LEVEL2 = .FALSE.
      IOLDP2 = IOLDPS + HF - 1
      NEWEL = IOLDP2 + NASS1
      NFRONT_EFF = NASS1
      IN = INODE
      INEW = IOLDPS + HF
      INEW1 = 1
   50 J1 = PTRAIW(IN) + 2
      JT1 = INTARR(J1)
      INTARR(J1) = INEW1
      ITLOC(JT1) = INEW1
      IW(INEW) = JT1
      INEW = INEW + 1
      INEW1 = INEW1 + 1
      IN = FILS(IN)
      IF (IN .GT. 0) GOTO 50
      IF (NUMSTK .NE. 0) THEN
        NTOTFS = NUMORG
        ISON = IFSON
        ICT11 = IOLDP2 + NFRONT
        DO 100 IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK = IW(J2+KEEP(IXSZ))
          NELIM = IW(J2 + 1+KEEP(IXSZ))
          NPIVS = IW(J2 + 3+KEEP(IXSZ))
          IF ( NPIVS .LT. 0 ) NPIVS = 0
          NSLSON = IW(J2 + 5+KEEP(IXSZ))
          IF( NSLSON.GT.0) SON_LEVEL2 = .TRUE.
          LEVEL1    = NSLSON.EQ.0
          NCOLS = NPIVS + LSTK
          NROWS = NCOLS
          ITRANS = NROWS
          IF (NIV1) THEN
           NBPROCFILS(STEP(ISON)) = NSLSON
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE)) + NSLSON
          ELSE
           IF (LEVEL1) THEN
            NBPROCFILS(STEP(ISON)) = 1
           ELSE
            NBPROCFILS(STEP(ISON)) = NSLSON
           ENDIF
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE))+           &
     &                               NBPROCFILS(STEP(ISON))
          ENDIF
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
           ITRANS = NPIVS + NROWS
          ENDIF
          HS = NSLSON + 6 + KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          IF (NELIM .EQ. 0) GOTO 70
          DO 60 JJ = J1, J3
            NTOTFS = NTOTFS + 1
            JT1 = IW(JJ)
            IW(ICT11 + NTOTFS) = JT1
            ITLOC(JT1) = NTOTFS
            IW(JJ) = NTOTFS
            IW(IOLDP2 + NTOTFS) = IW(JJ - ITRANS)
   60     CONTINUE
   70     J1 = J3 + 1
          IF (NASS1 .NE. NFRONT) THEN
            DO 80 JJ = J1, J2
              J = IW(JJ)
              IF (ITLOC(J) .EQ. 0) THEN
                NEWEL = NEWEL + 1
                NFRONT_EFF = NFRONT_EFF + 1
                IW(NEWEL) = J
                IW(JJ) = NFRONT_EFF
                ITLOC(J) = NFRONT_EFF
              ELSE
                IW(JJ) = ITLOC(J)
              ENDIF
   80       CONTINUE
          ELSE
            DO 90 JJ = J1, J2
              IW(JJ) = ITLOC(IW(JJ))
   90       CONTINUE
          ENDIF
          ISON = FRERE(STEP(ISON))
  100   CONTINUE
      ENDIF
      IBROT = INODE
      DO 120 IORG = 1, NUMORG
        J1 = PTRAIW(IBROT) + 2
        IBROT = FILS(IBROT)
        J2 = J1 + INTARR(J1 - 2) - INTARR(J1 - 1)
        J1 = J1 + 1
        IF (J1 .LE. J2) THEN
          DO 110 JJ = J1, J2
            J = INTARR(JJ)
            IF (ITLOC(J) .EQ. 0) THEN
              NEWEL = NEWEL + 1
              NFRONT_EFF = NFRONT_EFF + 1
              IW(NEWEL) = J
              INTARR(JJ) = NFRONT_EFF
              ITLOC(J) = NFRONT_EFF
            ELSE
              INTARR(JJ) = ITLOC(J)
            ENDIF
  110     CONTINUE
        ENDIF
  120 END DO
      IF (NFRONT.NE.NFRONT_EFF) THEN
       IF (NUMORG.EQ.NASS1) THEN
        IP1 = IOLDPS + HF
        IP2 = IOLDPS + HF + NFRONT_EFF - 1
        DO I = IP1, IP2
         IW(I + NFRONT_EFF) = IW(I)
        ENDDO
       ELSE
        IP1 = IOLDPS + NFRONT + HF + NUMORG
        IP2 = IOLDPS + HF + NFRONT_EFF + NUMORG
        IW(IP2:IP2+NASS-1) = IW(IP1:IP1+NASS-1)
        IP1 = IOLDPS + NASS1 + HF
        IP2 = IOLDPS + HF + NFRONT - 1
        DO I = IP1, IP2
         IW(I + NFRONT_EFF) = IW(I)
        ENDDO
        IP1 = IOLDPS + HF
        IP2 = IOLDPS + HF + NUMORG - 1
        DO I = IP1, IP2
          IW(I + NFRONT_EFF) = IW(I)
        ENDDO
       ENDIF
      ELSE
       IP1 = IOLDPS + NASS1 + HF
       IP2 = IOLDPS + HF + NFRONT - 1
       DO I = IP1, IP2
        IW(I + NFRONT) = IW(I)
       ENDDO
       IP1 = IOLDPS + HF
       IP2 = IOLDPS + HF + NUMORG - 1
       DO I = IP1, IP2
         IW(I + NFRONT) = IW(I)
       ENDDO
      ENDIF
      K1 = IOLDPS + HF + NUMORG
      K2 = K1 + NFRONT_EFF - 1 + NASS
      DO 150 K = K1, K2
        I = IW(K)
        ITLOC(I) = 0
  150 END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_81
      SUBROUTINE AGMG_MUMPS_124(                                             &
     &           NUMELT, LIST_ELT,                                      &
     &           MYID, INODE, N, IOLDPS,                                &
     &           HF, NFRONT, NFRONT_EFF,                                &
     &           NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                  &
     &           IFSON, STEP, PIMASTER, PTRAIW, NELT,                   &
     &           IW, LIW,                                               &
     &           INTARR, LINTARR, ITLOC, FILS, FRERE_STEPS,             &
     &           KEEP,                                                  &
     &           SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
      IMPLICIT NONE
      INTEGER NELT, INODE, N, IOLDPS, HF, NFRONT, NASS1, LIW, NASS,     &
     &        NUMSTK, NUMORG, IWPOSCB, IFSON, MYID, IFLAG,              &
     &        LINTARR, NUMELT, NFRONT_EFF
      INTEGER KEEP(500)
      INTEGER LIST_ELT(*)
      INTEGER STEP(N),                                                  &
     & PIMASTER(KEEP(28)),                                              &
     &  PTRAIW(NELT+1), IW(LIW),                                        &
     &        ITLOC(N), FILS(N), FRERE_STEPS(KEEP(28)),                 &
     &        NBPROCFILS(KEEP(28))
      INTEGER INTARR(LINTARR)
      LOGICAL SON_LEVEL2, NIV1
      INTEGER NEWEL, INEW, IOLDP2, INEW1,                               &
     &        IN, NTOTFS, ICT11, NELIM, NPIVS, NSLSON, NCOLS,           &
     &        ITRANS, J, JJ, J1, J2, J3, JT1, ISON, IELL, LSTK,         &
     &        NROWS, HS, IP1, IP2, K1, K2,                              &
     &        I, K, ELTI
      LOGICAL LEVEL1
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      SON_LEVEL2 = .FALSE.
      IOLDP2 = IOLDPS + HF - 1
      NEWEL = IOLDP2 + NASS1
      NFRONT_EFF = NASS1
      IN = INODE
      INEW = IOLDPS + HF
      INEW1 = 1
      DO WHILE (IN.GT.0)
       ITLOC(IN) = INEW1
       IW(INEW)  = IN
       INEW1     = INEW1 + 1
       INEW      = INEW + 1
       IN = FILS(IN)
      END DO
      IF (NUMSTK .NE. 0) THEN
        NTOTFS = NUMORG
        ISON = IFSON
        ICT11 = IOLDP2 + NFRONT
        DO 100 IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK = IW(J2+KEEP(IXSZ))
          NELIM = IW(J2 + 1+KEEP(IXSZ))
          NPIVS = IW(J2 + 3+KEEP(IXSZ))
          IF ( NPIVS .LT. 0 ) NPIVS = 0
          NSLSON = IW(J2 + 5+KEEP(IXSZ))
          IF( NSLSON.GT.0) SON_LEVEL2 = .TRUE.
          LEVEL1    = NSLSON.EQ.0
          NCOLS = NPIVS + LSTK
          NROWS = NCOLS
          ITRANS = NROWS
          IF (NIV1) THEN
           NBPROCFILS(STEP(ISON)) = NSLSON
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE)) + NSLSON
          ELSE
           IF (LEVEL1) THEN
            NBPROCFILS(STEP(ISON)) = 1
           ELSE
            NBPROCFILS(STEP(ISON)) = NSLSON
           ENDIF
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE))+           &
     &                               NBPROCFILS(STEP(ISON))
          ENDIF
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
           ITRANS = NPIVS + NROWS
          ENDIF
          HS = NSLSON + 6 +KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          IF (NELIM .EQ. 0) GOTO 70
          DO 60 JJ = J1, J3
            NTOTFS = NTOTFS + 1
            JT1 = IW(JJ)
            IW(ICT11 + NTOTFS) = JT1
            ITLOC(JT1) = NTOTFS
            IW(JJ) = NTOTFS
            IW(IOLDP2 + NTOTFS) = IW(JJ - ITRANS)
   60     CONTINUE
   70     J1 = J3 + 1
          IF (NASS1 .NE. NFRONT) THEN
            DO 80 JJ = J1, J2
              J = IW(JJ)
              IF (ITLOC(J) .EQ. 0) THEN
                NEWEL = NEWEL + 1
                NFRONT_EFF = NFRONT_EFF + 1
                IW(NEWEL) = J
                IW(JJ) = NFRONT_EFF
                ITLOC(J) = NFRONT_EFF
              ELSE
                IW(JJ) = ITLOC(J)
              ENDIF
   80       CONTINUE
          ELSE
            DO 90 JJ = J1, J2
              IW(JJ) = ITLOC(IW(JJ))
   90       CONTINUE
          ENDIF
          ISON = FRERE_STEPS(STEP(ISON))
  100   CONTINUE
      ENDIF
      DO IELL=1,NUMELT
       ELTI = LIST_ELT(IELL)
       J1= PTRAIW(ELTI)
       J2= PTRAIW(ELTI+1)-1
       DO JJ=J1,J2
          J = INTARR(JJ)
          IF (ITLOC(J) .EQ. 0) THEN
              NEWEL = NEWEL + 1
              NFRONT_EFF = NFRONT_EFF + 1
              IW(NEWEL)  = J
              INTARR(JJ) = NFRONT_EFF
              ITLOC(J)   = NFRONT_EFF
          ELSE
              INTARR(JJ) = ITLOC(J)
          ENDIF
       END DO
      ENDDO
      IF (NFRONT.NE.NFRONT_EFF) THEN
       IF (NUMORG.EQ.NASS1) THEN
        IP1 = IOLDPS + HF
        IP2 = IOLDPS + HF + NFRONT_EFF - 1
        DO I = IP1, IP2
         IW(I + NFRONT_EFF) = IW(I)
        ENDDO
       ELSE
        IP1 = IOLDPS + NFRONT + HF + NUMORG
        IP2 = IOLDPS + HF + NFRONT_EFF + NUMORG
        IW(IP2:IP2+NASS-1) = IW(IP1:IP1+NASS-1)
        IP1 = IOLDPS + NASS1 + HF
        IP2 = IOLDPS + HF + NFRONT - 1
        DO I = IP1, IP2
         IW(I + NFRONT_EFF) = IW(I)
        ENDDO
        IP1 = IOLDPS + HF
        IP2 = IOLDPS + HF + NUMORG - 1
        DO I = IP1, IP2
          IW(I + NFRONT_EFF) = IW(I)
        ENDDO
       ENDIF
      ELSE
       IP1 = IOLDPS + NASS1 + HF
       IP2 = IOLDPS + HF + NFRONT - 1
       DO I = IP1, IP2
        IW(I + NFRONT) = IW(I)
       ENDDO
       IP1 = IOLDPS + HF
       IP2 = IOLDPS + HF + NUMORG - 1
       DO I = IP1, IP2
         IW(I + NFRONT) = IW(I)
       ENDDO
      ENDIF
      K1 = IOLDPS + HF + NUMORG
      K2 = K1 + NFRONT_EFF - 1 + NASS
      DO 150 K = K1, K2
        I = IW(K)
        ITLOC(I) = 0
  150 END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_124
      SUBROUTINE AGMG_MUMPS_86(MYID, INODE, N, IOLDPS,                       &
     &           HF, NFRONT, NFRONT_EFF, PERM,                          &
     &           NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                  &
     &           IFSON, STEP, PIMASTER, PTRAIW, IW, LIW,                &
     &           INTARR, ITLOC, FILS, FRERE_STEPS,                      &
     &           SON_LEVEL2, NIV1, NBPROCFILS, KEEP,KEEP8, IFLAG,       &
     &           ISON_IN_PLACE)
      IMPLICIT NONE
      INTEGER INODE, N, IOLDPS, HF, NFRONT, NASS1, LIW, NASS,           &
     &        NUMSTK, NUMORG, IWPOSCB, IFSON, MYID, IFLAG,              &
     &        NFRONT_EFF
      INTEGER ISON_IN_PLACE
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER STEP(N),                                                  &
     & PIMASTER(KEEP(28)),                                              &
     &  PTRAIW(N), IW(LIW),                                             &
     &        ITLOC(N), FILS(N), FRERE_STEPS(KEEP(28)),                 &
     &        NBPROCFILS(KEEP(28)), PERM(N)
      INTEGER INTARR(max(1,KEEP(14)))
      LOGICAL SON_LEVEL2, NIV1
      INTEGER NELIM_SON_IN_PLACE
      INTEGER NEWEL, IOLDP2, INEW, INEW1,                               &
     &        IN, NTOTFS, ICT11, NELIM, NPIVS, NSLSON, NCOLS,           &
     &        ITRANS, J, JJ, J1, J2, J3, JT1, ISON, IELL, LSTK,         &
     &        NROWS, HS, IP1, IP2, K1, K2, IBROT, IORG,                 &
     &        I, K, JDEBROW, ILOC, NEWEL_SAVE, NEWEL1_SAVE,             &
     &        LAST_J_ASS, JMIN, MIN_PERM
      LOGICAL LEVEL1
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      INTEGER allocok
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PTTRI, PTLAST
      ALLOCATE(PTTRI(NUMSTK+1), stat=allocok)
      IF (allocok .GT. 0) THEN
       IFLAG = -13
       GOTO 800
      ENDIF
      ALLOCATE(PTLAST(NUMSTK+1), stat=allocok)
      IF (allocok .GT. 0) THEN
       IFLAG = -13
       GOTO 800
      ENDIF
      SON_LEVEL2 = .FALSE.
      IOLDP2     = IOLDPS + HF - 1
      ICT11      = IOLDP2 + NFRONT
      NFRONT_EFF = NASS1
      NTOTFS = 0
      NELIM_SON_IN_PLACE = 0
      IF ( ISON_IN_PLACE > 0 ) THEN
        ISON  = ISON_IN_PLACE
        J2    = PIMASTER(STEP(ISON))
        LSTK   = IW(J2    +KEEP(IXSZ))
        NELIM = IW(J2 + 1+KEEP(IXSZ))
        NPIVS  = IW(J2 + 3+KEEP(IXSZ))
        IF (NPIVS.LT.0) NPIVS = 0
        NSLSON = IW(J2 + 5+KEEP(IXSZ))
        NCOLS  = NPIVS + LSTK
        NROWS  = NCOLS
        ITRANS = NROWS
        IF ( J2.GT. IWPOSCB ) THEN
          NROWS = IW(J2 + 2+KEEP(IXSZ))
          ITRANS = NPIVS + NROWS
        ENDIF
        HS = NSLSON + 6 + KEEP(IXSZ)
        J1 = J2 + HS + NROWS + NPIVS
        J2 = J1 + LSTK - 1
        J3 = J1 + NELIM - 1
        DO JJ = J1, J3
          NTOTFS = NTOTFS + 1
          JT1 = IW(JJ)
          IW(ICT11 + NTOTFS) = JT1
          ITLOC(JT1) = NTOTFS
          IW(JJ) = NTOTFS
          IW(IOLDP2 + NTOTFS) = IW(JJ - ITRANS)
        ENDDO
        NELIM_SON_IN_PLACE = NTOTFS
      ENDIF
      IN = INODE
      INEW = IOLDPS + HF +  NTOTFS
      INEW1 = NTOTFS + 1
      JDEBROW = PTRAIW(INODE)+3
      PTTRI(NUMSTK+1)  = JDEBROW
      PTLAST(NUMSTK+1) = JDEBROW + INTARR(JDEBROW-3) - 1
   50 J1 = PTRAIW(IN) + 2
      JT1 = INTARR(J1)
      INTARR(J1) = INEW1
      ITLOC(JT1) = INEW1
      IW(INEW)         = JT1
      IW (INEW+NFRONT) = JT1
      INEW = INEW + 1
      INEW1 = INEW1 + 1
      IN = FILS(IN)
      IF (IN .GT. 0) GOTO 50
      NTOTFS = NTOTFS + NUMORG
      IF (NUMSTK .NE. 0) THEN
        ISON = IFSON
        DO IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK   = IW(J2    +KEEP(IXSZ))
          NELIM  = IW(J2 + 1+KEEP(IXSZ))
          NPIVS  = IW(J2 + 3+KEEP(IXSZ))
          IF (NPIVS.LT.0) NPIVS = 0
          NSLSON = IW(J2 + 5+KEEP(IXSZ))
          IF( NSLSON.GT.0) SON_LEVEL2 = .TRUE.
          LEVEL1    = NSLSON.EQ.0
          NCOLS  = NPIVS + LSTK
          NROWS  = NCOLS
          ITRANS = NROWS
          IF (NIV1) THEN
           NBPROCFILS(STEP(ISON)) = NSLSON
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE)) + NSLSON
          ELSE
           IF (LEVEL1) THEN
            NBPROCFILS(STEP(ISON)) = 1
           ELSE
            NBPROCFILS(STEP(ISON)) = NSLSON
           ENDIF
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE))+           &
     &                               NBPROCFILS(STEP(ISON))
          ENDIF
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
           ITRANS = NPIVS + NROWS
          ENDIF
          HS = NSLSON + 6 + KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          IF (NELIM .NE. 0 .AND. ISON.NE.ISON_IN_PLACE) THEN
            DO JJ = J1, J3
              NTOTFS = NTOTFS + 1
              JT1 = IW(JJ)
              IW(ICT11 + NTOTFS) = JT1
              ITLOC(JT1) = NTOTFS
              IW(JJ) = NTOTFS
              IW(IOLDP2 + NTOTFS) = IW(JJ - ITRANS)
            ENDDO
          ENDIF
          PTTRI(IELL)  = J2+1
          PTLAST(IELL) = J2
          J1 = J3 + 1
          IF (NASS1 .NE. NFRONT) THEN
            DO JJ = J1, J2
              J = IW(JJ)
              IF (ITLOC(J) .EQ. 0) THEN
                PTTRI(IELL) = JJ
                EXIT
              ENDIF
            ENDDO
          ELSE
            DO JJ = J1, J2
              IW(JJ) = ITLOC(IW(JJ))
            ENDDO
          ENDIF
          ISON = FRERE_STEPS(STEP(ISON))
        ENDDO
      ENDIF
      IF (NFRONT.EQ.NASS1) GOTO 600
  199 CONTINUE
      IF ( PTTRI( NUMSTK + 1 ) .LE. PTLAST( NUMSTK + 1 ) ) THEN
      IF ( ITLOC( INTARR( PTTRI( NUMSTK + 1 ) ) ) .NE. 0 ) THEN
       PTTRI( NUMSTK + 1 ) = PTTRI( NUMSTK + 1 ) + 1
       GOTO 199
      END IF
      END IF
      MIN_PERM = N + 1
      DO IELL = 1, NUMSTK
        ILOC = PTTRI( IELL )
        IF ( ILOC .LE. PTLAST( IELL ) ) THEN
         IF ( PERM( IW( ILOC ) ) .LT. MIN_PERM ) THEN
           JMIN     = IW( ILOC )
           MIN_PERM = PERM( JMIN )
         END IF
        END IF
      END DO
      IELL = NUMSTK + 1
      ILOC =  PTTRI( IELL )
      IF ( ILOC .LE. PTLAST( IELL ) ) THEN
        IF ( PERM( INTARR( ILOC ) ) .LT. MIN_PERM ) THEN
         JMIN        = INTARR( ILOC )
         MIN_PERM = PERM( JMIN )
        END IF
      END IF
      NEWEL = IOLDP2 + NASS1 + NFRONT
      DO WHILE ( MIN_PERM .NE. N + 1 )
          NEWEL  = NEWEL + 1
          NFRONT_EFF = NFRONT_EFF + 1
          IW( NEWEL ) = JMIN
          ITLOC( JMIN ) = NFRONT_EFF
          LAST_J_ASS = JMIN
          MIN_PERM = N + 1
          DO IELL = 1,  NUMSTK
            IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
              IF ( IW( PTTRI( IELL ) ) .eq. LAST_J_ASS )                &
     &        PTTRI( IELL ) = PTTRI( IELL ) + 1
            ENDIF
            IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
             IF ( PERM(IW( PTTRI( IELL )) ) .LT. MIN_PERM ) THEN
                JMIN        = IW( PTTRI( IELL ) )
                MIN_PERM = PERM( JMIN )
             END IF
            END IF
          END DO
          IELL = NUMSTK + 1
  145     CONTINUE
          IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
            IF ( INTARR( PTTRI( IELL ) ) .eq. LAST_J_ASS ) THEN
              PTTRI( IELL ) = PTTRI( IELL ) + 1
              GOTO 145
            END IF
          END IF
          IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
            IF (PERM(INTARR( PTTRI(IELL) )) .LT. MIN_PERM) THEN
              JMIN        = INTARR( PTTRI(IELL) )
              MIN_PERM = PERM( JMIN )
            END IF
          END IF
      END DO
      NEWEL_SAVE  = NEWEL
      NEWEL1_SAVE = NFRONT_EFF
      IF (NEWEL1_SAVE.LT.NFRONT) THEN
       IBROT = INODE
       DO IORG = 1, NUMORG
         J1    = PTRAIW(IBROT) + 2
         J2    = J1 + INTARR(J1 - 2) - INTARR(J1-1)
         IBROT = FILS( IBROT )
         IF ( IORG.EQ. 1) THEN
           IF ( KEEP(50).NE.0 ) CYCLE
           J1 = J1 + 1 + INTARR(J1-2)
         ELSE
           J1 = J1 + 1
         ENDIF
         DO JJ = J1, J2
           J     = INTARR( JJ )
           IF ( ITLOC( J ) .eq. 0 ) THEN
            NEWEL  = NEWEL + 1
            NFRONT_EFF = NFRONT_EFF + 1
            IW( NEWEL ) = J
            ITLOC( J ) = NFRONT_EFF
           END IF
         ENDDO
       ENDDO
      ENDIF
      IF ( NEWEL1_SAVE .eq. NFRONT_EFF ) THEN
        IW( IOLDP2+NASS1+1 : IOLDP2+NFRONT_EFF ) =                      &
     &    IW( ICT11+NASS1+1 : ICT11+NFRONT_EFF )
      ELSE
        CALL AGMG_MUMPS_308( N, PERM,                                        &
     &           IW( NEWEL_SAVE + 1 ), NFRONT_EFF - NEWEL1_SAVE )
        CALL AGMG_MUMPS_309( N, NASS1, PERM, ITLOC,                          &
     &    IW( NEWEL_SAVE + 1), NFRONT_EFF - NEWEL1_SAVE,                &
     &    IW( ICT11  + NASS1 + 1 ), NEWEL1_SAVE - NASS1,                &
     &    IW( IOLDP2 + NASS1 + 1 ), NFRONT_EFF - NASS1 )
        IW(ICT11+NASS1+1:ICT11+NFRONT_EFF)=                             &
     &    IW(IOLDP2+NASS1+1:IOLDP2+NFRONT_EFF)
      END IF
      IF (NFRONT.NE.NFRONT_EFF) THEN
        IP1 = IOLDPS + NFRONT + HF
        IP2 = IOLDPS + NFRONT_EFF + HF
        DO I=1, NFRONT_EFF
          IW(IP2+I-1)=IW(IP1+I-1)
        ENDDO
      ENDIF
  600 CONTINUE
      IF ((NUMSTK .NE. 0).AND.(NFRONT.GT.NASS1)) THEN
        ISON = IFSON
        DO IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK = IW(J2+KEEP(IXSZ))
          NELIM = IW(J2 + 1+KEEP(IXSZ))
          NPIVS = IW(J2 + 3+KEEP(IXSZ))
          IF (NPIVS.LT.0) NPIVS = 0
          NSLSON = IW(J2 + 5+KEEP(IXSZ))
          NCOLS = NPIVS + LSTK
          NROWS = NCOLS
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
          ENDIF
          HS = NSLSON + 6 +KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          J1 = J3 + 1
          DO JJ = J1, J2
              J = IW(JJ)
                IW(JJ) = ITLOC(J)
          ENDDO
          ISON = FRERE_STEPS(STEP(ISON))
        ENDDO
      ENDIF
      IBROT = INODE
      DO IORG = 1, NUMORG
        J1 = PTRAIW(IBROT) + 2
        IBROT = FILS(IBROT)
        J2 = J1 + INTARR(J1 - 2) - INTARR(J1 - 1)
        J1 = J1 + 1
        IF (J1 .LE. J2) THEN
          DO JJ = J1, J2
            J = INTARR(JJ)
            INTARR(JJ) = ITLOC(J)
          ENDDO
        ENDIF
      ENDDO
        K1 = IOLDPS + HF
        K2 = K1 + NFRONT_EFF -1
        IF (KEEP(50).EQ.0) K2 = K2 + NELIM_SON_IN_PLACE
        DO K = K1, K2
          I = IW(K)
          ITLOC(I) = 0
        ENDDO
        IF (KEEP(50).EQ.0) THEN
          K1 = IOLDPS+HF+NFRONT_EFF+NELIM_SON_IN_PLACE+NUMORG
          K2 = K1 + NASS -NELIM_SON_IN_PLACE - 1
          DO K = K1, K2
            I = IW(K)
            ITLOC(I) = 0
          ENDDO
        ENDIF
  800 CONTINUE
      IF (allocated(PTTRI)) DEALLOCATE(PTTRI)
      IF (allocated(PTLAST)) DEALLOCATE(PTLAST)
      RETURN
      END SUBROUTINE AGMG_MUMPS_86
      SUBROUTINE AGMG_MUMPS_308( N, PERM, IW, LIW )
      IMPLICIT NONE
      INTEGER N, LIW
      INTEGER PERM( N ), IW( LIW )
      INTEGER I, SWAP
      LOGICAL DONE
      DONE = .FALSE.
      DO WHILE ( .NOT. DONE )
        DONE = .TRUE.
        DO I = 1, LIW - 1
          IF ( PERM( IW( I ) ) .GT. PERM( IW( I + 1 ) ) ) THEN
            DONE = .FALSE.
            SWAP  = IW( I + 1 )
            IW( I + 1 ) = IW( I )
            IW( I ) = SWAP
          END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_308
      SUBROUTINE AGMG_MUMPS_309( N, NASS1, PERM, ITLOC,                      &
     &                             SMALL, LSMALL,                       &
     &                             LARGE, LLARGE,                       &
     &                             MERGE, LMERGE )
      IMPLICIT NONE
      INTEGER N, NASS1, LSMALL, LLARGE, LMERGE
      INTEGER PERM( N ), ITLOC( N )
      INTEGER SMALL(LSMALL), LARGE(LLARGE), MERGE(LMERGE)
      INTEGER PSMALL, PLARGE, PMERGE, VSMALL, VLARGE, VMERGE
      PSMALL = 1
      PLARGE = 1
      PMERGE = 1
      DO WHILE ( PSMALL .LE. LSMALL .or. PLARGE.LE. LLARGE )
        IF ( PSMALL .GT. LSMALL ) THEN
          VMERGE = LARGE( PLARGE )
          PLARGE = PLARGE + 1
        ELSE IF ( PLARGE .GT. LLARGE ) THEN
          VMERGE = SMALL( PSMALL )
          PSMALL = PSMALL + 1
        ELSE
          VSMALL = SMALL( PSMALL )
          VLARGE = LARGE( PLARGE )
          IF ( PERM( VSMALL ) .LT. PERM( VLARGE ) ) THEN
            VMERGE = VSMALL
            PSMALL   = PSMALL + 1
          ELSE
            VMERGE = VLARGE
            PLARGE   = PLARGE + 1
          END IF
        END IF
        MERGE( PMERGE ) = VMERGE
        ITLOC( VMERGE ) = PMERGE + NASS1
        PMERGE = PMERGE + 1
      END DO
      PMERGE = PMERGE - 1
      RETURN
      END SUBROUTINE AGMG_MUMPS_309
      SUBROUTINE AGMG_MUMPS_88( MYID, N, PERM,                               &
     &                             ITLOC,                               &
     &                             IW, LIW, NASS1 )
      IMPLICIT NONE
      INTEGER MYID, N, LIW, NASS1
      INTEGER PERM( N ), ITLOC( N ), IW( LIW )
      INTEGER I, J
      IF ( LIW .eq. 0 ) RETURN
      IF ( NASS1 .eq. 0 ) THEN
      END IF
      DO I = 1, LIW - 1
        IF ( PERM( IW( I ) ) .GE. PERM( IW( I + 1 ) ) ) THEN
          WRITE(*,*) MYID,                                              &
     &    ':Error in MUMPS_88: not sorted'
          WRITE(*,*) MYID,':List = ',IW(1:LIW)
          WRITE(*,*) MYID,':Permuted list =', (PERM(IW(J)),J=1,LIW)
          CALL AGMG_MUMPS_ABORT()
        END IF
        IF (ITLOC( IW( I + 1 ) ) .NE. ITLOC( IW( I ) ) + 1 ) THEN
          WRITE(*,*) MYID,':Error in MUMPS_88: bad ITLOC'
          WRITE(*,*) MYID,':ITLOC( IW ) =',(ITLOC(IW(J)),J=1,LIW)
          CALL AGMG_MUMPS_ABORT()
        END IF
      END DO
      IF ( ITLOC( IW( 1 ) )  .NE. NASS1 + 1 ) THEN
        WRITE(*,*) MYID,': Bad First ITLOC ITLOC(IW(1)),NASS1+1=',      &
     &              ITLOC( IW( 1 ) ), NASS1 + 1
        CALL AGMG_MUMPS_ABORT()
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_88
      SUBROUTINE AGMG_MUMPS_125(                                             &
     &           NUMELT, LIST_ELT,                                      &
     &           MYID, INODE, N, IOLDPS,                                &
     &           HF, NFRONT, NFRONT_EFF, PERM,                          &
     &           NASS1, NASS, NUMSTK, NUMORG, IWPOSCB,                  &
     &           IFSON, STEP, PIMASTER, PTRAIW, NELT,                   &
     &           IW, LIW,                                               &
     &           INTARR, LINTARR, ITLOC, FILS, FRERE_STEPS,             &
     &           KEEP, SON_LEVEL2, NIV1, NBPROCFILS, IFLAG)
      IMPLICIT NONE
      INTEGER NELT, INODE, N, IOLDPS, HF, NFRONT, NASS1, LIW, NASS,     &
     &        NUMSTK, NUMORG, IWPOSCB, IFSON, MYID, IFLAG,              &
     &        LINTARR, NUMELT, NFRONT_EFF
      INTEGER KEEP(500)
      INTEGER LIST_ELT(*)
      INTEGER STEP(N), PIMASTER(KEEP(28)),                              &
     &  PTRAIW(NELT+1), IW(LIW),                                        &
     &        ITLOC(N), FILS(N), FRERE_STEPS(KEEP(28)),                 &
     &        NBPROCFILS(KEEP(28)), PERM(N)
      INTEGER INTARR(LINTARR)
      LOGICAL SON_LEVEL2, NIV1
      INTEGER NEWEL, IOLDP2, INEW, INEW1,                               &
     &        IN, NTOTFS, ICT11, NELIM, NPIVS, NSLSON, NCOLS,           &
     &        ITRANS, J, JJ, J1, J2, J3, JT1, ISON, IELL, LSTK,         &
     &        NROWS, HS, IP1, IP2, K1, K2, IBROT, IORG,                 &
     &        I, K, JDEBROW, ILOC, NEWEL_SAVE, NEWEL1_SAVE,             &
     &        LAST_J_ASS, JMIN, MIN_PERM
      INTEGER ELTI
!
!  This file is part of MUMPS 4.9.2, built on Thu Nov  5 07:05:08 UTC 20
!
!
!  This version of MUMPS is provided to you free of charge. It is public
!  domain, based on public domain software developed during the Esprit I
!  European project PARASOL (1996-1999) by CERFACS, ENSEEIHT-IRIT and RA
!  Since this first public domain version in 1999, the developments are
!  supported by the following institutions: CERFACS, CNRS, INPT(ENSEEIHT
!  IRIT, and INRIA.
!
!  Current development team includes Patrick Amestoy, Alfredo Buttari,
!  Abdou Guermouche, Jean-Yves L'Excellent, Bora Ucar.
!
!  Up-to-date copies of the MUMPS package can be obtained
!  from the Web pages:
!  http://mumps.enseeiht.fr/  or  http://graal.ens-lyon.fr/MUMPS
!
!
!   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
!   EXPRESSED OR IMPLIED. ANY USE IS AT YOUR OWN RISK.
!
!
!  User documentation of any code that uses this software can
!  include this complete notice. You can acknowledge (using
!  references [1] and [2]) the contribution of this package
!  in any scientific publication dependent upon the use of the
!  package. You shall use reasonable endeavours to notify
!  the authors of the package of this publication.
!
!   [1] P. R. Amestoy, I. S. Duff, J. Koster and  J.-Y. L'Excellent,
!   A fully asynchronous multifrontal solver using distributed dynamic
!   scheduling, SIAM Journal of Matrix Analysis and Applications,
!   Vol 23, No 1, pp 15-41 (2001).
!
!   [2] P. R. Amestoy and A. Guermouche and J.-Y. L'Excellent and
!   S. Pralet, Hybrid scheduling for the parallel solution of linear
!   systems. Parallel Computing Vol 32 (2), pp 136-156 (2006).
!
      INTEGER XXI, XXR, XXS, XXN, XXP
      PARAMETER(XXI=0,XXR=1,XXS=3,XXN=4,XXP=5)
      INTEGER XXNDIAG2W
      PARAMETER(XXNDIAG2W=6)
      INTEGER XSIZE_IC, XSIZE_OOC_SYM, XSIZE_OOC_UNSYM
      INTEGER XSIZE_OOC_NOPANEL
      PARAMETER (XSIZE_IC=6,XSIZE_OOC_SYM=7,XSIZE_OOC_UNSYM=7,          &
     &           XSIZE_OOC_NOPANEL=6)
      INTEGER IXSZ
      PARAMETER(IXSZ= 222)
      INTEGER S_CB1COMP
      PARAMETER (S_CB1COMP=314)
      INTEGER S_ACTIVE, S_ALL, S_NOLCBCONTIG,                           &
     &        S_NOLCBNOCONTIG, S_NOLCLEANED,                            &
     &        S_NOLCBNOCONTIG38, S_NOLCBCONTIG38,                       &
     &        S_NOLCLEANED38, C_FINI
      PARAMETER(S_ACTIVE=400, S_ALL=401, S_NOLCBCONTIG=402,             &
     &          S_NOLCBNOCONTIG=403, S_NOLCLEANED=404,                  &
     &          S_NOLCBNOCONTIG38=405, S_NOLCBCONTIG38=406,             &
     &          S_NOLCLEANED38=407,C_FINI=1)
      INTEGER S_FREE, S_NOTFREE
      PARAMETER(S_FREE=54321,S_NOTFREE=-123456)
      INTEGER TOP_OF_STACK
      PARAMETER(TOP_OF_STACK=-999999)
      INTEGER XTRA_SLAVES_SYM, XTRA_SLAVES_UNSYM
      PARAMETER(XTRA_SLAVES_SYM=3, XTRA_SLAVES_UNSYM=1)
         INTEGER S_ROOT2SON_CALLED, S_REC_CONTSTATIC,                   &
     &  S_ROOTBAND_INIT
         PARAMETER(S_ROOT2SON_CALLED=-341,S_REC_CONTSTATIC=1,           &
     &             S_ROOTBAND_INIT=0)
      LOGICAL LEVEL1
      INTEGER allocok
      INTEGER , ALLOCATABLE, DIMENSION(:) :: PTTRI, PTLAST
      IF (NUMSTK.GT.0) THEN
        ALLOCATE(PTTRI(NUMSTK), stat=allocok)
        IF (allocok .GT. 0) THEN
         IFLAG = -13
         GOTO 800
        ENDIF
        ALLOCATE(PTLAST(NUMSTK), stat=allocok)
        IF (allocok .GT. 0) THEN
         IFLAG = -13
         GOTO 800
        ENDIF
      ENDIF
      SON_LEVEL2 = .FALSE.
      IOLDP2 = IOLDPS + HF - 1
      ICT11  = IOLDP2 + NFRONT
      NFRONT_EFF = NASS1
      IN = INODE
      INEW = IOLDPS + HF
      INEW1 = 1
      DO WHILE (IN.GT.0)
       ITLOC(IN)        = INEW1
       IW(INEW)         = IN
       IW(INEW+NFRONT)  = IN
       INEW1     = INEW1 + 1
       INEW      = INEW + 1
       IN = FILS(IN)
      END DO
      NTOTFS = NUMORG
      IF (NUMSTK .NE. 0) THEN
        ISON = IFSON
        DO IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK   = IW(J2    +KEEP(IXSZ))
          NELIM  = IW(J2 + 1+KEEP(IXSZ))
          NPIVS  = IW(J2 + 3+KEEP(IXSZ))
          IF (NPIVS.LT.0) NPIVS = 0
          NSLSON = IW(J2 + 5+KEEP(IXSZ))
          IF( NSLSON.GT.0) SON_LEVEL2 = .TRUE.
          LEVEL1    = NSLSON.EQ.0
          NCOLS  = NPIVS + LSTK
          NROWS  = NCOLS
          ITRANS = NROWS
          IF (NIV1) THEN
           NBPROCFILS(STEP(ISON)) = NSLSON
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE)) + NSLSON
          ELSE
           IF (LEVEL1) THEN
            NBPROCFILS(STEP(ISON)) = 1
           ELSE
            NBPROCFILS(STEP(ISON)) = NSLSON
           ENDIF
           NBPROCFILS(STEP(INODE)) = NBPROCFILS(STEP(INODE))+           &
     &                               NBPROCFILS(STEP(ISON))
          ENDIF
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
           ITRANS = NPIVS + NROWS
          ENDIF
          HS = NSLSON + 6 + KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          IF (NELIM .NE. 0) THEN
            DO JJ = J1, J3
              NTOTFS = NTOTFS + 1
              JT1 = IW(JJ)
              IW(ICT11 + NTOTFS) = JT1
              ITLOC(JT1) = NTOTFS
              IW(JJ) = NTOTFS
              IW(IOLDP2 + NTOTFS) = IW(JJ - ITRANS)
            ENDDO
          ENDIF
          PTTRI(IELL)  = J2+1
          PTLAST(IELL) = J2
          J1 = J3 + 1
          IF (NASS1 .NE. NFRONT) THEN
            DO JJ = J1, J2
              J = IW(JJ)
              IF (ITLOC(J) .EQ. 0) THEN
                PTTRI(IELL) = JJ
                EXIT
              ENDIF
            ENDDO
          ELSE
            DO JJ = J1, J2
              IW(JJ) = ITLOC(IW(JJ))
            ENDDO
          ENDIF
          ISON = FRERE_STEPS(STEP(ISON))
        ENDDO
      ENDIF
      IF (NFRONT.EQ.NASS1) GOTO 600
      MIN_PERM = N + 1
      JMIN     = -1
      DO IELL = 1, NUMSTK
        ILOC = PTTRI( IELL )
        IF ( ILOC .LE. PTLAST( IELL ) ) THEN
         IF ( PERM( IW( ILOC ) ) .LT. MIN_PERM ) THEN
           JMIN     = IW( ILOC )
           MIN_PERM = PERM( JMIN )
         END IF
        END IF
      END DO
      NEWEL = IOLDP2 + NASS1 + NFRONT
      DO WHILE ( MIN_PERM .NE. N + 1 )
          NEWEL  = NEWEL + 1
          NFRONT_EFF = NFRONT_EFF + 1
          IW( NEWEL ) = JMIN
          ITLOC( JMIN ) = NFRONT_EFF
          LAST_J_ASS = JMIN
          MIN_PERM = N + 1
          DO IELL = 1,  NUMSTK
            IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
              IF ( IW( PTTRI( IELL ) ) .eq. LAST_J_ASS )                &
     &        PTTRI( IELL ) = PTTRI( IELL ) + 1
            ENDIF
            IF ( PTTRI( IELL ) .LE. PTLAST( IELL ) ) THEN
             IF ( PERM(IW( PTTRI( IELL )) ) .LT. MIN_PERM ) THEN
                JMIN        = IW( PTTRI( IELL ) )
                MIN_PERM = PERM( JMIN )
             END IF
            END IF
          END DO
      END DO
      NEWEL_SAVE  = NEWEL
      NEWEL1_SAVE = NFRONT_EFF
      IF (NEWEL1_SAVE.LT.NFRONT) THEN
       DO IELL = 1,NUMELT
        ELTI = LIST_ELT(IELL)
         J1= PTRAIW(ELTI)
         J2= PTRAIW(ELTI+1)-1
         DO JJ=J1,J2
           J     = INTARR( JJ )
           IF ( ITLOC( J ) .eq. 0 ) THEN
            NEWEL  = NEWEL + 1
            NFRONT_EFF = NFRONT_EFF + 1
            IW( NEWEL ) = J
            ITLOC( J ) = NFRONT_EFF
           END IF
         ENDDO
       ENDDO
      END IF
      IF ( NEWEL1_SAVE .eq. NFRONT_EFF ) THEN
       IW( IOLDP2+NASS1+1 : IOLDP2+NFRONT_EFF ) =                       &
     &  IW( ICT11+NASS1+1 : ICT11+NFRONT_EFF )
      ELSE
          CALL AGMG_MUMPS_308( N, PERM,                                      &
     &            IW( NEWEL_SAVE + 1 ), NFRONT_EFF - NEWEL1_SAVE )
          CALL AGMG_MUMPS_309( N, NASS1, PERM, ITLOC,                        &
     &               IW( NEWEL_SAVE + 1), NFRONT_EFF - NEWEL1_SAVE,     &
     &               IW( ICT11  + NASS1 + 1 ), NEWEL1_SAVE - NASS1,     &
     &               IW( IOLDP2 + NASS1 + 1 ), NFRONT_EFF - NASS1 )
      END IF
      IF ( NFRONT_EFF .NE. NEWEL1_SAVE ) THEN
        IP1 = IOLDPS + NASS1 + HF
        IP2 = IOLDPS + HF + NFRONT - 1
        DO I = IP1, IP2
          IW(I + NFRONT) = IW(I)
        ENDDO
      END IF
      IF (NFRONT.NE.NFRONT_EFF) THEN
        IP1 = IOLDPS + NFRONT + HF
        IP2 = IOLDPS + NFRONT_EFF + HF
        IW (IP2:IP2+NFRONT_EFF) = IW (IP1:IP1+NFRONT_EFF)
      ENDIF
  600 CONTINUE
      IF ((NUMSTK .NE. 0).AND.(NFRONT.GT.NASS1)) THEN
        ISON = IFSON
        DO IELL = 1, NUMSTK
          J2 = PIMASTER(STEP(ISON))
          LSTK = IW(J2+KEEP(IXSZ))
          NELIM = IW(J2 + 1 +KEEP(IXSZ))
          NPIVS = IW(J2 + 3 +KEEP(IXSZ))
          IF (NPIVS.LT.0) NPIVS = 0
          NSLSON = IW(J2 + 5 +KEEP(IXSZ))
          NCOLS = NPIVS + LSTK
          NROWS = NCOLS
          IF (J2.GT.IWPOSCB) THEN
           NROWS = IW(J2 + 2+KEEP(IXSZ))
          ENDIF
          HS = NSLSON + 6 +KEEP(IXSZ)
          J1 = J2 + HS + NROWS + NPIVS
          J2 = J1 + LSTK - 1
          J3 = J1 + NELIM - 1
          J1 = J3 + 1
          DO JJ = J1, J2
              J = IW(JJ)
                IW(JJ) = ITLOC(J)
          ENDDO
          ISON = FRERE_STEPS(STEP(ISON))
        ENDDO
      ENDIF
      DO IELL=1,NUMELT
       ELTI = LIST_ELT(IELL)
       J1= PTRAIW(ELTI)
       J2= PTRAIW(ELTI+1)-1
       DO JJ=J1,J2
          J = INTARR(JJ)
          INTARR(JJ) = ITLOC(J)
       END DO
      ENDDO
        K1 = IOLDPS + HF + NUMORG
        K2 = K1 + NFRONT_EFF - 1 + NASS
        DO K = K1, K2
          I = IW(K)
          ITLOC(I) = 0
        ENDDO
  800 CONTINUE
      IF (allocated(PTTRI)) DEALLOCATE(PTTRI)
      IF (allocated(PTLAST)) DEALLOCATE(PTLAST)
      RETURN
      END SUBROUTINE AGMG_MUMPS_125
      INTEGER FUNCTION AGMG_MUMPS_50                                         &
     &         ( SLAVEF, K48, K821, K50,                                &
     &         NFRONT, NCB)
      IMPLICIT NONE
      INTEGER,    INTENT (IN) :: SLAVEF, K48, K50, NFRONT, NCB
      INTEGER(8), INTENT (IN) :: K821
      INTEGER NSLAVESMIN, NASS, KMAX
      REAL Wmaster, Wtotal, Wmax
      INTEGER I,ACC,X
      REAL AGMG_MUMPS_45
      INTEGER AGMG_MUMPS_497
      EXTERNAL  AGMG_MUMPS_45, AGMG_MUMPS_497
      KMAX = AGMG_MUMPS_497( K821, NCB )
      NASS = NFRONT - NCB
      NSLAVESMIN  = 1
      IF ( K48 .EQ.0 .OR. (K48.EQ.5 .AND.K50.EQ.0)) THEN
         NSLAVESMIN = max(NCB/max(1,KMAX),1)
      ELSE IF (K48 .EQ. 3 .OR.(K48.EQ.5 .AND.K50.NE.0) ) THEN
        Wmax    = AGMG_MUMPS_45(KMAX,NFRONT,NASS)
        Wtotal  = AGMG_MUMPS_45(NCB,NFRONT,NASS)
        Wmaster = real(NASS*NASS)*real(NASS)/(3.0)
        IF ( Wmaster .GT.  Wmax ) THEN
         NSLAVESMIN = max ( nint ( Wtotal / Wmaster ), 1 )
        ELSE
         NSLAVESMIN = max ( nint ( Wtotal / Wmax ), 1 )
        ENDIF
        IF (K48 .EQ. 5) THEN
          NSLAVESMIN = max ( NSLAVESMIN/2, 1 )
        END IF
      ELSE IF (K48 .EQ. 4 ) THEN
         IF ( K821 > 0_8 ) THEN
           WRITE(*,*) 'Internal Error 1 in MUMPS_50'
           CALL AGMG_MUMPS_ABORT()
         ENDIF
         CALL AGMG_MUMPS_ABORT_ON_OVERFLOW(K821,                             &
     &           "K821 too large in AGMG_MUMPS_50" )
         KMAX=int(abs(K821))
         IF(K50.EQ.0)THEN
            NSLAVESMIN = max(int(                                       &
     &                (int(NCB,8)*int(NCB,8))/int(KMAX,8)               &
     &                  ),1)
         ELSE
            ACC=0
            NSLAVESMIN=0
            DO WHILE (ACC.NE.NCB)
               X=int((-real(NFRONT-NCB+ACC)                             &
     &              +sqrt(((real(NFRONT-NCB+ACC)*                       &
     &              real(NFRONT-NCB+ACC))+real(4)*                      &
     &              real(KMAX))))/                                      &
     &              real(2))
               ACC=ACC+X
               NSLAVESMIN=NSLAVESMIN+1
               IF (((NCB-ACC)*NCB).LT.KMAX)THEN
                  ACC=NCB
                  NSLAVESMIN=NSLAVESMIN+1
               ENDIF
            ENDDO
         ENDIF
      ENDIF
      NSLAVESMIN = min ( NSLAVESMIN,(SLAVEF-1) )
      AGMG_MUMPS_50 =                                                        &
     &               min ( NSLAVESMIN, NCB )
      RETURN
      END FUNCTION AGMG_MUMPS_50
      INTEGER FUNCTION AGMG_MUMPS_52                                         &
     &        ( SLAVEF, K48, K821, K50,                                 &
     &          NFRONT, NCB)
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: SLAVEF, K48, K50,NFRONT, NCB
      INTEGER(8), INTENT(IN) :: K821
      INTEGER NSLAVESMAX, KMAX, KMIN
      INTEGER NSLAVESMIN
      INTEGER AGMG_MUMPS_497,AGMG_MUMPS_442,                                      &
     &        AGMG_MUMPS_50,                                                 &
     &        AGMG_MUMPS_46
      EXTERNAL AGMG_MUMPS_497,AGMG_MUMPS_442,                                     &
     &        AGMG_MUMPS_50,                                                 &
     &        AGMG_MUMPS_46
      IF (K48 .eq. 0 .OR. K48.eq.3.OR.K48.EQ.5) THEN
         KMAX = AGMG_MUMPS_497( K821, NCB )
         KMIN = AGMG_MUMPS_442( K821, K50, KMAX, NCB)
         NSLAVESMAX = AGMG_MUMPS_46(                                         &
     &                SLAVEF, K48, K50, KMIN, NFRONT, NCB )
      ELSE
         NSLAVESMAX = SLAVEF-1
      ENDIF
      NSLAVESMIN = AGMG_MUMPS_50(                                            &
     &     SLAVEF, K48, K821, K50, NFRONT, NCB )
      NSLAVESMAX = max ( NSLAVESMAX, NSLAVESMIN )
      AGMG_MUMPS_52 =                                                        &
     &               min ( NSLAVESMAX, NCB )
      RETURN
      END FUNCTION AGMG_MUMPS_52
      SUBROUTINE AGMG_MUMPS_503( WHAT, KEEP,KEEP8,                           &
     &           NCB, NFR, SLAVEF, NBROWMAX, MAXSURFCB8 )
      IMPLICIT NONE
      INTEGER, intent(in) :: WHAT, NCB, NFR, SLAVEF
      INTEGER, intent(in) :: KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER, intent(out) :: NBROWMAX
      INTEGER*8, intent(out) :: MAXSURFCB8
      INTEGER KMAX, KMIN, NSLAVES, SIZEDUMMY, TABDUMMY(1)
      EXTERNAL AGMG_MUMPS_497, AGMG_MUMPS_442,                                    &
     &         AGMG_MUMPS_50
      INTEGER AGMG_MUMPS_497, AGMG_MUMPS_442,                                     &
     &        AGMG_MUMPS_50
      IF ( WHAT .NE. 1 .and. WHAT .NE. 2 ) THEN
        IF (WHAT .NE. 4 .and. WHAT .NE. 5 .AND.                         &
     &       KEEP(48).NE.5 ) THEN
        WRITE(*,*) "Internal error 1 in AGMG_MUMPS_503"
        CALL AGMG_MUMPS_ABORT()
        END IF
      ENDIF
      KMAX    = AGMG_MUMPS_497( KEEP8(21), NCB )
      IF (WHAT .EQ.1.OR.WHAT.EQ.2) THEN
        NSLAVES = AGMG_MUMPS_50( SLAVEF, KEEP(48),                           &
     &            KEEP8(21), KEEP(50),                                  &
     &            NFR, NCB )
      ELSE
        NSLAVES=SLAVEF
      ENDIF
      IF ( KEEP(48) == 0 .OR. (KEEP(48).EQ.5.AND.KEEP(50).EQ.0)) THEN
        NBROWMAX = NCB / NSLAVES + mod( NCB, NSLAVES )
        IF ( WHAT == 2 .OR. WHAT == 5 )                                 &
     &    MAXSURFCB8 = int(NBROWMAX,8) * int(NCB,8)
      ELSE IF (KEEP(48) == 3.OR.(KEEP(48).EQ.5.AND.KEEP(50).NE.0))THEN
        KMIN = AGMG_MUMPS_442( KEEP8(21), KEEP(50), KMAX, NCB )
        SIZEDUMMY        = 1
        IF (WHAT.GT.3) THEN
           CALL  AGMG_MUMPS_440(                                             &
     &          WHAT-3, NSLAVES, NFR, NCB,                              &
     &          KMIN, KMAX, SLAVEF,                                     &
     &          NBROWMAX, MAXSURFCB8, TABDUMMY, SIZEDUMMY)
        ELSE
           CALL  AGMG_MUMPS_440(                                             &
     &          WHAT, NSLAVES, NFR, NCB,                                &
     &          KMIN, KMAX, SLAVEF,                                     &
     &          NBROWMAX, MAXSURFCB8, TABDUMMY, SIZEDUMMY)
        ENDIF
      ELSE IF ( KEEP(48) == 4 ) THEN
         IF (KEEP8(21) > 0_8) THEN
            WRITE(*,*) "Internal error 2 in AGMG_MUMPS_503"
            CALL AGMG_MUMPS_ABORT()
         END IF
         IF(KEEP(50).EQ.0)THEN
            IF ( abs(KEEP8(21)) * int( SLAVEF - 1,8 ) >                 &
     &                            int( NCB,8) * int(NFR,8) ) THEN
              NBROWMAX = (NCB + SLAVEF -2 ) / ( SLAVEF - 1 )
              IF ( WHAT == 2 ) MAXSURFCB8 = int(NBROWMAX,8) *int(NCB,8)
            ELSE
              NBROWMAX=int(                                             &
     &                      (abs(KEEP8(21)) + int(NFR - 1,8))           &
     &                    /  int(NFR,8)                                 &
     &                    )
              IF ( WHAT == 2 ) MAXSURFCB8 = abs(KEEP8(21))
            ENDIF
         ELSE
            NBROWMAX=int((-real(NFR-NCB)                                &
     &              +sqrt((real(NFR-NCB)*                               &
     &              real(NFR-NCB))+real(4)*                             &
     &              real(abs(KEEP8(21)))))/                             &
     &              real(2))
            IF ( WHAT == 2 ) MAXSURFCB8 = abs(KEEP8(21))
         ENDIF
      ELSE
        NBROWMAX = NCB
        IF (WHAT == 2) MAXSURFCB8 = int(NCB,8) * int(NCB,8)
      ENDIF
      NBROWMAX = min ( max(NBROWMAX, 1), NCB)
      RETURN
      END SUBROUTINE AGMG_MUMPS_503
      INTEGER FUNCTION AGMG_MUMPS_46( SLAVEF, K48, K50,                      &
     &         BLSIZE, NFRONT, NCB)
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: SLAVEF, K48, K50, BLSIZE, NFRONT, NCB
      INTEGER NSLAVES, NASS
      REAL Wtotal, Wblsize
      REAL AGMG_MUMPS_45
      EXTERNAL          AGMG_MUMPS_45
      NASS = NFRONT - NCB
      NSLAVES  = SLAVEF-1
      IF ( K48 .EQ.0 .OR. (K48.EQ.5 .AND. K50.EQ.0)) THEN
         NSLAVES = max(NCB/max(1,BLSIZE),1)
      ELSE IF (K48.EQ.3 .OR. (K48.EQ.5 .AND. K50.NE.0))THEN
        Wblsize = AGMG_MUMPS_45(BLSIZE,NFRONT,NASS)
        Wtotal  = AGMG_MUMPS_45(NCB,NFRONT,NASS)
        NSLAVES = max(nint ( Wtotal / Wblsize ), 1)
      ENDIF
      AGMG_MUMPS_46 =                                                        &
     &               min ( NSLAVES,(SLAVEF-1) )
      RETURN
      END FUNCTION AGMG_MUMPS_46
      SUBROUTINE  AGMG_MUMPS_440(                                            &
     &    GETPOSITIONS, NSLAVES, NFRONT, NCB,                           &
     &    KMIN, KMAX, SLAVEF,                                           &
     &    NBROWMAX, MAXSURFCB, TABPOS, SIZETABPOS)
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: GETPOSITIONS,                             &
     &    NSLAVES, NFRONT, NCB,                                         &
     &    KMIN, KMAX, SLAVEF, SIZETABPOS
      INTEGER, INTENT (OUT) :: NBROWMAX
      INTEGER*8, INTENT(OUT) :: MAXSURFCB
      INTEGER, INTENT (OUT) :: TABPOS(SIZETABPOS)
      REAL Wtotal, W, COSTni
      REAL delta
      INTEGER  SumNi, NCOLim1, I, BLSIZE, NASS
      LOGICAL GETROW, GETSURF, GETPOS, GET_AVGROW, GET_AVGSURF
      REAL AGMG_MUMPS_45
      EXTERNAL          AGMG_MUMPS_45
      GETROW = (GETPOSITIONS.EQ.1)
      GETSURF= (GETPOSITIONS.EQ.2)
      GETPOS = (GETPOSITIONS.EQ.3)
      GET_AVGROW = (GETPOSITIONS.EQ.4)
      GET_AVGSURF = (GETPOSITIONS.EQ.5)
      NBROWMAX  = 0
      MAXSURFCB = 0_8
      IF (GETPOS) THEN
        TABPOS (1) = 1
        TABPOS (NSLAVES+1)= NCB+1
        TABPOS (SLAVEF+2) = NSLAVES
      ENDIF
      IF (NSLAVES.EQ.1) THEN
       IF ( GETSURF ) THEN
         NBROWMAX  = NCB
         MAXSURFCB = int(NCB,8)*int(NCB,8)
       ELSEIF ( GETROW ) THEN
         NBROWMAX  = NCB
       ENDIF
      ELSE
        NASS    = NFRONT - NCB
        W       = AGMG_MUMPS_45(NCB,NFRONT,NASS)
        SumNi   = 0
        NCOLim1 = NASS
        DO I = 1, NSLAVES-1
          delta   = real(2*NCOLim1-NASS+1)**2 +                         &
     &                  (real(4)*W)/real(NASS*(NSLAVES-I+1))
          delta   = sqrt(delta)
          delta   = (real(-2*NCOLim1+NASS-1) + delta )/real(2)
          BLSIZE  = max(int(delta), 1)
          IF ( (NFRONT-NCOLim1-BLSIZE) .LE. NSLAVES-I ) THEN
            BLSIZE = 1
          ENDIF
          NCOLim1 = NCOLim1+BLSIZE
          COSTni  = AGMG_MUMPS_45(BLSIZE,NCOLim1,NASS)
          W       = W - COSTni
          IF (GETPOS) TABPOS(I) = SumNi + 1
          IF (GETSURF) THEN
            NBROWMAX  = max ( NBROWMAX,                                 &
     &       BLSIZE )
            MAXSURFCB = max ( MAXSURFCB,                                &
     &       int(BLSIZE,8)* int(SumNi+BLSIZE,8) )
          ELSEIF ( GETROW ) THEN
            NBROWMAX  = max ( NBROWMAX,                                 &
     &       BLSIZE )
             RETURN
          ELSEIF (GET_AVGSURF) THEN
            NBROWMAX = NBROWMAX + BLSIZE
            MAXSURFCB = MAXSURFCB + int(BLSIZE,8)*int(SumNi+BLSIZE,8)
          ELSEIF (GET_AVGROW) THEN
             NBROWMAX = NBROWMAX + BLSIZE
          ENDIF
          SumNi   = SumNi + BLSIZE
        ENDDO
        BLSIZE = NCB - SumNi
        IF (BLSIZE.LE.0) THEN
          write(*,*) ' Error in MUMPS_440: ',                           &
     &     ' size lastbloc ', BLSIZE
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        if (NCOLim1+BLSIZE.NE.NFRONT) then
          write(*,*) ' Error in MUMPS_440: ',                           &
     &     ' NCOLim1, BLSIZE, NFRONT=',                                 &
     &       NCOLim1, BLSIZE, NFRONT
          CALL AGMG_MUMPS_ABORT()
        endif
        IF (GETPOS) TABPOS(NSLAVES) = SumNi + 1
        IF (GETSURF) THEN
            NBROWMAX  = max ( NBROWMAX,                                 &
     &       BLSIZE )
            MAXSURFCB = max ( MAXSURFCB,                                &
     &       int(BLSIZE,8)* int(SumNi+BLSIZE,8 ))
        ELSEIF ( GETROW ) THEN
            NBROWMAX  = max ( NBROWMAX,                                 &
     &       BLSIZE )
        ELSEIF (GET_AVGSURF) THEN
          NBROWMAX = NBROWMAX + BLSIZE
          MAXSURFCB = MAXSURFCB + int(BLSIZE,8)*int(SumNi+BLSIZE,8)
          NBROWMAX=(NBROWMAX+NSLAVES-1)/NSLAVES
          MAXSURFCB=(MAXSURFCB+int(NSLAVES-1,8))/int(NSLAVES,8)
        ELSEIF (GET_AVGROW) THEN
          NBROWMAX = NBROWMAX + BLSIZE
          NBROWMAX=(NBROWMAX+NSLAVES-1)/NSLAVES
        ENDIF
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_440
      SUBROUTINE AGMG_MUMPS_441(                                             &
     &            KEEP,KEEP8, SLAVEF,                                   &
     &            TAB_POS_IN_PERE,                                      &
     &            NSLAVES, NFRONT, NCB                                  &
     &             )
      IMPLICIT NONE
      INTEGER, INTENT( IN ) :: NCB, NSLAVES, SLAVEF, NFRONT,            &
     &                         KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER TAB_POS_IN_PERE(SLAVEF+2)
      INTEGER :: I, BLSIZE
      INTEGER KMIN, KMAX, NBROWDUMMY,                                   &
     &        GETPOSITIONS, SIZECOLTAB
      INTEGER*8 MAXSURFDUMMY8
      INTEGER AGMG_MUMPS_442, AGMG_MUMPS_497
      EXTERNAL AGMG_MUMPS_442, AGMG_MUMPS_497,                                    &
     &        AGMG_MUMPS_440
       IF (KEEP(48).EQ.0) THEN
        BLSIZE = NCB / NSLAVES
        TAB_POS_IN_PERE( 1 ) = 1
        DO I = 1, NSLAVES-1
          TAB_POS_IN_PERE( I+1 ) = TAB_POS_IN_PERE(I) +                 &
     &    BLSIZE
        ENDDO
        TAB_POS_IN_PERE(NSLAVES+1) = NCB+1
        TAB_POS_IN_PERE(SLAVEF+2)  = NSLAVES
        RETURN
      ELSE IF (KEEP(48).EQ.3 ) THEN
        KMAX = AGMG_MUMPS_497(KEEP8(21), NCB)
        KMIN = AGMG_MUMPS_442(KEEP8(21), KEEP(50), KMAX, NCB)
        GETPOSITIONS = 3
        SIZECOLTAB       = SLAVEF+2
        CALL  AGMG_MUMPS_440(                                                &
     &    GETPOSITIONS, NSLAVES, NFRONT, NCB,                           &
     &    KMIN, KMAX, SLAVEF,                                           &
     &    NBROWDUMMY, MAXSURFDUMMY8,                                    &
     &    TAB_POS_IN_PERE(1), SIZECOLTAB)
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_441
      SUBROUTINE AGMG_MUMPS_49(                                              &
     &            KEEP,KEEP8, INODE, STEP, N, SLAVEF,                   &
     &            ISTEP_TO_INIV2, TAB_POS_IN_PERE,                      &
     &            ISLAVE, NCB, NSLAVES, SIZE, FIRST_INDEX )
      IMPLICIT NONE
      INTEGER, INTENT( IN ) :: ISLAVE, NCB, NSLAVES, SLAVEF,            &
     &                         KEEP(500), INODE, N
      INTEGER*8 KEEP8(150)
      INTEGER, INTENT( IN ) :: STEP(N),                                 &
     &          ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER, INTENT( OUT ):: SIZE, FIRST_INDEX
      INTEGER BLSIZE, J
      IF (KEEP(48).EQ.0) THEN
       BLSIZE = NCB / NSLAVES
       IF ( ISLAVE .NE. NSLAVES ) THEN
        SIZE = BLSIZE
       ELSE
        SIZE = BLSIZE + mod( NCB, NSLAVES )
       END IF
       FIRST_INDEX = ( ISLAVE - 1 ) * BLSIZE + 1
      ELSEIF (KEEP(48).EQ.3) THEN
       J = ISTEP_TO_INIV2 ( STEP(INODE) )
       FIRST_INDEX = TAB_POS_IN_PERE (ISLAVE,J)
       SIZE        = TAB_POS_IN_PERE (ISLAVE+1,J) - FIRST_INDEX
      ELSEIF (KEEP(48).EQ.4) THEN
         J = ISTEP_TO_INIV2 ( STEP(INODE) )
         FIRST_INDEX = TAB_POS_IN_PERE (ISLAVE,J)
         SIZE = TAB_POS_IN_PERE (ISLAVE+1,J) - FIRST_INDEX
      ELSEIF (KEEP(48).EQ.5) THEN
         J = ISTEP_TO_INIV2 ( STEP(INODE) )
         FIRST_INDEX = TAB_POS_IN_PERE (ISLAVE,J)
         SIZE = TAB_POS_IN_PERE (ISLAVE+1,J) - FIRST_INDEX
      ELSE
       WRITE(*,*) 'Error in MUMPS_BLOC2 undef strat'
       CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_49
      REAL FUNCTION AGMG_MUMPS_45(NROW,NCOL,NASS)
      IMPLICIT NONE
      INTEGER, INTENT (IN) :: NROW,NCOL,NASS
      AGMG_MUMPS_45 = real(NASS*NROW)*                                       &
     &                 real(2*NCOL - NASS - NROW + 1)
      RETURN
      END FUNCTION AGMG_MUMPS_45
      INTEGER FUNCTION AGMG_MUMPS_12                                         &
     &      (K821, K48, K50, SLAVEF,                                    &
     &      NCB, NFRONT, NSLAVES_less, NMB_OF_CAND )
      IMPLICIT NONE
      INTEGER, INTENT( IN ) :: NCB, NFRONT, NSLAVES_less,               &
     &                  K48, K50, SLAVEF, NMB_OF_CAND
      INTEGER(8), INTENT(IN) :: K821
      INTEGER J, NSLAVES, NSLAVES_REAL, ISLAVE
      INTEGER KMIN, KMAX, BLSIZE, NPIV,                                 &
     &        NSLAVES_ref, KMINSURF, NSLAVES_max
      REAL WK_MASTER, WK_SLAVE
      INTEGER  AGMG_MUMPS_497, AGMG_MUMPS_50,                                     &
     &         AGMG_MUMPS_52
      REAL  AGMG_MUMPS_45
      EXTERNAL AGMG_MUMPS_497, AGMG_MUMPS_50,                                     &
     &         AGMG_MUMPS_52
      EXTERNAL AGMG_MUMPS_45
      IF (NMB_OF_CAND.LE.0) THEN
      ENDIF
      IF ( (K48.EQ.0).OR. (K48.EQ.3) ) THEN
         KMAX = AGMG_MUMPS_497( K821, NCB )
         NSLAVES_ref = AGMG_MUMPS_50(                                        &
     &     SLAVEF, K48, K821, K50, NFRONT, NCB )
         NSLAVES = NSLAVES_ref
         IF ( NSLAVES_ref.LT.SLAVEF ) THEN
           NSLAVES_max = AGMG_MUMPS_52(                                      &
     &       SLAVEF, K48, K821, K50, NFRONT, NCB )
           IF ( NSLAVES_max .LT. NSLAVES_less ) THEN
            NSLAVES =  NSLAVES_max
           ELSE
            NSLAVES =  NSLAVES_less
           ENDIF
           NSLAVES = max(NSLAVES_ref,NSLAVES)
         ENDIF
         NSLAVES = min (NSLAVES, NMB_OF_CAND)
         IF ( NSLAVES.GT.NSLAVES_ref) THEN
          NPIV = NFRONT - NCB
          IF ( K50.EQ.0 ) THEN
           WK_SLAVE = real( NPIV ) * real( NCB ) *                      &
     &         ( 2.0E0 * real(NFRONT) - real(NPIV) )                    &
     &         / real(NSLAVES)
           WK_MASTER = 0.66667E0 *                                      &
     &                 real(NPIV)*real(NPIV)*real(NPIV)+                &
     &                 real(NPIV)*real(NPIV)*real(NCB)
          ELSE
           WK_SLAVE = AGMG_MUMPS_45(NCB,NFRONT,NPIV)                         &
     &         / real(NSLAVES)
           WK_MASTER =  real(NPIV)*real(NPIV)*real(NPIV)/3.0E0
          ENDIF
          IF ( (WK_MASTER.GT.WK_SLAVE).AND.                             &
     &     (WK_SLAVE.GT.1.0E0) ) THEN
           NSLAVES =                                                    &
     &         int( real(NSLAVES) * (WK_SLAVE/WK_MASTER))
           NSLAVES = max(NSLAVES_ref, NSLAVES)
          ENDIF
         ENDIF
      ELSE
       NSLAVES = NSLAVES_less
      ENDIF
      NSLAVES = min (NSLAVES, NCB)
      NSLAVES = min (NSLAVES, NMB_OF_CAND)
      AGMG_MUMPS_12 = NSLAVES
      RETURN
      END FUNCTION AGMG_MUMPS_12
      SUBROUTINE AGMG_MUMPS_47(                                              &
     &   KEEP,KEEP8, INODE, STEP, N, SLAVEF,                            &
     &   ISTEP_TO_INIV2, TAB_POS_IN_PERE,                               &
     &   NASS, NCB,                                                     &
     &   NSLAVES, POSITION, ISLAVE, IPOSSLAVE )
      IMPLICIT NONE
      INTEGER, INTENT( IN ) :: KEEP(500),INODE,N,SLAVEF
      INTEGER*8 KEEP8(150)
      INTEGER, INTENT( IN ) :: STEP(N),                                 &
     &          ISTEP_TO_INIV2(KEEP(71)),                               &
     &          TAB_POS_IN_PERE(SLAVEF+2,max(1,KEEP(56)))
      INTEGER, INTENT( IN  ) :: NASS, NCB,                              &
     &                          NSLAVES, POSITION
      INTEGER, INTENT( OUT ) :: ISLAVE, IPOSSLAVE
      INTEGER BLSIZE, J, ISHIFT
      IF ((NSLAVES.LE.0).OR.(POSITION.LE.NASS)) THEN
       ISLAVE = 0
       IPOSSLAVE = POSITION
       RETURN
      ENDIF
      IF ( KEEP(48).EQ.0) THEN
       BLSIZE = NCB / NSLAVES
       ISLAVE    = min( NSLAVES,                                        &
     &               ( POSITION - NASS - 1 ) / BLSIZE + 1 )
       IPOSSLAVE = POSITION - NASS - ( ISLAVE - 1 ) * BLSIZE
      ELSEIF (KEEP(48).EQ.3) THEN
         J = ISTEP_TO_INIV2 ( STEP(INODE) )
         ISHIFT = POSITION - NASS
         DO ISLAVE = NSLAVES,1,-1
          IF ( ISHIFT .GE. TAB_POS_IN_PERE(ISLAVE,J)) THEN
           IPOSSLAVE = ISHIFT - TAB_POS_IN_PERE(ISLAVE,J) + 1
           EXIT
          END IF
         END DO
      ELSEIF (KEEP(48).EQ.4) THEN
         J = ISTEP_TO_INIV2 ( STEP(INODE) )
         ISHIFT = POSITION - NASS
         DO ISLAVE = NSLAVES,1,-1
          IF ( ISHIFT .GE. TAB_POS_IN_PERE(ISLAVE,J)) THEN
           IPOSSLAVE = ISHIFT - TAB_POS_IN_PERE(ISLAVE,J) + 1
           EXIT
          END IF
         END DO
      ELSEIF (KEEP(48).EQ.5) THEN
         J = ISTEP_TO_INIV2 ( STEP(INODE) )
         ISHIFT = POSITION - NASS
         DO ISLAVE = NSLAVES,1,-1
          IF ( ISHIFT .GE. TAB_POS_IN_PERE(ISLAVE,J)) THEN
           IPOSSLAVE = ISHIFT - TAB_POS_IN_PERE(ISLAVE,J) + 1
           EXIT
          END IF
         END DO
      ELSE
       WRITE(*,*) 'Error in MUMPS_47: undef strat'
       CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_47
      INTEGER FUNCTION AGMG_MUMPS_442( K821, K50, KMAX, NCB )
      IMPLICIT NONE
      INTEGER, INTENT( IN    )  :: KMAX, NCB, K50
      INTEGER(8), INTENT(IN) :: K821
      INTEGER KMIN, MINGRAN
      INTEGER(8) :: KMINSURF
      IF ( ( NCB .LE.0 ).OR. (KMAX.LE.0) ) THEN
        AGMG_MUMPS_442 = 1
        RETURN
      ENDIF
      IF (K50.EQ.0) THEN
       KMINSURF = 60000_8
       MINGRAN = 50
      ELSE
       KMINSURF = 30000_8
       MINGRAN = 20
      ENDIF
      IF (K821.GT.0_8) THEN
           KMIN = max(MINGRAN,KMAX/20)
      ELSE
           KMINSURF = max( abs(K821)/500_8, KMINSURF )
           KMIN     = max(                                              &
     &                     int( KMINSURF / int(max(NCB,1),8) ),         &
     &                     1                                            &
     &                   )
      ENDIF
      KMIN = min(KMIN,KMAX)
      KMIN = max(KMIN,1)
      AGMG_MUMPS_442 = KMIN
      RETURN
      END FUNCTION AGMG_MUMPS_442
      INTEGER FUNCTION AGMG_MUMPS_497( KEEP821, NCB )
      IMPLICIT NONE
      INTEGER,    intent( in    )  :: NCB
      INTEGER(8), intent( in    )  :: KEEP821
      INTEGER KMAX
      IF ( NCB .LE.0 ) THEN
        AGMG_MUMPS_497 = 1
        RETURN
      ENDIF
      IF ( KEEP821.GT.0_8 ) THEN
       KMAX = int(KEEP821)
      ELSE
       KMAX =  -int(KEEP821/int(NCB,8))
      ENDIF
      KMAX = min (NCB, KMAX)
      AGMG_MUMPS_497 = max ( KMAX, 1 )
      RETURN
      END FUNCTION AGMG_MUMPS_497
      SUBROUTINE AGMG_MUMPS_546( IS, DS )
      INTEGER IS, DS
      IS = 4
      DS = 8
      END SUBROUTINE AGMG_MUMPS_546
      SUBROUTINE AGMG_MUMPS_SET_VERSION( VERSION_STR )
      IMPLICIT NONE
      CHARACTER(LEN=*) :: VERSION_STR
      CHARACTER(LEN=*) :: V;
      PARAMETER (V = "4.9.2" )
      IF ( LEN(V) .GT. 14 ) THEN
         WRITE(*,*) "Version string too long ( >14 characters )"
         CALL AGMG_MUMPS_ABORT()
      END IF
      VERSION_STR = V
      RETURN
      END SUBROUTINE
      SUBROUTINE AGMG_MUMPS_420                                              &
     &                ( JOB, THRESH, NDENSE,                            &
     &                 N, IWLEN, PE, PFREE, LEN, IW, NV,                &
     &                 ELEN, LAST, NCMPA, DEGREE, HEAD, NEXT, W,        &
     &                 PERM, COMPLEM_LIST, SIZE_COMPLEM_LIST, AGG6 )
      IMPLICIT NONE
      INTEGER JOB
      INTEGER N, IWLEN, PE(N), PFREE, LEN(N), IW(IWLEN), NV(N),         &
     &        ELEN(N), LAST(N), NCMPA, DEGREE(N), HEAD(N), NEXT(N),     &
     &        W(N)
      LOGICAL AGG6
      INTEGER, intent(in) :: SIZE_COMPLEM_LIST
      INTEGER NDENSE(N)
      INTEGER, intent (in) :: COMPLEM_LIST(max(1,SIZE_COMPLEM_LIST))
      INTEGER PERM(N)
      INTEGER THRESH
      INTEGER THRESM, NDME, PERMeqN
      INTEGER NBD,NBED, NBDM, LASTD, NELME, DEG1
      LOGICAL IDENSE
      INTEGER FDEG, ThresMin, ThresPrev, IBEGSchur,                     &
     &        ThresMinINIT
      LOGICAL SchurON
      INTEGER DEG, DEGME, DEXT, DMAX, E, ELENME, ELN, I,                &
     &        ILAST, INEXT, J, JLAST, JNEXT, K, KNT1, KNT2, KNT3,       &
     &        LENJ, LN, MAXMEM, ME, MEM, MINDEG, NEL, NEWMEM,           &
     &        NLEFT, NVI, NVJ, NVPIV, SLENME, WE, WFLG, WNVI, X
      INTEGER*8 HASH, HMOD
      INTEGER P, P1, P2, P3, PDST, PEND, PJ, PME, PME1, PME2, PN, PSRC
      INTRINSIC max, min, mod
        IF (N.EQ.1) THEN
           ELEN(1) = 1
           LAST(1) = 1
           PE(1) = 0
           NV(1) = 1
           RETURN
        ENDIF
        IF ( SIZE_COMPLEM_LIST < 0 .OR. SIZE_COMPLEM_LIST > N ) THEN
          WRITE(*,*) "Internal AGMG_MUMPS_420", SIZE_COMPLEM_LIST,N
          CALL AGMG_MUMPS_ABORT()
        ENDIF
        IF (JOB.EQ.2) THEN
          SchurON = .FALSE.
        ENDIF
        IF (JOB.NE.2) THEN
          SchurON   = (SIZE_COMPLEM_LIST > 0)
          IF ((JOB.EQ.1) .AND. (.NOT.SchurON) .AND. (N .GT. 0)) THEN
           WRITE(6,*) ' WARNING MUMPS_420 on Options '
          ENDIF
          IBEGSchur = N-SIZE_COMPLEM_LIST+1
          IF (THRESH.GT.N) THRESH = N
          IF (THRESH.LT.0) THRESH = 0
          IF ( SchurON )  THEN
           DO I= 1, N
             IF ( PERM(I) .GE. IBEGSchur) THEN
                 PERM(I) = N + 1
                IF (LEN(I) .EQ.0) THEN
                  PE(I) = 0
                ENDIF
             ENDIF
           ENDDO
          ENDIF
        ENDIF
        IF (SchurON) THEN
             THRESM    = N
             ThresMin  = N
             ThresPrev = N
        ELSE
             THRESM    = max(int(31*N/32),THRESH)
             THRESM    = max(THRESM,1)
             ThresMin  = max( 3*THRESM / 4, 1)
             ThresPrev = THRESM
        ENDIF
        ThresMinINIT = ThresMin/4
      IF (THRESM.GT.0) THEN
       IF ((THRESM.GT.N).OR.(THRESM.LT.2)) THEN
          THRESM = N
       ENDIF
      ENDIF
      IF (JOB.EQ.2) THEN
      ENDIF
      PERMeqN = 0
      LASTD = 0
      NBD   = 0
      NBED  = 0
      NBDM  = 0
      NEL   = 0
      WFLG   = 2
      MINDEG = 1
      NCMPA  = 0
      HMOD = INT(max (1, N-1),KIND=8)
      DMAX = 0
      MEM  = PFREE - 1
      MAXMEM = MEM
      DO 10 I = 1, N
        NDENSE(I)= 0
        LAST (I) = 0
        HEAD (I) = 0
        NV (I) = 1
        W (I) = 1
   10 END DO
      IF (JOB.EQ.2) THEN
        DO I = 1,SIZE_COMPLEM_LIST
             X       = COMPLEM_LIST(I)
             ELEN(X) = -I
             NV(X)   = LEN(X)+1
             DMAX = max(DMAX, LEN(X))
        ENDDO
        NEL = NEL + SIZE_COMPLEM_LIST
        DO I=1,N
          DEGREE (I) = LEN (I)
        ENDDO
      ELSE
        DO I=1, N
          ELEN (I) = 0
          DEGREE (I) = LEN (I)
        ENDDO
      ENDIF
      DO 20 I = 1, N
        IF (ELEN(I).LT.0) CYCLE
        DEG = DEGREE (I)
        IF (PERM(I).EQ.N) THEN
           PERMeqN = I
           PERM(I) = N-1
        ENDIF
        FDEG = PERM(I)
        IF ( (DEG .GT. 0).OR.(PERM(I).EQ.N+1) ) THEN
          IF ( (THRESM.GT.0) .AND.                                      &
     &         (FDEG .GT.THRESM) ) THEN
            NBD = NBD+1
            IF (FDEG.NE.N+1) THEN
             DEGREE(I) = DEGREE(I)+N+2
             DEG = N
             INEXT = HEAD (DEG)
             IF (INEXT .NE. 0) LAST (INEXT) = I
             NEXT (I) = INEXT
             HEAD (DEG) = I
             LAST(I)  = 0
             IF (LASTD.EQ.0) LASTD=I
            ELSE
             NBED = NBED+1
             DEGREE(I) = N+1
             DEG = N
             IF (LASTD.EQ.0) THEN
               LASTD     = I
               HEAD(DEG) = I
               NEXT(I)   = 0
               LAST(I)   = 0
             ELSE
               NEXT(LASTD) = I
               LAST(I)     = LASTD
               LASTD       = I
               NEXT(I)     = 0
             ENDIF
            ENDIF
          ELSE
            INEXT = HEAD (FDEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            HEAD (FDEG) = I
          ENDIF
        ELSE
          NEL = NEL + 1
          ELEN (I) = -NEL
          PE (I) = 0
          W (I) = 0
        ENDIF
   20 END DO
          IF ((NBD.EQ.0).AND.(THRESM.GT.0)) THRESM = N
   30 IF (NEL .LT. N) THEN
        DO 40 DEG = MINDEG, N
          ME = HEAD (DEG)
          IF (ME .GT. 0) GO TO 50
   40   CONTINUE
   50   MINDEG = DEG
        IF ( (DEG.NE.N) .AND.                                           &
     &    (DEG.GT.THRESM+1) .AND. (NBD.GT.0) ) THEN
           MINDEG = N
           GOTO 30
        ENDIF
        IF (DEGREE(ME).LE.N)  THEN
          INEXT = NEXT (ME)
          IF (INEXT .NE. 0) LAST (INEXT) = 0
          HEAD (DEG) = INEXT
        ELSE
          MINDEG = 1
          NBDM = max(NBDM,NBD)
          IF (DEGREE(ME).GT.N+1) THEN
            IF (WFLG+NBD+1 .LE. WFLG) THEN
             DO  52 X = 1, N
              IF (W (X) .NE. 0) W (X) = 1
   52        CONTINUE
             WFLG = 2
            ENDIF
            WFLG = WFLG + 1
   51       CONTINUE
            INEXT = NEXT (ME)
            IF (INEXT .NE. 0) THEN
               LAST (INEXT) = 0
            ELSE
               LASTD = 0
            ENDIF
            NDENSE(ME) = 0
            W(ME)      = WFLG
            P1 = PE(ME)
            P2 = P1 + LEN(ME) -1
            LN       = P1
            ELN      = P1
            DO 55 P=P1,P2
              E= IW(P)
              IF (W(E).EQ.WFLG) GOTO 55
              W(E) = WFLG
              IF (PE(E).LT.0) THEN
                X = E
   53           X = -PE(X)
                IF (W(X) .EQ.WFLG) GOTO 55
                W(X) = WFLG
                IF ( PE(X) .LT. 0 ) GOTO 53
                E = X
              ENDIF
              IF (ELEN(E).LT.0) THEN
               NDENSE(E) = NDENSE(E) - NV(ME)
               IW(LN) = IW(ELN)
               IW(ELN) = E
               LN  = LN+1
               ELN = ELN + 1
               PME1 = PE(E)
               DO 54 PME = PME1, PME1+LEN(E)-1
                X = IW(PME)
                IF ((ELEN(X).GE.0).AND.(W(X).NE.WFLG)) THEN
                 NDENSE(ME) = NDENSE(ME) + NV(X)
                 W(X) = WFLG
                ENDIF
   54          CONTINUE
              ELSE
               NDENSE(ME) = NDENSE(ME) + NV(E)
               IW(LN)=E
               LN = LN+1
              ENDIF
   55       CONTINUE
            WFLG     = WFLG + 1
            LEN(ME)  = LN-P1
            ELEN(ME) = ELN- P1
            NDME = NDENSE(ME)+NV(ME)
            IF (NDENSE(ME).EQ.0) NDENSE(ME) =1
            DEGREE(ME) = NDENSE(ME)
            DEG = PERM(ME)
            MINDEG = min(DEG,MINDEG)
            JNEXT = HEAD(DEG)
            IF (JNEXT.NE. 0) LAST (JNEXT) = ME
            NEXT(ME) = JNEXT
            HEAD(DEG) = ME
            ME    = INEXT
            IF (ME.NE.0) THEN
              IF (DEGREE(ME).GT.(N+1) ) GOTO 51
            ENDIF
            HEAD (N) = ME
            IF (THRESM.LT.N) THEN
             ThresMin  = max(THRESM+ThresMin,ThresPrev+ThresMin/2+1)
             ThresMin  = min(ThresMin, N)
             ThresPrev = ThresPrev+(N-ThresPrev)/2+ThresMinINIT
             THRESM    = max(                                           &
     &         THRESM + int(sqrt(dble(ThresMin)))+ ThresMinINIT ,       &
     &         ThresPrev)
!    $         THRESM + ThresMin/2+ ThresMinINIT ,
             THRESM    = min(THRESM,N)
             ThresMin  = min(THRESM, ThresMin)
             ThresPrev = THRESM
            ENDIF
            NBD    = NBED
            GOTO 30
          ENDIF
          IF (DEGREE(ME).EQ.N+1) THEN
           IF (NBD.NE.NBED) THEN
          write(6,*) ' ERROR in MUMPS_420 ',                            &
     &                ' quasi dense rows remains'
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF (JOB.EQ.1) THEN
            DO I = 1,SIZE_COMPLEM_LIST
             X       = COMPLEM_LIST(I)
             ELEN(X) = -(N-SIZE_COMPLEM_LIST+I)
             NV(X)   = 1
             PE(X)   = 0
            ENDDO
            GOTO 265
           ENDIF
           NELME    = -(NEL+1)
           DO 59 X=1,N
            IF ((PE(X).GT.0) .AND. (ELEN(X).LT.0)) THEN
             PE(X) = -COMPLEM_LIST(1)
            ELSEIF (DEGREE(X).EQ.N+1) THEN
             NEL   = NEL + NV(X)
             PE(X) = -ME
             ELEN(X) = 0
             NV(X) = 0
            ENDIF
   59      CONTINUE
           ELEN(ME) = NELME
           NV(ME)   = NBD
           PE(ME)   = 0
           IF (NEL.NE.N) THEN
            write(6,*) 'Internal ERROR 2 detected in QAMD'
            write(6,*) ' NEL not equal to N: N, NEL =',N,NEL
            CALL AGMG_MUMPS_ABORT()
           ENDIF
           IF (ME.NE. COMPLEM_LIST(1)) THEN
             DO I=1, SIZE_COMPLEM_LIST
               PE(COMPLEM_LIST(I)) = -COMPLEM_LIST(1)
             ENDDO
             PE(COMPLEM_LIST(1)) = 0
             NV( COMPLEM_LIST(1))= NV(ME)
             NV(ME)               = 0
             ELEN( COMPLEM_LIST(1)) = ELEN(ME)
             ELEN(ME)             = 0
           ENDIF
           GOTO 265
          ENDIF
        ENDIF
        ELENME = ELEN (ME)
        ELEN (ME) = - (NEL + 1)
        NVPIV = NV (ME)
        NEL = NEL + NVPIV
        NDENSE(ME) = 0
        NV (ME) = -NVPIV
        DEGME = 0
        IF (ELENME .EQ. 0) THEN
          PME1 = PE (ME)
          PME2 = PME1 - 1
          DO 60 P = PME1, PME1 + LEN (ME) - 1
            I = IW (P)
            NVI = NV (I)
            IF (NVI .GT. 0) THEN
              DEGME = DEGME + NVI
              NV (I) = -NVI
              PME2 = PME2 + 1
              IW (PME2) = I
              IF (DEGREE(I).LE.N) THEN
              ILAST = LAST (I)
              INEXT = NEXT (I)
              IF (INEXT .NE. 0) LAST (INEXT) = ILAST
              IF (ILAST .NE. 0) THEN
                NEXT (ILAST) = INEXT
              ELSE
                HEAD (PERM(I)) = INEXT
              ENDIF
              ELSE
               NDENSE(ME) = NDENSE(ME) + NVI
              ENDIF
            ENDIF
   60     CONTINUE
          NEWMEM = 0
        ELSE
          P = PE (ME)
          PME1 = PFREE
          SLENME = LEN (ME) - ELENME
          DO 120 KNT1 = 1, ELENME + 1
            IF (KNT1 .GT. ELENME) THEN
              E = ME
              PJ = P
              LN = SLENME
            ELSE
              E = IW (P)
              P = P + 1
              PJ = PE (E)
              LN = LEN (E)
            ENDIF
            DO 110 KNT2 = 1, LN
              I = IW (PJ)
              PJ = PJ + 1
              NVI = NV (I)
              IF (NVI .GT. 0) THEN
                IF (PFREE .GT. IWLEN) THEN
                  PE (ME) = P
                  LEN (ME) = LEN (ME) - KNT1
                  IF (LEN (ME) .EQ. 0) PE (ME) = 0
                  PE (E) = PJ
                  LEN (E) = LN - KNT2
                  IF (LEN (E) .EQ. 0) PE (E) = 0
                  NCMPA = NCMPA + 1
                  DO 70 J = 1, N
                    PN = PE (J)
                    IF (PN .GT. 0) THEN
                      PE (J) = IW (PN)
                      IW (PN) = -J
                    ENDIF
   70             CONTINUE
                  PDST = 1
                  PSRC = 1
                  PEND = PME1 - 1
   80             CONTINUE
                  IF (PSRC .LE. PEND) THEN
                    J = -IW (PSRC)
                    PSRC = PSRC + 1
                    IF (J .GT. 0) THEN
                      IW (PDST) = PE (J)
                      PE (J) = PDST
                      PDST = PDST + 1
                      LENJ = LEN (J)
                      DO 90 KNT3 = 0, LENJ - 2
                        IW (PDST + KNT3) = IW (PSRC + KNT3)
   90                 CONTINUE
                      PDST = PDST + LENJ - 1
                      PSRC = PSRC + LENJ - 1
                    ENDIF
                    GO TO 80
                  ENDIF
                  P1 = PDST
                  DO 100 PSRC = PME1, PFREE - 1
                    IW (PDST) = IW (PSRC)
                    PDST = PDST + 1
  100             CONTINUE
                  PME1 = P1
                  PFREE = PDST
                  PJ = PE (E)
                  P = PE (ME)
                ENDIF
                DEGME = DEGME + NVI
                NV (I) = -NVI
                IW (PFREE) = I
                PFREE = PFREE + 1
                IF (DEGREE(I).LE.N) THEN
                ILAST = LAST (I)
                INEXT = NEXT (I)
                IF (INEXT .NE. 0) LAST (INEXT) = ILAST
                IF (ILAST .NE. 0) THEN
                  NEXT (ILAST) = INEXT
                ELSE
                  HEAD (PERM(I)) = INEXT
                ENDIF
                ELSE
                 NDENSE(ME) = NDENSE(ME) + NVI
                ENDIF
              ENDIF
  110       CONTINUE
            IF (E .NE. ME) THEN
              PE (E) = -ME
              W (E) = 0
            ENDIF
  120     CONTINUE
          PME2 = PFREE - 1
          NEWMEM = PFREE - PME1
          MEM = MEM + NEWMEM
          MAXMEM = max (MAXMEM, MEM)
        ENDIF
        DEGREE (ME) = DEGME
        PE (ME) = PME1
        LEN (ME) = PME2 - PME1 + 1
        IF (WFLG+N .LE. WFLG) THEN
          DO 130 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  130     CONTINUE
          WFLG = 2
        ENDIF
        DO 150 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.N) GOTO 150
          ELN = ELEN (I)
          IF (ELN .GT. 0) THEN
            NVI = -NV (I)
            WNVI = WFLG - NVI
            DO 140 P = PE (I), PE (I) + ELN - 1
              E = IW (P)
              WE = W (E)
              IF (WE .GE. WFLG) THEN
                WE = WE - NVI
              ELSE IF (WE .NE. 0) THEN
                WE = DEGREE (E) + WNVI - NDENSE(E)
              ENDIF
              W (E) = WE
  140       CONTINUE
          ENDIF
  150   CONTINUE
        DO 180 PME = PME1, PME2
          I = IW (PME)
          IF (DEGREE(I).GT.N) GOTO 180
          P1 = PE (I)
          P2 = P1 + ELEN (I) - 1
          PN = P1
          HASH = 0_8
          DEG = 0
          DO 160 P = P1, P2
            E = IW (P)
            DEXT = W (E) - WFLG
            IF (DEXT .GT. 0) THEN
              DEG = DEG + DEXT
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (.NOT. AGG6 .AND. DEXT .EQ. 0) THEN
              IW (PN) = E
              PN = PN + 1
              HASH = HASH + INT(E,KIND=8)
            ELSE IF (AGG6 .AND. (DEXT .EQ. 0) .AND.                     &
     &            ((NDENSE(ME).EQ.NBD).OR.(NDENSE(E).EQ.0))) THEN
                PE (E) = -ME
                W (E)  = 0
             ELSE IF (AGG6 .AND. DEXT.EQ.0) THEN
                  IW(PN) = E
                  PN     = PN+1
                  HASH   = HASH + INT(E,KIND=8)
            ENDIF
  160     CONTINUE
          ELEN (I) = PN - P1 + 1
          P3 = PN
          DO 170 P = P2 + 1, P1 + LEN (I) - 1
            J = IW (P)
            NVJ = NV (J)
            IF (NVJ .GT. 0) THEN
              IF (DEGREE(J).LE.N) DEG=DEG+NVJ
              IW (PN) = J
              PN = PN + 1
              HASH = HASH + INT(J,KIND=8)
            ENDIF
  170     CONTINUE
          IF (((ELEN(I).EQ.1).AND.(P3.EQ.PN))                           &
     &     .OR.                                                         &
     &         (AGG6.AND.(DEG .EQ. 0).AND.(NDENSE(ME).EQ.NBD))          &
     &       )                                                          &
     &    THEN
            PE (I) = -ME
            NVI = -NV (I)
            DEGME = DEGME - NVI
            NVPIV = NVPIV + NVI
            NEL = NEL + NVI
            NV (I) = 0
            ELEN (I) = 0
          ELSE
            DEGREE(I) = min (DEG+NBD-NDENSE(ME),                        &
     &                       DEGREE(I))
            IW (PN) = IW (P3)
            IW (P3) = IW (P1)
            IW (P1) = ME
            LEN (I) = PN - P1 + 1
            HASH = mod (HASH, HMOD) + 1_8
            J = HEAD (HASH)
            IF (J .LE. 0) THEN
              NEXT (I) = -J
              HEAD (HASH) = -I
            ELSE
              NEXT (I) = LAST (J)
              LAST (J) = I
            ENDIF
            LAST (I) = INT(HASH,KIND=KIND(LAST))
          ENDIF
  180   CONTINUE
        DEGREE (ME) = DEGME
        DMAX = max (DMAX, DEGME)
        WFLG = WFLG + DMAX
        IF (WFLG+N .LE. WFLG) THEN
          DO 190 X = 1, N
            IF (W (X) .NE. 0) W (X) = 1
  190     CONTINUE
          WFLG = 2
        ENDIF
        DO 250 PME = PME1, PME2
          I = IW (PME)
          IF ( (NV(I).LT.0) .AND. (DEGREE(I).LE.N) ) THEN
            HASH = INT(LAST (I),KIND=8)
            J = HEAD (HASH)
            IF (J .EQ. 0) GO TO 250
            IF (J .LT. 0) THEN
              I = -J
              HEAD (HASH) = 0
            ELSE
              I = LAST (J)
              LAST (J) = 0
            ENDIF
            IF (I .EQ. 0) GO TO 250
  200       CONTINUE
            IF (NEXT (I) .NE. 0) THEN
             X = I
              LN = LEN (I)
              ELN = ELEN (I)
              DO 210 P = PE (I) + 1, PE (I) + LN - 1
                W (IW (P)) = WFLG
  210         CONTINUE
              JLAST = I
              J = NEXT (I)
  220         CONTINUE
              IF (J .NE. 0) THEN
                IF (LEN (J) .NE. LN) GO TO 240
                IF (ELEN (J) .NE. ELN) GO TO 240
                DO 230 P = PE (J) + 1, PE (J) + LN - 1
                  IF (W (IW (P)) .NE. WFLG) GO TO 240
  230           CONTINUE
                IF (PERM(J).GT.PERM(X)) THEN
                  PE (J) = -X
                  NV (X) = NV (X) + NV (J)
                  NV (J) = 0
                  ELEN (J) = 0
                ELSE
                  PE (X) = -J
                  NV (J) = NV (X) + NV (J)
                  NV (X) = 0
                  ELEN (X) = 0
                  X = J
                ENDIF
                J = NEXT (J)
                NEXT (JLAST) = J
                GO TO 220
  240           CONTINUE
                JLAST = J
                J = NEXT (J)
              GO TO 220
              ENDIF
              WFLG = WFLG + 1
              I = NEXT (I)
              IF (I .NE. 0) GO TO 200
            ENDIF
          ENDIF
  250   CONTINUE
        IF ( (THRESM .GT. 0).AND.(THRESM.LT.N) ) THEN
          THRESM = max(ThresMin, THRESM-NVPIV)
        ENDIF
        P = PME1
        NLEFT = N - NEL
        DO 260 PME = PME1, PME2
          I = IW (PME)
          NVI = -NV (I)
          IF (NVI .GT. 0) THEN
            NV (I) = NVI
            IF (DEGREE(I).LE.N) THEN
            DEG = min (DEGREE (I)+ DEGME - NVI, NLEFT - NVI)
            DEGREE (I) = DEG
            IDENSE = .FALSE.
            IF (THRESM.GT.0) THEN
             IF (PERM(I) .GT. THRESM) THEN
               IDENSE = .TRUE.
               DEGREE(I) = DEGREE(I)+N+2
             ENDIF
             IF (IDENSE) THEN
               P1 = PE(I)
               P2 = P1 + ELEN(I) - 1
               IF (P2.GE.P1) THEN
               DO 264 PJ=P1,P2
                 E= IW(PJ)
                 NDENSE (E) = NDENSE(E) + NVI
  264          CONTINUE
               ENDIF
               NBD = NBD+NVI
               FDEG = N
               DEG = N
               INEXT = HEAD(DEG)
               IF (INEXT .NE. 0) LAST (INEXT) = I
               NEXT (I) = INEXT
               HEAD (DEG) = I
               LAST(I)    = 0
               IF (LASTD.EQ.0) LASTD=I
             ENDIF
            ENDIF
            IF (.NOT.IDENSE) THEN
            FDEG = PERM(I)
            INEXT = HEAD (FDEG)
            IF (INEXT .NE. 0) LAST (INEXT) = I
            NEXT (I) = INEXT
            LAST (I) = 0
            HEAD (FDEG) = I
            ENDIF
            MINDEG = min (MINDEG, FDEG)
            ENDIF
            IW (P) = I
            P = P + 1
          ENDIF
  260   CONTINUE
        NV (ME) = NVPIV + DEGME
        LEN (ME) = P - PME1
        IF (LEN (ME) .EQ. 0) THEN
          PE (ME) = 0
          W (ME) = 0
        ENDIF
        IF (NEWMEM .NE. 0) THEN
          PFREE = P
          MEM = MEM - NEWMEM + LEN (ME)
        ENDIF
      GO TO 30
      ENDIF
  265 CONTINUE
      DO 290 I = 1, N
        IF (ELEN (I) .EQ. 0) THEN
          J = -PE (I)
  270     CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              J = -PE (J)
              GO TO 270
            ENDIF
            E = J
            K = -ELEN (E)
            J = I
  280       CONTINUE
            IF (ELEN (J) .GE. 0) THEN
              JNEXT = -PE (J)
              PE (J) = -E
              IF (ELEN (J) .EQ. 0) THEN
                ELEN (J) = K
                K = K + 1
              ENDIF
              J = JNEXT
            GO TO 280
            ENDIF
          ELEN (E) = -K
        ENDIF
  290 END DO
      DO 300 I = 1, N
        K = abs (ELEN (I))
        LAST (K) = I
        ELEN (I) = K
  300 END DO
      IF (.NOT.SchurON) THEN
        IF (PERMeqN.GT.0) PERM(PERMeqN) = N
      ENDIF
      PFREE = MAXMEM
      RETURN
      END SUBROUTINE AGMG_MUMPS_420
      SUBROUTINE AGMG_MUMPS_209( N, FRERE, FILS, NFSIZ, THEROOT )
      IMPLICIT NONE
      INTEGER, intent( in    )  :: N
      INTEGER, intent( in    )  :: NFSIZ( N )
      INTEGER, intent( inout )  :: FRERE( N ), FILS( N )
      INTEGER, intent( out   )  :: THEROOT
      INTEGER INODE, IROOT, IFILS, IN, IROOTLAST, SIZE
      IROOT = -9999
      SIZE  = 0
      DO INODE = 1, N
        IF ( FRERE( INODE ) .EQ. 0 )  THEN
          IF ( NFSIZ( INODE ) .GT. SIZE ) THEN
            SIZE  = NFSIZ( INODE )
            IROOT = INODE
          END IF
        ENDIF
      END DO
      IN = IROOT
      DO WHILE ( FILS( IN ) .GT. 0 )
        IN = FILS( IN )
      END DO
      IROOTLAST = IN
      IFILS     = - FILS ( IN )
      DO INODE = 1, N
        IF ( FRERE( INODE ) .eq. 0 .and. INODE .ne. IROOT ) THEN
          IF ( IFILS .eq. 0 ) THEN
            FILS( IROOTLAST ) = - INODE
            FRERE( INODE )    = -IROOT
            IFILS             = INODE
          ELSE
            FRERE( INODE ) = -FILS( IROOTLAST )
            FILS( IROOTLAST ) = - INODE
          END IF
        END IF
      END DO
      THEROOT = IROOT
      RETURN
      END SUBROUTINE AGMG_MUMPS_209
      INTEGER FUNCTION AGMG_MUMPS_330(INODE, PROCNODE, SLAVEF)
      IMPLICIT NONE
      INTEGER INODE, SLAVEF
      INTEGER PROCNODE(*)
      INTEGER MYPROC, TPN
      MYPROC = PROCNODE( INODE )
      IF (MYPROC <= SLAVEF ) THEN
        AGMG_MUMPS_330 = 1
      ELSE
        TPN = (MYPROC-1+2*SLAVEF)/SLAVEF - 1
        IF ( TPN .LT. 1 ) TPN = 1
        AGMG_MUMPS_330 = TPN
      END IF
      RETURN
      END FUNCTION AGMG_MUMPS_330
      INTEGER FUNCTION AGMG_MUMPS_275(INODE, PROCNODE, SLAVEF)
      IMPLICIT NONE
      INTEGER INODE, SLAVEF
      INTEGER PROCNODE(*)
      INTEGER MYPROC
      IF (SLAVEF == 1) THEN
        AGMG_MUMPS_275 = 0
      ELSE
        MYPROC = PROCNODE( INODE )
        AGMG_MUMPS_275=mod(2*SLAVEF+MYPROC-1,SLAVEF)
      END IF
      RETURN
      END FUNCTION AGMG_MUMPS_275
      LOGICAL FUNCTION AGMG_MUMPS_283( INODE, PROCNODE, SLAVEF )
      IMPLICIT NONE
      INTEGER INODE, SLAVEF
      INTEGER  PROCNODE(*)
      INTEGER TPN, MYPROC
      MYPROC = PROCNODE( INODE )
      TPN = (MYPROC-1+2*SLAVEF)/SLAVEF - 1
      AGMG_MUMPS_283 = ( TPN .eq. 0 )
      RETURN
      END FUNCTION AGMG_MUMPS_283
      LOGICAL FUNCTION AGMG_MUMPS_167( INODE, PROCNODE, SLAVEF )
      IMPLICIT NONE
      INTEGER INODE, SLAVEF
      INTEGER  PROCNODE(*)
      INTEGER TPN, MYPROC
      MYPROC = PROCNODE( INODE )
      TPN = (MYPROC-1+SLAVEF+SLAVEF)/SLAVEF - 1
      AGMG_MUMPS_167 = ( TPN .eq. -1 )
      RETURN
      END FUNCTION AGMG_MUMPS_167
      LOGICAL FUNCTION AGMG_MUMPS_170                                        &
     &        ( INODE, PROCNODE, SLAVEF )
      IMPLICIT NONE
      INTEGER INODE, SLAVEF
      INTEGER  PROCNODE(*)
      INTEGER TPN, MYPROC
      MYPROC = PROCNODE( INODE )
      TPN = (MYPROC-1+SLAVEF+SLAVEF)/SLAVEF - 1
      AGMG_MUMPS_170 =                                                       &
     &           ( TPN .eq. -1 .OR. TPN .eq. 0 )
      RETURN
      END FUNCTION AGMG_MUMPS_170
      LOGICAL FUNCTION AGMG_MUMPS_358( MYID, SLAVEF, INODE,                  &
     &                 NMB_PAR2, ISTEP_TO_INIV2 , K71, STEP, N,         &
     &                 CANDIDATES, KEEP24 )
      IMPLICIT NONE
      INTEGER MYID, SLAVEF, INODE, NMB_PAR2, KEEP24, I
      INTEGER K71, N
      INTEGER ISTEP_TO_INIV2 ( K71 ), STEP ( N )
      INTEGER CANDIDATES(SLAVEF+1, max(NMB_PAR2,1))
      INTEGER NCAND, POSINODE
      AGMG_MUMPS_358 = .FALSE.
      IF (KEEP24 .eq. 0) RETURN
      POSINODE = ISTEP_TO_INIV2 ( STEP (INODE) )
      NCAND = CANDIDATES( SLAVEF+1, POSINODE )
      DO I = 1, NCAND
        IF (MYID .EQ. CANDIDATES( I, POSINODE ))                        &
     &     AGMG_MUMPS_358 = .TRUE.
      END DO
      RETURN
      END FUNCTION AGMG_MUMPS_358
      SUBROUTINE AGMG_MUMPS_291(T)
      DOUBLE PRECISION T
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      T=AGMG_MPF_WTIME()
      RETURN
      END SUBROUTINE AGMG_MUMPS_291
      SUBROUTINE AGMG_MUMPS_292(T)
      DOUBLE PRECISION T
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      T=AGMG_MPF_WTIME()-T
      RETURN
      END SUBROUTINE AGMG_MUMPS_292
      SUBROUTINE AGMG_MUMPS_558( N, VAL, ID )
      INTEGER N
      INTEGER ID( N )
      DOUBLE PRECISION VAL( N )
      INTEGER I, ISWAP
      DOUBLE PRECISION SWAP
      LOGICAL DONE
      DONE = .FALSE.
      DO WHILE ( .NOT. DONE )
        DONE = .TRUE.
        DO I = 1, N - 1
          IF ( VAL( I ) .GT. VAL( I + 1 ) ) THEN
            DONE = .FALSE.
            ISWAP = ID( I )
            ID ( I ) = ID ( I + 1 )
            ID ( I + 1 ) = ISWAP
            SWAP = VAL( I )
            VAL( I ) = VAL( I + 1 )
            VAL( I + 1 ) = SWAP
          END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_558
      SUBROUTINE AGMG_MUMPS_158                                              &
     &( N, MYID, STEP, PROCNODE_STEPS, K28, SLAVEF, NA, LNA,  MYLEAF )
      IMPLICIT NONE
      INTEGER, intent(in) :: N, SLAVEF, MYID, K28, LNA
      INTEGER, intent(in) :: PROCNODE_STEPS( K28 ), STEP(N), NA( LNA )
      INTEGER, intent(out) :: MYLEAF
      INTEGER INODE, NBLEAF, I
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      MYLEAF = 0
      NBLEAF = NA(1)
      DO I = 1, NBLEAF
        INODE = NA(2+I)
        IF ( AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,SLAVEF)               &
     &       .eq. MYID ) THEN
          MYLEAF = MYLEAF + 1
        END IF
      ENDDO
      RETURN
      END SUBROUTINE AGMG_MUMPS_158
      SUBROUTINE AGMG_MUMPS_243(MYID, COMM, INFO, INFOG, IRANK)
      IMPLICIT NONE
      INTEGER MYID, COMM, IRANK, INFO, INFOG(2)
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR_MPI, MASTER
      INTEGER TEMP1(2), TEMP2(2)
      PARAMETER( MASTER = 0 )
      CALL AGMG_COPY( INFO, INFOG(1), 1, AGMG_MPF_INTEGER, IERR_MPI )
      CALL AGMG_COPY( INFO, INFOG(2), 1, AGMG_MPF_INTEGER, IERR_MPI )
      TEMP1(1) = INFO
      TEMP1(2) = MYID
      CALL AGMG_COPY( TEMP1, TEMP2, 1, AGMG_MPF_2INTEGER, IERR_MPI )
      IF ( MYID.eq. MASTER ) THEN
        IF ( INFOG(1) .ne. TEMP2(1) ) THEN
          write(*,*) 'Error in MUMPS_243'
          CALL AGMG_MUMPS_ABORT()
        END IF
        IRANK    = TEMP2(2)
      ELSE
        IRANK    = -1
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_243
      SUBROUTINE AGMG_MUMPS_362(N, LEAF, NBROOT, NROOT_LOC,                  &
     &           MYID_NODES,                                            &
     &           SLAVEF, NA, LNA, KEEP,KEEP8, STEP,                     &
     &           PROCNODE_STEPS, IPOOL, LPOOL)
      IMPLICIT NONE
      INTEGER N, LEAF, NROOT_LOC, NBROOT, MYID_NODES,                   &
     &        SLAVEF, LPOOL, LNA
      INTEGER KEEP(500)
      INTEGER*8 KEEP8(150)
      INTEGER STEP(N)
      INTEGER PROCNODE_STEPS(KEEP(28)), NA(LNA),                        &
     &        IPOOL(LPOOL)
      INTEGER NBLEAF, INODE, I
      INTEGER AGMG_MUMPS_275
      EXTERNAL AGMG_MUMPS_275
      NBLEAF = NA(1)
      NBROOT = NA(2)
      LEAF = 1
      DO I = 1, NBLEAF
        INODE = NA(I+2)
        IF (AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,SLAVEF)                &
     &   .EQ.MYID_NODES) THEN
           IPOOL(LEAF) = INODE
           LEAF        = LEAF + 1
          ENDIF
      ENDDO
      NROOT_LOC = 0
      DO I = 1, NBROOT
        INODE = NA(I+2+NBLEAF)
        IF (AGMG_MUMPS_275(STEP(INODE),PROCNODE_STEPS,                       &
     &    SLAVEF).EQ.MYID_NODES) THEN
            NROOT_LOC = NROOT_LOC + 1
        END IF
      ENDDO
      RETURN
      END SUBROUTINE AGMG_MUMPS_362
      LOGICAL FUNCTION AGMG_MUMPS_438(TAB1,TAB2,LEN1,LEN2)
      IMPLICIT NONE
      INTEGER LEN1 , LEN2 ,I
      INTEGER TAB1(LEN1)
      INTEGER TAB2(LEN2)
      AGMG_MUMPS_438=.FALSE.
      IF(LEN1 .NE. LEN2) THEN
         RETURN
      ENDIF
      DO I=1 , LEN1
         IF(TAB1(I) .NE. TAB2(I)) THEN
            RETURN
         ENDIF
      ENDDO
      AGMG_MUMPS_438=.TRUE.
      RETURN
      END FUNCTION AGMG_MUMPS_438
      SUBROUTINE AGMG_MUMPS_463( N, VAL, ID )
      INTEGER N
      INTEGER ID( N )
      INTEGER VAL( N )
      INTEGER I, ISWAP
      INTEGER SWAP
      LOGICAL DONE
      DONE = .FALSE.
      DO WHILE ( .NOT. DONE )
        DONE = .TRUE.
        DO I = 1, N - 1
           IF ( VAL( I ) .GT. VAL( I + 1 ) ) THEN
              DONE = .FALSE.
              ISWAP = ID( I )
              ID ( I ) = ID ( I + 1 )
              ID ( I + 1 ) = ISWAP
              SWAP = VAL( I )
              VAL( I ) = VAL( I + 1 )
              VAL( I + 1 ) = SWAP
           END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_463
      SUBROUTINE AGMG_MUMPS_466( N, VAL, ID )
      INTEGER N
      INTEGER ID( N )
      INTEGER VAL( N )
      INTEGER I, ISWAP
      INTEGER SWAP
      LOGICAL DONE
      DONE = .FALSE.
      DO WHILE ( .NOT. DONE )
        DONE = .TRUE.
        DO I = 1, N - 1
           IF ( VAL( I ) .LT. VAL( I + 1 ) ) THEN
              DONE = .FALSE.
              ISWAP = ID( I )
              ID ( I ) = ID ( I + 1 )
              ID ( I + 1 ) = ISWAP
              SWAP = VAL( I )
              VAL( I ) = VAL( I + 1 )
              VAL( I + 1 ) = SWAP
           END IF
        END DO
      END DO
      RETURN
      END SUBROUTINE AGMG_MUMPS_466
      SUBROUTINE AGMG_MUMPS_ABORT()
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER IERR, IERRCODE
      IERRCODE = -99
      CALL AGMG_NOCALL('MPI_ABORT')
      RETURN
      END SUBROUTINE AGMG_MUMPS_ABORT
      SUBROUTINE AGMG_MUMPS_633(KEEP12,ICNTL14,                              &
     &     KEEP50,KEEP54,ICNTL6,ICNTL8)
      IMPLICIT NONE
      INTEGER, intent(out)::KEEP12
      INTEGER, intent(in)::ICNTL14,KEEP50,KEEP54,ICNTL6,ICNTL8
      KEEP12 = ICNTL14
      IF(ICNTL6.EQ.0 .AND. ICNTL8.EQ.0) RETURN
      IF ( (KEEP54.NE.0).AND. (KEEP50.NE.1)                             &
     &     .AND. (KEEP12 .GT. 0) ) KEEP12= KEEP12+5
      RETURN
      END SUBROUTINE AGMG_MUMPS_633
      SUBROUTINE AGMG_MUMPS_749( I8_VALUE, ROOT, MYID, COMM, IERR)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER ROOT, MYID, COMM, IERR
      INTEGER(8) :: I8_VALUE
      DOUBLE PRECISION :: DBLE_VALUE
      IF (MYID .EQ. ROOT) THEN
        DBLE_VALUE = dble(I8_VALUE)
      ENDIF
      CALL AGMG_SETIERR( IERR )
      I8_VALUE = int( DBLE_VALUE,8)
      RETURN
      END SUBROUTINE AGMG_MUMPS_749
      SUBROUTINE AGMG_MUMPS_645( IN, OUT, COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER*8 IN, OUT
      INTEGER COMM
      INTEGER IERR
      DOUBLE PRECISION DIN, DOUT
      DIN =dble(IN)
      CALL AGMG_COPY(DIN, DOUT, 1, AGMG_MPF_DOUBLE_PRECISION, IERR)
      OUT=int(DOUT,KIND=8)
      RETURN
      END SUBROUTINE AGMG_MUMPS_645
      SUBROUTINE AGMG_MUMPS_646( IN, OUT, AGMG_MPF_OP, ROOT, COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER ROOT, COMM, AGMG_MPF_OP
      INTEGER*8 IN, OUT
      INTEGER IERR
      DOUBLE PRECISION DIN, DOUT
      DIN =dble(IN)
      DOUT=0.0D0
      CALL AGMG_COPY(DIN, DOUT, 1, AGMG_MPF_DOUBLE_PRECISION, IERR)
      OUT=int(DOUT,KIND=8)
      RETURN
      END SUBROUTINE AGMG_MUMPS_646
      SUBROUTINE AGMG_MUMPS_736( IN, OUT, AGMG_MPF_OP, COMM)
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER COMM, AGMG_MPF_OP
      INTEGER*8 IN, OUT
      INTEGER IERR
      DOUBLE PRECISION DIN, DOUT
      DIN =dble(IN)
      DOUT=0.0D0
      CALL AGMG_COPY(DIN, DOUT, 1, AGMG_MPF_DOUBLE_PRECISION, IERR)
      OUT=int(DOUT,KIND=8)
      RETURN
      END SUBROUTINE AGMG_MUMPS_736
      SUBROUTINE AGMG_MUMPS_754(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      INTEGER, POINTER             :: ARRAY(:)
      INTEGER                      :: INFO(*)
      INTEGER                      :: MINSIZE, LP
      LOGICAL, OPTIONAL            :: FORCE
      LOGICAL, OPTIONAL            :: COPY
      CHARACTER, OPTIONAL          :: STRING*(*)
      INTEGER, OPTIONAL            :: ERRCODE, MEMCNT
      LOGICAL                      :: ICOPY, IFORCE
      INTEGER, POINTER             :: TEMP(:)
      INTEGER                      :: I, IERR, ILP, ERRTPL(2)
      CHARACTER                    :: FMTA*60, FMTD*60
      IF(PRESENT(COPY)) THEN
         ICOPY = COPY
      ELSE
         ICOPY = .FALSE.
      END IF
      IF (PRESENT(FORCE)) THEN
         IFORCE = FORCE
      ELSE
         IFORCE = .FALSE.
      END IF
      IF (PRESENT(STRING)) THEN
         FMTA = "Allocation failed inside realloc: "//STRING
         FMTD = "Deallocation failed inside realloc: "//STRING
      ELSE
         FMTA = "Allocation failed inside realloc: "
         FMTD = "Deallocation failed inside realloc: "
      END IF
      IF (PRESENT(ERRCODE)) THEN
         ERRTPL = (/ERRCODE, MINSIZE/)
      ELSE
         ERRTPL = (/-13, MINSIZE/)
      END IF
      IF(ICOPY) THEN
         IF(associated(ARRAY)) THEN
            IF ((size(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               allocate(TEMP(MINSIZE), STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTA)
                  INFO(1:2) = ERRTPL
                  RETURN
               ELSE
                  IF(PRESENT(MEMCNT))MEMCNT = MEMCNT+MINSIZE
               END IF
               DO I=1, MIN(size(ARRAY), MINSIZE)
                  TEMP(I) = ARRAY(I)
               END DO
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
               NULLIFY(ARRAY)
               ARRAY => TEMP
               NULLIFY(TEMP)
            END IF
         ELSE
            WRITE(LP,                                                   &
     &      '("Input array is not associated. nothing to copy here")')
            RETURN
         END IF
      ELSE
         IF(associated(ARRAY)) THEN
            IF ((SIZE(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
            ELSE
               RETURN
            END IF
         END IF
         allocate(ARRAY(MINSIZE), STAT=IERR)
         IF(IERR .LT. 0) THEN
            WRITE(LP,FMTA)
            INFO(1:2) = ERRTPL
            RETURN
         ELSE
            IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT+MINSIZE
         END IF
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_754
      SUBROUTINE AGMG_MUMPS_750(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      REAL(kind(1.E0)), POINTER             :: ARRAY(:)
      INTEGER                      :: INFO(*)
      INTEGER                      :: MINSIZE, LP
      LOGICAL, OPTIONAL            :: FORCE
      LOGICAL, OPTIONAL            :: COPY
      CHARACTER, OPTIONAL          :: STRING*(*)
      INTEGER, OPTIONAL            :: ERRCODE, MEMCNT
      LOGICAL                      :: ICOPY, IFORCE
      REAL(kind(1.E0)), POINTER             :: TEMP(:)
      INTEGER                      :: I, IERR, ILP, ERRTPL(2)
      CHARACTER                    :: FMTA*60, FMTD*60
      IF(PRESENT(COPY)) THEN
         ICOPY = COPY
      ELSE
         ICOPY = .FALSE.
      END IF
      IF (PRESENT(FORCE)) THEN
         IFORCE = FORCE
      ELSE
         IFORCE = .FALSE.
      END IF
      IF (PRESENT(STRING)) THEN
         FMTA = "Allocation failed inside realloc: "//STRING
         FMTD = "Deallocation failed inside realloc: "//STRING
      ELSE
         FMTA = "Allocation failed inside realloc: "
         FMTD = "Deallocation failed inside realloc: "
      END IF
      IF (PRESENT(ERRCODE)) THEN
         ERRTPL = (/ERRCODE, MINSIZE/)
      ELSE
         ERRTPL = (/-13, MINSIZE/)
      END IF
      IF(ICOPY) THEN
         IF(associated(ARRAY)) THEN
            IF ((size(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               allocate(TEMP(MINSIZE), STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTA)
                  INFO(1:2) = ERRTPL
                  RETURN
               ELSE
                  IF(PRESENT(MEMCNT))MEMCNT = MEMCNT+MINSIZE
               END IF
               DO I=1, MIN(size(ARRAY), MINSIZE)
                  TEMP(I) = ARRAY(I)
               END DO
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
               NULLIFY(ARRAY)
               ARRAY => TEMP
               NULLIFY(TEMP)
            END IF
         ELSE
            WRITE(LP,                                                   &
     &      '("Input array is not associated. nothing to copy here")')
            RETURN
         END IF
      ELSE
         IF(associated(ARRAY)) THEN
            IF ((SIZE(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
            ELSE
               RETURN
            END IF
         END IF
         allocate(ARRAY(MINSIZE), STAT=IERR)
         IF(IERR .LT. 0) THEN
            WRITE(LP,FMTA)
            INFO(1:2) = ERRTPL
            RETURN
         ELSE
            IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT+MINSIZE
         END IF
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_750
      SUBROUTINE AGMG_MUMPS_752(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      REAL(kind(1.D0)), POINTER    :: ARRAY(:)
      INTEGER                      :: INFO(*)
      INTEGER                      :: MINSIZE, LP
      LOGICAL, OPTIONAL            :: FORCE
      LOGICAL, OPTIONAL            :: COPY
      CHARACTER, OPTIONAL          :: STRING*(*)
      INTEGER, OPTIONAL            :: ERRCODE, MEMCNT
      LOGICAL                      :: ICOPY, IFORCE
      REAL(kind(1.D0)), POINTER    :: TEMP(:)
      INTEGER                      :: I, IERR, ILP, ERRTPL(2)
      CHARACTER                    :: FMTA*60, FMTD*60
      IF(PRESENT(COPY)) THEN
         ICOPY = COPY
      ELSE
         ICOPY = .FALSE.
      END IF
      IF (PRESENT(FORCE)) THEN
         IFORCE = FORCE
      ELSE
         IFORCE = .FALSE.
      END IF
      IF (PRESENT(STRING)) THEN
         FMTA = "Allocation failed inside realloc: "//STRING
         FMTD = "Deallocation failed inside realloc: "//STRING
      ELSE
         FMTA = "Allocation failed inside realloc: "
         FMTD = "Deallocation failed inside realloc: "
      END IF
      IF (PRESENT(ERRCODE)) THEN
         ERRTPL = (/ERRCODE, MINSIZE/)
      ELSE
         ERRTPL = (/-13, MINSIZE/)
      END IF
      IF(ICOPY) THEN
         IF(associated(ARRAY)) THEN
            IF ((size(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               allocate(TEMP(MINSIZE), STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTA)
                  INFO(1:2) = ERRTPL
                  RETURN
               ELSE
                  IF(PRESENT(MEMCNT))MEMCNT = MEMCNT+MINSIZE
               END IF
               DO I=1, MIN(size(ARRAY), MINSIZE)
                  TEMP(I) = ARRAY(I)
               END DO
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
               NULLIFY(ARRAY)
               ARRAY => TEMP
               NULLIFY(TEMP)
            END IF
         ELSE
            WRITE(LP,                                                   &
     &      '("Input array is not associated. nothing to copy here")')
            RETURN
         END IF
      ELSE
         IF(associated(ARRAY)) THEN
            IF ((SIZE(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
            ELSE
               RETURN
            END IF
         END IF
         allocate(ARRAY(MINSIZE), STAT=IERR)
         IF(IERR .LT. 0) THEN
            WRITE(LP,FMTA)
            INFO(1:2) = ERRTPL
            RETURN
         ELSE
            IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT+MINSIZE
         END IF
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_752
      SUBROUTINE AGMG_MUMPS_751(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      COMPLEX(kind((1.E0,1.E0))), POINTER             :: ARRAY(:)
      INTEGER                      :: INFO(*)
      INTEGER                      :: MINSIZE, LP
      LOGICAL, OPTIONAL            :: FORCE
      LOGICAL, OPTIONAL            :: COPY
      CHARACTER, OPTIONAL          :: STRING*(*)
      INTEGER, OPTIONAL            :: ERRCODE, MEMCNT
      LOGICAL                      :: ICOPY, IFORCE
      COMPLEX(kind((1.E0,1.E0))), POINTER             :: TEMP(:)
      INTEGER                      :: I, IERR, ILP, ERRTPL(2)
      CHARACTER                    :: FMTA*60, FMTD*60
      IF(PRESENT(COPY)) THEN
         ICOPY = COPY
      ELSE
         ICOPY = .FALSE.
      END IF
      IF (PRESENT(FORCE)) THEN
         IFORCE = FORCE
      ELSE
         IFORCE = .FALSE.
      END IF
      IF (PRESENT(STRING)) THEN
         FMTA = "Allocation failed inside realloc: "//STRING
         FMTD = "Deallocation failed inside realloc: "//STRING
      ELSE
         FMTA = "Allocation failed inside realloc: "
         FMTD = "Deallocation failed inside realloc: "
      END IF
      IF (PRESENT(ERRCODE)) THEN
         ERRTPL = (/ERRCODE, MINSIZE/)
      ELSE
         ERRTPL = (/-13, MINSIZE/)
      END IF
      IF(ICOPY) THEN
         IF(associated(ARRAY)) THEN
            IF ((size(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               allocate(TEMP(MINSIZE), STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTA)
                  INFO(1:2) = ERRTPL
                  RETURN
               ELSE
                  IF(PRESENT(MEMCNT))MEMCNT = MEMCNT+MINSIZE
               END IF
               DO I=1, MIN(size(ARRAY), MINSIZE)
                  TEMP(I) = ARRAY(I)
               END DO
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
               NULLIFY(ARRAY)
               ARRAY => TEMP
               NULLIFY(TEMP)
            END IF
         ELSE
            WRITE(LP,                                                   &
     &      '("Input array is not associated. nothing to copy here")')
            RETURN
         END IF
      ELSE
         IF(associated(ARRAY)) THEN
            IF ((SIZE(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
            ELSE
               RETURN
            END IF
         END IF
         allocate(ARRAY(MINSIZE), STAT=IERR)
         IF(IERR .LT. 0) THEN
            WRITE(LP,FMTA)
            INFO(1:2) = ERRTPL
            RETURN
         ELSE
            IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT+MINSIZE
         END IF
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_751
      SUBROUTINE AGMG_MUMPS_753(ARRAY, MINSIZE, INFO, LP, FORCE, COPY,       &
     &     STRING, MEMCNT, ERRCODE)
      COMPLEX(kind((1.D0,1.D0))), POINTER             :: ARRAY(:)
      INTEGER                      :: INFO(*)
      INTEGER                      :: MINSIZE, LP
      LOGICAL, OPTIONAL            :: FORCE
      LOGICAL, OPTIONAL            :: COPY
      CHARACTER, OPTIONAL          :: STRING*(*)
      INTEGER, OPTIONAL            :: ERRCODE, MEMCNT
      LOGICAL                      :: ICOPY, IFORCE
      COMPLEX(kind((1.D0,1.D0))), POINTER             :: TEMP(:)
      INTEGER                      :: I, IERR, ILP, ERRTPL(2)
      CHARACTER                    :: FMTA*60, FMTD*60
      IF(PRESENT(COPY)) THEN
         ICOPY = COPY
      ELSE
         ICOPY = .FALSE.
      END IF
      IF (PRESENT(FORCE)) THEN
         IFORCE = FORCE
      ELSE
         IFORCE = .FALSE.
      END IF
      IF (PRESENT(STRING)) THEN
         FMTA = "Allocation failed inside realloc: "//STRING
         FMTD = "Deallocation failed inside realloc: "//STRING
      ELSE
         FMTA = "Allocation failed inside realloc: "
         FMTD = "Deallocation failed inside realloc: "
      END IF
      IF (PRESENT(ERRCODE)) THEN
         ERRTPL = (/ERRCODE, MINSIZE/)
      ELSE
         ERRTPL = (/-13, MINSIZE/)
      END IF
      IF(ICOPY) THEN
         IF(associated(ARRAY)) THEN
            IF ((size(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               allocate(TEMP(MINSIZE), STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTA)
                  INFO(1:2) = ERRTPL
                  RETURN
               ELSE
                  IF(PRESENT(MEMCNT))MEMCNT = MEMCNT+MINSIZE
               END IF
               DO I=1, MIN(size(ARRAY), MINSIZE)
                  TEMP(I) = ARRAY(I)
               END DO
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
               NULLIFY(ARRAY)
               ARRAY => TEMP
               NULLIFY(TEMP)
            END IF
         ELSE
            WRITE(LP,                                                   &
     &      '("Input array is not associated. nothing to copy here")')
            RETURN
         END IF
      ELSE
         IF(associated(ARRAY)) THEN
            IF ((SIZE(ARRAY) .LT. MINSIZE) .OR.                         &
     &           ((size(ARRAY).NE.MINSIZE) .AND. IFORCE)) THEN
               IF(PRESENT(MEMCNT))MEMCNT = MEMCNT-size(ARRAY)
               deallocate(ARRAY, STAT=IERR)
               IF(IERR .LT. 0) THEN
                  WRITE(LP,FMTD)
                  INFO(1:2) = ERRTPL
                  RETURN
               END IF
            ELSE
               RETURN
            END IF
         END IF
         allocate(ARRAY(MINSIZE), STAT=IERR)
         IF(IERR .LT. 0) THEN
            WRITE(LP,FMTA)
            INFO(1:2) = ERRTPL
            RETURN
         ELSE
            IF(PRESENT(MEMCNT)) MEMCNT = MEMCNT+MINSIZE
         END IF
      END IF
      RETURN
      END SUBROUTINE AGMG_MUMPS_753
      SUBROUTINE AGMG_MUMPS_735(I8, I4)
      IMPLICIT NONE
      INTEGER   , INTENT(OUT) :: I4
      INTEGER(8), INTENT(IN)  :: I8
      IF ( I8 .GT. int(huge(I4),8) ) THEN
        I4 = -int(I8/1000000_8,kind(I4))
      ELSE
        I4 = int(I8,kind(I4))
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_735
      SUBROUTINE AGMG_MUMPS_ABORT_ON_OVERFLOW(I8, STRING)
      IMPLICIT NONE
      INTEGER(8), INTENT(IN) :: I8
      CHARACTER(*), INTENT(IN) :: STRING
      INTEGER I4
      IF ( I8 .GT. int(huge(I4),8)) THEN
        WRITE(*,*) STRING
        CALL AGMG_MUMPS_ABORT()
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_ABORT_ON_OVERFLOW
      SUBROUTINE AGMG_MUMPS_731( SIZE8, IERROR  )
      INTEGER(8), INTENT(IN) :: SIZE8
      INTEGER, INTENT(OUT) :: IERROR
      CALL AGMG_MUMPS_735(SIZE8, IERROR)
      RETURN
      END SUBROUTINE AGMG_MUMPS_731
      SUBROUTINE AGMG_MUMPS_730(I8, INT_ARRAY)
      IMPLICIT NONE
      INTEGER(8), intent(in)  :: I8
      INTEGER,    intent(out) :: INT_ARRAY(2)
      INTEGER(8) :: IDIV, IPAR
      PARAMETER (IPAR=int(huge(INT_ARRAY),8))
      PARAMETER (IDIV=IPAR+1_8)
      IF ( I8 .LT. IDIV ) THEN
        INT_ARRAY(1) = 0
        INT_ARRAY(2) = int(I8)
      ELSE
        INT_ARRAY(1) = int(I8 / IDIV)
        INT_ARRAY(2) = int(mod(I8,IDIV))
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_730
      SUBROUTINE AGMG_MUMPS_729(I8, INT_ARRAY)
      IMPLICIT NONE
      INTEGER(8), intent(out)  :: I8
      INTEGER,    intent(in)  :: INT_ARRAY(2)
      INTEGER(8) :: IDIV, IPAR
      PARAMETER (IPAR=int(huge(INT_ARRAY),8))
      PARAMETER (IDIV=IPAR+1_8)
      IF ( INT_ARRAY(1) .EQ. 0 ) THEN
        I8=int(INT_ARRAY(2),8)
      ELSE
        I8=int(INT_ARRAY(1),8)*IDIV+int(INT_ARRAY(2),8)
      ENDIF
      RETURN
      END SUBROUTINE AGMG_MUMPS_729
      SUBROUTINE AGMG_MUMPS_723( INT_ARRAY, I8 )
      IMPLICIT NONE
      INTEGER(8), intent(in) :: I8
      INTEGER, intent(inout) :: INT_ARRAY(2)
      INTEGER(8) :: I8TMP
      CALL AGMG_MUMPS_729(I8TMP, INT_ARRAY)
      I8TMP = I8TMP + I8
      CALL AGMG_MUMPS_730(I8TMP, INT_ARRAY)
      RETURN
      END SUBROUTINE AGMG_MUMPS_723
      SUBROUTINE AGMG_MUMPS_724( INT_ARRAY, I8 )
      IMPLICIT NONE
      INTEGER(8), intent(in) :: I8
      INTEGER, intent(inout) :: INT_ARRAY(2)
      INTEGER(8) :: I8TMP
      CALL AGMG_MUMPS_729(I8TMP, INT_ARRAY)
      I8TMP = I8TMP - I8
      CALL AGMG_MUMPS_730(I8TMP, INT_ARRAY)
      RETURN
      END SUBROUTINE AGMG_MUMPS_724
      FUNCTION AGMG_MUMPS_PARANAL_AVAIL(WHICH)
      LOGICAL :: AGMG_MUMPS_PARANAL_AVAIL
      CHARACTER :: WHICH*(*)
      LOGICAL :: PTSCOTCH=.FALSE., PARMETIS=.FALSE.
      SELECT CASE(WHICH)
      CASE('ptscotch','PTSCOTCH')
         AGMG_MUMPS_PARANAL_AVAIL = PTSCOTCH
      CASE('parmetis','PARMETIS')
         AGMG_MUMPS_PARANAL_AVAIL = PARMETIS
      CASE('both','BOTH')
         AGMG_MUMPS_PARANAL_AVAIL = PTSCOTCH .AND. PARMETIS
      CASE('any','ANY')
         AGMG_MUMPS_PARANAL_AVAIL = PTSCOTCH .OR. PARMETIS
      CASE default
         write(*,'("Invakud input in MUMPS_PARANAL_AVAIL")')
      END SELECT
      RETURN
      END
      SUBROUTINE AGMG_NOCALL(A)
      CHARACTER A*(*)
      print 100,A
      STOP
 100  format(' FATAL ERROR in MUMPS: should not call subroutine',A)
      return
      END SUBROUTINE AGMG_NOCALL
      INTEGER FUNCTION NUMROC_FOOL( N, NB, IPROC, ISRCPROC, NPROCS )
      INTEGER N, NB, IPROC, ISRCPROC, NPROCS
!     Can be called
      IF ( NPROCS .ne. 1 ) THEN
        WRITE(*,*) 'Error. Last parameter from NUMROC should be 1'
        STOP
      ENDIF
      IF ( IPROC .ne. 0 ) THEN
        WRITE(*,*) 'Error. IPROC should be 0 in NUMROC.'
        STOP
      ENDIF
      NUMROC_FOOL = N
      RETURN
      END FUNCTION NUMROC_FOOL
      SUBROUTINE AGMG_SETIERR(I)
      INTEGER I
      I=0
      RETURN
      END SUBROUTINE AGMG_SETIERR
      SUBROUTINE AGMG_SETIERR2(I,J)
      INTEGER I,J
      I=0
      J=0
      RETURN
      END SUBROUTINE AGMG_SETIERR2
      SUBROUTINE AGMG_SETIERR12(I,J)
      INTEGER I,J
      I=1
      J=0
      RETURN
      END SUBROUTINE AGMG_SETIERR12
      SUBROUTINE AGMG_MPF_GET_PROCESSOR_NAME( NAME, RESULTLEN, IERROR)
      CHARACTER (LEN=*) NAME
      INTEGER RESULTLEN,IERROR
      RESULTLEN = 1
      IERROR = 0
      NAME = 'X'
      RETURN
      END SUBROUTINE AGMG_MPF_GET_PROCESSOR_NAME
      SUBROUTINE AGMG_MPF_INITIALIZED( FLAG, IERR )
      IMPLICIT NONE
      LOGICAL FLAG
      INTEGER IERR
      FLAG = .TRUE.
      IERR = 0
      RETURN
      END SUBROUTINE AGMG_MPF_INITIALIZED
      SUBROUTINE AGMG_MPF_IPROBE( SOURCE, TAG, COMM, FLAG, STATUS, IERR )
      IMPLICIT NONE
      INTEGER SOURCE, TAG, COMM, IERR
      INTEGER STATUS(*)
      LOGICAL FLAG
      FLAG = .FALSE.
      IERR = 0
      RETURN
      END SUBROUTINE AGMG_MPF_IPROBE
      SUBROUTINE AGMG_MPF_TEST( IREQ, FLAG, STATUS, IERR )
      IMPLICIT NONE
      INTEGER IREQ, IERR
      INTEGER STATUS(*)
      LOGICAL FLAG
      FLAG = .FALSE.
      IERR = 0
      RETURN
      END SUBROUTINE AGMG_MPF_TEST
      DOUBLE PRECISION FUNCTION AGMG_MPF_WTIME( )
!     elapsed time
      DOUBLE PRECISION VAL
      CALL AGMG_NOCALL('MUMPS_ELAPSE')
      AGMG_MPF_WTIME = VAL
      RETURN
      END FUNCTION AGMG_MPF_WTIME
      SUBROUTINE AGMG_MPF_ALLTOALL( SENDBUF, SENDCNT, SENDTYPE,               &
                               RECVBUF, RECVCNT, RECVTYPE, COMM, IERR )
      IMPLICIT NONE
!
      INTEGER AGMG_MPF_2DOUBLE_PRECISION
      INTEGER AGMG_MPF_2INTEGER
      INTEGER AGMG_MPF_2REAL
      INTEGER AGMG_MPF_ANY_SOURCE
      INTEGER AGMG_MPF_ANY_TAG
      INTEGER AGMG_MPF_BYTE
      INTEGER AGMG_MPF_CHARACTER
      INTEGER AGMG_MPF_COMM_NULL
      INTEGER AGMG_MPF_COMM_WORLD
      INTEGER AGMG_MPF_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_COMPLEX
      INTEGER AGMG_MPF_DOUBLE_PRECISION
      INTEGER AGMG_MPF_INTEGER
      INTEGER AGMG_MPF_LOGICAL
      INTEGER AGMG_MPF_MAX
      INTEGER AGMG_MPF_MAX_PROCESSOR_NAME
      INTEGER AGMG_MPF_MAXLOC
      INTEGER AGMG_MPF_MIN
      INTEGER AGMG_MPF_MINLOC
      INTEGER AGMG_MPF_PACKED
      INTEGER AGMG_MPF_PROD
      INTEGER AGMG_MPF_REAL
      INTEGER AGMG_MPF_REPLACE
      INTEGER AGMG_MPF_REQUEST_NULL
      INTEGER AGMG_MPF_SOURCE
      INTEGER AGMG_MPF_STATUS_SIZE
      INTEGER AGMG_MPF_SUM
      INTEGER AGMG_MPF_TAG
      INTEGER AGMG_MPF_UNDEFINED
      INTEGER AGMG_MPF_WTIME_IS_GLOBAL
      INTEGER AGMG_MPF_LOR
      INTEGER AGMG_MPF_LAND
      INTEGER AGMG_MPF_INTEGER8
      INTEGER AGMG_MPF_REAL8
      INTEGER AGMG_MPF_BSEND_OVERHEAD
      PARAMETER (AGMG_MPF_2DOUBLE_PRECISION=1)
      PARAMETER (AGMG_MPF_2INTEGER=2)
      PARAMETER (AGMG_MPF_2REAL=3)
      PARAMETER (AGMG_MPF_ANY_SOURCE=4)
      PARAMETER (AGMG_MPF_ANY_TAG=5)
      PARAMETER (AGMG_MPF_BYTE=6)
      PARAMETER (AGMG_MPF_CHARACTER=7)
      PARAMETER (AGMG_MPF_COMM_NULL=8)
      PARAMETER (AGMG_MPF_COMM_WORLD=9)
      PARAMETER (AGMG_MPF_COMPLEX=10)
      PARAMETER (AGMG_MPF_DOUBLE_COMPLEX=11)
      PARAMETER (AGMG_MPF_DOUBLE_PRECISION=12)
      PARAMETER (AGMG_MPF_INTEGER=13)
      PARAMETER (AGMG_MPF_LOGICAL=14)
      PARAMETER (AGMG_MPF_MAX=15)
      PARAMETER (AGMG_MPF_MAX_PROCESSOR_NAME=31)
      PARAMETER (AGMG_MPF_MAXLOC=16)
      PARAMETER (AGMG_MPF_MIN=17)
      PARAMETER (AGMG_MPF_MINLOC=18)
      PARAMETER (AGMG_MPF_PACKED=19)
      PARAMETER (AGMG_MPF_PROD=20)
      PARAMETER (AGMG_MPF_REAL=21)
      PARAMETER (AGMG_MPF_REPLACE=22)
      PARAMETER (AGMG_MPF_REQUEST_NULL=23)
      PARAMETER (AGMG_MPF_SOURCE=1)
      PARAMETER (AGMG_MPF_STATUS_SIZE=2)
      PARAMETER (AGMG_MPF_SUM=26)
      PARAMETER (AGMG_MPF_TAG=2)
      PARAMETER (AGMG_MPF_UNDEFINED=28)
      PARAMETER (AGMG_MPF_WTIME_IS_GLOBAL=30)
      PARAMETER (AGMG_MPF_LOR=31)
      PARAMETER (AGMG_MPF_LAND=32)
      PARAMETER (AGMG_MPF_INTEGER8=33)
      PARAMETER (AGMG_MPF_REAL8=34)
      PARAMETER (AGMG_MPF_BSEND_OVERHEAD=0)
      DOUBLE PRECISION AGMG_MPF_WTIME
      EXTERNAL AGMG_MPF_WTIME
      INTERFACE AGMG_COPY
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_INTEGER
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R(N)
      END SUBROUTINE AGMG_COPY_INTEGER1
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S,R
      END SUBROUTINE AGMG_COPY_INTEGER11
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER(8) :: S
      INTEGER:: R
      END SUBROUTINE AGMG_COPY_INTEGER1_81
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      INTEGER :: S(N),R
      END SUBROUTINE AGMG_COPY_INTEGER10
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N(*), DATATYPE, IERR
      INTEGER :: S(N(1),1),R(N(1))
      END SUBROUTINE AGMG_COPY_INTEGER21
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_REAL
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R(N)
      END SUBROUTINE AGMG_COPY_REAL1
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S,R
      END SUBROUTINE AGMG_COPY_REAL11
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      REAL :: S(N),R
      END SUBROUTINE AGMG_COPY_REAL10
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE PRECISION :: S(N),R
      END SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_COMPLEX
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_COMPLEX1
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_COMPLEX11
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S(*),R(*)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R(N)
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER :: N, DATATYPE, IERR
      DOUBLE COMPLEX :: S,R
      END SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11
      END INTERFACE
      INTEGER SENDCNT, SENDTYPE, RECVCNT, RECVTYPE, COMM, IERR
      INTEGER SENDBUF(*), RECVBUF(*)
      IF ( RECVCNT .NE. SENDCNT ) THEN
        WRITE(*,*) 'ERROR in MPI_ALLTOALL, RECVCOUNT != SENDCOUNT'
        STOP
      ELSE IF ( RECVTYPE .NE. SENDTYPE ) THEN
        WRITE(*,*) 'ERROR in MPI_ALLTOALL, RECVTYPE != SENDTYPE'
        STOP
      ELSE
        CALL AGMG_COPY(  SENDBUF, RECVBUF, SENDCNT, SENDTYPE, IERR )
      END IF
      RETURN
      END SUBROUTINE AGMG_MPF_ALLTOALL
      SUBROUTINE AGMG_COPY_INTEGER( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      INTEGER S(*),R(*)
      INTEGER I
      IF (DATATYPE.eq.13) THEN
        DO I = 1, N
          R(I) = S(I)
        END DO
      ELSE IF (DATATYPE.eq.2) THEN
        DO I = 1, 2*N
          R(I) = S(I)
        END DO
      ELSE
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER'
        STOP
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_INTEGER1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      INTEGER S,R(N)
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_INTEGER1'
        STOP
      ELSE IF (DATATYPE.ne.13) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER1'
        STOP
      ELSE
        R(1) = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_INTEGER11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      INTEGER S,R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_INTEGER11'
        STOP
      ELSE IF (DATATYPE.ne.13) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER11'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_INTEGER1_81( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      INTEGER(8) S
      INTEGER R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_INTEGER1_81'
        STOP
      ELSE IF (DATATYPE.ne.13) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER1_81'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_INTEGER10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      INTEGER S(N),R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_INTEGER10'
        STOP
      ELSE IF (DATATYPE.ne.13) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER10'
        STOP
      ELSE
        R = S(1)
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_INTEGER21( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N(*), DATATYPE, IERR
      INTEGER S(N(1),1),R(N(1))
      INTEGER I
      IF (DATATYPE.ne.13) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_INTEGER21'
        STOP
      ELSE
        DO I = 1, N(1)
          R(I) = S(I,1)
        END DO
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_REAL( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      REAL S(*),R(*)
      INTEGER I
      IF (DATATYPE.eq.21) THEN
        DO I = 1, N
          R(I) = S(I)
        END DO
      ELSE IF (DATATYPE.eq.3) THEN
        DO I = 1, 2*N
          R(I) = S(I)
        END DO
      ELSE
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_REAL'
        STOP
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_REAL1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      REAL S,R(N)
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_REAL1'
        STOP
      ELSE IF (DATATYPE.ne.21) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_REAL1'
        STOP
      ELSE
        R(1) = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_REAL11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      REAL S,R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_REAL11'
        STOP
      ELSE IF (DATATYPE.ne.21) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_REAL11'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_REAL10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      REAL S(N),R
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_REAL10'
        STOP
      ELSE IF (DATATYPE.ne.21) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_REAL10'
        STOP
      ELSE
        R = S(1)
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE PRECISION S(*),R(*)
      INTEGER I
      IF (DATATYPE.eq.12) THEN
        DO I = 1, N
          R(I) = S(I)
        END DO
      ELSE IF (DATATYPE.eq.1) THEN
        DO I = 1, 2*N
          R(I) = S(I)
        END DO
      ELSE
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_PRECISION'
        STOP
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE PRECISION S,R(N)
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_PRECISION1'
        STOP
      ELSE IF (DATATYPE.ne.12) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_PRECISION1'
        STOP
      ELSE
        R(1) = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE PRECISION S,R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_PRECISION11'
        STOP
      ELSE IF (DATATYPE.ne.12) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_PRECISION11'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_PRECISION10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE PRECISION S(N),R
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_PRECISION10'
        STOP
      ELSE IF (DATATYPE.ne.12) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_PRECISION10'
        STOP
      ELSE
        R = S(1)
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      COMPLEX S(*),R(*)
      INTEGER I
      IF (DATATYPE.eq.10) THEN
        DO I = 1, N
          R(I) = S(I)
        END DO
      ELSE
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_COMPLEX'
        STOP
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      COMPLEX S,R(N)
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_COMPLEX1'
        STOP
      ELSE IF (DATATYPE.ne.10) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_COMPLEX1'
        STOP
      ELSE
        R(1) = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      COMPLEX S,R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_COMPLEX11'
        STOP
      ELSE IF (DATATYPE.ne.10) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_COMPLEX11'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_COMPLEX10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      COMPLEX S(N),R
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_COMPLEX10'
        STOP
      ELSE IF (DATATYPE.ne.10) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_COMPLEX10'
        STOP
      ELSE
        R = S(1)
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE COMPLEX S(*),R(*)
      INTEGER I
      IF (DATATYPE.eq.11) THEN
        DO I = 1, N
          R(I) = S(I)
        END DO
      ELSE
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_COMPLEX'
        STOP
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX1( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE COMPLEX S,R(N)
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_COMPLEX1'
        STOP
      ELSE IF (DATATYPE.ne.11) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_COMPLEX1'
        STOP
      ELSE
        R(1) = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX11( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE COMPLEX S,R
      INTEGER I
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_COMPLEX11'
        STOP
      ELSE IF (DATATYPE.ne.11) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_COMPLEX11'
        STOP
      ELSE
        R = S
      END IF
      IERR=0
      RETURN
      END
      SUBROUTINE AGMG_COPY_DOUBLE_COMPLEX10( S, R, N, DATATYPE, IERR )
      IMPLICIT NONE
      INTEGER N, DATATYPE, IERR
      DOUBLE COMPLEX S(N),R
      IF (N.ne.1) THEN
        WRITE(*,*) 'Wrong N in AGMG_COPY_DOUBLE_COMPLEX10'
        STOP
      ELSE IF (DATATYPE.ne.11) THEN
        WRITE(*,*) 'Wrong DATATYPE in AGMG_COPY_DOUBLE_COMPLEX10'
        STOP
      ELSE
        R = S(1)
      END IF
      IERR=0
      RETURN
      END
