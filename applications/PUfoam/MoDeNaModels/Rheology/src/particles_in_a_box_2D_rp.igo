// this file is similar to particles_in_a_box_2D.igo, with the excepting
// that refinement points are used to generate meshes that are refined
// around the particle. This has the advantage that is gives more control
// over the element size in the domain


// Do not let Gmsh determine the element size (instead the element size
// will be specified using refinement fields) by setting
// Mesh.CharacteristicLengthExtendFromBoundary to 0 (its default value is 1)

//Mesh.CharacteristicLengthExtendFromBoundary = 0;


// Accuracy of evaluation of the LC field (characteristic length of elements)
// for 1D mesh generation (Default value: 1e-09)
// see: http://www.geuz.org/pipermail/gmsh/2013/008319.html

//Mesh.LcIntegrationPrecision = LcIntegrationPrecision;


// Create domain vertices

Point(1) = {ox,    oy,    0.0, dx_box};
Point(2) = {ox+lx, oy,    0.0, dx_box};
Point(3) = {ox+lx, oy+ly, 0.0, dx_box};
Point(4) = {ox,    oy+ly, 0.0, dx_box};

For i In {1:4}
  Physical Point(i) = i;
EndFor

// Create domain sides

Line(1) = {1, 2};
Line(2) = {2, 3};
Line(3) = {3, 4};
Line(4) = {4, 1};

For i In {1:4}
  Physical Line(i) = i;
EndFor

// Create outer boundary

lin_loop[0] = newll;
Line Loop(lin_loop[0]) = { 1, 2, 3, 4 };

Periodic Line {4} = {-2};
If ( biperiodic == 1 )
  Periodic Line {3} = {-1};
EndIf

// Circle

Function MakeCircle

  p1 = newp; Point(p1) = {x,    y,   0.0,   dx_part};
  p2 = newp; Point(p2) = {x-r,  y,   0.0,   dx_part};
  p3 = newp; Point(p3) = {x+r,  y,   0.0,   dx_part};

  c1 = newl; Circle(c1) = {p2, p1, p3};
  c2 = newl; Circle(c2) = {p3, p1, p2};

  lin_loop[t] = newll;

  Line Loop(lin_loop[t]) = {c1, c2};

  Physical Line(t+4) = {c1, c2};

Return

// Make nobj circles

For t In {1:nobj}

  x = xp[t];
  y = yp[t];
  r = rp[t];

  Call MakeCircle;

EndFor

// Create surface mesh (with holes)

Plane Surface(1) = {lin_loop[]};

Physical Surface(1) = {1};

// add refinement points

pcount=0;

If (0 > 0 )

  For i In {1:nrefinement_field}

      // generate a list with the refinement points
      For t In {1:nrefine[i]}

        p_refine = newp; Point(p_refine) = {xp_refine[t+pcount],
          yp_refine[t+pcount], 0.0};

        // apparently, Gmsh start counting with 0, so t-1 is the first index!
        refinement_points[t-1] = p_refine;

      EndFor

      // generate an attractor field that returns the distance to the closest
      // refinement point
      Field[2*i-1] = Attractor;
      Field[2*i-1].NodesList = {refinement_points[]};

      // use the values generated by the attractor field to determine the
      // element size
      Field[2*i] = Threshold;
      Field[2*i].IField = 2*i-1;
      Field[2*i].LcMin = dx_fine[i];
      Field[2*i].LcMax = dx_coarse[i];
      Field[2*i].DistMin = distmin[i];
      Field[2*i].DistMax = distmax[i];

      pcount=pcount+nrefine[i];

    EndFor

    // use the minimum of all element-size-fields
    Field[2*nrefinement_field+1] = Min;
    For i In {1:nrefinement_field}
      field_list[i-1] = i*2;
    EndFor
    Field[2*nrefinement_field+1].FieldsList = {field_list[]};
    Background Field = 2*nrefinement_field+1;

EndIf


// vim: set filetype=gmsh :  //
